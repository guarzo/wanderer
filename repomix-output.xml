<repomix>This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where content has been formatted for parsing.<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: priv/**/*, **/*.svg, .notes/**/*, .cursor/**/*, _build/**/*, deps/**/*, assets/node_modules/**/*, CHANGELOG.md, CONTRIBUTING.md, CODE_OF_CONDUCT.md, LICENSE, SECURITY.md, UPGRADE.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style</notes><additional_info></additional_info></file_summary><directory_structure>.devcontainer/
  devcontainer.json
  docker-compose.yml
  Dockerfile
.github/
  workflows/
    build.yml
    release_actions.yml
  FUNDING.yml
  release.yml
assets/
  css/
    app.css
  js/
    hooks/
      Mapper/
        common-styles/
          prime-fixes/
            fix-dialog.scss
            fix-input.scss
            fix-popup.scss
            fix-tabs.scss
            index.scss
            theme.scss
          context-menu.scss
          custom-scrollbar.scss
          fixes.scss
          main.scss
          tooltip.scss
        components/
          characters/
            Characters.module.scss
            Characters.tsx
          contexts/
            components/
              FastSystemActions/
                FastSystemActions.module.scss
                FastSystemActions.tsx
                index.ts
              index.ts
            ContextMenuSystem/
              hooks/
                useLabelsMenu/
                  index.ts
                  useLabelsMenu.ts
                useStatusMenu/
                  index.ts
                  useStatusMenu.ts
                useTagMenu/
                  index.ts
                  useTagMenu.tsx
                index.ts
              constants.ts
              ContextMenuSystem.module.scss
              ContextMenuSystem.tsx
              index.ts
              useContextMenuSystemHandlers.ts
              useContextMenuSystemItems.tsx
            ContextMenuSystemInfo/
              constants.ts
              ContextMenuSystemInfo.module.scss
              ContextMenuSystemInfo.tsx
              index.ts
              useContextMenuSystemInfoHandlers.ts
            ContextMenuSystemMultiple/
              ContextMenuSystemMultiple.tsx
              index.ts
              useContextMenuSystemMultipleHandlers.ts
            hooks/
              useJumpPlannerMenu/
                index.ts
                useJumpPlannerMenu.tsx
              useWaypointMenu/
                index.ts
                useWaypointMenu.ts
              index.ts
              useDeleteSystems.ts
            index.ts
            types.ts
          hooks/
            index.ts
            useElementWidth.ts
            useGetOwnOnlineCharacters.ts
            useSystemInfo.ts
          layout/
            Layout.module.scss
            Layout.tsx
          map/
            components/
              ContextMenuConnection/
                ContextMenuConnection.module.scss
                ContextMenuConnection.tsx
                index.ts
                useContextMenuConnectionHandlers.ts
              ContextMenuRoot/
                ContextMenuRoot.tsx
                index.ts
                useContextMenuRootHandlers.ts
              SolarSystemEdge/
                index.ts
                SolarSystemEdge.module.scss
                SolarSystemEdge.tsx
              SolarSystemNode/
                index.ts
                SolarSystemKillsCounter.module.scss
                SolarSystemKillsCounter.tsx
                SolarSystemLocalCounter.module.scss
                SolarSystemLocalCounter.tsx
                SolarSystemNodeDefault.module.scss
                SolarSystemNodeDefault.tsx
                SolarSystemNodeTheme.module.scss
                SolarSystemNodeTheme.tsx
              UnsplashedSignature/
                index.ts
                UnsplashedSignature.module.scss
                UnsplashedSignature.tsx
              WormholeClassComp/
                index.ts
                WormholeClassComp.tsx
              index.ts
            helpers/
              convertConnection2Edge.ts
              convertSystem2Node.ts
              getBackgroundClass.ts
              getShapeClass.ts
              getSystemClassStyles.ts
              getThemeBehavior.ts
              index.ts
              isKnownSpace.ts
              isPochvenSpace.ts
              isTriglavianInvasion.ts
              isWormholeSpace.ts
              isZarzakhSpace.ts
              prepareUnsplashedChunks.ts
            hooks/
              api/
                index.ts
                useCenterSystem.ts
                useCommandsCharacters.ts
                useCommandsConnections.ts
                useMapAddSystems.ts
                useMapCommands.ts
                useMapInit.ts
                useMapRemoveSystems.ts
                useMapUpdateSystems.ts
                useSelectSystem.ts
              index.ts
              useBackgroundVars.ts
              useKillsCounter.ts
              useLabelsInfo.ts
              useMapHandlers.ts
              useNodeKillsCount.ts
              useNodesEdgesState.ts
              useSolarSystemNode.ts
              useSystemName.ts
              useUnsplashedSignatures.ts
              useUpdateNodes.ts
            styles/
              default-theme.scss
              eve-common-variables.scss
              eve-common.scss
              index.scss
              pathfinder-theme.scss
            utils/
              changes.ts
            constants.ts
            Map.module.scss
            Map.tsx
            map.types.ts
            MapProvider.tsx
            utils.ts
          mapInterface/
            components/
              AddSystemDialog/
                AddSystemDialog.module.scss
                AddSystemDialog.tsx
                index.ts
              Comments/
                components/
                  MarkdownComment/
                    index.ts
                    MarkdownComment.module.scss
                    MarkdownComment.tsx
                  index.ts
                Comments.tsx
                index.ts
                markdownexample.ts
              CommentsEditor/
                CommentsEditor.tsx
                index.ts
              MarkdownEditor/
                index.ts
                MarkdownEditor.module.scss
                MarkdownEditor.tsx
              SystemCustomLabelDialog/
                index.ts
                SystemCustomLabelDialog.tsx
              SystemLinkSignatureDialog/
                index.ts
                SystemLinkSignatureDialog.tsx
              SystemSettingsDialog/
                index.ts
                SystemSettingsDialog.tsx
              Widget/
                index.ts
                Widget.module.scss
                Widget.tsx
              index.ts
            helpers/
              sortCharacters.ts
            widgets/
              CommentsWidget/
                CommentsWidget.tsx
                index.ts
              LocalCharacters/
                components/
                  LocalCharactersItemTemplate/
                    index.ts
                    LocalCharactersItemTemplate.module.scss
                    LocalCharactersItemTemplate.tsx
                  index.ts
                  LocalCharactersHeader.tsx
                  LocalCharactersList.tsx
                  types.ts
                hooks/
                  useLocalCharacters.tsx
                  useLocalWidgetSettings.ts
                index.ts
                LocalCharacters.module.scss
                LocalCharacters.tsx
              RoutesWidget/
                hooks/
                  index.ts
                  useLoadRoutes.ts
                RoutesList/
                  index.ts
                  RoutesList.module.scss
                  RoutesList.tsx
                RoutesSettingsDialog/
                  index.ts
                  RoutesSettingsDialog.tsx
                index.ts
                RoutesProvider.tsx
                RoutesWidget.module.scss
                RoutesWidget.tsx
                types.ts
              SystemInfo/
                SystemInfoContent/
                  index.ts
                  SystemInfoContent.module.scss
                  SystemInfoContent.tsx
                index.ts
                SystemInfo.module.scss
                SystemInfo.tsx
              SystemSignatures/
                helpers/
                  contentHelpers.ts
                  getActualSigs.ts
                  getRowBackgroundColor.ts
                  getState.ts
                  index.ts
                  rowStyles.module.scss
                  rowStyles.ts
                hooks/
                  types.ts
                  usePendingDeletions.ts
                  useSignatureFetching.ts
                  useSystemSignaturesData.ts
                renders/
                  index.ts
                  renderAddedTimeLeft.tsx
                  renderDescription.tsx
                  renderIcon.tsx
                  renderInfoColumn.tsx
                  renderLinkedSystem.tsx
                  renderName.tsx
                  renderUpdatedTimeLeft.tsx
                SignatureView/
                  index.ts
                  SignatureView.tsx
                SystemSignatureHeader/
                  index.ts
                  SystemSignatureHeader.tsx
                SystemSignaturesContent/
                  index.ts
                  SystemSignaturesContent.tsx
                SystemSignatureSettingsDialog/
                  index.ts
                  SystemSignatureSettingsDialog.tsx
                constants.ts
                index.ts
                SystemSignatures.tsx
              SystemStructures/
                helpers/
                  index.ts
                  parserHelper.ts
                  pasteParser.ts
                  structureTypes.ts
                  structureUtils.ts
                hooks/
                  useSystemStructures.ts
                renders/
                  cellRenders.tsx
                  TimerCell.tsx
                SystemStructuresContent/
                  SystemStructuresContent.module.scss
                  SystemStructuresContent.tsx
                SystemStructuresDialog/
                  SystemStructureDialog.module.scss
                  SystemStructuresDialog.tsx
                index.ts
                SystemStructures.tsx
              WRoutesPublic/
                index.ts
                WRoutesPublic.tsx
              WRoutesUser/
                index.ts
                WRoutesUser.tsx
              WSystemKills/
                components/
                  KillItemTemplate.tsx
                  KillRowDetail.module.scss
                  KillRowDetail.tsx
                  SystemKillsHeader.tsx
                  SystemKillsSettingsDialog.tsx
                helpers/
                  index.ts
                  killRowUtils.ts
                  linkHelpers.ts
                hooks/
                  useKillsWidgetSettings.ts
                  useSystemKills.ts
                  useSystemKillsItemTemplate.ts
                SystemKillsList/
                  index.ts
                  SystemKillsList.tsx
                index.ts
                WSystemKills.tsx
              index.ts
            constants.tsx
            MapInterface.tsx
          mapRootContent/
            components/
              CharacterActivity/
                CharacterActivity.tsx
                CharacterActivityContent.tsx
                helpers.tsx
                index.ts
              Connections/
                PassageCard/
                  index.ts
                  PassageCard.module.scss
                  PassageCard.tsx
                Connections.module.scss
                Connections.tsx
                index.ts
              MapContextMenu/
                MapContextMenu.tsx
              MapSettings/
                components/
                  PrettySwitchbox/
                    index.ts
                    MapSettings.module.scss
                    PrettySwitchbox.tsx
                  CommonSettings.tsx
                  index.ts
                  WidgetsSettings.tsx
                constants.ts
                index.ts
                MapSettings.module.scss
                MapSettings.tsx
                MapSettingsProvider.tsx
                types.ts
              OnTheMap/
                index.ts
                OnTheMap.module.scss
                OnTheMap.tsx
              RightBar/
                index.ts
                RightBar.module.scss
                RightBar.tsx
              SignatureSettings/
                components/
                  SignatureEOLCheckbox/
                    index.ts
                    SignatureEOLCheckbox.tsx
                  SignatureGroupContent/
                    index.ts
                    SignatureGroupContent.tsx
                  SignatureGroupSelect/
                    index.ts
                    SignatureGroupSelect.tsx
                  SignatureK162TypeSelect/
                    index.ts
                    renderK162Type.tsx
                    SignatureK162TypeSelect.tsx
                  SignatureLeadsToSelect/
                    index.ts
                    SignatureLeadsToSelect.module.scss
                    SignatureLeadsToSelect.tsx
                  SignatureWormholeTypeSelect/
                    index.ts
                    SignatureWormholeTypeSelect.tsx
                  index.ts
                  SignatureGroupContentWormholes.tsx
                index.ts
                Provider.tsx
                SignatureSettings.module.scss
                SignatureSettings.tsx
              TrackingDialog/
                index.ts
                TrackingCharactersList.tsx
                TrackingDialog.tsx
                TrackingProvider.tsx
                TrackingSettings.tsx
              index.ts
            hooks/
              useCharacterActivityHandlers.ts
            MapRootContent.tsx
          mapWrapper/
            hooks/
              useCommonMapEventProcessor.ts
            MapWrapper.module.scss
            MapWrapper.tsx
          topbar/
            Topbar.tsx
          ui-kit/
            CharacterCard/
              CharacterCard.module.scss
              CharacterCard.tsx
              index.ts
            FixedTooltip/
              FixedTooltip.tsx
              index.ts
            InfoDrawer/
              index.ts
              InfoDrawer.module.scss
              InfoDrawer.tsx
            SystemView/
              index.ts
              SystemView.tsx
            SystemViewStandalone/
              index.ts
              SystemViewStandalone.module.scss
              SystemViewStandalone.tsx
            TimeAgo/
              index.ts
              TimeAgo.tsx
            TimeLeft/
              index.ts
              TimeLeft.tsx
            WdCheckbox/
              index.ts
              WdCheckbox.module.scss
              WdCheckbox.tsx
            WdEveEntityPortrait/
              index.ts
              WdEveEntityPortrait.tsx
            WdImgButton/
              index.ts
              WdImgButton.module.scss
              WdImgButton.tsx
            WdRadioButton/
              index.ts
              WdRadioButton.module.scss
              WdRadioButton.tsx
            WdResponsiveCheckBox/
              index.ts
              WdResponsiveCheckbox.tsx
            WdTooltip/
              index.ts
              WdTooltip.module.scss
              WdTooltip.tsx
            WdTooltipWrapper/
              index.ts
              utils.ts
              WdTooltipWrapper.module.scss
              WdTooltipWrapper.tsx
            WdTransition/
              index.ts
              WdTransition.module.scss
              WdTransition.tsx
            WHClassView/
              index.ts
              WHClassView.module.scss
              WHClassView.tsx
            WHEffectView/
              index.ts
              WHEffectView.module.scss
              WHEffectView.tsx
            WindowManager/
              index.ts
              types.ts
              utils.ts
              WindowManager.module.scss
              WindowManager.tsx
            index.ts
            LayoutEventBlocker.tsx
            LoadingWrapper.tsx
            SvgIconWrapper.tsx
        events/
          index.ts
        helpers/
          getEveImageUrl.ts
          getSystemById.ts
          getWhSize.ts
          index.ts
          isDocked.ts
          parseSignatureCustomInfo.ts
          parseSignatures.ts
          sortWHClasses.ts
        hooks/
          index.ts
          useActualizeSettings.ts
          useClipboard.ts
          useDoubleClick.ts
          useHotkey.ts
          useMaxWidth.ts
          usePageVisibility.ts
          useSkipContextMenu.ts
          useTheme.ts
        icons/
          index.ts
          MapAddIcon.tsx
          MapDeleteIcon.tsx
          MapUserAddIcon.tsx
          MapUserDeleteIcon.tsx
        mapRootProvider/
          hooks/
            api/
              index.ts
              useCommandComments.ts
              useCommandsActivity.ts
              useCommandsCharacters.ts
              useCommandsConnections.ts
              useCommandsSystems.ts
              useGetCacheCharacter.ts
              useMapCheckPermissions.ts
              useMapGetOption.ts
              useMapInit.ts
              useMapUpdated.ts
              useRoutes.ts
            index.ts
            useCharactersCache.ts
            useComments.ts
            useLoadSystemStatic.ts
            useMapRootHandlers.ts
            useMapUserSettings.ts
            useStoreWidgets.ts
          constants.ts
          index.ts
          MapRootProvider.tsx
          types.ts
        types/
          character.ts
          commandsIn.ts
          comment.ts
          common.ts
          connection.ts
          connectionPassages.ts
          effect.ts
          index.ts
          kills.ts
          mapHandlers.ts
          mapUnionTypes.ts
          permissions.ts
          routes.ts
          signatures.ts
          system.ts
          wormholes.ts
        utils/
          contextStore/
            index.ts
            types.ts
            useContextStore.ts
          abstractContextProvider.tsx
          contextManager.ts
          getQueryVariable.ts
          index.ts
          kgToTons.ts
          labelsManager.ts
        constants.ts
        index.tsx
        MapRoot.tsx
        useMapperHandlers.ts
      maps/
        mapAction.ts
      clientTime.ts
      copyToClipboard.ts
      downloadJson.ts
      drag.ts
      index.ts
      localStorageSetting.ts
      localTime.ts
      newVersionUpdate.ts
      ping.ts
      showCharactersAddAlert.ts
    typings.d.ts
  lib/
    phoenix/
      index.js
      live_reload.css
    phoenix_live_view/
      index.js
    tailwind/
      colors.js
      index.css
  vendor/
    heroicons/
      LICENSE.md
      UPGRADE.md
    topbar.js
  .eslintrc.cjs
  .gitignore
  .prettierrc
  app.tsx
  package.json
  postcss.config.js
  tailwind.config.js
  tsconfig.json
  vite-env.d.ts
  vite.config.js
config/
  config.exs
  dev.exs
  prod.exs
  runtime.exs
  test.exs
lib/
  wanderer_app/
    api/
      calculations/
        calc_map_permissions.ex
      changes/
        slugify_name.ex
      preparations/
        filter_acls_by_roles.ex
        filter_maps_by_roles.ex
        load_character.ex
      access_list_member.ex
      access_list.ex
      character.ex
      corp_wallet_transaction.ex
      license.ex
      map_access_list.ex
      map_chain_passages.ex
      map_character_settings.ex
      map_connection.ex
      map_solar_system_jumps.ex
      map_solar_system.ex
      map_state.ex
      map_subscription.ex
      map_system_comment.ex
      map_system_signature.ex
      map_system_structure.ex
      map_system.ex
      map_transaction.ex
      map_user_settings.ex
      map.ex
      ship_type_info.ex
      user_activity.ex
      user_transaction.ex
      user.ex
    blog/
      blog.ex
      post.ex
    changelog/
      changelog.ex
      file.ex
    character/
      activity.ex
      tracker_manager_impl.ex
      tracker_manager.ex
      tracker_pool_dynamic_supervisor.ex
      tracker_pool_supervisor.ex
      tracker_pool.ex
      tracker_registry_helper.ex
      tracker_supervisor.ex
      tracker.ex
      tracking_utils.ex
      transactions_tracker_impl.ex
      transactions_tracker_supervisor.ex
      transactions_tracker.ex
    esi/
      api_client.ex
    helpers/
      config.ex
    license/
      license_manager_client.ex
      license_manager.ex
    map/
      operations/
        connections.ex
        owner.ex
        signatures.ex
        structures.ex
        systems.ex
      server/
        map_server_acls_impl.ex
        map_server_characters_impl.ex
        map_server_connections_impl.ex
        map_server_impl.ex
        map_server_signatures_impl.ex
        map_server_supervisor.ex
        map_server_systems_impl.ex
      map_audit.ex
      map_dynamic_supervisor.ex
      map_manager.ex
      map_operations.ex
      map_position_calculator.ex
      map_registry_helper.ex
      map_rtree_dynamic_supervisor.ex
      map_server.ex
      map_subscription_manager.ex
      map_zkb_data_fetcher.ex
    metrics/
      prom_ex_plugin.ex
    repositories/
      access_list_repo.ex
      map_chain_passages_repo.ex
      map_character_settings_repo.ex
      map_connection_repo.ex
      map_repo.ex
      map_subscription_repo.ex
      map_system_comment_repo.ex
      map_system_repo.ex
      map_transaction_repo.ex
      map_user_settings_repo.ex
    schema/
      ash_erlang_binary.ex
    server/
      server_status_tracker.ex
      thera_data_fetcher.ex
    ueberauth/
      strategy/
        eve/
          oauth.ex
        eve.ex
      uberauth.ex
    user/
      user_activity_tracker.ex
    utils/
      cache.ex
      CSVUtil.ex
      eve_util.ex
      http_util.ex
      JSONUtil.ex
    zkb/
      zkills_provider/
        cache.ex
        fetcher.ex
        parser.ex
        redisq.ex
        zkb_api.ex
      zkb_kills_preloader.ex
      zkb_supervisor.ex
    acls.ex
    api.ex
    application.ex
    cache.ex
    cached_info.ex
    character.ex
    env.ex
    esi.ex
    eve_data_service.ex
    gen_impl.ex
    init_corp_wallet_tracker_task.ex
    mailer.ex
    map.ex
    maps.ex
    permissions.ex
    prom_ex.ex
    queue.ex
    release.ex
    repo.ex
    sheduler.ex
    structures.ex
    task_wrapper.ex
    user.ex
    vault.ex
  wanderer_app_web/
    components/
      layouts/
        app.html.heex
        blog.html.heex
        landing.html.heex
        live.html.heex
        root.html.heex
      alerts.ex
      core_components.ex
      layouts.ex
    controllers/
      blog_html/
        changelog.html.heex
        contacts.heex
        index.html.heex
        license.html.heex
        list.html.heex
        show.html.heex
      plugs/
        assign_map_owner.ex
        check_acl_api_key.ex
        check_api_disabled.ex
        check_character_api_disabled.ex
        check_kills_disabled.ex
        check_map_api_key.ex
        check_map_subscription.ex
        license_auth.ex
        set_user.ex
      access_list_api_controller.ex
      access_list_member_api_controller.ex
      auth_controller.ex
      basic_auth.ex
      blog_controller.ex
      blog_html.ex
      character_api_controller.ex
      common_api_controller.ex
      error_html.ex
      error_json.ex
      fallback_controller.ex
      license_api_controller.ex
      map_api_controller.ex
      map_audit_api_controller.ex
      map_connection_api_controller.ex
      map_system_api_controller.ex
      map_system_signature_api_controller.ex
      map_system_structure_api_controller.ex
      maps_controller.ex
      redirect_controller.ex
      user_auth.ex
    helpers/
      api_utils.ex
      csp.ex
    live/
      access_lists/
        components/
          acl_member.ex
        access_lists_live.ex
        access_lists_live.html.heex
      admin/
        admin_live.ex
        admin_live.html.heex
      characters/
        characters_live.ex
        characters_live.html.heex
        characters_tracking_live.ex
        characters_tracking_live.html.heex
      map/
        components/
          map_characters.ex
          map_loader.ex
          map_picker.ex
          map_refresh.ex
          user_activity.ex
        event_handlers/
          map_activity_event_handler.ex
          map_characters_event_handler.ex
          map_connections_event_handler.ex
          map_core_event_handler.ex
          map_kills_event_handler.ex
          map_routes_event_handler.ex
          map_signatures_event_handler.ex
          map_structures_event_handler.ex
          map_system_comments_event_handler.ex
          map_systems_event_handler.ex
        map_audit_live.ex
        map_audit_live.html.heex
        map_characters_live.ex
        map_characters_live.html.heex
        map_event_handler.ex
        map_live.ex
        map_live.html.heex
      maps/
        components/
          license_component.ex
          map_balance_component.ex
          map_subscriptions_component.ex
        maps_live.ex
        maps_live.html.heex
      profile/
        profile_live.ex
        profile_live.html.heex
      coming_live.ex
      nav.ex
      server_status_live.ex
    schemas/
      api_schemas.ex
      response_schemas.ex
    api_spec.ex
    endpoint_metrics.ex
    endpoint.ex
    gettext.ex
    presence.ex
    router.ex
    telemetry.ex
  wanderer_app_web.ex
  wanderer_app.ex
rel/
  overlays/
    bin/
      createdb.sh
      migrate.bat
      migrate.sh
      rollback.sh
      server
      server.bat
  docker-entrypoint.sh
  env.sh.eex
test/
  manual/
    api/
      map_api_backup_restore_test.sh
      structure_signature_api_tests.sh
      system_api_legacy_tests.sh
      system_api_tests.sh
      utils.sh
  support/
    conn_case.ex
    data_case.ex
  unit/
    character_api_controller_test.exs
    common_api_controller_test.exs
    map_api_controller_test.exs
    map_route_api_controller_test.exs
    tracking_utils_test.exs
    util_api_controller_test.exs
  wanderer_app/
    test.ex
  wanderer_app_web/
    controllers/
      error_html_test.exs
      error_json_test.exs
      page_controller_test.exs
  test_helper.exs
.check.exs
.coderabbit.yaml
.credo.exs
.cursorrules
.dockerignore
.editorconfig
.env.example
.envrc
.formatter.exs
.gitignore
.gitmessage
.tool-versions
default.nix
Dockerfile
elixir_buildpack.config
flake.lock
flake.nix
fly.toml
m
Makefile
mix.exs
phoenix_static_buildpack.config
README.md
repomix.config.json</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".devcontainer/devcontainer.json">{
  &quot;name&quot;: &quot;wanderer-dev&quot;,
  &quot;dockerComposeFile&quot;: [&quot;./docker-compose.yml&quot;],
  &quot;customizations&quot;: {
    &quot;vscode&quot;: {
      &quot;extensions&quot;: [
        &quot;jakebecker.elixir-ls&quot;,
        &quot;JakeBecker.elixir-ls&quot;,
        &quot;dbaeumer.vscode-eslint&quot;,
        &quot;esbenp.prettier-vscode&quot;
      ],
      &quot;settings&quot;: {
        &quot;editor.formatOnSave&quot;: true,
        &quot;search.exclude&quot;: {
          &quot;**/doc&quot;: true
        },
        &quot;elixirLS.dialyzerEnabled&quot;: false
      }
    }
  },
  &quot;service&quot;: &quot;wanderer&quot;,
  &quot;workspaceFolder&quot;: &quot;/app&quot;,
  &quot;shutdownAction&quot;: &quot;stopCompose&quot;,
  &quot;features&quot;: {
    &quot;ghcr.io/devcontainers/features/common-utils:2&quot;: {
      &quot;networkArgs&quot;: [&quot;--add-host=host.docker.internal:host-gateway&quot;]
    }
  },
  &quot;forwardPorts&quot;: [4444]
}</file><file path=".devcontainer/docker-compose.yml">version: &quot;0.1&quot;

services:
  db:
    image: postgres:13-alpine
    restart: always
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - &quot;5432:5432&quot;
    volumes:
      - db-new:/var/lib/postgresql/data

  wanderer:
    environment:
      PORT: 4444
      DB_HOST: db
      WEB_APP_URL: &quot;http://localhost:4444&quot;
      ERL_AFLAGS: &quot;-kernel shell_history enabled&quot;
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - 4444:4444
    volumes:
      - ..:/app:delegated
      - ~/.gitconfig:/root/.gitconfig
      - ~/.gitignore:/root/.gitignore
      - ~/.ssh:/root/.ssh
      - elixir-artifacts:/opt/elixir-artifacts
    command: sleep infinity

volumes:
  elixir-artifacts: {}
  db-new: {}</file><file path=".devcontainer/Dockerfile">FROM elixir:1.17-otp-27

RUN apt install -yq curl gnupg
# Install OS packages and Node.js (via nodesource),
# plus inotify-tools and yarn
RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
    sudo \
    curl \
    make \
    git \
    bash \
    build-essential \
    ca-certificates \
    jq \
    vim \
    net-tools \
    procps \
    # Optionally add any other tools you need, e.g. vim, wget...
    &amp;&amp; curl -sL https://deb.nodesource.com/setup_18.x | bash - \
    &amp;&amp; apt-get install -y --no-install-recommends nodejs inotify-tools \
    &amp;&amp; npm install -g yarn \
    &amp;&amp; apt-get clean \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

RUN apt --fix-broken install

RUN mix local.hex --force

WORKDIR /app</file><file path=".github/workflows/build.yml">name: Build

on:
  push:
    branches:
      - main
      - &quot;releases/*&quot;
env:
  MIX_ENV: prod
  GH_TOKEN: ${{ github.token }}
  REGISTRY_IMAGE: wandererltd/community-edition

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  deploy-test:
    name: üöÄ Deploy to test env (fly.io)
    runs-on: ubuntu-latest
    if: ${{ github.base_ref == &apos;main&apos; || (github.ref == &apos;refs/heads/main&apos; &amp;&amp; github.event_name == &apos;push&apos;) }}
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v3
      - uses: superfly/flyctl-actions/setup-flyctl@master

      - name: üëÄ Read app name
        uses: SebRollen/toml-action@v1.0.0
        id: app_name
        with:
          file: &quot;fly.toml&quot;
          field: &quot;app&quot;

      - name: üöÄ Deploy Test
        run: flyctl deploy --remote-only --wait-timeout=300 --ha=false
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

  manual-approval:
    name: Manual Approval
    runs-on: ubuntu-latest
    needs: deploy-test
    if: success()

    permissions:
      issues: write

    steps:
      - name: Await Manual Approval
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }}
          approvers: DmitryPopov
          minimum-approvals: 1
          issue-title: &quot;Manual Approval Required for Release&quot;
          issue-body: &quot;Please approve or deny the deployment.&quot;

  build:
    name: üõ† Build
    needs: manual-approval
    runs-on: ubuntu-22.04
    if: ${{ (github.ref == &apos;refs/heads/main&apos;) &amp;&amp; github.event_name == &apos;push&apos; }}
    permissions:
      checks: write
      contents: write
      packages: write
      attestations: write
      id-token: write
      pull-requests: write
      repository-projects: write
    strategy:
      matrix:
        otp: [&quot;27&quot;]
        elixir: [&quot;1.17&quot;]
        node-version: [&quot;18.x&quot;]
    outputs:
      commit_hash: ${{ steps.generate-changelog.outputs.commit_hash }}
    steps:
      - name: Prepare
        run: |
          platform=${{ matrix.platform }}
          echo &quot;PLATFORM_PAIR=${platform//\//-}&quot; &gt;&gt; $GITHUB_ENV

      - name: Setup Elixir
        uses: erlef/setup-beam@v1
        with:
          otp-version: ${{matrix.otp}}
          elixir-version: ${{matrix.elixir}}
        # nix build would also work here because `todos` is the default package
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: üòÖ Cache deps
        id: cache-deps
        uses: actions/cache@v4
        env:
          cache-name: cache-elixir-deps
        with:
          path: |
            deps
          key: ${{ runner.os }}-mix-${{ matrix.elixir }}-${{ matrix.otp }}-${{ hashFiles(&apos;**/mix.lock&apos;) }}
          restore-keys: |
            ${{ runner.os }}-mix-${{ matrix.elixir }}-${{ matrix.otp }}-
      - name: üòÖ Cache compiled build
        id: cache-build
        uses: actions/cache@v4
        env:
          cache-name: cache-compiled-build
        with:
          path: |
            _build
          key: ${{ runner.os }}-build-${{ hashFiles(&apos;**/mix.lock&apos;) }}-${{ hashFiles( &apos;**/lib/**/*.{ex,eex}&apos;, &apos;**/config/*.exs&apos;, &apos;**/mix.exs&apos; ) }}
          restore-keys: |
            ${{ runner.os }}-build-${{ hashFiles(&apos;**/mix.lock&apos;) }}-
            ${{ runner.os }}-build-
      # Step: Download project dependencies. If unchanged, uses
      # the cached version.
      - name: üåê Install dependencies
        run: mix deps.get --only &quot;prod&quot;

      # Step: Compile the project treating any warnings as errors.
      # Customize this step if a different behavior is desired.
      - name: üõ† Compiles without warnings
        if: steps.cache-build.outputs.cache-hit != &apos;true&apos;
        run: mix compile

      - name: Generate Changelog &amp; Update Tag Version
        id: generate-changelog
        run: |
          git config --global user.name &apos;CI&apos;
          git config --global user.email &apos;ci@users.noreply.github.com&apos;
          mix git_ops.release --force-patch --yes
          git push --follow-tags
          echo &quot;commit_hash=$(git rev-parse HEAD)&quot; &gt;&gt; $GITHUB_OUTPUT

  docker:
    name: üõ† Build Docker Images
    needs: build
    runs-on: ubuntu-22.04
    outputs:
      release-tag: ${{ steps.get-latest-tag.outputs.tag }}
      release-notes: ${{ steps.get-content.outputs.string }}
    permissions:
      checks: write
      contents: write
      packages: write
      attestations: write
      id-token: write
      pull-requests: write
      repository-projects: write
    strategy:
      fail-fast: false
      matrix:
        platform:
          - linux/amd64
          - linux/arm64
    steps:
      - name: Prepare
        run: |
          platform=${{ matrix.platform }}
          echo &quot;PLATFORM_PAIR=${platform//\//-}&quot; &gt;&gt; $GITHUB_ENV

      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v3
        with:
          ref: ${{ needs.build.outputs.commit_hash }}
          fetch-depth: 0

      - name: Prepare Changelog
        run: |
          yes | cp -rf CHANGELOG.md priv/changelog/CHANGELOG.md
          sed -i &apos;1i%{title: &quot;Change Log&quot;}\n\n---\n&apos; priv/changelog/CHANGELOG.md

      - name: Get Release Tag
        id: get-latest-tag
        uses: &quot;WyriHaximus/github-action-get-previous-tag@v1&quot;
        with:
          fallback: 1.0.0

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_IMAGE }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.WANDERER_DOCKER_USER }}
          password: ${{ secrets.WANDERER_DOCKER_PASSWORD }}

      - name: Build and push
        id: build
        uses: docker/build-push-action@v6
        with:
          push: true
          context: .
          file: ./Dockerfile
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: ${{ steps.meta.outputs.labels }}
          platforms: ${{ matrix.platform }}
          outputs: type=image,&quot;name=${{ env.REGISTRY_IMAGE }}&quot;,push-by-digest=true,name-canonical=true,push=true
          build-args: |
            MIX_ENV=prod
            BUILD_METADATA=${{ steps.meta.outputs.json }}

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest=&quot;${{ steps.build.outputs.digest }}&quot;
          touch &quot;/tmp/digests/${digest#sha256:}&quot;

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ env.PLATFORM_PAIR }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

      - uses: markpatterson27/markdown-to-output@v1
        id: extract-changelog
        with:
          filepath: CHANGELOG.md

      - name: Get content
        uses: 2428392/gh-truncate-string-action@v1.3.0
        id: get-content
        with:
          stringToTruncate: |
            üì£ Wanderer new release available üéâ

            **Version**: ${{ steps.get-latest-tag.outputs.tag }}

            ${{ steps.extract-changelog.outputs.body }}
          maxLength: 500
          truncationSymbol: &quot;‚Ä¶&quot;

  merge:
    runs-on: ubuntu-latest
    needs:
      - docker
    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-*
          merge-multiple: true

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.WANDERER_DOCKER_USER }}
          password: ${{ secrets.WANDERER_DOCKER_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.REGISTRY_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{version}},value=${{ needs.docker.outputs.release-tag }}

      - name: Create manifest list and push
        working-directory: /tmp/digests
        run: |
          docker buildx imagetools create $(jq -cr &apos;.tags | map(&quot;-t &quot; + .) | join(&quot; &quot;)&apos; &lt;&lt;&lt; &quot;$DOCKER_METADATA_OUTPUT_JSON&quot;) \
            $(printf &apos;${{ env.REGISTRY_IMAGE }}@sha256:%s &apos; *)

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ env.REGISTRY_IMAGE }}:${{ steps.meta.outputs.version }}

  create-release:
    name: üè∑ Create Release
    runs-on: ubuntu-22.04
    needs: [docker, merge]
    if: ${{ github.ref == &apos;refs/heads/main&apos; &amp;&amp; github.event_name == &apos;push&apos; }}
    steps:
      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: üè∑ Create Draft Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.docker.outputs.release-tag }}
          name: Release ${{ needs.docker.outputs.release-tag }}
          body: |
            ## Info
            Commit ${{ github.sha }} was deployed to `staging`. [See code diff](${{ github.event.compare }}).

            It was initialized by [${{ github.event.sender.login }}](${{ github.event.sender.html_url }}).

            ## How to Promote?
            In order to promote this to prod, edit the draft and press **&quot;Publish release&quot;**.
          draft: true

      - name: Discord Webhook Action
        uses: tsickert/discord-webhook@v5.3.0
        with:
          webhook-url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          content: ${{ needs.docker.outputs.release-notes }}</file><file path=".github/workflows/release_actions.yml">on:
  release:
    types: [published]

jobs:
  deploy:
    name: Deploy artifact
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: executing remote ssh commands using password
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.PORT }}
          script: |
            /home/wanderer/app/deploy.sh ${{ github.event.release.tag_name }}</file><file path=".github/FUNDING.yml"># These are supported funding model platforms

github: # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]
patreon: WandererLtd
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
lfx_crowdfunding: # Replace with a single LFX Crowdfunding project-name e.g., cloud-foundry
polar: # Replace with a single Polar username
buy_me_a_coffee: # Replace with a single Buy Me a Coffee username
thanks_dev: # Replace with a single thanks.dev username
custom: # Replace with up to 4 custom sponsorship URLs e.g., [&apos;link1&apos;, &apos;link2&apos;]</file><file path=".github/release.yml">changelog:
  exclude:
    labels:
      - ignore-for-release
  categories:
    - title: Breaking Changes üõ†
      labels:
        - Semver-Major
        - breaking-change
    - title: Exciting New Features üéâ
      labels:
        - Semver-Minor
        - feat
    - title: Other Changes
      labels:
        - &quot;*&quot;</file><file path="assets/css/app.css">@layer tailwind-base, primereact, tailwind-utilities;

@import &apos;primereact/resources/themes/arya-blue/theme.css&apos; layer(primereact);
/*@import &apos;primereact/resources/themes/bootstrap4-dark-blue/theme.css&apos; layer(primereact);*/

@import &apos;../js/hooks/Mapper/components/map/styles/index.scss&apos;;

@layer tailwind-base {
  @tailwind base;
}

@layer tailwind-utilities {
  @tailwind components;
  @tailwind utilities;
}

#app {
  overflow: hidden;
}

body {
  font-family: &apos;Shentox&apos;, &apos;Rogan&apos;, sans-serif !important;
  min-width: 400px; /* Suppose you want minimum width of 400px */
  width: auto !important; /* Firefox will set width as auto */
  width: 400px; /* As IE6 ignores !important it will set width as 400px; */
}

body &gt; div:first-of-type {
  min-height: 500px !important;
}

.lending-normal {
  font-family: &apos;Shentox&apos;, &apos;Rogan&apos;, sans-serif !important;
  font-weight: 500;
}

#bg-canvas {
  position: absolute;
  width: 100vw;
  height: 100vh;
}

.ccp-font {
  font-family: &apos;Shentox&apos;, &apos;Rogan&apos;, sans-serif !important;
}

.discount {
  position: absolute;
  width: 100%;
  height: 100%;
  background-color: red;
  clip-path: polygon(100% 0, 100% 12%, 0% 100%, 0% 88%);
}

.blur {
  filter: blur(3px);
}

.blur:hover {
  filter: none;
}

.show-blured .blur {
  filter: none;
}

.blog-bg {
  background-image: url(&apos;https://images.ctfassets.net/7lhcm73ukv5p/3kBbL40e9KAKPMlM27jqRw/670eb7dd8cd76eab700ec8445373dd2c/news_detail_background.jpg?w=900&amp;q=75&amp;fm=webp&apos;);
  background-size: cover;
  background-position: center;
  width: 100%;
  height: 100%;
}

.maps_bg {
  background-image: url(&apos;../images/maps_bg.webp&apos;);
  background-size: cover;
  background-position: center;
  width: 100%;
  height: 100%;
}

.cover_bg {
  background-image: url(&apos;../images/hello.webp&apos;);
  background-size: cover;
  background-position: center;
  width: 100%;
  height: 100%;
}

.copied .link-copied {
  display: block;
  animation-name: fadeOutOpacity;
  animation-iteration-count: 1;
  animation-delay: 0.5s;
  animation-timing-function: ease-out;
  animation-duration: 1s;
  animation-fill-mode: forwards;
}

@keyframes fadeOutOpacity {
  0% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}

.wd-user-characters &gt; .wd-characters-icons:not(:last-child) {
  margin-right: 5px;
}

.wd-characters-icons {
  /*display: flex;*/
  /*transition:*/
  /*  border-color 250ms,*/
  /*  opacity 250ms;*/
  /*width: 35px;*/
  /*height: 35px;*/
  /*border-radius: 50%;*/
  /*border-width: 2px;*/
  /*border-style: solid;*/
  /*border-color: #5a5a5a;*/
  /*background-color: rgba(0, 0, 0, 0);*/
  /*cursor: pointer;*/
  /*opacity: 0.6;*/
}

.wd-bg-default {
  background-position: center;
  background-size: 100%;
  background-repeat: no-repeat;
}

.wd-characters-icons.character-online {
  border-color: #4fa224de;
  opacity: 1;
}

.wd-app-menu[data-v-24097c87] {
  border-right: 1px solid #454545;
  width: 60px;
  background-color: #2f2f2f;
}
.wd.padding-top {
  padding-top: 10px;
}
.wd.f-height {
  height: 100%;
}
.wd.flex-align-center {
  align-items: center;
}
.wd.flex {
  display: flex;
}
.wd.flex-column {
  flex-direction: column;
}

.h-auto {
  height: auto !important;
}
.min-h-auto {
  min-height: auto !important;
}

.react-flow__attribution {
  display: none;
}

.sortable-ghost {
  display: block;
  width: 100%;
  height: 0;
  font-size: 0.001px;
  line-height: 0;
  color: transparent;
}

.sortable-ghost::before {
  content: &apos;&apos;;
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  height: 0;
  background: blue;
}

.Loader {
  padding-top: 10px;
  width: 150px;
  height: 150px;
}

/* ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà */
.Loader {
  position: relative;
  width: 150px;
  width: 150px;
  min-width: 110px;
  overflow: visible;
  margin: 20px;
  border-radius: 50%;
  box-shadow:
    inset 0 0 8px rgba(255, 255, 255, 0.4),
    0 0 25px rgba(255, 255, 255, 0.8);
}
.Loader::after {
  content: attr(data-text);
  color: #cecece;
  color: #cecece;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  font-size: calc(70% + 0.1vw);
  text-transform: uppercase;
  letter-spacing: 5px;
}
.Loader {
  /* Keep ratio on resize */
}
.Loader::before {
  content: &apos;&apos;;
  float: left;
  padding-top: 100%;
}
.Loader__Circle {
  display: block;
  position: absolute;
  border-radius: 50%;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  opacity: 0.8;
  mix-blend-mode: screen;
  filter: url(&apos;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;filter id=&quot;filter&quot;&gt;&lt;feComponentTransfer color-interpolation-filters=&quot;sRGB&quot;&gt;&lt;feFuncR type=&quot;linear&quot; slope=&quot;1.2&quot; /&gt;&lt;feFuncG type=&quot;linear&quot; slope=&quot;1.2&quot; /&gt;&lt;feFuncB type=&quot;linear&quot; slope=&quot;1.2&quot; /&gt;&lt;/feComponentTransfer&gt;&lt;/filter&gt;&lt;/svg&gt;#filter&apos;);
  filter: brightness(120%);
  -webkit-animation-name: SpinAround;
  animation-name: SpinAround;
  -webkit-animation-iteration-count: infinite;
  animation-iteration-count: infinite;
  -webkit-animation-duration: 2s;
  animation-duration: 2s;
  -webkit-animation-fill-mode: both;
  animation-fill-mode: both;
  -webkit-animation-timing-function: linear;
  animation-timing-function: linear;
}
.Loader__Circle:nth-of-type(1) {
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    4px 0 0 4px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    4px 0 0 4px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    4px 0 0 3px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    4px 0 0 3px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    3px 0 0 4px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    3px 0 0 4px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    3px 0 0 3px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    3px 0 0 3px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    4px 0 0 4px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    4px 0 0 4px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    4px 0 0 3px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    4px 0 0 3px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    3px 0 0 4px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    3px 0 0 4px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    3px 0 0 3px #2979ff;
  box-shadow:
    inset 1px 0 0 1px #2979ff,
    3px 0 0 3px #2979ff;
  animation-direction: reverse;
  transform-origin: 49.6% 49.8%;
}
.Loader__Circle:nth-of-type(2) {
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    4px 0px 0 4px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    4px 0px 0 4px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    4px 0px 0 3px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    4px 0px 0 3px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    3px 0px 0 4px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    3px 0px 0 4px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    3px 0px 0 3px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    3px 0px 0 3px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    4px 0px 0 4px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    4px 0px 0 4px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    4px 0px 0 3px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    4px 0px 0 3px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    3px 0px 0 4px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    3px 0px 0 4px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    3px 0px 0 3px #ff1744;
  box-shadow:
    inset 1px 0 0 1px #ff1744,
    3px 0px 0 3px #ff1744;
  transform-origin: 49.5% 49.8%;
}
.Loader__Circle:nth-of-type(3) {
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 4px 0 4px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 4px 0 4px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 4px 0 3px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 4px 0 3px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 3px 0 4px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 3px 0 4px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 3px 0 3px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 3px 0 3px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 4px 0 4px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 4px 0 4px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 4px 0 3px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 4px 0 3px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 3px 0 4px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 3px 0 4px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 3px 0 3px #ffff8d;
  box-shadow:
    inset 1px 0 0 1px #ffff8d,
    0 3px 0 3px #ffff8d;
  transform-origin: 49.8% 49.8%;
}
.Loader__Circle:nth-of-type(4) {
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 4px 0 4px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 4px 0 4px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 4px 0 3px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 4px 0 3px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 3px 0 4px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 3px 0 4px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 3px 0 3px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 3px 0 3px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 4px 0 4px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 4px 0 4px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 4px 0 3px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 4px 0 3px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 3px 0 4px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 3px 0 4px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 3px 0 3px #b2ff59;
  box-shadow:
    inset 1px 0 0 1px #b2ff59,
    0 3px 0 3px #b2ff59;
  transform-origin: 49.7% 49.7%;
}
@-webkit-keyframes SpinAround {
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(-360deg);
  }
}
@keyframes SpinAround {
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(-360deg);
  }
}

/* Map refresh */
.socket {
  scale: 0.5;
  width: 150px;
  height: 150px;
  left: 50%;
  /* margin-left: -75px; */
  top: 50%;
  /* margin-top: -50px; */
}

.hex-brick {
  background: #000;
  width: 30px;
  height: 17px;
  position: absolute;
  top: 5px;
  animation-name: fade;
  animation-duration: 2s;
  animation-iteration-count: infinite;
  -webkit-animation-name: fade;
  -webkit-animation-duration: 2s;
  -webkit-animation-iteration-count: infinite;
}

.hex-brick--active {
  animation-name: fade-active;
  -webkit-animation-name: fade-active;
}

.h2 {
  transform: rotate(60deg);
  -webkit-transform: rotate(60deg);
}

.h3 {
  transform: rotate(-60deg);
  -webkit-transform: rotate(-60deg);
}

.gel {
  height: 30px;
  width: 30px;
  transition: all 0.3s;
  -webkit-transition: all 0.3s;
  position: absolute;
  top: 50%;
  left: 50%;
}

.center-gel {
  margin-left: -15px;
  margin-top: -15px;

  animation-name: pulse-version;
  animation-duration: 2s;
  animation-iteration-count: infinite;
  -webkit-animation-name: pulse-version;
  -webkit-animation-duration: 2s;
  -webkit-animation-iteration-count: infinite;
}

.c1 {
  margin-left: -47px;
  margin-top: -15px;
}

.c2 {
  margin-left: -31px;
  margin-top: -43px;
}

.c3 {
  margin-left: 1px;
  margin-top: -43px;
}

.c4 {
  margin-left: 17px;
  margin-top: -15px;
}
.c5 {
  margin-left: -31px;
  margin-top: 13px;
}

.c6 {
  margin-left: 1px;
  margin-top: 13px;
}

.c7 {
  margin-left: -63px;
  margin-top: -43px;
}

.c8 {
  margin-left: 33px;
  margin-top: -43px;
}

.c9 {
  margin-left: -15px;
  margin-top: 41px;
}

.c10 {
  margin-left: -63px;
  margin-top: 13px;
}

.c11 {
  margin-left: 33px;
  margin-top: 13px;
}

.c12 {
  margin-left: -15px;
  margin-top: -71px;
}

.c13 {
  margin-left: -47px;
  margin-top: -71px;
}

.c14 {
  margin-left: 17px;
  margin-top: -71px;
}

.c15 {
  margin-left: -47px;
  margin-top: 41px;
}

.c16 {
  margin-left: 17px;
  margin-top: 41px;
}

.c17 {
  margin-left: -79px;
  margin-top: -15px;
}

.c18 {
  margin-left: 49px;
  margin-top: -15px;
}

.c19 {
  margin-left: -63px;
  margin-top: -99px;
}

.c20 {
  margin-left: 33px;
  margin-top: -99px;
}

.c21 {
  margin-left: 1px;
  margin-top: -99px;
}

.c22 {
  margin-left: -31px;
  margin-top: -99px;
}

.c23 {
  margin-left: -63px;
  margin-top: 69px;
}

.c24 {
  margin-left: 33px;
  margin-top: 69px;
}

.c25 {
  margin-left: 1px;
  margin-top: 69px;
}

.c26 {
  margin-left: -31px;
  margin-top: 69px;
}

.c27 {
  margin-left: -79px;
  margin-top: -15px;
}

.c28 {
  margin-left: -95px;
  margin-top: -43px;
}

.c29 {
  margin-left: -95px;
  margin-top: 13px;
}

.c30 {
  margin-left: 49px;
  margin-top: 41px;
}

.c31 {
  margin-left: -79px;
  margin-top: -71px;
}

.c32 {
  margin-left: -111px;
  margin-top: -15px;
}

.c33 {
  margin-left: 65px;
  margin-top: -43px;
}

.c34 {
  margin-left: 65px;
  margin-top: 13px;
}

.c35 {
  margin-left: -79px;
  margin-top: 41px;
}

.c36 {
  margin-left: 49px;
  margin-top: -71px;
}

.c37 {
  margin-left: 81px;
  margin-top: -15px;
}

.r1 {
  animation-name: pulse-version;
  animation-duration: 2s;
  animation-iteration-count: infinite;
  animation-delay: 0.2s;
  -webkit-animation-name: pulse-version;
  -webkit-animation-duration: 2s;
  -webkit-animation-iteration-count: infinite;
  -webkit-animation-delay: 0.2s;
}

.r2 {
  animation-name: pulse-version;
  animation-duration: 2s;
  animation-iteration-count: infinite;
  animation-delay: 0.4s;
  -webkit-animation-name: pulse-version;
  -webkit-animation-duration: 2s;
  -webkit-animation-iteration-count: infinite;
  -webkit-animation-delay: 0.4s;
}

.r3 {
  animation-name: pulse-version;
  animation-duration: 2s;
  animation-iteration-count: infinite;
  animation-delay: 0.6s;
  -webkit-animation-name: pulse-version;
  -webkit-animation-duration: 2s;
  -webkit-animation-iteration-count: infinite;
  -webkit-animation-delay: 0.6s;
}

.r1 &gt; .hex-brick {
  animation-name: fade;
  animation-duration: 2s;
  animation-iteration-count: infinite;
  animation-delay: 0.2s;
  -webkit-animation-name: fade;
  -webkit-animation-duration: 2s;
  -webkit-animation-iteration-count: infinite;
  -webkit-animation-delay: 0.2s;
}

.r1 &gt; .hex-brick--active {
  animation-name: fade-active;
  -webkit-animation-name: fade-active;
}

.r2 &gt; .hex-brick {
  animation-name: fade;
  animation-duration: 2s;
  animation-iteration-count: infinite;
  animation-delay: 0.4s;
  -webkit-animation-name: fade;
  -webkit-animation-duration: 2s;
  -webkit-animation-iteration-count: infinite;
  -webkit-animation-delay: 0.4s;
}

.r2 &gt; .hex-brick--active {
  animation-name: fade-active;
  -webkit-animation-name: fade-active;
}

.r3 &gt; .hex-brick {
  animation-name: fade;
  animation-duration: 2s;
  animation-iteration-count: infinite;
  animation-delay: 0.6s;
  -webkit-animation-name: fade;
  -webkit-animation-duration: 2s;
  -webkit-animation-iteration-count: infinite;
  -webkit-animation-delay: 0.6s;
}

.r3 &gt; .hex-brick--active {
  animation-name: fade-active;
  -webkit-animation-name: fade-active;
}

@keyframes pulse-version {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }

  50% {
    -webkit-transform: scale(0.01);
    transform: scale(0.01);
  }

  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }
}

@keyframes fade {
  0% {
    background: #09d0e2;
  }

  50% {
    background: #8ae6ee;
  }

  100% {
    background: #09d0e2;
  }
}

@keyframes fade-active {
  0% {
    background: #ff52d9;
  }

  50% {
    background: #ff52d9;
  }

  100% {
    background: #ff52d9;
  }
}

@-webkit-keyframes pulse {
  0% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }

  50% {
    -webkit-transform: scale(0.01);
    transform: scale(0.01);
  }

  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }
}

@-webkit-keyframes fade {
  0% {
    background: #abf8ff;
  }

  50% {
    background: #389ca6;
  }

  100% {
    background: #abf8ff;
  }
}
/* Map refresh END */

.inputContainer {
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
}
.inputContainer &gt; span:nth-child(1),
.inputContainer &gt; label:nth-child(1) {
  color: var(--gray-200);
  font-size: 13px;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}
.inputContainer &gt; :nth-child(2) {
  border-bottom: 2px dotted #3f3f3f;
  height: 1px;
  margin: 0 12px;
}

.smallInputSwitch {
  height: 100%;
  display: flex;
  align-items: center;
}
.smallInputSwitch .p-inputswitch {
  height: 1rem;
  width: 2rem;
}
.smallInputSwitch .p-inputswitch.p-inputswitch-checked .p-inputswitch-slider::before {
  transform: translateX(1rem);
}
.smallInputSwitch .p-inputswitch.p-highlight .p-inputswitch-slider:before {
  transform: translateX(1rem);
}
.smallInputSwitch .p-inputswitch .p-inputswitch-slider::before {
  width: 0.8rem;
  height: 0.8rem;
  margin-top: -0.4rem;
  margin-left: -3px;
}

.checkboxRoot.sizeXS {
  width: 14px;
  height: 14px;
}
.checkboxRoot.sizeXS .p-checkbox-box,
.checkboxRoot.sizeXS .p-checkbox-input {
  width: 14px;
  height: 14px;
}
.checkboxRoot.sizeM {
  width: 16px;
  height: 16px;
}
.checkboxRoot.sizeM .p-checkbox-box,
.checkboxRoot.sizeM .p-checkbox-input {
  width: 16px;
  height: 16px;
}

.verticalTabsContainer {
  display: flex;
  width: 100%;
  min-height: 300px;
}
.verticalTabsContainer .p-tabview {
  width: 100%;
  display: flex;
  align-items: flex-start;
}
.verticalTabsContainer .p-tabview-panels {
  padding: 6px 1rem !important;
  flex-grow: 1;
  height: 100%;
}
.verticalTabsContainer .p-tabview-nav-container {
  border-right: none;
  height: 100%;
}
.verticalTabsContainer .p-tabview-nav {
  flex-direction: column;
  width: 150px;
  min-height: 100%;
  border: none;
}
.verticalTabsContainer .p-tabview-nav li {
  width: 100%;
  border-right: 4px solid var(--surface-hover);
  background-color: var(--surface-card);
  transition:
    background-color 200ms,
    border-right-color 200ms;
}
.verticalTabsContainer .p-tabview-nav li:hover {
  background-color: var(--surface-hover);
  border-right: 4px solid var(--surface-100);
}
.verticalTabsContainer .p-tabview-nav li .p-tabview-nav-link {
  transition: color 200ms;
  justify-content: flex-end;
  padding: 10px;
  background-color: initial;
  border: none;
  color: var(--gray-400);
  border-radius: initial;
  font-weight: 400;
  margin: 0;
}
.verticalTabsContainer .p-tabview-nav li.p-tabview-selected {
  background-color: var(--surface-50);
  border-right: 4px solid var(--primary-color);
}
.verticalTabsContainer .p-tabview-nav li.p-tabview-selected .p-tabview-nav-link {
  font-weight: 600;
  color: var(--primary-color);
}
.verticalTabsContainer .p-tabview-nav li.p-tabview-selected:hover {
  border-right: 4px solid var(--primary-color);
}
.verticalTabsContainer .p-tabview-panel {
  flex-grow: 1;
}</file><file path="assets/js/hooks/Mapper/common-styles/prime-fixes/fix-dialog.scss">body .p-dialog {
  display: flex;
  flex-direction: column;
  top: 0;
  left: 0;
  overflow: hidden;
  border-radius: 2px;
  box-shadow: 0 2px 10px 0 rgba(0,0,0,0.2);
  transition: box-shadow 0.3s;
  z-index: 1000;
  border: 1px solid #212121;
  background: var(--surface-h);
  color: var(--text-color);

  .p-dialog-header {
    background: #171717 !important;
    color: var(--text-color);

    .p-dialog-header-icon:focus-visible {
      box-shadow: none !important;
    }
  }

  .p-dialog-footer {
    border-top: 1px solid var(--surface-d);
  }
}

.p-dialog-visible {
  visibility: visible;
}

.p-dialog-enter {
  opacity: 0;
}

.p-dialog-enter-active {
  opacity: 1;
  transition: opacity 0.3s;
}

.p-dialog-exit {
  opacity: 1;
}

.p-dialog-exit-active {
  opacity: 0;
  transition: opacity 0.3s;
}

.p-dialog-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem;
  background: #f4f4f4;
  height: 40px;
}

.p-dialog-content {
  padding: 0.5rem;
  overflow-y: auto;
  flex: 1;
}

.p-dialog-footer {
  padding: 1rem;
  border-top: 1px solid #ddd;
  background: #f4f4f4;
}

.p-dialog-header-close {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 2rem;
  height: 2rem;
  background: transparent;
  border: none;
  cursor: pointer;
  outline: none;
}

.p-dialog-header-close .pi {
  font-size: 1.25rem;
}

.p-dialog {
  .p-dialog-title {
    font-size: 1rem !important;
  }
  .p-dialog-header-icons {
    align-self: initial !important;
  }
}</file><file path="assets/js/hooks/Mapper/common-styles/prime-fixes/fix-input.scss">/* bootstrap4-dark-blue/theme.css */

/* –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –¥–ª—è Input */
.p-inputtext {
  display: inline-block;
  width: 100%;
  padding: .375rem .75rem;
  font-size: 1rem;
  font-weight: 400;
  line-height: 1.5;
  //color: #495057;
  //background-color: #2a2a2a;
  background-clip: padding-box;
  //border: 1px solid #ced4da;
  border-radius: .25rem;
  transition: border-color .15s ease-in-out, box-shadow .15s ease-in-out;
}

.p-inputtext:focus {
  //color: #495057;
  //background-color: #2a2a2a;
  //border-color: #80bdff;
  outline: 0;
  //box-shadow: 0 0 0 .2rem rgba(0, 123, 255, .25);
}

.p-inputtext::placeholder {
  //color: #6c757d;
  opacity: 1;
}

.p-inputtext:disabled, .p-inputtext[readonly] {
  //background-color: #e9ecef;
  opacity: 1;
}

/* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π */
.p-inputtext:-moz-placeholder {
  //color: #6c757d;
  opacity: 1;
}

.p-inputtext::-moz-placeholder {
  //color: #6c757d;
  opacity: 1;
}

.p-inputtext:-ms-input-placeholder {
  //color: #6c757d;
  opacity: 1;
}

.p-inputtext::-webkit-input-placeholder {
  //color: #6c757d;
  opacity: 1;
}

.p-inputtext[readonly] {
  //background-color: #e9ecef;
  opacity: 1;
}</file><file path="assets/js/hooks/Mapper/common-styles/prime-fixes/fix-popup.scss">.p-confirm-popup {
  display: flex;
  flex-direction: column;
  gap: 6px;
  @apply p-[12px];

  &amp;::before, &amp;::after {
    display: none;
  }

  .p-confirm-popup-content, .p-confirm-popup-footer {
    @apply p-0 m-0;
  }

  .p-confirm-popup-content {
    display: flex;
    gap: 6px;
  }

  .p-confirm-popup-footer {
    display: flex;
    justify-content: flex-end;
    gap: 4px;
  }

  .p-confirm-popup-icon {
    font-size: 14px;
  }

  .p-confirm-popup-message {
    @apply m-0;
    font-size: 12px;
  }

  .p-confirm-popup-reject.p-button-sm,
  .p-confirm-popup-accept.p-button-sm {
    @apply px-1.5 py-1 m-0;

    &amp; &gt; span {
      font-size: 12px;
      line-height: 12px;
    }
  }

}</file><file path="assets/js/hooks/Mapper/common-styles/prime-fixes/fix-tabs.scss">.vertical-tabs-container {
  display: flex;
  width: 100%;
  min-height: 300px;

  .p-tabview {
    width: 100%;
    display: flex;
    align-items: flex-start;
  }

  .p-tabview-panels {
    padding: 6px 1rem;
    flex-grow: 1;
    height: 100%;
  }

  .p-tabview-nav-container {
    border-right: none;
    height: 100%;
  }

  .p-tabview-nav {
    flex-direction: column;
    width: 150px;
    min-height: 100%;
    border: none;

    li {
      width: 100%;
      border-right: 4px solid var(--surface-hover);
      background-color: var(--surface-card);

      transition: background-color 200ms, border-right-color 200ms;

      &amp;:hover {
        background-color: var(--surface-hover);
        border-right: 4px solid var(--surface-100);
      }

      .p-tabview-nav-link {
        transition: color 200ms;

        justify-content: flex-end;
        padding: 10px;
        //background-color: var(--surface-card);
        background-color: initial;
        border: none;
        color: var(--gray-400);

        border-radius: initial;
        font-weight: 400;
        margin: 0;
      }

      &amp;.p-tabview-selected {
        background-color: var(--surface-50);
        border-right: 4px solid var(--primary-color);

        .p-tabview-nav-link {
          font-weight: 600;
          color: var(--primary-color);
        }

        &amp;:hover {
          //background-color: var(--surface-hover);
          border-right: 4px solid var(--primary-color);
        }

      }
    }
  }

  .p-tabview-panel {
    flex-grow: 1;
  }
}</file><file path="assets/js/hooks/Mapper/common-styles/prime-fixes/index.scss">@import &quot;fix-dialog&quot;;
@import &quot;fix-popup&quot;;
@import &quot;fix-tabs&quot;;
//@import &quot;fix-input&quot;;

//@import &quot;theme&quot;;</file><file path="assets/js/hooks/Mapper/common-styles/prime-fixes/theme.scss">:root {
  font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;
  --font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto,
  	Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;,
  	&quot;Segoe UI Symbol&quot;;
  --surface-a: #2a323d;
  --surface-b: #20262e;
  --surface-c: rgba(255, 255, 255, 0.04);
  --surface-d: #3f4b5b;
  --surface-e: #2a323d;
  --surface-f: #2a323d;
  --surface-h: #171717;
  --text-color: rgba(255, 255, 255, 0.87);
  --text-color-secondary: rgba(255, 255, 255, 0.6);
  --primary-color: #8dd0ff;
  --primary-color-text: #151515;
  --surface-0: #20262e;
  --surface-50: #363c43;
  --surface-100: #4d5158;
  --surface-200: #63676d;
  --surface-300: #797d82;
  --surface-400: #909397;
  --surface-500: #a6a8ab;
  --surface-600: #bcbec0;
  --surface-700: #d2d4d5;
  --surface-800: #e9e9ea;
  --surface-900: #ffffff;
  --gray-50: #e9e9ea;
  --gray-100: #d2d4d5;
  --gray-200: #bcbec0;
  --gray-300: #a6a8ab;
  --gray-400: #909397;
  --gray-500: #797d82;
  --gray-600: #63676d;
  --gray-700: #4d5158;
  --gray-800: #363c43;
  --gray-900: #20262e;
  --content-padding: 1.25rem;
  --inline-spacing: 0.5rem;
  --border-radius: 4px;
  --surface-ground: #20262e;
  --surface-section: #20262e;
  --surface-card: #2a323d;
  --surface-overlay: #2a323d;
  --surface-border: #3f4b5b;
  --surface-hover: rgba(255, 255, 255, 0.04);
  --focus-ring: 0 0 0 1px #e3f3fe;
  --maskbg: rgba(0, 0, 0, 0.4);
  --highlight-bg: #8dd0ff;
  --highlight-text-color: #151515;
  color-scheme: dark;
}

:root {
  --blue-50:#f3f8ff;
  --blue-100:#c5dcff;
  --blue-200:#97c1fe;
  --blue-300:#69a5fe;
  --blue-400:#3b8afd;
  --blue-500:#0d6efd;
  --blue-600:#0b5ed7;
  --blue-700:#094db1;
  --blue-800:#073d8b;
  --blue-900:#052c65;
  --green-50:#f4f9f6;
  --green-100:#c8e2d6;
  --green-200:#9ccbb5;
  --green-300:#70b595;
  --green-400:#459e74;
  --green-500:#198754;
  --green-600:#157347;
  --green-700:#125f3b;
  --green-800:#0e4a2e;
  --green-900:#0a3622;
  --yellow-50:#fffcf3;
  --yellow-100:#fff0c3;
  --yellow-200:#ffe494;
  --yellow-300:#ffd965;
  --yellow-400:#ffcd36;
  --yellow-500:#ffc107;
  --yellow-600:#d9a406;
  --yellow-700:#b38705;
  --yellow-800:#8c6a04;
  --yellow-900:#664d03;
  --cyan-50:#f3fcfe;
  --cyan-100:#c5f2fb;
  --cyan-200:#97e8f9;
  --cyan-300:#69def6;
  --cyan-400:#3bd4f3;
  --cyan-500:#0dcaf0;
  --cyan-600:#0baccc;
  --cyan-700:#098da8;
  --cyan-800:#076f84;
  --cyan-900:#055160;
  --pink-50:#fdf5f9;
  --pink-100:#f5cee1;
  --pink-200:#eda7ca;
  --pink-300:#e681b3;
  --pink-400:#de5a9b;
  --pink-500:#d63384;
  --pink-600:#b62b70;
  --pink-700:#96245c;
  --pink-800:#761c49;
  --pink-900:#561435;
  --indigo-50:#f7f3fe;
  --indigo-100:#dac6fc;
  --indigo-200:#bd98f9;
  --indigo-300:#a06bf7;
  --indigo-400:#833df4;
  --indigo-500:#6610f2;
  --indigo-600:#570ece;
  --indigo-700:#470ba9;
  --indigo-800:#380985;
  --indigo-900:#290661;
  --teal-50:#f4fcfa;
  --teal-100:#c9f2e6;
  --teal-200:#9fe8d2;
  --teal-300:#75debf;
  --teal-400:#4ad3ab;
  --teal-500:#20c997;
  --teal-600:#1bab80;
  --teal-700:#168d6a;
  --teal-800:#126f53;
  --teal-900:#0d503c;
  --orange-50:#fff9f3;
  --orange-100:#ffe0c7;
  --orange-200:#fec89a;
  --orange-300:#feaf6d;
  --orange-400:#fd9741;
  --orange-500:#fd7e14;
  --orange-600:#d76b11;
  --orange-700:#b1580e;
  --orange-800:#8b450b;
  --orange-900:#653208;
  --bluegray-50:#f8f9fb;
  --bluegray-100:#e0e4ea;
  --bluegray-200:#c7ced9;
  --bluegray-300:#aeb9c8;
  --bluegray-400:#95a3b8;
  --bluegray-500:#7c8ea7;
  --bluegray-600:#69798e;
  --bluegray-700:#576375;
  --bluegray-800:#444e5c;
  --bluegray-900:#323943;
  --purple-50:#f8f6fc;
  --purple-100:#dcd2f0;
  --purple-200:#c1aee4;
  --purple-300:#a68ad9;
  --purple-400:#8a66cd;
  --purple-500:#6f42c1;
  --purple-600:#5e38a4;
  --purple-700:#4e2e87;
  --purple-800:#3d246a;
  --purple-900:#2c1a4d;
  --red-50:#fdf5f6;
  --red-100:#f7cfd2;
  --red-200:#f0a8af;
  --red-300:#e9828c;
  --red-400:#e35b68;
  --red-500:#dc3545;
  --red-600:#bb2d3b;
  --red-700:#9a2530;
  --red-800:#791d26;
  --red-900:#58151c;
  --primary-50:#f9fdff;
  --primary-100:#e4f4ff;
  --primary-200:#ceebff;
  --primary-300:#b8e2ff;
  --primary-400:#a3d9ff;
  --primary-500:#8dd0ff;
  --primary-600:#78b1d9;
  --primary-700:#6392b3;
  --primary-800:#4e728c;
  --primary-900:#385366;
}

.p-editor-container .p-editor-toolbar {
  background: #2a323d;
  border-top-right-radius: 4px;
  border-top-left-radius: 4px;
}
.p-editor-container .p-editor-toolbar.ql-snow {
  border: 1px solid #3f4b5b;
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-stroke {
  stroke: rgba(255, 255, 255, 0.6);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-fill {
  fill: rgba(255, 255, 255, 0.6);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker .ql-picker-label {
  border: 0 none;
  color: rgba(255, 255, 255, 0.6);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker .ql-picker-label:hover {
  color: rgba(255, 255, 255, 0.87);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker .ql-picker-label:hover .ql-stroke {
  stroke: rgba(255, 255, 255, 0.87);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker .ql-picker-label:hover .ql-fill {
  fill: rgba(255, 255, 255, 0.87);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label {
  color: rgba(255, 255, 255, 0.87);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-stroke {
  stroke: rgba(255, 255, 255, 0.87);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-fill {
  fill: rgba(255, 255, 255, 0.87);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options {
  background: #2a323d;
  border: 1px solid #3f4b5b;
  box-shadow: none;
  border-radius: 4px;
  padding: 0.5rem 0;
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options .ql-picker-item {
  color: rgba(255, 255, 255, 0.87);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options .ql-picker-item:hover {
  color: rgba(255, 255, 255, 0.87);
  background: rgba(255, 255, 255, 0.04);
}
.p-editor-container .p-editor-toolbar.ql-snow .ql-picker.ql-expanded:not(.ql-icon-picker) .ql-picker-item {
  padding: 0.5rem 1.5rem;
}
.p-editor-container .p-editor-content {
  border-bottom-right-radius: 4px;
  border-bottom-left-radius: 4px;
}
.p-editor-container .p-editor-content.ql-snow {
  border: 1px solid #3f4b5b;
}
.p-editor-container .p-editor-content .ql-editor {
  background: #20262e;
  color: rgba(255, 255, 255, 0.87);
  border-bottom-right-radius: 4px;
  border-bottom-left-radius: 4px;
}
.p-editor-container .ql-snow.ql-toolbar button:hover,
.p-editor-container .ql-snow.ql-toolbar button:focus {
  color: rgba(255, 255, 255, 0.87);
}
.p-editor-container .ql-snow.ql-toolbar button:hover .ql-stroke,
.p-editor-container .ql-snow.ql-toolbar button:focus .ql-stroke {
  stroke: rgba(255, 255, 255, 0.87);
}
.p-editor-container .ql-snow.ql-toolbar button:hover .ql-fill,
.p-editor-container .ql-snow.ql-toolbar button:focus .ql-fill {
  fill: rgba(255, 255, 255, 0.87);
}
.p-editor-container .ql-snow.ql-toolbar button.ql-active,
.p-editor-container .ql-snow.ql-toolbar .ql-picker-label.ql-active,
.p-editor-container .ql-snow.ql-toolbar .ql-picker-item.ql-selected {
  color: #8dd0ff;
}
.p-editor-container .ql-snow.ql-toolbar button.ql-active .ql-stroke,
.p-editor-container .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke,
.p-editor-container .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke {
  stroke: #8dd0ff;
}
.p-editor-container .ql-snow.ql-toolbar button.ql-active .ql-fill,
.p-editor-container .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-fill,
.p-editor-container .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-fill {
  fill: #8dd0ff;
}
.p-editor-container .ql-snow.ql-toolbar button.ql-active .ql-picker-label,
.p-editor-container .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-picker-label,
.p-editor-container .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-picker-label {
  color: #8dd0ff;
}

@layer primereact {
  * {
    box-sizing: border-box;
  }
  .p-component {
    font-family: var(--font-family);
    font-feature-settings: var(--font-feature-settings, normal);
    font-size: 1rem;
    font-weight: normal;
  }
  .p-component-overlay {
    background-color: rgba(0, 0, 0, 0.4);
    transition-duration: 0.15s;
  }
  .p-disabled, .p-component:disabled {
    opacity: 0.65;
  }
  .p-error {
    color: #f19ea6;
  }
  .p-text-secondary {
    color: rgba(255, 255, 255, 0.6);
  }
  .pi {
    font-size: 1rem;
  }
  .p-icon {
    width: 1rem;
    height: 1rem;
  }
  .p-link {
    font-family: var(--font-family);
    font-feature-settings: var(--font-feature-settings, normal);
    font-size: 1rem;
    border-radius: 4px;
  }
  .p-link:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-component-overlay-enter {
    animation: p-component-overlay-enter-animation 150ms forwards;
  }
  .p-component-overlay-leave {
    animation: p-component-overlay-leave-animation 150ms forwards;
  }
  @keyframes p-component-overlay-enter-animation {
    from {
      background-color: transparent;
    }
    to {
      background-color: var(--maskbg);
    }
  }
  @keyframes p-component-overlay-leave-animation {
    from {
      background-color: var(--maskbg);
    }
    to {
      background-color: transparent;
    }
  }
  .p-autocomplete .p-autocomplete-loader {
    right: 0.75rem;
  }
  .p-autocomplete.p-autocomplete-dd .p-autocomplete-loader {
    right: 3.107rem;
  }
  .p-autocomplete .p-autocomplete-multiple-container {
    padding: 0.25rem 0.75rem;
    gap: 0.5rem;
  }
  .p-autocomplete .p-autocomplete-multiple-container:not(.p-disabled):hover {
    border-color: #3f4b5b;
  }
  .p-autocomplete .p-autocomplete-multiple-container:not(.p-disabled).p-focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-autocomplete .p-autocomplete-multiple-container .p-autocomplete-input-token {
    padding: 0.25rem 0;
  }
  .p-autocomplete .p-autocomplete-multiple-container .p-autocomplete-input-token input {
    font-family: var(--font-family);
    font-feature-settings: var(--font-feature-settings, normal);
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.87);
    padding: 0;
    margin: 0;
  }
  .p-autocomplete .p-autocomplete-multiple-container .p-autocomplete-token {
    padding: 0.25rem 0.75rem;
    margin-right: 0.5rem;
    background: #8dd0ff;
    color: #151515;
    border-radius: 4px;
  }
  .p-autocomplete .p-autocomplete-multiple-container .p-autocomplete-token .p-autocomplete-token-icon {
    margin-left: 0.5rem;
  }
  .p-autocomplete.p-invalid.p-component &gt; .p-inputtext {
    border-color: #f19ea6;
  }
  .p-autocomplete-panel {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    box-shadow: none;
  }
  .p-autocomplete-panel .p-autocomplete-items {
    padding: 0.5rem 0;
  }
  .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item {
    margin: 0;
    padding: 0.5rem 1.5rem;
    border: 0 none;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item:hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item-group {
    margin: 0;
    padding: 0.75rem 1rem;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    font-weight: 600;
  }
  .p-calendar.p-invalid.p-component &gt; .p-inputtext {
    border-color: #f19ea6;
  }
  .p-calendar:not(.p-calendar-disabled).p-focus &gt; .p-inputtext {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-datepicker {
    padding: 0;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
  }
  .p-datepicker:not(.p-datepicker-inline) {
    background: #2a323d;
    border: 1px solid #3f4b5b;
    box-shadow: none;
  }
  .p-datepicker:not(.p-datepicker-inline) .p-datepicker-header {
    background: #2a323d;
  }
  .p-datepicker .p-datepicker-header {
    padding: 0.5rem;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    font-weight: 600;
    margin: 0;
    border-bottom: 1px solid #3f4b5b;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-datepicker .p-datepicker-header .p-datepicker-prev,
  .p-datepicker .p-datepicker-header .p-datepicker-next {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-datepicker .p-datepicker-header .p-datepicker-prev:enabled:hover,
  .p-datepicker .p-datepicker-header .p-datepicker-next:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-datepicker .p-datepicker-header .p-datepicker-prev:focus-visible,
  .p-datepicker .p-datepicker-header .p-datepicker-next:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-datepicker .p-datepicker-header .p-datepicker-title {
    line-height: 2rem;
  }
  .p-datepicker .p-datepicker-header .p-datepicker-title .p-datepicker-year,
  .p-datepicker .p-datepicker-header .p-datepicker-title .p-datepicker-month {
    color: rgba(255, 255, 255, 0.87);
    transition: color 0.15s, box-shadow 0.15s;
    font-weight: 600;
    padding: 0.5rem;
  }
  .p-datepicker .p-datepicker-header .p-datepicker-title .p-datepicker-year:enabled:hover,
  .p-datepicker .p-datepicker-header .p-datepicker-title .p-datepicker-month:enabled:hover {
    color: #8dd0ff;
  }
  .p-datepicker .p-datepicker-header .p-datepicker-title .p-datepicker-month {
    margin-right: 0.5rem;
  }
  .p-datepicker table {
    font-size: 1rem;
    margin: 0.5rem 0;
  }
  .p-datepicker table th {
    padding: 0.5rem;
  }
  .p-datepicker table th &gt; span {
    width: 2.5rem;
    height: 2.5rem;
  }
  .p-datepicker table td {
    padding: 0.5rem;
  }
  .p-datepicker table td &gt; span {
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 4px;
    transition: box-shadow 0.15s;
    border: 1px solid transparent;
  }
  .p-datepicker table td &gt; span.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-datepicker table td &gt; span:focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-datepicker table td.p-datepicker-today &gt; span {
    background: transparent;
    color: #8dd0ff;
    border-color: transparent;
  }
  .p-datepicker table td.p-datepicker-today &gt; span.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-datepicker .p-datepicker-buttonbar {
    padding: 1rem 0;
    border-top: 1px solid #3f4b5b;
  }
  .p-datepicker .p-datepicker-buttonbar .p-button {
    width: auto;
  }
  .p-datepicker .p-timepicker {
    border-top: 1px solid #3f4b5b;
    padding: 0.5rem;
  }
  .p-datepicker .p-timepicker button {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-datepicker .p-timepicker button:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-datepicker .p-timepicker button:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-datepicker .p-timepicker button:last-child {
    margin-top: 0.2em;
  }
  .p-datepicker .p-timepicker span {
    font-size: 1.25rem;
  }
  .p-datepicker .p-timepicker &gt; div {
    padding: 0 0.5rem;
  }
  .p-datepicker.p-datepicker-timeonly .p-timepicker {
    border-top: 0 none;
  }
  .p-datepicker .p-monthpicker {
    margin: 0.5rem 0;
  }
  .p-datepicker .p-monthpicker .p-monthpicker-month {
    padding: 0.5rem;
    transition: box-shadow 0.15s;
    border-radius: 4px;
  }
  .p-datepicker .p-monthpicker .p-monthpicker-month.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-datepicker .p-yearpicker {
    margin: 0.5rem 0;
  }
  .p-datepicker .p-yearpicker .p-yearpicker-year {
    padding: 0.5rem;
    transition: box-shadow 0.15s;
    border-radius: 4px;
  }
  .p-datepicker .p-yearpicker .p-yearpicker-year.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-datepicker.p-datepicker-multiple-month .p-datepicker-group {
    border-left: 1px solid #3f4b5b;
    padding-right: 0;
    padding-left: 0;
    padding-top: 0;
    padding-bottom: 0;
  }
  .p-datepicker.p-datepicker-multiple-month .p-datepicker-group:first-child {
    padding-left: 0;
    border-left: 0 none;
  }
  .p-datepicker.p-datepicker-multiple-month .p-datepicker-group:last-child {
    padding-right: 0;
  }
  .p-datepicker:not(.p-disabled) table td span:not(.p-highlight):not(.p-disabled):hover {
    background: rgba(255, 255, 255, 0.04);
  }
  .p-datepicker:not(.p-disabled) table td span:not(.p-highlight):not(.p-disabled):focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-datepicker:not(.p-disabled) .p-monthpicker .p-monthpicker-month:not(.p-disabled):not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
  }
  .p-datepicker:not(.p-disabled) .p-monthpicker .p-monthpicker-month:not(.p-disabled):focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-datepicker:not(.p-disabled) .p-yearpicker .p-yearpicker-year:not(.p-disabled):not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
  }
  .p-datepicker:not(.p-disabled) .p-yearpicker .p-yearpicker-year:not(.p-disabled):focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  @media screen and (max-width: 769px) {
    .p-datepicker table th,
    .p-datepicker table td {
      padding: 0;
    }
  }
  .p-cascadeselect {
    background: #20262e;
    border: 1px solid #3f4b5b;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    border-radius: 4px;
    outline-color: transparent;
  }
  .p-cascadeselect:not(.p-disabled):hover {
    border-color: #3f4b5b;
  }
  .p-cascadeselect:not(.p-disabled).p-focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-cascadeselect.p-variant-filled {
    background-color: #3f4b5b;
  }
  .p-cascadeselect.p-variant-filled:enabled:hover {
    background-color: #3f4b5b;
  }
  .p-cascadeselect.p-variant-filled:enabled:focus {
    background-color: #3f4b5b;
  }
  .p-cascadeselect .p-cascadeselect-label {
    background: transparent;
    border: 0 none;
    padding: 0.5rem 0.75rem;
  }
  .p-cascadeselect .p-cascadeselect-label.p-placeholder {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-cascadeselect .p-cascadeselect-label:enabled:focus {
    outline: 0 none;
    box-shadow: none;
  }
  .p-cascadeselect .p-cascadeselect-trigger {
    background: transparent;
    color: rgba(255, 255, 255, 0.6);
    width: 2.357rem;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
  }
  .p-cascadeselect.p-invalid.p-component {
    border-color: #f19ea6;
  }
  .p-cascadeselect-panel {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    box-shadow: none;
  }
  .p-cascadeselect-panel .p-cascadeselect-items {
    padding: 0.5rem 0;
  }
  .p-cascadeselect-panel .p-cascadeselect-items .p-cascadeselect-item {
    margin: 0;
    border: 0 none;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-cascadeselect-panel .p-cascadeselect-items .p-cascadeselect-item:first-child {
    margin-top: 0;
  }
  .p-cascadeselect-panel .p-cascadeselect-items .p-cascadeselect-item:last-child {
    margin-bottom: 0;
  }
  .p-cascadeselect-panel .p-cascadeselect-items .p-cascadeselect-item.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-cascadeselect-panel .p-cascadeselect-items .p-cascadeselect-item.p-highlight.p-focus {
    background: #64bfff;
  }
  .p-cascadeselect-panel .p-cascadeselect-items .p-cascadeselect-item:not(.p-highlight):not(.p-disabled).p-focus {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-cascadeselect-panel .p-cascadeselect-items .p-cascadeselect-item .p-cascadeselect-item-content {
    padding: 0.5rem 1.5rem;
  }
  .p-cascadeselect-panel .p-cascadeselect-items .p-cascadeselect-item .p-cascadeselect-group-icon {
    font-size: 0.875rem;
  }
  .p-checkbox {
    position: relative;
    display: inline-flex;
    user-select: none;
    vertical-align: bottom;
  }
  .p-checkbox-input {
    appearance: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: 1;
    outline: 0 none;
    cursor: pointer;
  }
  .p-checkbox-box {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .p-checkbox {
    width: 20px;
    height: 20px;
  }
  .p-checkbox .p-checkbox-input {
    border: 1px solid #3f4b5b;
    border-radius: 4px;
  }
  .p-checkbox .p-checkbox-box {
    border: 1px solid #3f4b5b;
    background: #20262e;
    width: 20px;
    height: 20px;
    color: rgba(255, 255, 255, 0.87);
    border-radius: 4px;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    outline-color: transparent;
  }
  .p-checkbox .p-checkbox-box .p-checkbox-icon {
    transition-duration: 0.15s;
    color: #151515;
    font-size: 14px;
  }
  .p-checkbox .p-checkbox-box .p-checkbox-icon.p-icon {
    width: 14px;
    height: 14px;
  }
  .p-checkbox .p-checkbox-box {
    border: 1px solid #3f4b5b;
    background: #20262e;
    width: 20px;
    height: 20px;
    color: rgba(255, 255, 255, 0.87);
    border-radius: 4px;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    outline-color: transparent;
  }
  .p-checkbox .p-checkbox-box .p-checkbox-icon {
    transition-duration: 0.15s;
    color: #151515;
    font-size: 14px;
  }
  .p-checkbox .p-checkbox-box .p-checkbox-icon.p-icon {
    width: 14px;
    height: 14px;
  }
  .p-checkbox.p-highlight .p-checkbox-box {
    border-color: #8dd0ff;
    background: #8dd0ff;
  }
  .p-checkbox:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {
    border-color: #3f4b5b;
  }
  .p-checkbox:not(.p-disabled):has(.p-checkbox-input:hover).p-highlight .p-checkbox-box {
    border-color: #1dadff;
    background: #1dadff;
    color: #151515;
  }
  .p-checkbox:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-checkbox.p-invalid &gt; .p-checkbox-box {
    border-color: #f19ea6;
  }
  .p-checkbox.p-variant-filled .p-checkbox-box {
    background-color: #3f4b5b;
  }
  .p-checkbox.p-variant-filled.p-highlight .p-checkbox-box {
    background: #8dd0ff;
  }
  .p-checkbox.p-variant-filled:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {
    background-color: #3f4b5b;
  }
  .p-checkbox.p-variant-filled:not(.p-disabled):has(.p-checkbox-input:hover).p-highlight .p-checkbox-box {
    background: #1dadff;
  }
  .p-input-filled .p-checkbox .p-checkbox-box {
    background-color: #3f4b5b;
  }
  .p-input-filled .p-checkbox.p-highlight .p-checkbox-box {
    background: #8dd0ff;
  }
  .p-input-filled .p-checkbox:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {
    background-color: #3f4b5b;
  }
  .p-input-filled .p-checkbox:not(.p-disabled):has(.p-checkbox-input:hover).p-highlight .p-checkbox-box {
    background: #1dadff;
  }
  .p-highlight .p-checkbox .p-checkbox-box {
    border-color: #151515;
  }
  .p-checkbox {
    position: relative;
    display: inline-flex;
    user-select: none;
    vertical-align: bottom;
  }
  .p-checkbox-input {
    cursor: pointer;
  }
  .p-checkbox-box {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .p-tristatecheckbox.p-variant-filled .p-checkbox-box {
    background-color: #3f4b5b;
  }
  .p-tristatecheckbox.p-variant-filled.p-highlight .p-checkbox-box {
    background: #8dd0ff;
  }
  .p-tristatecheckbox.p-variant-filled:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {
    background-color: #3f4b5b;
  }
  .p-tristatecheckbox.p-variant-filled:not(.p-disabled):has(.p-checkbox-input:hover).p-highlight .p-checkbox-box {
    background: #1dadff;
  }
  .p-chips {
    display: inline-flex;
  }
  .p-chips-multiple-container {
    margin: 0;
    padding: 0;
    list-style-type: none;
    cursor: text;
    overflow: hidden;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
  }
  .p-chips-token {
    cursor: default;
    display: inline-flex;
    align-items: center;
    flex: 0 0 auto;
  }
  .p-chips-input-token {
    flex: 1 1 auto;
    display: inline-flex;
  }
  .p-chips-token-icon {
    cursor: pointer;
  }
  .p-chips-input-token input {
    border: 0 none;
    outline: 0 none;
    background-color: transparent;
    margin: 0;
    padding: 0;
    box-shadow: none;
    border-radius: 0;
    width: 100%;
  }
  .p-fluid .p-chips {
    display: flex;
  }
  .p-chips:not(.p-disabled):hover .p-chips-multiple-container {
    border-color: #3f4b5b;
  }
  .p-chips:not(.p-disabled).p-focus .p-chips-multiple-container {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-chips .p-chips-multiple-container {
    padding: 0.25rem 0.75rem;
    outline-color: transparent;
  }
  .p-chips .p-chips-multiple-container .p-chips-token {
    padding: 0.25rem 0.75rem;
    margin-right: 0.5rem;
    background: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    border-radius: 16px;
  }
  .p-chips .p-chips-multiple-container .p-chips-token.p-focus {
    background: #4c5866;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-chips .p-chips-multiple-container .p-chips-token .p-chips-token-icon {
    margin-left: 0.5rem;
  }
  .p-chips .p-chips-multiple-container .p-chips-input-token {
    padding: 0.25rem 0;
  }
  .p-chips .p-chips-multiple-container .p-chips-input-token input {
    font-family: var(--font-family);
    font-feature-settings: var(--font-feature-settings, normal);
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.87);
    padding: 0;
    margin: 0;
  }
  .p-chips.p-invalid.p-component &gt; .p-inputtext {
    border-color: #f19ea6;
  }
  .p-colorpicker-preview {
    width: 2rem;
    height: 2rem;
  }
  .p-colorpicker-panel {
    background: #2a323d;
    border: 1px solid #3f4b5b;
  }
  .p-colorpicker-panel .p-colorpicker-color-handle,
  .p-colorpicker-panel .p-colorpicker-hue-handle {
    border-color: rgba(255, 255, 255, 0.87);
  }
  .p-colorpicker-overlay-panel {
    box-shadow: none;
  }
  .p-dropdown {
    display: inline-flex;
    cursor: pointer;
    position: relative;
    user-select: none;
  }
  .p-dropdown-clear-icon {
    position: absolute;
    top: 50%;
    margin-top: -0.5rem;
  }
  .p-dropdown-trigger {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  .p-dropdown-label {
    display: block;
    white-space: nowrap;
    overflow: hidden;
    flex: 1 1 auto;
    width: 1%;
    text-overflow: ellipsis;
    cursor: pointer;
  }
  .p-dropdown-label-empty {
    overflow: hidden;
    opacity: 0;
  }
  input.p-dropdown-label {
    cursor: default;
  }
  .p-dropdown .p-dropdown-panel {
    min-width: 100%;
  }
  .p-dropdown-panel {
    position: absolute;
    top: 0;
    left: 0;
  }
  .p-dropdown-items-wrapper {
    overflow: auto;
  }
  .p-dropdown-item {
    cursor: pointer;
    font-weight: normal;
    white-space: nowrap;
    position: relative;
    overflow: hidden;
    display: flex;
    align-items: center;
  }
  .p-dropdown-item-group {
    cursor: auto;
  }
  .p-dropdown-items {
    margin: 0;
    padding: 0;
    list-style-type: none;
  }
  .p-dropdown-filter {
    width: 100%;
  }
  .p-dropdown-filter-container {
    position: relative;
  }
  .p-dropdown-filter-icon {
    position: absolute;
    top: 50%;
    margin-top: -0.5rem;
  }
  .p-fluid .p-dropdown {
    display: flex;
  }
  .p-fluid .p-dropdown .p-dropdown-label {
    width: 1%;
  }
  .p-dropdown {
    background: #20262e;
    border: 1px solid #3f4b5b;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    border-radius: 4px;
    outline-color: transparent;
  }
  .p-dropdown:not(.p-disabled):hover {
    border-color: #3f4b5b;
  }
  .p-dropdown:not(.p-disabled).p-focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-dropdown.p-variant-filled {
    background: #3f4b5b;
  }
  .p-dropdown.p-variant-filled:not(.p-disabled):hover {
    background-color: #3f4b5b;
  }
  .p-dropdown.p-variant-filled:not(.p-disabled).p-focus {
    background-color: #3f4b5b;
  }
  .p-dropdown.p-variant-filled:not(.p-disabled).p-focus .p-inputtext {
    background-color: transparent;
  }
  .p-dropdown.p-dropdown-clearable .p-dropdown-label {
    padding-right: 1.75rem;
  }
  .p-dropdown .p-dropdown-label {
    background: transparent;
    border: 0 none;
  }
  .p-dropdown .p-dropdown-label.p-placeholder {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-dropdown .p-dropdown-label:focus, .p-dropdown .p-dropdown-label:enabled:focus {
    outline: 0 none;
    box-shadow: none;
  }
  .p-dropdown .p-dropdown-trigger {
    background: transparent;
    color: rgba(255, 255, 255, 0.6);
    width: 2.357rem;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
  }
  .p-dropdown .p-dropdown-clear-icon {
    color: rgba(255, 255, 255, 0.6);
    right: 2.357rem;
  }
  .p-dropdown.p-invalid.p-component {
    border-color: #f19ea6;
  }
  .p-dropdown-panel {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    box-shadow: none;
  }
  .p-dropdown-panel .p-dropdown-header {
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    margin: 0;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-dropdown-panel .p-dropdown-header .p-dropdown-filter {
    padding-right: 1.75rem;
    margin-right: -1.75rem;
  }
  .p-dropdown-panel .p-dropdown-header .p-dropdown-filter-icon {
    right: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-dropdown-panel .p-dropdown-items {
    padding: 0.5rem 0;
  }
  .p-dropdown-panel .p-dropdown-items .p-dropdown-item {
    margin: 0;
    padding: 0.5rem 1.5rem;
    border: 0 none;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-dropdown-panel .p-dropdown-items .p-dropdown-item:first-child {
    margin-top: 0;
  }
  .p-dropdown-panel .p-dropdown-items .p-dropdown-item:last-child {
    margin-bottom: 0;
  }
  .p-dropdown-panel .p-dropdown-items .p-dropdown-item.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-dropdown-panel .p-dropdown-items .p-dropdown-item.p-highlight.p-focus {
    background: #64bfff;
  }
  .p-dropdown-panel .p-dropdown-items .p-dropdown-item:not(.p-highlight):not(.p-disabled).p-focus {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-dropdown-panel .p-dropdown-items .p-dropdown-item .p-dropdown-check-icon {
    position: relative;
    margin-left: -0.5rem;
    margin-right: 0.5rem;
  }
  .p-dropdown-panel .p-dropdown-items .p-dropdown-item-group {
    margin: 0;
    padding: 0.75rem 1rem;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    font-weight: 600;
  }
  .p-dropdown-panel .p-dropdown-items .p-dropdown-empty-message {
    padding: 0.5rem 1.5rem;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
  }
  .p-inputgroup-addon {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.6);
    border-top: 1px solid #3f4b5b;
    border-left: 1px solid #3f4b5b;
    border-bottom: 1px solid #3f4b5b;
    padding: 0.5rem 0.75rem;
    min-width: 2.357rem;
  }
  .p-inputgroup-addon:last-child {
    border-right: 1px solid #3f4b5b;
  }
  .p-inputgroup &gt; .p-component,
  .p-inputgroup &gt; .p-inputwrapper &gt; .p-inputtext,
  .p-inputgroup &gt; .p-float-label &gt; .p-component {
    border-radius: 0;
    margin: 0;
  }
  .p-inputgroup &gt; .p-component + .p-inputgroup-addon,
  .p-inputgroup &gt; .p-inputwrapper &gt; .p-inputtext + .p-inputgroup-addon,
  .p-inputgroup &gt; .p-float-label &gt; .p-component + .p-inputgroup-addon {
    border-left: 0 none;
  }
  .p-inputgroup &gt; .p-component:focus,
  .p-inputgroup &gt; .p-inputwrapper &gt; .p-inputtext:focus,
  .p-inputgroup &gt; .p-float-label &gt; .p-component:focus {
    z-index: 1;
  }
  .p-inputgroup &gt; .p-component:focus ~ label,
  .p-inputgroup &gt; .p-inputwrapper &gt; .p-inputtext:focus ~ label,
  .p-inputgroup &gt; .p-float-label &gt; .p-component:focus ~ label {
    z-index: 1;
  }
  .p-inputgroup-addon:first-child,
  .p-inputgroup button:first-child,
  .p-inputgroup input:first-child,
  .p-inputgroup &gt; .p-inputwrapper:first-child,
  .p-inputgroup &gt; .p-inputwrapper:first-child &gt; .p-inputtext {
    border-top-left-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-inputgroup .p-float-label:first-child input {
    border-top-left-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-inputgroup-addon:last-child,
  .p-inputgroup button:last-child,
  .p-inputgroup input:last-child,
  .p-inputgroup &gt; .p-inputwrapper:last-child,
  .p-inputgroup &gt; .p-inputwrapper:last-child &gt; .p-inputtext {
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
  }
  .p-inputgroup .p-float-label:last-child input {
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
  }
  .p-fluid .p-inputgroup .p-button {
    width: auto;
  }
  .p-fluid .p-inputgroup .p-button.p-button-icon-only {
    width: 2.357rem;
  }
  .p-inputnumber.p-invalid.p-component &gt; .p-inputtext {
    border-color: #f19ea6;
  }
  .p-inputswitch {
    position: relative;
    display: inline-block;
  }
  .p-inputswitch-input {
    appearance: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: 1;
    outline: 0 none;
    cursor: pointer;
  }
  .p-inputswitch-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border: 1px solid transparent;
  }
  .p-inputswitch-slider:before {
    position: absolute;
    content: &quot;&quot;;
    top: 50%;
  }
  .p-inputswitch {
    width: 3rem;
    height: 1.75rem;
  }
  .p-inputswitch .p-inputswitch-input {
    border-radius: 4px;
  }
  .p-inputswitch .p-inputswitch-slider {
    background: #3f4b5b;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    border-radius: 4px;
    outline-color: transparent;
  }
  .p-inputswitch .p-inputswitch-slider:before {
    background: rgba(255, 255, 255, 0.6);
    width: 1.25rem;
    height: 1.25rem;
    left: 0.25rem;
    margin-top: -0.625rem;
    border-radius: 4px;
    transition-duration: 0.15s;
  }
  .p-inputswitch.p-highlight .p-inputswitch-slider {
    background: #8dd0ff;
  }
  .p-inputswitch.p-highlight .p-inputswitch-slider:before {
    background: #151515;
    transform: translateX(1.25rem);
  }
  .p-inputswitch:not(.p-disabled):has(.p-inputswitch-input:hover) .p-inputswitch-slider {
    background: #3f4b5b;
  }
  .p-inputswitch:not(.p-disabled):has(.p-inputswitch-input:hover).p-highlight .p-inputswitch-slider {
    background: #8dd0ff;
  }
  .p-inputswitch:not(.p-disabled):has(.p-inputswitch-input:focus-visible) .p-inputswitch-slider {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-inputswitch.p-invalid &gt; .p-inputswitch-slider {
    border-color: #f19ea6;
  }
  .p-inputtext {
    font-family: var(--font-family);
    font-feature-settings: var(--font-feature-settings, normal);
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.87);
    background: #20262e;
    padding: 0.5rem 0.75rem;
    border: 1px solid #3f4b5b;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    appearance: none;
    border-radius: 4px;
    outline-color: transparent;
  }
  .p-inputtext:enabled:hover {
    border-color: #3f4b5b;
  }
  .p-inputtext:enabled:focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-inputtext.p-invalid.p-component {
    border-color: #f19ea6;
  }
  .p-inputtext.p-variant-filled {
    background-color: #3f4b5b;
  }
  .p-inputtext.p-variant-filled:enabled:hover {
    background-color: #3f4b5b;
  }
  .p-inputtext.p-variant-filled:enabled:focus {
    background-color: #3f4b5b;
  }
  .p-inputtext.p-inputtext-sm {
    font-size: 0.875rem;
    padding: 0.4375rem 0.65625rem;
  }
  .p-inputtext.p-inputtext-lg {
    font-size: 1.25rem;
    padding: 0.625rem 0.9375rem;
  }
  .p-float-label &gt; label {
    left: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
    transition-duration: 0.15s;
  }
  .p-float-label &gt; .p-invalid + label {
    color: #f19ea6;
  }
  .p-icon-field-left &gt; .p-inputtext {
    padding-left: 2.5rem;
  }
  .p-icon-field-left.p-float-label &gt; label {
    left: 2.5rem;
  }
  .p-icon-field-right &gt; .p-inputtext {
    padding-right: 2.5rem;
  }
  ::-webkit-input-placeholder {
    color: rgba(255, 255, 255, 0.6);
  }
  :-moz-placeholder {
    color: rgba(255, 255, 255, 0.6);
  }
  ::-moz-placeholder {
    color: rgba(255, 255, 255, 0.6);
  }
  :-ms-input-placeholder {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-input-filled .p-inputtext {
    background-color: #3f4b5b;
  }
  .p-input-filled .p-inputtext:enabled:hover {
    background-color: #3f4b5b;
  }
  .p-input-filled .p-inputtext:enabled:focus {
    background-color: #3f4b5b;
  }
  .p-inputtext-sm .p-inputtext {
    font-size: 0.875rem;
    padding: 0.4375rem 0.65625rem;
  }
  .p-inputtext-lg .p-inputtext {
    font-size: 1.25rem;
    padding: 0.625rem 0.9375rem;
  }
  .p-icon-field {
    position: relative;
  }
  .p-icon-field &gt; .p-input-icon {
    position: absolute;
    top: 50%;
    margin-top: -0.5rem;
  }
  .p-fluid .p-icon-field-left,
  .p-fluid .p-icon-field-right {
    width: 100%;
  }
  .p-icon-field-left &gt; .p-input-icon:first-of-type {
    left: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-icon-field-right &gt; .p-input-icon:last-of-type {
    right: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-inputotp {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  .p-inputotp-input {
    text-align: center;
    width: 2.5rem;
  }
  .p-listbox-list-wrapper {
    overflow: auto;
  }
  .p-listbox-list {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
  .p-listbox-item {
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  .p-listbox-item-group {
    cursor: auto;
  }
  .p-listbox-filter-container {
    position: relative;
  }
  .p-listbox-filter-icon {
    position: absolute;
    top: 50%;
    margin-top: -0.5rem;
  }
  .p-listbox-filter {
    width: 100%;
  }
  .p-listbox {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    outline-color: transparent;
  }
  .p-listbox .p-listbox-header {
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    margin: 0;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-listbox .p-listbox-header .p-listbox-filter {
    padding-right: 1.75rem;
  }
  .p-listbox .p-listbox-header .p-listbox-filter-icon {
    right: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-listbox .p-listbox-list {
    padding: 0.5rem 0;
    outline: 0 none;
  }
  .p-listbox .p-listbox-list .p-listbox-item {
    margin: 0;
    padding: 0.5rem 1.5rem;
    border: 0 none;
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-listbox .p-listbox-list .p-listbox-item:first-child {
    margin-top: 0;
  }
  .p-listbox .p-listbox-list .p-listbox-item:last-child {
    margin-bottom: 0;
  }
  .p-listbox .p-listbox-list .p-listbox-item.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-listbox .p-listbox-list .p-listbox-item-group {
    margin: 0;
    padding: 0.75rem 1rem;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    font-weight: 600;
  }
  .p-listbox .p-listbox-list .p-listbox-empty-message {
    padding: 0.5rem 1.5rem;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
  }
  .p-listbox:not(.p-disabled) .p-listbox-item.p-highlight.p-focus {
    background: #64bfff;
  }
  .p-listbox:not(.p-disabled) .p-listbox-item:not(.p-highlight):not(.p-disabled).p-focus {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-listbox:not(.p-disabled) .p-listbox-item:not(.p-highlight):not(.p-disabled):hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-listbox:not(.p-disabled) .p-listbox-item:not(.p-highlight):not(.p-disabled):hover.p-focus {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-listbox.p-focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-listbox.p-invalid {
    border-color: #f19ea6;
  }
  .p-mention-panel {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    box-shadow: none;
  }
  .p-mention-panel .p-mention-items {
    padding: 0.5rem 0;
  }
  .p-mention-panel .p-mention-items .p-mention-item {
    margin: 0;
    padding: 0.5rem 1.5rem;
    border: 0 none;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-mention-panel .p-mention-items .p-mention-item:hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-mention-panel .p-mention-items .p-mention-item.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-multiselect {
    display: inline-flex;
    cursor: pointer;
    user-select: none;
  }
  .p-multiselect-trigger {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  .p-multiselect-label-container {
    overflow: hidden;
    flex: 1 1 auto;
    cursor: pointer;
  }
  .p-multiselect-label {
    display: block;
    white-space: nowrap;
    cursor: pointer;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .p-multiselect-label-empty {
    overflow: hidden;
    visibility: hidden;
  }
  .p-multiselect-token {
    cursor: default;
    display: inline-flex;
    align-items: center;
    flex: 0 0 auto;
  }
  .p-multiselect-token-icon {
    cursor: pointer;
  }
  .p-multiselect .p-multiselect-panel {
    min-width: 100%;
  }
  .p-multiselect-items-wrapper {
    overflow: auto;
  }
  .p-multiselect-items {
    margin: 0;
    padding: 0;
    list-style-type: none;
  }
  .p-multiselect-item {
    cursor: pointer;
    display: flex;
    align-items: center;
    font-weight: normal;
    white-space: nowrap;
    position: relative;
    overflow: hidden;
  }
  .p-multiselect-item-group {
    cursor: auto;
  }
  .p-multiselect-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .p-multiselect-filter-container {
    position: relative;
    flex: 1 1 auto;
  }
  .p-multiselect-filter-icon {
    position: absolute;
    top: 50%;
    margin-top: -0.5rem;
  }
  .p-multiselect-filter-container .p-inputtext {
    width: 100%;
  }
  .p-multiselect-close {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    overflow: hidden;
    position: relative;
    margin-left: auto;
  }
  .p-fluid .p-multiselect {
    display: flex;
  }
  .p-multiselect {
    background: #20262e;
    border: 1px solid #3f4b5b;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    border-radius: 4px;
    outline-color: transparent;
  }
  .p-multiselect:not(.p-disabled):hover {
    border-color: #3f4b5b;
  }
  .p-multiselect:not(.p-disabled).p-focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-multiselect.p-variant-filled {
    background: #3f4b5b;
  }
  .p-multiselect.p-variant-filled:not(.p-disabled):hover {
    background-color: #3f4b5b;
  }
  .p-multiselect.p-variant-filled:not(.p-disabled).p-focus {
    background-color: #3f4b5b;
  }
  .p-multiselect .p-multiselect-label {
    padding: 0.5rem 0.75rem;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
  }
  .p-multiselect .p-multiselect-label.p-placeholder {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-multiselect.p-multiselect-chip .p-multiselect-token {
    padding: 0.25rem 0.75rem;
    margin-right: 0.5rem;
    background: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    border-radius: 16px;
  }
  .p-multiselect.p-multiselect-chip .p-multiselect-token .p-multiselect-token-icon {
    margin-left: 0.5rem;
  }
  .p-multiselect .p-multiselect-trigger {
    background: transparent;
    color: rgba(255, 255, 255, 0.6);
    width: 2.357rem;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
  }
  .p-multiselect.p-invalid.p-component {
    border-color: #f19ea6;
  }
  .p-inputwrapper-filled.p-multiselect.p-multiselect-chip .p-multiselect-label {
    padding: 0.25rem 0.75rem;
  }
  .p-multiselect-panel {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    box-shadow: none;
  }
  .p-multiselect-panel .p-multiselect-header {
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    margin: 0;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-multiselect-panel .p-multiselect-header .p-multiselect-filter-container .p-inputtext {
    padding-right: 1.75rem;
  }
  .p-multiselect-panel .p-multiselect-header .p-multiselect-filter-container .p-multiselect-filter-icon {
    right: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-multiselect-panel .p-multiselect-header .p-checkbox {
    margin-right: 0.5rem;
  }
  .p-multiselect-panel .p-multiselect-header .p-multiselect-close {
    margin-left: 0.5rem;
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-multiselect-panel .p-multiselect-header .p-multiselect-close:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-multiselect-panel .p-multiselect-header .p-multiselect-close:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-multiselect-panel .p-multiselect-items {
    padding: 0.5rem 0;
  }
  .p-multiselect-panel .p-multiselect-items .p-multiselect-item {
    margin: 0;
    padding: 0.5rem 1.5rem;
    border: 0 none;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-multiselect-panel .p-multiselect-items .p-multiselect-item:first-child {
    margin-top: 0;
  }
  .p-multiselect-panel .p-multiselect-items .p-multiselect-item:last-child {
    margin-bottom: 0;
  }
  .p-multiselect-panel .p-multiselect-items .p-multiselect-item.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-multiselect-panel .p-multiselect-items .p-multiselect-item.p-highlight.p-focus {
    background: #64bfff;
  }
  .p-multiselect-panel .p-multiselect-items .p-multiselect-item:not(.p-highlight):not(.p-disabled).p-focus {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-multiselect-panel .p-multiselect-items .p-multiselect-item .p-checkbox {
    margin-right: 0.5rem;
  }
  .p-multiselect-panel .p-multiselect-items .p-multiselect-item-group {
    margin: 0;
    padding: 0.75rem 1rem;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    font-weight: 600;
  }
  .p-multiselect-panel .p-multiselect-items .p-multiselect-empty-message {
    padding: 0.5rem 1.5rem;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
  }
  .p-password.p-invalid.p-component &gt; .p-inputtext {
    border-color: #f19ea6;
  }
  .p-password-panel {
    padding: 1.25rem;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    box-shadow: none;
    border-radius: 4px;
  }
  .p-password-panel .p-password-meter {
    margin-bottom: 0.5rem;
    background: #3f4b5b;
  }
  .p-password-panel .p-password-meter .p-password-strength.weak {
    background: #f19ea6;
  }
  .p-password-panel .p-password-meter .p-password-strength.medium {
    background: #ffe082;
  }
  .p-password-panel .p-password-meter .p-password-strength.strong {
    background: #9fdaa8;
  }
  .p-radiobutton {
    position: relative;
    display: inline-flex;
    user-select: none;
    vertical-align: bottom;
  }
  .p-radiobutton-input {
    cursor: pointer;
  }
  .p-radiobutton-box {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .p-radiobutton-icon {
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    transform: translateZ(0) scale(0.1);
    border-radius: 50%;
    visibility: hidden;
  }
  .p-radiobutton.p-highlight .p-radiobutton-icon {
    transform: translateZ(0) scale(1, 1);
    visibility: visible;
  }
  .p-radiobutton {
    width: 20px;
    height: 20px;
  }
  .p-radiobutton .p-radiobutton-input {
    appearance: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: 1;
    outline: 0 none;
    border: 1px solid #3f4b5b;
    border-radius: 50%;
  }
  .p-radiobutton .p-radiobutton-box {
    border: 1px solid #3f4b5b;
    background: #20262e;
    width: 20px;
    height: 20px;
    color: rgba(255, 255, 255, 0.87);
    border-radius: 50%;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    outline-color: transparent;
  }
  .p-radiobutton .p-radiobutton-box .p-radiobutton-icon {
    width: 12px;
    height: 12px;
    transition-duration: 0.15s;
    background-color: #151515;
  }
  .p-radiobutton.p-highlight .p-radiobutton-box {
    border-color: #8dd0ff;
    background: #8dd0ff;
  }
  .p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:hover) .p-radiobutton-box {
    border-color: #3f4b5b;
  }
  .p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:hover).p-highlight .p-radiobutton-box {
    border-color: #1dadff;
    background: #1dadff;
  }
  .p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:hover).p-highlight .p-radiobutton-box .p-radiobutton-icon {
    background-color: #151515;
  }
  .p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:focus-visible) .p-radiobutton-box {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-radiobutton.p-invalid &gt; .p-radiobutton-box {
    border-color: #f19ea6;
  }
  .p-radiobutton.p-variant-filled .p-radiobutton-box {
    background-color: #3f4b5b;
  }
  .p-radiobutton.p-variant-filled.p-highlight .p-radiobutton-box {
    background: #8dd0ff;
  }
  .p-radiobutton.p-variant-filled:not(.p-disabled):has(.p-radiobutton-input:hover) .p-radiobutton-box {
    background-color: #3f4b5b;
  }
  .p-radiobutton.p-variant-filled:not(.p-disabled):has(.p-radiobutton-input:hover).p-highlight .p-radiobutton-box {
    background: #1dadff;
  }
  .p-input-filled .p-radiobutton .p-radiobutton-box {
    background-color: #3f4b5b;
  }
  .p-input-filled .p-radiobutton.p-highlight .p-radiobutton-box {
    background: #8dd0ff;
  }
  .p-input-filled .p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:hover) .p-radiobutton-box {
    background-color: #3f4b5b;
  }
  .p-input-filled .p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:hover).p-highlight .p-radiobutton-box {
    background: #1dadff;
  }
  .p-highlight .p-radiobutton .p-radiobutton-box {
    border-color: #151515;
  }
  .p-rating {
    position: relative;
    display: flex;
    align-items: center;
  }
  .p-rating-item {
    display: inline-flex;
    align-items: center;
    cursor: pointer;
  }
  .p-rating.p-readonly .p-rating-item {
    cursor: default;
  }
  .p-rating {
    gap: 0.5rem;
  }
  .p-rating .p-rating-item {
    outline-color: transparent;
    border-radius: 50%;
  }
  .p-rating .p-rating-item .p-rating-icon {
    color: rgba(255, 255, 255, 0.87);
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    font-size: 1.143rem;
  }
  .p-rating .p-rating-item .p-rating-icon.p-icon {
    width: 1.143rem;
    height: 1.143rem;
  }
  .p-rating .p-rating-item .p-rating-icon.p-rating-cancel {
    color: #f19ea6;
  }
  .p-rating .p-rating-item.p-focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-rating .p-rating-item.p-rating-item-active .p-rating-icon {
    color: #8dd0ff;
  }
  .p-rating:not(.p-disabled):not(.p-readonly) .p-rating-item:hover .p-rating-icon {
    color: #8dd0ff;
  }
  .p-rating:not(.p-disabled):not(.p-readonly) .p-rating-item:hover .p-rating-icon.p-rating-cancel {
    color: #f19ea6;
  }
  .p-highlight .p-rating .p-rating-item.p-rating-item-active .p-rating-icon {
    color: #151515;
  }
  .p-selectbutton .p-button {
    background: #6c757d;
    border: 1px solid #6c757d;
    color: #ffffff;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
  }
  .p-selectbutton .p-button .p-button-icon-left,
  .p-selectbutton .p-button .p-button-icon-right {
    color: #ffffff;
  }
  .p-selectbutton .p-button:not(.p-disabled):not(.p-highlight):hover {
    background: #5a6268;
    border-color: #545b62;
    color: #ffffff;
  }
  .p-selectbutton .p-button:not(.p-disabled):not(.p-highlight):hover .p-button-icon-left,
  .p-selectbutton .p-button:not(.p-disabled):not(.p-highlight):hover .p-button-icon-right {
    color: #ffffff;
  }
  .p-selectbutton .p-button.p-highlight {
    background: #545b62;
    border-color: #4e555b;
    color: #ffffff;
  }
  .p-selectbutton .p-button.p-highlight .p-button-icon-left,
  .p-selectbutton .p-button.p-highlight .p-button-icon-right {
    color: #ffffff;
  }
  .p-selectbutton .p-button.p-highlight:hover {
    background: #545b62;
    border-color: #4e555b;
    color: #ffffff;
  }
  .p-selectbutton .p-button.p-highlight:hover .p-button-icon-left,
  .p-selectbutton .p-button.p-highlight:hover .p-button-icon-right {
    color: #ffffff;
  }
  .p-selectbutton.p-invalid &gt; .p-button {
    border-color: #f19ea6;
  }
  .p-slider {
    background: #3f4b5b;
    border: 0 none;
    border-radius: 4px;
  }
  .p-slider.p-slider-horizontal {
    height: 0.286rem;
  }
  .p-slider.p-slider-horizontal .p-slider-handle {
    margin-top: -0.5715rem;
    margin-left: -0.5715rem;
  }
  .p-slider.p-slider-vertical {
    width: 0.286rem;
  }
  .p-slider.p-slider-vertical .p-slider-handle {
    margin-left: -0.5715rem;
    margin-bottom: -0.5715rem;
  }
  .p-slider .p-slider-handle {
    height: 1.143rem;
    width: 1.143rem;
    background: #8dd0ff;
    border: 2px solid #8dd0ff;
    border-radius: 4px;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
  }
  .p-slider .p-slider-handle:focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-slider .p-slider-range {
    background: #8dd0ff;
  }
  .p-slider:not(.p-disabled) .p-slider-handle:hover {
    background: #56bdff;
    border-color: #56bdff;
  }
  .p-treeselect {
    background: #20262e;
    border: 1px solid #3f4b5b;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    border-radius: 4px;
  }
  .p-treeselect:not(.p-disabled):hover {
    border-color: #3f4b5b;
  }
  .p-treeselect:not(.p-disabled).p-focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-treeselect.p-treeselect-clearable .p-treeselect-label {
    padding-right: 1.75rem;
  }
  .p-treeselect.p-variant-filled {
    background: #3f4b5b;
  }
  .p-treeselect.p-variant-filled:not(.p-disabled):hover {
    background-color: #3f4b5b;
  }
  .p-treeselect.p-variant-filled:not(.p-disabled).p-focus {
    background-color: #3f4b5b;
  }
  .p-treeselect .p-treeselect-label {
    padding: 0.5rem 0.75rem;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
  }
  .p-treeselect .p-treeselect-label.p-placeholder {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-treeselect.p-treeselect-chip .p-treeselect-token {
    padding: 0.25rem 0.75rem;
    margin-right: 0.5rem;
    background: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    border-radius: 16px;
  }
  .p-treeselect .p-treeselect-trigger {
    background: transparent;
    color: rgba(255, 255, 255, 0.6);
    width: 2.357rem;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
  }
  .p-treeselect .p-treeselect-clear-icon {
    color: rgba(255, 255, 255, 0.6);
    right: 2.357rem;
  }
  .p-treeselect.p-invalid.p-component {
    border-color: #f19ea6;
  }
  .p-inputwrapper-filled.p-treeselect.p-treeselect-chip .p-treeselect-label {
    padding: 0.25rem 0.75rem;
  }
  .p-treeselect-panel {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    box-shadow: none;
  }
  .p-treeselect-panel .p-treeselect-header {
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    margin: 0;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-treeselect-panel .p-treeselect-header .p-treeselect-filter-container {
    margin-right: 0.5rem;
  }
  .p-treeselect-panel .p-treeselect-header .p-treeselect-filter-container .p-treeselect-filter {
    padding-right: 1.75rem;
  }
  .p-treeselect-panel .p-treeselect-header .p-treeselect-filter-container .p-treeselect-filter-icon {
    right: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-treeselect-panel .p-treeselect-header .p-treeselect-filter-container.p-treeselect-clearable-filter .p-treeselect-filter {
    padding-right: 3.5rem;
  }
  .p-treeselect-panel .p-treeselect-header .p-treeselect-filter-container.p-treeselect-clearable-filter .p-treeselect-filter-clear-icon {
    right: 2.5rem;
  }
  .p-treeselect-panel .p-treeselect-header .p-treeselect-close {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-treeselect-panel .p-treeselect-header .p-treeselect-close:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-treeselect-panel .p-treeselect-header .p-treeselect-close:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-treeselect-panel .p-treeselect-items-wrapper .p-tree {
    border: 0 none;
  }
  .p-treeselect-panel .p-treeselect-items-wrapper .p-treeselect-empty-message {
    padding: 0.5rem 1.5rem;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
  }
  .p-input-filled .p-treeselect {
    background: #3f4b5b;
  }
  .p-input-filled .p-treeselect:not(.p-disabled):hover {
    background-color: #3f4b5b;
  }
  .p-input-filled .p-treeselect:not(.p-disabled).p-focus {
    background-color: #3f4b5b;
  }
  .p-togglebutton {
    position: relative;
    display: inline-flex;
    user-select: none;
    vertical-align: bottom;
  }
  .p-togglebutton-input {
    cursor: pointer;
  }
  .p-togglebutton .p-button {
    flex: 1 1 auto;
  }
  .p-togglebutton .p-togglebutton-input {
    appearance: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: 1;
    outline: 0 none;
    border: 1px solid #6c757d;
    border-radius: 4px;
  }
  .p-togglebutton .p-button {
    background: #6c757d;
    border: 1px solid #6c757d;
    color: #ffffff;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    outline-color: transparent;
  }
  .p-togglebutton .p-button .p-button-icon-left,
  .p-togglebutton .p-button .p-button-icon-right {
    color: #ffffff;
  }
  .p-togglebutton.p-highlight .p-button {
    background: #545b62;
    border-color: #4e555b;
    color: #ffffff;
  }
  .p-togglebutton.p-highlight .p-button .p-button-icon-left,
  .p-togglebutton.p-highlight .p-button .p-button-icon-right {
    color: #ffffff;
  }
  .p-togglebutton:not(.p-disabled):has(.p-togglebutton-input:hover):not(.p-highlight) .p-button {
    background: #5a6268;
    border-color: #545b62;
    color: #ffffff;
  }
  .p-togglebutton:not(.p-disabled):has(.p-togglebutton-input:hover):not(.p-highlight) .p-button .p-button-icon-left,
  .p-togglebutton:not(.p-disabled):has(.p-togglebutton-input:hover):not(.p-highlight) .p-button .p-button-icon-right {
    color: #ffffff;
  }
  .p-togglebutton:not(.p-disabled):has(.p-togglebutton-input:hover).p-highlight .p-button {
    background: #545b62;
    border-color: #4e555b;
    color: #ffffff;
  }
  .p-togglebutton:not(.p-disabled):has(.p-togglebutton-input:hover).p-highlight .p-button .p-button-icon-left,
  .p-togglebutton:not(.p-disabled):has(.p-togglebutton-input:hover).p-highlight .p-button .p-button-icon-right {
    color: #ffffff;
  }
  .p-togglebutton:not(.p-disabled):has(.p-togglebutton-input:focus-visible) .p-button {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: #8dd0ff;
  }
  .p-togglebutton.p-invalid &gt; .p-button {
    border-color: #f19ea6;
  }
  .p-button {
    color: #151515;
    background: #8dd0ff;
    border: 1px solid #8dd0ff;
    padding: 0.5rem 0.75rem;
    font-size: 1rem;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
    border-radius: 4px;
  }
  .p-button:not(:disabled):hover {
    background: #56bdff;
    color: #151515;
    border-color: #56bdff;
  }
  .p-button:not(:disabled):active {
    background: #1dadff;
    color: #151515;
    border-color: #1dadff;
  }
  .p-button.p-button-outlined {
    background-color: transparent;
    color: #8dd0ff;
    border: 1px solid;
  }
  .p-button.p-button-outlined:not(:disabled):hover {
    background: rgba(141, 208, 255, 0.04);
    color: #8dd0ff;
    border: 1px solid;
  }
  .p-button.p-button-outlined:not(:disabled):active {
    background: rgba(141, 208, 255, 0.16);
    color: #8dd0ff;
    border: 1px solid;
  }
  .p-button.p-button-outlined.p-button-plain {
    color: rgba(255, 255, 255, 0.6);
    border-color: rgba(255, 255, 255, 0.6);
  }
  .p-button.p-button-outlined.p-button-plain:not(:disabled):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.6);
  }
  .p-button.p-button-outlined.p-button-plain:not(:disabled):active {
    background: rgba(255, 255, 255, 0.16);
    color: rgba(255, 255, 255, 0.6);
  }
  .p-button.p-button-text {
    background-color: transparent;
    color: #8dd0ff;
    border-color: transparent;
  }
  .p-button.p-button-text:not(:disabled):hover {
    background: rgba(141, 208, 255, 0.04);
    color: #8dd0ff;
    border-color: transparent;
  }
  .p-button.p-button-text:not(:disabled):active {
    background: rgba(141, 208, 255, 0.16);
    color: #8dd0ff;
    border-color: transparent;
  }
  .p-button.p-button-text.p-button-plain {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-button.p-button-text.p-button-plain:not(:disabled):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.6);
  }
  .p-button.p-button-text.p-button-plain:not(:disabled):active {
    background: rgba(255, 255, 255, 0.16);
    color: rgba(255, 255, 255, 0.6);
  }
  .p-button:focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-button .p-button-label {
    transition-duration: 0.15s;
  }
  .p-button .p-button-icon-left {
    margin-right: 0.5rem;
  }
  .p-button .p-button-icon-right {
    margin-left: 0.5rem;
  }
  .p-button .p-button-icon-bottom {
    margin-top: 0.5rem;
  }
  .p-button .p-button-icon-top {
    margin-bottom: 0.5rem;
  }
  .p-button .p-badge {
    margin-left: 0.5rem;
    min-width: 1rem;
    height: 1rem;
    line-height: 1rem;
    color: #8dd0ff;
    background-color: #151515;
  }
  .p-button.p-button-raised {
    box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  }
  .p-button.p-button-rounded {
    border-radius: 2rem;
  }
  .p-button.p-button-icon-only {
    width: 2.357rem;
    padding: 0.5rem 0;
  }
  .p-button.p-button-icon-only .p-button-icon-left,
  .p-button.p-button-icon-only .p-button-icon-right {
    margin: 0;
  }
  .p-button.p-button-icon-only.p-button-rounded {
    border-radius: 50%;
    height: 2.357rem;
  }
  .p-button.p-button-sm {
    font-size: 0.875rem;
    padding: 0.4375rem 0.65625rem;
  }
  .p-button.p-button-sm .p-button-icon {
    font-size: 0.875rem;
  }
  .p-button.p-button-lg {
    font-size: 1.25rem;
    padding: 0.625rem 0.9375rem;
  }
  .p-button.p-button-lg .p-button-icon {
    font-size: 1.25rem;
  }
  .p-button.p-button-loading-label-only.p-button-loading-left .p-button-label {
    margin-left: 0.5rem;
  }
  .p-button.p-button-loading-label-only.p-button-loading-right .p-button-label {
    margin-right: 0.5rem;
  }
  .p-button.p-button-loading-label-only.p-button-loading-top .p-button-label {
    margin-top: 0.5rem;
  }
  .p-button.p-button-loading-label-only.p-button-loading-bottom .p-button-label {
    margin-bottom: 0.5rem;
  }
  .p-button.p-button-loading-label-only .p-button-loading-icon {
    margin: 0;
  }
  .p-fluid .p-button {
    width: 100%;
  }
  .p-fluid .p-button-icon-only {
    width: 2.357rem;
  }
  .p-fluid .p-button-group {
    display: flex;
  }
  .p-fluid .p-button-group .p-button {
    flex: 1;
  }
  .p-button.p-button-secondary, .p-button-group.p-button-secondary &gt; .p-button, .p-splitbutton.p-button-secondary &gt; .p-button, .p-fileupload-choose.p-button-secondary {
    color: #ffffff;
    background: #6c757d;
    border: 1px solid #6c757d;
  }
  .p-button.p-button-secondary:not(:disabled):hover, .p-button-group.p-button-secondary &gt; .p-button:not(:disabled):hover, .p-splitbutton.p-button-secondary &gt; .p-button:not(:disabled):hover, .p-fileupload-choose.p-button-secondary:not(:disabled):hover {
    background: #5a6268;
    color: #ffffff;
    border-color: #5a6268;
  }
  .p-button.p-button-secondary:not(:disabled):focus, .p-button-group.p-button-secondary &gt; .p-button:not(:disabled):focus, .p-splitbutton.p-button-secondary &gt; .p-button:not(:disabled):focus, .p-fileupload-choose.p-button-secondary:not(:disabled):focus {
    box-shadow: 0 0 0 1px rgba(130, 138, 145, 0.5);
  }
  .p-button.p-button-secondary:not(:disabled):active, .p-button-group.p-button-secondary &gt; .p-button:not(:disabled):active, .p-splitbutton.p-button-secondary &gt; .p-button:not(:disabled):active, .p-fileupload-choose.p-button-secondary:not(:disabled):active {
    background: #545b62;
    color: #ffffff;
    border-color: #4e555b;
  }
  .p-button.p-button-secondary.p-button-outlined, .p-button-group.p-button-secondary &gt; .p-button.p-button-outlined, .p-splitbutton.p-button-secondary &gt; .p-button.p-button-outlined, .p-fileupload-choose.p-button-secondary.p-button-outlined {
    background-color: transparent;
    color: #6c757d;
    border: 1px solid;
  }
  .p-button.p-button-secondary.p-button-outlined:not(:disabled):hover, .p-button-group.p-button-secondary &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-splitbutton.p-button-secondary &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-fileupload-choose.p-button-secondary.p-button-outlined:not(:disabled):hover {
    background: rgba(108, 117, 125, 0.04);
    color: #6c757d;
    border: 1px solid;
  }
  .p-button.p-button-secondary.p-button-outlined:not(:disabled):active, .p-button-group.p-button-secondary &gt; .p-button.p-button-outlined:not(:disabled):active, .p-splitbutton.p-button-secondary &gt; .p-button.p-button-outlined:not(:disabled):active, .p-fileupload-choose.p-button-secondary.p-button-outlined:not(:disabled):active {
    background: rgba(108, 117, 125, 0.16);
    color: #6c757d;
    border: 1px solid;
  }
  .p-button.p-button-secondary.p-button-text, .p-button-group.p-button-secondary &gt; .p-button.p-button-text, .p-splitbutton.p-button-secondary &gt; .p-button.p-button-text, .p-fileupload-choose.p-button-secondary.p-button-text {
    background-color: transparent;
    color: #6c757d;
    border-color: transparent;
  }
  .p-button.p-button-secondary.p-button-text:not(:disabled):hover, .p-button-group.p-button-secondary &gt; .p-button.p-button-text:not(:disabled):hover, .p-splitbutton.p-button-secondary &gt; .p-button.p-button-text:not(:disabled):hover, .p-fileupload-choose.p-button-secondary.p-button-text:not(:disabled):hover {
    background: rgba(108, 117, 125, 0.04);
    border-color: transparent;
    color: #6c757d;
  }
  .p-button.p-button-secondary.p-button-text:not(:disabled):active, .p-button-group.p-button-secondary &gt; .p-button.p-button-text:not(:disabled):active, .p-splitbutton.p-button-secondary &gt; .p-button.p-button-text:not(:disabled):active, .p-fileupload-choose.p-button-secondary.p-button-text:not(:disabled):active {
    background: rgba(108, 117, 125, 0.16);
    border-color: transparent;
    color: #6c757d;
  }
  .p-button.p-button-info, .p-button-group.p-button-info &gt; .p-button, .p-splitbutton.p-button-info &gt; .p-button, .p-fileupload-choose.p-button-info {
    color: #151515;
    background: #7fd8e6;
    border: 1px solid #4cc8db;
  }
  .p-button.p-button-info:not(:disabled):hover, .p-button-group.p-button-info &gt; .p-button:not(:disabled):hover, .p-splitbutton.p-button-info &gt; .p-button:not(:disabled):hover, .p-fileupload-choose.p-button-info:not(:disabled):hover {
    background: #4cc8db;
    color: #151515;
    border-color: #26bdd3;
  }
  .p-button.p-button-info:not(:disabled):focus, .p-button-group.p-button-info &gt; .p-button:not(:disabled):focus, .p-splitbutton.p-button-info &gt; .p-button:not(:disabled):focus, .p-fileupload-choose.p-button-info:not(:disabled):focus {
    box-shadow: 0 0 0 1px #b1e8f0;
  }
  .p-button.p-button-info:not(:disabled):active, .p-button-group.p-button-info &gt; .p-button:not(:disabled):active, .p-splitbutton.p-button-info &gt; .p-button:not(:disabled):active, .p-fileupload-choose.p-button-info:not(:disabled):active {
    background: #26bdd3;
    color: #151515;
    border-color: #00b2cc;
  }
  .p-button.p-button-info.p-button-outlined, .p-button-group.p-button-info &gt; .p-button.p-button-outlined, .p-splitbutton.p-button-info &gt; .p-button.p-button-outlined, .p-fileupload-choose.p-button-info.p-button-outlined {
    background-color: transparent;
    color: #7fd8e6;
    border: 1px solid;
  }
  .p-button.p-button-info.p-button-outlined:not(:disabled):hover, .p-button-group.p-button-info &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-splitbutton.p-button-info &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-fileupload-choose.p-button-info.p-button-outlined:not(:disabled):hover {
    background: rgba(127, 216, 230, 0.04);
    color: #7fd8e6;
    border: 1px solid;
  }
  .p-button.p-button-info.p-button-outlined:not(:disabled):active, .p-button-group.p-button-info &gt; .p-button.p-button-outlined:not(:disabled):active, .p-splitbutton.p-button-info &gt; .p-button.p-button-outlined:not(:disabled):active, .p-fileupload-choose.p-button-info.p-button-outlined:not(:disabled):active {
    background: rgba(127, 216, 230, 0.16);
    color: #7fd8e6;
    border: 1px solid;
  }
  .p-button.p-button-info.p-button-text, .p-button-group.p-button-info &gt; .p-button.p-button-text, .p-splitbutton.p-button-info &gt; .p-button.p-button-text, .p-fileupload-choose.p-button-info.p-button-text {
    background-color: transparent;
    color: #7fd8e6;
    border-color: transparent;
  }
  .p-button.p-button-info.p-button-text:not(:disabled):hover, .p-button-group.p-button-info &gt; .p-button.p-button-text:not(:disabled):hover, .p-splitbutton.p-button-info &gt; .p-button.p-button-text:not(:disabled):hover, .p-fileupload-choose.p-button-info.p-button-text:not(:disabled):hover {
    background: rgba(127, 216, 230, 0.04);
    border-color: transparent;
    color: #7fd8e6;
  }
  .p-button.p-button-info.p-button-text:not(:disabled):active, .p-button-group.p-button-info &gt; .p-button.p-button-text:not(:disabled):active, .p-splitbutton.p-button-info &gt; .p-button.p-button-text:not(:disabled):active, .p-fileupload-choose.p-button-info.p-button-text:not(:disabled):active {
    background: rgba(127, 216, 230, 0.16);
    border-color: transparent;
    color: #7fd8e6;
  }
  .p-button.p-button-success, .p-button-group.p-button-success &gt; .p-button, .p-splitbutton.p-button-success &gt; .p-button, .p-fileupload-choose.p-button-success {
    color: #151515;
    background: #9fdaa8;
    border: 1px solid #78cc86;
  }
  .p-button.p-button-success:not(:disabled):hover, .p-button-group.p-button-success &gt; .p-button:not(:disabled):hover, .p-splitbutton.p-button-success &gt; .p-button:not(:disabled):hover, .p-fileupload-choose.p-button-success:not(:disabled):hover {
    background: #78cc86;
    color: #151515;
    border-color: #5ac06c;
  }
  .p-button.p-button-success:not(:disabled):focus, .p-button-group.p-button-success &gt; .p-button:not(:disabled):focus, .p-splitbutton.p-button-success &gt; .p-button:not(:disabled):focus, .p-fileupload-choose.p-button-success:not(:disabled):focus {
    box-shadow: 0 0 0 1px #c5e8ca;
  }
  .p-button.p-button-success:not(:disabled):active, .p-button-group.p-button-success &gt; .p-button:not(:disabled):active, .p-splitbutton.p-button-success &gt; .p-button:not(:disabled):active, .p-fileupload-choose.p-button-success:not(:disabled):active {
    background: #5ac06c;
    color: #151515;
    border-color: #3cb553;
  }
  .p-button.p-button-success.p-button-outlined, .p-button-group.p-button-success &gt; .p-button.p-button-outlined, .p-splitbutton.p-button-success &gt; .p-button.p-button-outlined, .p-fileupload-choose.p-button-success.p-button-outlined {
    background-color: transparent;
    color: #9fdaa8;
    border: 1px solid;
  }
  .p-button.p-button-success.p-button-outlined:not(:disabled):hover, .p-button-group.p-button-success &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-splitbutton.p-button-success &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-fileupload-choose.p-button-success.p-button-outlined:not(:disabled):hover {
    background: rgba(159, 218, 168, 0.04);
    color: #9fdaa8;
    border: 1px solid;
  }
  .p-button.p-button-success.p-button-outlined:not(:disabled):active, .p-button-group.p-button-success &gt; .p-button.p-button-outlined:not(:disabled):active, .p-splitbutton.p-button-success &gt; .p-button.p-button-outlined:not(:disabled):active, .p-fileupload-choose.p-button-success.p-button-outlined:not(:disabled):active {
    background: rgba(159, 218, 168, 0.16);
    color: #9fdaa8;
    border: 1px solid;
  }
  .p-button.p-button-success.p-button-text, .p-button-group.p-button-success &gt; .p-button.p-button-text, .p-splitbutton.p-button-success &gt; .p-button.p-button-text, .p-fileupload-choose.p-button-success.p-button-text {
    background-color: transparent;
    color: #9fdaa8;
    border-color: transparent;
  }
  .p-button.p-button-success.p-button-text:not(:disabled):hover, .p-button-group.p-button-success &gt; .p-button.p-button-text:not(:disabled):hover, .p-splitbutton.p-button-success &gt; .p-button.p-button-text:not(:disabled):hover, .p-fileupload-choose.p-button-success.p-button-text:not(:disabled):hover {
    background: rgba(159, 218, 168, 0.04);
    border-color: transparent;
    color: #9fdaa8;
  }
  .p-button.p-button-success.p-button-text:not(:disabled):active, .p-button-group.p-button-success &gt; .p-button.p-button-text:not(:disabled):active, .p-splitbutton.p-button-success &gt; .p-button.p-button-text:not(:disabled):active, .p-fileupload-choose.p-button-success.p-button-text:not(:disabled):active {
    background: rgba(159, 218, 168, 0.16);
    border-color: transparent;
    color: #9fdaa8;
  }
  .p-button.p-button-warning, .p-button-group.p-button-warning &gt; .p-button, .p-splitbutton.p-button-warning &gt; .p-button, .p-fileupload-choose.p-button-warning {
    color: #151515;
    background: #ffe082;
    border: 1px solid #ffd54f;
  }
  .p-button.p-button-warning:not(:disabled):hover, .p-button-group.p-button-warning &gt; .p-button:not(:disabled):hover, .p-splitbutton.p-button-warning &gt; .p-button:not(:disabled):hover, .p-fileupload-choose.p-button-warning:not(:disabled):hover {
    background: #ffd54f;
    color: #151515;
    border-color: #ffca28;
  }
  .p-button.p-button-warning:not(:disabled):focus, .p-button-group.p-button-warning &gt; .p-button:not(:disabled):focus, .p-splitbutton.p-button-warning &gt; .p-button:not(:disabled):focus, .p-fileupload-choose.p-button-warning:not(:disabled):focus {
    box-shadow: 0 0 0 1px #ffecb3;
  }
  .p-button.p-button-warning:not(:disabled):active, .p-button-group.p-button-warning &gt; .p-button:not(:disabled):active, .p-splitbutton.p-button-warning &gt; .p-button:not(:disabled):active, .p-fileupload-choose.p-button-warning:not(:disabled):active {
    background: #ffca28;
    color: #151515;
    border-color: #ffc107;
  }
  .p-button.p-button-warning.p-button-outlined, .p-button-group.p-button-warning &gt; .p-button.p-button-outlined, .p-splitbutton.p-button-warning &gt; .p-button.p-button-outlined, .p-fileupload-choose.p-button-warning.p-button-outlined {
    background-color: transparent;
    color: #ffe082;
    border: 1px solid;
  }
  .p-button.p-button-warning.p-button-outlined:not(:disabled):hover, .p-button-group.p-button-warning &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-splitbutton.p-button-warning &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-fileupload-choose.p-button-warning.p-button-outlined:not(:disabled):hover {
    background: rgba(255, 224, 130, 0.04);
    color: #ffe082;
    border: 1px solid;
  }
  .p-button.p-button-warning.p-button-outlined:not(:disabled):active, .p-button-group.p-button-warning &gt; .p-button.p-button-outlined:not(:disabled):active, .p-splitbutton.p-button-warning &gt; .p-button.p-button-outlined:not(:disabled):active, .p-fileupload-choose.p-button-warning.p-button-outlined:not(:disabled):active {
    background: rgba(255, 224, 130, 0.16);
    color: #ffe082;
    border: 1px solid;
  }
  .p-button.p-button-warning.p-button-text, .p-button-group.p-button-warning &gt; .p-button.p-button-text, .p-splitbutton.p-button-warning &gt; .p-button.p-button-text, .p-fileupload-choose.p-button-warning.p-button-text {
    background-color: transparent;
    color: #ffe082;
    border-color: transparent;
  }
  .p-button.p-button-warning.p-button-text:not(:disabled):hover, .p-button-group.p-button-warning &gt; .p-button.p-button-text:not(:disabled):hover, .p-splitbutton.p-button-warning &gt; .p-button.p-button-text:not(:disabled):hover, .p-fileupload-choose.p-button-warning.p-button-text:not(:disabled):hover {
    background: rgba(255, 224, 130, 0.04);
    border-color: transparent;
    color: #ffe082;
  }
  .p-button.p-button-warning.p-button-text:not(:disabled):active, .p-button-group.p-button-warning &gt; .p-button.p-button-text:not(:disabled):active, .p-splitbutton.p-button-warning &gt; .p-button.p-button-text:not(:disabled):active, .p-fileupload-choose.p-button-warning.p-button-text:not(:disabled):active {
    background: rgba(255, 224, 130, 0.16);
    border-color: transparent;
    color: #ffe082;
  }
  .p-button.p-button-help, .p-button-group.p-button-help &gt; .p-button, .p-splitbutton.p-button-help &gt; .p-button, .p-fileupload-choose.p-button-help {
    color: #151515;
    background: #b7a2e0;
    border: 1px solid #9a7cd4;
  }
  .p-button.p-button-help:not(:disabled):hover, .p-button-group.p-button-help &gt; .p-button:not(:disabled):hover, .p-splitbutton.p-button-help &gt; .p-button:not(:disabled):hover, .p-fileupload-choose.p-button-help:not(:disabled):hover {
    background: #9a7cd4;
    color: #151515;
    border-color: #845fca;
  }
  .p-button.p-button-help:not(:disabled):focus, .p-button-group.p-button-help &gt; .p-button:not(:disabled):focus, .p-splitbutton.p-button-help &gt; .p-button:not(:disabled):focus, .p-fileupload-choose.p-button-help:not(:disabled):focus {
    box-shadow: 0 0 0 1px #d3c7ec;
  }
  .p-button.p-button-help:not(:disabled):active, .p-button-group.p-button-help &gt; .p-button:not(:disabled):active, .p-splitbutton.p-button-help &gt; .p-button:not(:disabled):active, .p-fileupload-choose.p-button-help:not(:disabled):active {
    background: #845fca;
    color: #151515;
    border-color: #6d43c0;
  }
  .p-button.p-button-help.p-button-outlined, .p-button-group.p-button-help &gt; .p-button.p-button-outlined, .p-splitbutton.p-button-help &gt; .p-button.p-button-outlined, .p-fileupload-choose.p-button-help.p-button-outlined {
    background-color: transparent;
    color: #b7a2e0;
    border: 1px solid;
  }
  .p-button.p-button-help.p-button-outlined:not(:disabled):hover, .p-button-group.p-button-help &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-splitbutton.p-button-help &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-fileupload-choose.p-button-help.p-button-outlined:not(:disabled):hover {
    background: rgba(183, 162, 224, 0.04);
    color: #b7a2e0;
    border: 1px solid;
  }
  .p-button.p-button-help.p-button-outlined:not(:disabled):active, .p-button-group.p-button-help &gt; .p-button.p-button-outlined:not(:disabled):active, .p-splitbutton.p-button-help &gt; .p-button.p-button-outlined:not(:disabled):active, .p-fileupload-choose.p-button-help.p-button-outlined:not(:disabled):active {
    background: rgba(183, 162, 224, 0.16);
    color: #b7a2e0;
    border: 1px solid;
  }
  .p-button.p-button-help.p-button-text, .p-button-group.p-button-help &gt; .p-button.p-button-text, .p-splitbutton.p-button-help &gt; .p-button.p-button-text, .p-fileupload-choose.p-button-help.p-button-text {
    background-color: transparent;
    color: #b7a2e0;
    border-color: transparent;
  }
  .p-button.p-button-help.p-button-text:not(:disabled):hover, .p-button-group.p-button-help &gt; .p-button.p-button-text:not(:disabled):hover, .p-splitbutton.p-button-help &gt; .p-button.p-button-text:not(:disabled):hover, .p-fileupload-choose.p-button-help.p-button-text:not(:disabled):hover {
    background: rgba(183, 162, 224, 0.04);
    border-color: transparent;
    color: #b7a2e0;
  }
  .p-button.p-button-help.p-button-text:not(:disabled):active, .p-button-group.p-button-help &gt; .p-button.p-button-text:not(:disabled):active, .p-splitbutton.p-button-help &gt; .p-button.p-button-text:not(:disabled):active, .p-fileupload-choose.p-button-help.p-button-text:not(:disabled):active {
    background: rgba(183, 162, 224, 0.16);
    border-color: transparent;
    color: #b7a2e0;
  }
  .p-button.p-button-danger, .p-button-group.p-button-danger &gt; .p-button, .p-splitbutton.p-button-danger &gt; .p-button, .p-fileupload-choose.p-button-danger {
    color: #151515;
    background: #f19ea6;
    border: 1px solid #e97984;
  }
  .p-button.p-button-danger:not(:disabled):hover, .p-button-group.p-button-danger &gt; .p-button:not(:disabled):hover, .p-splitbutton.p-button-danger &gt; .p-button:not(:disabled):hover, .p-fileupload-choose.p-button-danger:not(:disabled):hover {
    background: #e97984;
    color: #151515;
    border-color: #f75965;
  }
  .p-button.p-button-danger:not(:disabled):focus, .p-button-group.p-button-danger &gt; .p-button:not(:disabled):focus, .p-splitbutton.p-button-danger &gt; .p-button:not(:disabled):focus, .p-fileupload-choose.p-button-danger:not(:disabled):focus {
    box-shadow: 0 0 0 1px #ffd0d9;
  }
  .p-button.p-button-danger:not(:disabled):active, .p-button-group.p-button-danger &gt; .p-button:not(:disabled):active, .p-splitbutton.p-button-danger &gt; .p-button:not(:disabled):active, .p-fileupload-choose.p-button-danger:not(:disabled):active {
    background: #f75965;
    color: #151515;
    border-color: #fd464e;
  }
  .p-button.p-button-danger.p-button-outlined, .p-button-group.p-button-danger &gt; .p-button.p-button-outlined, .p-splitbutton.p-button-danger &gt; .p-button.p-button-outlined, .p-fileupload-choose.p-button-danger.p-button-outlined {
    background-color: transparent;
    color: #f19ea6;
    border: 1px solid;
  }
  .p-button.p-button-danger.p-button-outlined:not(:disabled):hover, .p-button-group.p-button-danger &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-splitbutton.p-button-danger &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-fileupload-choose.p-button-danger.p-button-outlined:not(:disabled):hover {
    background: rgba(241, 158, 166, 0.04);
    color: #f19ea6;
    border: 1px solid;
  }
  .p-button.p-button-danger.p-button-outlined:not(:disabled):active, .p-button-group.p-button-danger &gt; .p-button.p-button-outlined:not(:disabled):active, .p-splitbutton.p-button-danger &gt; .p-button.p-button-outlined:not(:disabled):active, .p-fileupload-choose.p-button-danger.p-button-outlined:not(:disabled):active {
    background: rgba(241, 158, 166, 0.16);
    color: #f19ea6;
    border: 1px solid;
  }
  .p-button.p-button-danger.p-button-text, .p-button-group.p-button-danger &gt; .p-button.p-button-text, .p-splitbutton.p-button-danger &gt; .p-button.p-button-text, .p-fileupload-choose.p-button-danger.p-button-text {
    background-color: transparent;
    color: #f19ea6;
    border-color: transparent;
  }
  .p-button.p-button-danger.p-button-text:not(:disabled):hover, .p-button-group.p-button-danger &gt; .p-button.p-button-text:not(:disabled):hover, .p-splitbutton.p-button-danger &gt; .p-button.p-button-text:not(:disabled):hover, .p-fileupload-choose.p-button-danger.p-button-text:not(:disabled):hover {
    background: rgba(241, 158, 166, 0.04);
    border-color: transparent;
    color: #f19ea6;
  }
  .p-button.p-button-danger.p-button-text:not(:disabled):active, .p-button-group.p-button-danger &gt; .p-button.p-button-text:not(:disabled):active, .p-splitbutton.p-button-danger &gt; .p-button.p-button-text:not(:disabled):active, .p-fileupload-choose.p-button-danger.p-button-text:not(:disabled):active {
    background: rgba(241, 158, 166, 0.16);
    border-color: transparent;
    color: #f19ea6;
  }
  .p-button.p-button-contrast, .p-button-group.p-button-contrast &gt; .p-button, .p-splitbutton.p-button-contrast &gt; .p-button {
    color: #20262e;
    background: #ffffff;
    border: 1px solid #ffffff;
  }
  .p-button.p-button-contrast:not(:disabled):hover, .p-button-group.p-button-contrast &gt; .p-button:not(:disabled):hover, .p-splitbutton.p-button-contrast &gt; .p-button:not(:disabled):hover {
    background: #d2d4d5;
    color: #20262e;
    border-color: #d2d4d5;
  }
  .p-button.p-button-contrast:not(:disabled):focus, .p-button-group.p-button-contrast &gt; .p-button:not(:disabled):focus, .p-splitbutton.p-button-contrast &gt; .p-button:not(:disabled):focus {
    box-shadow: none;
  }
  .p-button.p-button-contrast:not(:disabled):active, .p-button-group.p-button-contrast &gt; .p-button:not(:disabled):active, .p-splitbutton.p-button-contrast &gt; .p-button:not(:disabled):active {
    background: #bcbec0;
    color: #20262e;
    border-color: #bcbec0;
  }
  .p-button.p-button-contrast.p-button-outlined, .p-button-group.p-button-contrast &gt; .p-button.p-button-outlined, .p-splitbutton.p-button-contrast &gt; .p-button.p-button-outlined {
    background-color: transparent;
    color: #ffffff;
    border: 1px solid;
  }
  .p-button.p-button-contrast.p-button-outlined:not(:disabled):hover, .p-button-group.p-button-contrast &gt; .p-button.p-button-outlined:not(:disabled):hover, .p-splitbutton.p-button-contrast &gt; .p-button.p-button-outlined:not(:disabled):hover {
    background: rgba(255, 255, 255, 0.04);
    color: #ffffff;
    border: 1px solid;
  }
  .p-button.p-button-contrast.p-button-outlined:not(:disabled):active, .p-button-group.p-button-contrast &gt; .p-button.p-button-outlined:not(:disabled):active, .p-splitbutton.p-button-contrast &gt; .p-button.p-button-outlined:not(:disabled):active {
    background: rgba(255, 255, 255, 0.16);
    color: #ffffff;
    border: 1px solid;
  }
  .p-button.p-button-contrast.p-button-text, .p-button-group.p-button-contrast &gt; .p-button.p-button-text, .p-splitbutton.p-button-contrast &gt; .p-button.p-button-text {
    background-color: transparent;
    color: #ffffff;
    border-color: transparent;
  }
  .p-button.p-button-contrast.p-button-text:not(:disabled):hover, .p-button-group.p-button-contrast &gt; .p-button.p-button-text:not(:disabled):hover, .p-splitbutton.p-button-contrast &gt; .p-button.p-button-text:not(:disabled):hover {
    background: rgba(255, 255, 255, 0.04);
    border-color: transparent;
    color: #ffffff;
  }
  .p-button.p-button-contrast.p-button-text:not(:disabled):active, .p-button-group.p-button-contrast &gt; .p-button.p-button-text:not(:disabled):active, .p-splitbutton.p-button-contrast &gt; .p-button.p-button-text:not(:disabled):active {
    background: rgba(255, 255, 255, 0.16);
    border-color: transparent;
    color: #ffffff;
  }
  .p-button.p-button-link {
    color: #8dd0ff;
    background: transparent;
    border: transparent;
  }
  .p-button.p-button-link:not(:disabled):hover {
    background: transparent;
    color: #56bdff;
    border-color: transparent;
  }
  .p-button.p-button-link:not(:disabled):hover .p-button-label {
    text-decoration: underline;
  }
  .p-button.p-button-link:not(:disabled):focus {
    background: transparent;
    box-shadow: 0 0 0 1px #e3f3fe;
    border-color: transparent;
  }
  .p-button.p-button-link:not(:disabled):active {
    background: transparent;
    color: #8dd0ff;
    border-color: transparent;
  }
  .p-splitbutton {
    border-radius: 4px;
  }
  .p-splitbutton.p-button-outlined &gt; .p-button {
    background-color: transparent;
    color: #8dd0ff;
    border: 1px solid;
  }
  .p-splitbutton.p-button-outlined &gt; .p-button:not(:disabled):hover {
    background: rgba(141, 208, 255, 0.04);
    color: #8dd0ff;
  }
  .p-splitbutton.p-button-outlined &gt; .p-button:not(:disabled):active {
    background: rgba(141, 208, 255, 0.16);
    color: #8dd0ff;
  }
  .p-splitbutton.p-button-outlined.p-button-plain &gt; .p-button {
    color: rgba(255, 255, 255, 0.6);
    border-color: rgba(255, 255, 255, 0.6);
  }
  .p-splitbutton.p-button-outlined.p-button-plain &gt; .p-button:not(:disabled):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.6);
  }
  .p-splitbutton.p-button-outlined.p-button-plain &gt; .p-button:not(:disabled):active {
    background: rgba(255, 255, 255, 0.16);
    color: rgba(255, 255, 255, 0.6);
  }
  .p-splitbutton.p-button-text &gt; .p-button {
    background-color: transparent;
    color: #8dd0ff;
    border-color: transparent;
  }
  .p-splitbutton.p-button-text &gt; .p-button:not(:disabled):hover {
    background: rgba(141, 208, 255, 0.04);
    color: #8dd0ff;
    border-color: transparent;
  }
  .p-splitbutton.p-button-text &gt; .p-button:not(:disabled):active {
    background: rgba(141, 208, 255, 0.16);
    color: #8dd0ff;
    border-color: transparent;
  }
  .p-splitbutton.p-button-text.p-button-plain &gt; .p-button {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-splitbutton.p-button-text.p-button-plain &gt; .p-button:not(:disabled):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.6);
  }
  .p-splitbutton.p-button-text.p-button-plain &gt; .p-button:not(:disabled):active {
    background: rgba(255, 255, 255, 0.16);
    color: rgba(255, 255, 255, 0.6);
  }
  .p-splitbutton.p-button-raised {
    box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  }
  .p-splitbutton.p-button-rounded {
    border-radius: 2rem;
  }
  .p-splitbutton.p-button-rounded &gt; .p-button {
    border-radius: 2rem;
  }
  .p-splitbutton.p-button-sm &gt; .p-button {
    font-size: 0.875rem;
    padding: 0.4375rem 0.65625rem;
  }
  .p-splitbutton.p-button-sm &gt; .p-button .p-button-icon {
    font-size: 0.875rem;
  }
  .p-splitbutton.p-button-lg &gt; .p-button {
    font-size: 1.25rem;
    padding: 0.625rem 0.9375rem;
  }
  .p-splitbutton.p-button-lg &gt; .p-button.p-button-icon-only {
    width: auto;
  }
  .p-splitbutton.p-button-lg &gt; .p-button .p-button-icon {
    font-size: 1.25rem;
  }
  .p-splitbutton .p-splitbutton-menubutton,
  .p-splitbutton .p-splitbutton.p-button-rounded &gt; .p-splitbutton-menubutton.p-button,
  .p-splitbutton .p-splitbutton.p-button-outlined &gt; .p-splitbutton-menubutton.p-button {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }
  .p-splitbutton.p-button-secondary.p-button-outlined &gt; .p-button {
    background-color: transparent;
    color: #6c757d;
    border: 1px solid;
  }
  .p-splitbutton.p-button-secondary.p-button-outlined &gt; .p-button:not(:disabled):hover {
    background: rgba(108, 117, 125, 0.04);
    color: #6c757d;
  }
  .p-splitbutton.p-button-secondary.p-button-outlined &gt; .p-button:not(:disabled):active {
    background: rgba(108, 117, 125, 0.16);
    color: #6c757d;
  }
  .p-splitbutton.p-button-secondary.p-button-text &gt; .p-button {
    background-color: transparent;
    color: #6c757d;
    border-color: transparent;
  }
  .p-splitbutton.p-button-secondary.p-button-text &gt; .p-button:not(:disabled):hover {
    background: rgba(108, 117, 125, 0.04);
    border-color: transparent;
    color: #6c757d;
  }
  .p-splitbutton.p-button-secondary.p-button-text &gt; .p-button:not(:disabled):active {
    background: rgba(108, 117, 125, 0.16);
    border-color: transparent;
    color: #6c757d;
  }
  .p-splitbutton.p-button-info.p-button-outlined &gt; .p-button {
    background-color: transparent;
    color: #7fd8e6;
    border: 1px solid;
  }
  .p-splitbutton.p-button-info.p-button-outlined &gt; .p-button:not(:disabled):hover {
    background: rgba(127, 216, 230, 0.04);
    color: #7fd8e6;
  }
  .p-splitbutton.p-button-info.p-button-outlined &gt; .p-button:not(:disabled):active {
    background: rgba(127, 216, 230, 0.16);
    color: #7fd8e6;
  }
  .p-splitbutton.p-button-info.p-button-text &gt; .p-button {
    background-color: transparent;
    color: #7fd8e6;
    border-color: transparent;
  }
  .p-splitbutton.p-button-info.p-button-text &gt; .p-button:not(:disabled):hover {
    background: rgba(127, 216, 230, 0.04);
    border-color: transparent;
    color: #7fd8e6;
  }
  .p-splitbutton.p-button-info.p-button-text &gt; .p-button:not(:disabled):active {
    background: rgba(127, 216, 230, 0.16);
    border-color: transparent;
    color: #7fd8e6;
  }
  .p-splitbutton.p-button-success.p-button-outlined &gt; .p-button {
    background-color: transparent;
    color: #9fdaa8;
    border: 1px solid;
  }
  .p-splitbutton.p-button-success.p-button-outlined &gt; .p-button:not(:disabled):hover {
    background: rgba(159, 218, 168, 0.04);
    color: #9fdaa8;
  }
  .p-splitbutton.p-button-success.p-button-outlined &gt; .p-button:not(:disabled):active {
    background: rgba(159, 218, 168, 0.16);
    color: #9fdaa8;
  }
  .p-splitbutton.p-button-success.p-button-text &gt; .p-button {
    background-color: transparent;
    color: #9fdaa8;
    border-color: transparent;
  }
  .p-splitbutton.p-button-success.p-button-text &gt; .p-button:not(:disabled):hover {
    background: rgba(159, 218, 168, 0.04);
    border-color: transparent;
    color: #9fdaa8;
  }
  .p-splitbutton.p-button-success.p-button-text &gt; .p-button:not(:disabled):active {
    background: rgba(159, 218, 168, 0.16);
    border-color: transparent;
    color: #9fdaa8;
  }
  .p-splitbutton.p-button-warning.p-button-outlined &gt; .p-button {
    background-color: transparent;
    color: #ffe082;
    border: 1px solid;
  }
  .p-splitbutton.p-button-warning.p-button-outlined &gt; .p-button:not(:disabled):hover {
    background: rgba(255, 224, 130, 0.04);
    color: #ffe082;
  }
  .p-splitbutton.p-button-warning.p-button-outlined &gt; .p-button:not(:disabled):active {
    background: rgba(255, 224, 130, 0.16);
    color: #ffe082;
  }
  .p-splitbutton.p-button-warning.p-button-text &gt; .p-button {
    background-color: transparent;
    color: #ffe082;
    border-color: transparent;
  }
  .p-splitbutton.p-button-warning.p-button-text &gt; .p-button:not(:disabled):hover {
    background: rgba(255, 224, 130, 0.04);
    border-color: transparent;
    color: #ffe082;
  }
  .p-splitbutton.p-button-warning.p-button-text &gt; .p-button:not(:disabled):active {
    background: rgba(255, 224, 130, 0.16);
    border-color: transparent;
    color: #ffe082;
  }
  .p-splitbutton.p-button-help.p-button-outlined &gt; .p-button {
    background-color: transparent;
    color: #b7a2e0;
    border: 1px solid;
  }
  .p-splitbutton.p-button-help.p-button-outlined &gt; .p-button:not(:disabled):hover {
    background: rgba(183, 162, 224, 0.04);
    color: #b7a2e0;
  }
  .p-splitbutton.p-button-help.p-button-outlined &gt; .p-button:not(:disabled):active {
    background: rgba(183, 162, 224, 0.16);
    color: #b7a2e0;
  }
  .p-splitbutton.p-button-help.p-button-text &gt; .p-button {
    background-color: transparent;
    color: #b7a2e0;
    border-color: transparent;
  }
  .p-splitbutton.p-button-help.p-button-text &gt; .p-button:not(:disabled):hover {
    background: rgba(183, 162, 224, 0.04);
    border-color: transparent;
    color: #b7a2e0;
  }
  .p-splitbutton.p-button-help.p-button-text &gt; .p-button:not(:disabled):active {
    background: rgba(183, 162, 224, 0.16);
    border-color: transparent;
    color: #b7a2e0;
  }
  .p-splitbutton.p-button-danger.p-button-outlined &gt; .p-button {
    background-color: transparent;
    color: #f19ea6;
    border: 1px solid;
  }
  .p-splitbutton.p-button-danger.p-button-outlined &gt; .p-button:not(:disabled):hover {
    background: rgba(241, 158, 166, 0.04);
    color: #f19ea6;
  }
  .p-splitbutton.p-button-danger.p-button-outlined &gt; .p-button:not(:disabled):active {
    background: rgba(241, 158, 166, 0.16);
    color: #f19ea6;
  }
  .p-splitbutton.p-button-danger.p-button-text &gt; .p-button {
    background-color: transparent;
    color: #f19ea6;
    border-color: transparent;
  }
  .p-splitbutton.p-button-danger.p-button-text &gt; .p-button:not(:disabled):hover {
    background: rgba(241, 158, 166, 0.04);
    border-color: transparent;
    color: #f19ea6;
  }
  .p-splitbutton.p-button-danger.p-button-text &gt; .p-button:not(:disabled):active {
    background: rgba(241, 158, 166, 0.16);
    border-color: transparent;
    color: #f19ea6;
  }
  .p-speeddial-button.p-button.p-button-icon-only {
    width: 4rem;
    height: 4rem;
  }
  .p-speeddial-button.p-button.p-button-icon-only .p-button-icon {
    font-size: 1.3rem;
  }
  .p-speeddial-button.p-button.p-button-icon-only .p-button-icon.p-icon {
    width: 1.3rem;
    height: 1.3rem;
  }
  .p-speeddial-list {
    outline: 0 none;
  }
  .p-speeddial-action {
    width: 3rem;
    height: 3rem;
    background: #343e4d;
    color: #fff;
  }
  .p-speeddial-action:hover {
    background: #3f4b5b;
    color: #fff;
  }
  .p-speeddial-direction-up .p-speeddial-item {
    margin: 0.25rem;
  }
  .p-speeddial-direction-up .p-speeddial-item:first-child {
    margin-bottom: 0.5rem;
  }
  .p-speeddial-direction-down .p-speeddial-item {
    margin: 0.25rem;
  }
  .p-speeddial-direction-down .p-speeddial-item:first-child {
    margin-top: 0.5rem;
  }
  .p-speeddial-direction-left .p-speeddial-item {
    margin: 0 0.25rem;
  }
  .p-speeddial-direction-left .p-speeddial-item:first-child {
    margin-right: 0.5rem;
  }
  .p-speeddial-direction-right .p-speeddial-item {
    margin: 0 0.25rem;
  }
  .p-speeddial-direction-right .p-speeddial-item:first-child {
    margin-left: 0.5rem;
  }
  .p-speeddial-circle .p-speeddial-item,
  .p-speeddial-semi-circle .p-speeddial-item,
  .p-speeddial-quarter-circle .p-speeddial-item {
    margin: 0;
  }
  .p-speeddial-circle .p-speeddial-item:first-child, .p-speeddial-circle .p-speeddial-item:last-child,
  .p-speeddial-semi-circle .p-speeddial-item:first-child,
  .p-speeddial-semi-circle .p-speeddial-item:last-child,
  .p-speeddial-quarter-circle .p-speeddial-item:first-child,
  .p-speeddial-quarter-circle .p-speeddial-item:last-child {
    margin: 0;
  }
  .p-speeddial-mask {
    background-color: rgba(0, 0, 0, 0.4);
    border-radius: 4px;
  }
  .p-carousel .p-carousel-content .p-carousel-prev,
  .p-carousel .p-carousel-content .p-carousel-next {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
    margin: 0.5rem;
  }
  .p-carousel .p-carousel-content .p-carousel-prev:enabled:hover,
  .p-carousel .p-carousel-content .p-carousel-next:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-carousel .p-carousel-content .p-carousel-prev:focus-visible,
  .p-carousel .p-carousel-content .p-carousel-next:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-carousel .p-carousel-indicators {
    padding: 1rem;
  }
  .p-carousel .p-carousel-indicators .p-carousel-indicator {
    margin-right: 0.5rem;
    margin-bottom: 0.5rem;
  }
  .p-carousel .p-carousel-indicators .p-carousel-indicator button {
    background-color: #3f4b5b;
    width: 2rem;
    height: 0.5rem;
    transition: color 0.15s, box-shadow 0.15s;
    border-radius: 0;
  }
  .p-carousel .p-carousel-indicators .p-carousel-indicator button:hover {
    background: rgba(255, 255, 255, 0.04);
  }
  .p-carousel .p-carousel-indicators .p-carousel-indicator.p-highlight button {
    background: #8dd0ff;
    color: #151515;
  }
  .p-datatable .p-paginator-top {
    border-width: 0;
    border-radius: 0;
  }
  .p-datatable .p-paginator-bottom {
    border-width: 1px 0 0 0;
    border-radius: 0;
  }
  .p-datatable .p-datatable-header {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.6);
    border: solid #3f4b5b;
    border-width: 1px 0 0 0;
    padding: 1rem 1rem;
    font-weight: 600;
  }
  .p-datatable .p-datatable-footer {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-width: 1px 0 1px 0;
    padding: 1rem 1rem;
    font-weight: 600;
  }
  .p-datatable .p-datatable-thead &gt; tr &gt; th {
    text-align: left;
    padding: 1rem 1rem;
    border: 1px solid #3f4b5b;
    border-width: 1px 0 2px 0;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    transition: box-shadow 0.15s;
  }
  .p-datatable .p-datatable-tfoot &gt; tr &gt; td {
    text-align: left;
    padding: 1rem 1rem;
    border: 1px solid #3f4b5b;
    border-width: 1px 0 1px 0;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
  }
  .p-datatable .p-sortable-column .p-sortable-column-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-left: 0.5rem;
  }
  .p-datatable .p-sortable-column .p-sortable-column-badge {
    border-radius: 50%;
    height: 1.143rem;
    min-width: 1.143rem;
    line-height: 1.143rem;
    color: #151515;
    background: #8dd0ff;
    margin-left: 0.5rem;
  }
  .p-datatable .p-sortable-column:not(.p-highlight):not(.p-sortable-disabled):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-datatable .p-sortable-column:not(.p-highlight):not(.p-sortable-disabled):hover .p-sortable-column-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-datatable .p-sortable-column.p-highlight {
    background: #2a323d;
    color: #8dd0ff;
  }
  .p-datatable .p-sortable-column.p-highlight .p-sortable-column-icon {
    color: #8dd0ff;
  }
  .p-datatable .p-sortable-column.p-highlight:not(.p-sortable-disabled):hover {
    background: rgba(255, 255, 255, 0.04);
    color: #8dd0ff;
  }
  .p-datatable .p-sortable-column.p-highlight:not(.p-sortable-disabled):hover .p-sortable-column-icon {
    color: #8dd0ff;
  }
  .p-datatable .p-sortable-column:focus-visible {
    box-shadow: inset 0 0 0 0.15rem #e3f3fe;
    outline: 0 none;
  }
  .p-datatable .p-datatable-tbody &gt; tr {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
  }
  .p-datatable .p-datatable-tbody &gt; tr &gt; td {
    text-align: left;
    border: 1px solid #3f4b5b;
    border-width: 1px 0 0 0;
    padding: 1rem 1rem;
  }
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-toggler,
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-editor-init,
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-editor-save,
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-editor-cancel {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-toggler:enabled:hover,
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-editor-init:enabled:hover,
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-editor-save:enabled:hover,
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-editor-cancel:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-toggler:focus-visible,
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-editor-init:focus-visible,
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-editor-save:focus-visible,
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-editor-cancel:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-datatable .p-datatable-tbody &gt; tr &gt; td .p-row-editor-save {
    margin-right: 0.5rem;
  }
  .p-datatable .p-datatable-tbody &gt; tr &gt; td &gt; .p-column-title {
    font-weight: 600;
  }
  .p-datatable .p-datatable-tbody &gt; tr &gt; td.p-highlight {
    background: #8dd0ff;
    color: #151515;
  }
  .p-datatable .p-datatable-tbody &gt; tr.p-highlight {
    background: #8dd0ff;
    color: #151515;
  }
  .p-datatable .p-datatable-tbody &gt; tr.p-highlight-contextmenu {
    outline: 0.15rem solid #e3f3fe;
    outline-offset: -0.15rem;
  }
  .p-datatable .p-datatable-tbody &gt; tr.p-datatable-dragpoint-top &gt; td {
    box-shadow: inset 0 2px 0 0 #8dd0ff;
  }
  .p-datatable .p-datatable-tbody &gt; tr.p-datatable-dragpoint-bottom &gt; td {
    box-shadow: inset 0 -2px 0 0 #8dd0ff;
  }
  .p-datatable.p-datatable-selectable .p-datatable-tbody &gt; tr.p-selectable-row:not(.p-highlight):not(.p-datatable-emptymessage):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-datatable.p-datatable-selectable .p-datatable-tbody &gt; tr.p-selectable-row:focus-visible {
    outline: 0.15rem solid #e3f3fe;
    outline-offset: -0.15rem;
  }
  .p-datatable.p-datatable-selectable-cell .p-datatable-tbody &gt; tr.p-selectable-row &gt; td.p-selectable-cell:not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-datatable.p-datatable-selectable-cell .p-datatable-tbody &gt; tr.p-selectable-row &gt; td.p-selectable-cell:focus-visible {
    outline: 0.15rem solid #e3f3fe;
    outline-offset: -0.15rem;
  }
  .p-datatable.p-datatable-hoverable-rows .p-datatable-tbody &gt; tr:not(.p-highlight):not(.p-datatable-emptymessage):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-datatable .p-column-resizer-helper {
    background: #8dd0ff;
  }
  .p-datatable .p-datatable-scrollable-header,
  .p-datatable .p-datatable-scrollable-footer {
    background: #2a323d;
  }
  .p-datatable.p-datatable-scrollable &gt; .p-datatable-wrapper &gt; .p-datatable-table &gt; .p-datatable-thead,
  .p-datatable.p-datatable-scrollable &gt; .p-datatable-wrapper &gt; .p-datatable-table &gt; .p-datatable-tfoot, .p-datatable.p-datatable-scrollable &gt; .p-datatable-wrapper &gt; .p-virtualscroller &gt; .p-datatable-table &gt; .p-datatable-thead,
  .p-datatable.p-datatable-scrollable &gt; .p-datatable-wrapper &gt; .p-virtualscroller &gt; .p-datatable-table &gt; .p-datatable-tfoot {
    background-color: #2a323d;
  }
  .p-datatable .p-datatable-loading-icon {
    font-size: 2rem;
  }
  .p-datatable .p-datatable-loading-icon.p-icon {
    width: 2rem;
    height: 2rem;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-header {
    border-width: 1px 1px 0 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-footer {
    border-width: 0 1px 1px 1px;
  }
  .p-datatable.p-datatable-gridlines .p-paginator-top {
    border-width: 0 1px 0 1px;
  }
  .p-datatable.p-datatable-gridlines .p-paginator-bottom {
    border-width: 0 1px 1px 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-thead &gt; tr &gt; th {
    border-width: 1px 0 1px 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-thead &gt; tr &gt; th:last-child {
    border-width: 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-tbody &gt; tr &gt; td {
    border-width: 1px 0 0 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-tbody &gt; tr &gt; td:last-child {
    border-width: 1px 1px 0 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-tbody &gt; tr:last-child &gt; td {
    border-width: 1px 0 1px 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-tbody &gt; tr:last-child &gt; td:last-child {
    border-width: 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-tfoot &gt; tr &gt; td {
    border-width: 1px 0 1px 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-tfoot &gt; tr &gt; td:last-child {
    border-width: 1px 1px 1px 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-thead + .p-datatable-tfoot &gt; tr &gt; td {
    border-width: 0 0 1px 1px;
  }
  .p-datatable.p-datatable-gridlines .p-datatable-thead + .p-datatable-tfoot &gt; tr &gt; td:last-child {
    border-width: 0 1px 1px 1px;
  }
  .p-datatable.p-datatable-gridlines:has(.p-datatable-thead):has(.p-datatable-tbody) .p-datatable-tbody &gt; tr &gt; td {
    border-width: 0 0 1px 1px;
  }
  .p-datatable.p-datatable-gridlines:has(.p-datatable-thead):has(.p-datatable-tbody) .p-datatable-tbody &gt; tr &gt; td:last-child {
    border-width: 0 1px 1px 1px;
  }
  .p-datatable.p-datatable-gridlines:has(.p-datatable-tbody):has(.p-datatable-tfoot) .p-datatable-tbody &gt; tr:last-child &gt; td {
    border-width: 0 0 0 1px;
  }
  .p-datatable.p-datatable-gridlines:has(.p-datatable-tbody):has(.p-datatable-tfoot) .p-datatable-tbody &gt; tr:last-child &gt; td:last-child {
    border-width: 0 1px 0 1px;
  }
  .p-datatable.p-datatable-striped .p-datatable-tbody &gt; tr.p-row-odd {
    background: #2f3641;
  }
  .p-datatable.p-datatable-striped .p-datatable-tbody &gt; tr.p-row-odd.p-highlight {
    background: #8dd0ff;
    color: #151515;
  }
  .p-datatable.p-datatable-striped .p-datatable-tbody &gt; tr.p-row-odd.p-highlight .p-row-toggler {
    color: #151515;
  }
  .p-datatable.p-datatable-striped .p-datatable-tbody &gt; tr.p-row-odd.p-highlight .p-row-toggler:hover {
    color: #151515;
  }
  .p-datatable.p-datatable-striped .p-datatable-tbody &gt; tr.p-row-odd + .p-row-expanded {
    background: #2f3641;
  }
  .p-datatable.p-datatable-sm .p-datatable-header {
    padding: 0.5rem 0.5rem;
  }
  .p-datatable.p-datatable-sm .p-datatable-thead &gt; tr &gt; th {
    padding: 0.5rem 0.5rem;
  }
  .p-datatable.p-datatable-sm .p-datatable-tbody &gt; tr &gt; td {
    padding: 0.5rem 0.5rem;
  }
  .p-datatable.p-datatable-sm .p-datatable-tfoot &gt; tr &gt; td {
    padding: 0.5rem 0.5rem;
  }
  .p-datatable.p-datatable-sm .p-datatable-footer {
    padding: 0.5rem 0.5rem;
  }
  .p-datatable.p-datatable-lg .p-datatable-header {
    padding: 1.25rem 1.25rem;
  }
  .p-datatable.p-datatable-lg .p-datatable-thead &gt; tr &gt; th {
    padding: 1.25rem 1.25rem;
  }
  .p-datatable.p-datatable-lg .p-datatable-tbody &gt; tr &gt; td {
    padding: 1.25rem 1.25rem;
  }
  .p-datatable.p-datatable-lg .p-datatable-tfoot &gt; tr &gt; td {
    padding: 1.25rem 1.25rem;
  }
  .p-datatable.p-datatable-lg .p-datatable-footer {
    padding: 1.25rem 1.25rem;
  }
  .p-datatable-drag-selection-helper {
    background: rgba(141, 208, 255, 0.16);
  }
  .p-dataview .p-paginator-top {
    border-width: 0;
    border-radius: 0;
  }
  .p-dataview .p-paginator-bottom {
    border-width: 1px 0 0 0;
    border-radius: 0;
  }
  .p-dataview .p-dataview-header {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.6);
    border: solid #3f4b5b;
    border-width: 1px 0 0 0;
    padding: 1rem 1rem;
    font-weight: 600;
  }
  .p-dataview .p-dataview-content {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 0 none;
    padding: 0;
  }
  .p-dataview .p-dataview-footer {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-width: 1px 0 1px 0;
    padding: 1rem 1rem;
    font-weight: 600;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
  }
  .p-dataview .p-dataview-loading-icon {
    font-size: 2rem;
  }
  .p-dataview .p-dataview-loading-icon.p-icon {
    width: 2rem;
    height: 2rem;
  }
  .p-datascroller .p-paginator-top {
    border-width: 0;
    border-radius: 0;
  }
  .p-datascroller .p-paginator-bottom {
    border-width: 1px 0 0 0;
    border-radius: 0;
  }
  .p-datascroller .p-datascroller-header {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.6);
    border: solid #3f4b5b;
    border-width: 1px 0 0 0;
    padding: 1rem 1rem;
    font-weight: 600;
  }
  .p-datascroller .p-datascroller-content {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 0 none;
    padding: 0;
  }
  .p-datascroller.p-datascroller-inline .p-datascroller-list &gt; li {
    border: 1px solid #3f4b5b;
    border-width: 1px 0 0 0;
  }
  .p-datascroller .p-datascroller-footer {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-width: 1px 0 1px 0;
    padding: 1rem 1rem;
    font-weight: 600;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
  }
  .p-column-filter-row .p-column-filter-menu-button,
  .p-column-filter-row .p-column-filter-clear-button {
    margin-left: 0.5rem;
  }
  .p-column-filter-menu-button {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-column-filter-menu-button:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-column-filter-menu-button.p-column-filter-menu-button-open, .p-column-filter-menu-button.p-column-filter-menu-button-open:hover {
    background: transparent;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-column-filter-menu-button.p-column-filter-menu-button-active, .p-column-filter-menu-button.p-column-filter-menu-button-active:hover {
    background: #8dd0ff;
    color: #151515;
  }
  .p-column-filter-menu-button:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-column-filter-clear-button {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-column-filter-clear-button:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-column-filter-clear-button:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-column-filter-overlay {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    box-shadow: none;
    min-width: 12.5rem;
  }
  .p-column-filter-overlay .p-column-filter-row-items {
    padding: 0.5rem 0;
  }
  .p-column-filter-overlay .p-column-filter-row-items .p-column-filter-row-item {
    margin: 0;
    padding: 0.5rem 1.5rem;
    border: 0 none;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-column-filter-overlay .p-column-filter-row-items .p-column-filter-row-item.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-column-filter-overlay .p-column-filter-row-items .p-column-filter-row-item:not(.p-highlight):not(.p-disabled):hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-column-filter-overlay .p-column-filter-row-items .p-column-filter-row-item:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: inset 0 0 0 0.15rem #e3f3fe;
  }
  .p-column-filter-overlay .p-column-filter-row-items .p-column-filter-separator {
    border-top: 1px solid #3f4b5b;
    margin: 0.5rem 0;
  }
  .p-column-filter-overlay-menu .p-column-filter-operator {
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    margin: 0;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-column-filter-overlay-menu .p-column-filter-constraint {
    padding: 1.25rem;
    border-bottom: 1px solid #3f4b5b;
  }
  .p-column-filter-overlay-menu .p-column-filter-constraint .p-column-filter-matchmode-dropdown {
    margin-bottom: 0.5rem;
  }
  .p-column-filter-overlay-menu .p-column-filter-constraint .p-column-filter-remove-button {
    margin-top: 0.5rem;
  }
  .p-column-filter-overlay-menu .p-column-filter-constraint:last-child {
    border-bottom: 0 none;
  }
  .p-column-filter-overlay-menu .p-column-filter-add-rule {
    padding: 0.5rem 1.25rem;
  }
  .p-column-filter-overlay-menu .p-column-filter-buttonbar {
    padding: 1.25rem;
  }
  .p-orderlist .p-orderlist-controls {
    padding: 1.25rem;
  }
  .p-orderlist .p-orderlist-controls .p-button {
    margin-bottom: 0.5rem;
  }
  .p-orderlist .p-orderlist-header {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    padding: 1rem 1.25rem;
    font-weight: 600;
    border-bottom: 0 none;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-orderlist .p-orderlist-filter-container {
    padding: 1rem 1.25rem;
    background: #2a323d;
    border: 1px solid #3f4b5b;
    border-bottom: 0 none;
  }
  .p-orderlist .p-orderlist-filter-container .p-orderlist-filter-input {
    padding-right: 1.75rem;
  }
  .p-orderlist .p-orderlist-filter-container .p-orderlist-filter-icon {
    right: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-orderlist .p-orderlist-list {
    border: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    padding: 0.5rem 0;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
    outline: 0 none;
  }
  .p-orderlist .p-orderlist-list .p-orderlist-item {
    padding: 0.5rem 1.5rem;
    margin: 0;
    border: 0 none;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .p-orderlist .p-orderlist-list .p-orderlist-item:not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-orderlist .p-orderlist-list .p-orderlist-item.p-focus {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.12);
  }
  .p-orderlist .p-orderlist-list .p-orderlist-item.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-orderlist .p-orderlist-list .p-orderlist-item.p-highlight.p-focus {
    background: #64bfff;
  }
  .p-orderlist.p-orderlist-striped .p-orderlist-list .p-orderlist-item:nth-child(even) {
    background: rgba(255, 255, 255, 0.02);
  }
  .p-orderlist.p-orderlist-striped .p-orderlist-list .p-orderlist-item:nth-child(even):hover {
    background: rgba(255, 255, 255, 0.04);
  }
  .p-organizationchart .p-organizationchart-node-content.p-organizationchart-selectable-node:not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-organizationchart .p-organizationchart-node-content.p-highlight {
    background: #8dd0ff;
    color: #151515;
  }
  .p-organizationchart .p-organizationchart-node-content.p-highlight .p-node-toggler i {
    color: #0e9bff;
  }
  .p-organizationchart .p-organizationchart-line-down {
    background: #3f4b5b;
  }
  .p-organizationchart .p-organizationchart-line-left {
    border-right: 1px solid #3f4b5b;
    border-color: #3f4b5b;
  }
  .p-organizationchart .p-organizationchart-line-top {
    border-top: 1px solid #3f4b5b;
    border-color: #3f4b5b;
  }
  .p-organizationchart .p-organizationchart-node-content {
    border: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    padding: 1.25rem;
  }
  .p-organizationchart .p-organizationchart-node-content .p-node-toggler {
    background: inherit;
    color: inherit;
    border-radius: 50%;
  }
  .p-organizationchart .p-organizationchart-node-content .p-node-toggler:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-paginator {
    background: #2a323d;
    color: #8dd0ff;
    border: solid #3f4b5b;
    border-width: 0;
    padding: 0.75rem;
    border-radius: 4px;
  }
  .p-paginator .p-paginator-first,
  .p-paginator .p-paginator-prev,
  .p-paginator .p-paginator-next,
  .p-paginator .p-paginator-last {
    background-color: transparent;
    border: 1px solid #3f4b5b;
    color: #8dd0ff;
    min-width: 2.357rem;
    height: 2.357rem;
    margin: 0 0 0 -1px;
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-paginator .p-paginator-first:not(.p-disabled):not(.p-highlight):hover,
  .p-paginator .p-paginator-prev:not(.p-disabled):not(.p-highlight):hover,
  .p-paginator .p-paginator-next:not(.p-disabled):not(.p-highlight):hover,
  .p-paginator .p-paginator-last:not(.p-disabled):not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
    border-color: #3f4b5b;
    color: #8dd0ff;
  }
  .p-paginator .p-paginator-first {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }
  .p-paginator .p-paginator-last {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
  }
  .p-paginator .p-dropdown {
    margin-left: 0.5rem;
    height: 2.357rem;
  }
  .p-paginator .p-dropdown .p-dropdown-label {
    padding-right: 0;
  }
  .p-paginator .p-paginator-page-input {
    margin-left: 0.5rem;
    margin-right: 0.5rem;
  }
  .p-paginator .p-paginator-page-input .p-inputtext {
    max-width: 2.357rem;
  }
  .p-paginator .p-paginator-current {
    background-color: transparent;
    border: 1px solid #3f4b5b;
    color: #8dd0ff;
    min-width: 2.357rem;
    height: 2.357rem;
    margin: 0 0 0 -1px;
    padding: 0 0.5rem;
  }
  .p-paginator .p-paginator-pages .p-paginator-page {
    background-color: transparent;
    border: 1px solid #3f4b5b;
    color: #8dd0ff;
    min-width: 2.357rem;
    height: 2.357rem;
    margin: 0 0 0 -1px;
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-paginator .p-paginator-pages .p-paginator-page.p-highlight {
    background: #8dd0ff;
    border-color: #8dd0ff;
    color: #151515;
  }
  .p-paginator .p-paginator-pages .p-paginator-page:not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
    border-color: #3f4b5b;
    color: #8dd0ff;
  }
  .p-picklist .p-picklist-buttons {
    padding: 1.25rem;
  }
  .p-picklist .p-picklist-buttons .p-button {
    margin-bottom: 0.5rem;
  }
  .p-picklist .p-picklist-header {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    padding: 1rem 1.25rem;
    font-weight: 600;
    border-bottom: 0 none;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-picklist .p-picklist-filter-container {
    padding: 1rem 1.25rem;
    background: #2a323d;
    border: 1px solid #3f4b5b;
    border-bottom: 0 none;
  }
  .p-picklist .p-picklist-filter-container .p-picklist-filter-input {
    padding-right: 1.75rem;
  }
  .p-picklist .p-picklist-filter-container .p-picklist-filter-icon {
    right: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-picklist .p-picklist-list {
    border: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    padding: 0.5rem 0;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
    outline: 0 none;
  }
  .p-picklist .p-picklist-list .p-picklist-item {
    padding: 0.5rem 1.5rem;
    margin: 0;
    border: 0 none;
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .p-picklist .p-picklist-list .p-picklist-item:not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-picklist .p-picklist-list .p-picklist-item.p-focus {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.12);
  }
  .p-picklist .p-picklist-list .p-picklist-item.p-highlight {
    color: #151515;
    background: #8dd0ff;
  }
  .p-picklist .p-picklist-list .p-picklist-item.p-highlight.p-focus {
    background: #64bfff;
  }
  .p-tree-container {
    margin: 0;
    padding: 0;
    list-style-type: none;
    overflow: auto;
  }
  .p-treenode-children {
    margin: 0;
    padding: 0;
    list-style-type: none;
  }
  .p-treenode-selectable {
    cursor: pointer;
    user-select: none;
  }
  .p-tree-toggler {
    cursor: pointer;
    user-select: none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    position: relative;
    flex-shrink: 0;
  }
  .p-treenode-leaf &gt; .p-treenode-content .p-tree-toggler {
    visibility: hidden;
  }
  .p-treenode-content {
    display: flex;
    align-items: center;
  }
  .p-tree-filter {
    width: 100%;
  }
  .p-tree-filter-container {
    position: relative;
    display: block;
    width: 100%;
  }
  .p-tree-filter-icon {
    position: absolute;
    top: 50%;
    margin-top: -0.5rem;
  }
  .p-tree-loading {
    position: relative;
    min-height: 4rem;
  }
  .p-tree .p-tree-loading-overlay {
    position: absolute;
    z-index: 1;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .p-tree {
    border: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    padding: 1.25rem;
    border-radius: 4px;
  }
  .p-tree .p-tree-container .p-treenode {
    padding: 0.143rem;
    outline: 0 none;
  }
  .p-tree .p-tree-container .p-treenode:focus &gt; .p-treenode-content {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: inset 0 0 0 0.15rem #e3f3fe;
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content {
    border-radius: 4px;
    transition: box-shadow 0.15s;
    padding: 0.286rem;
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content .p-tree-toggler {
    margin-right: 0.5rem;
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content .p-tree-toggler:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content .p-tree-toggler:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content .p-treenode-icon {
    margin-right: 0.5rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content .p-checkbox {
    margin-right: 0.5rem;
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content .p-checkbox.p-indeterminate .p-checkbox-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content.p-highlight {
    background: #8dd0ff;
    color: #151515;
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content.p-highlight .p-tree-toggler,
  .p-tree .p-tree-container .p-treenode .p-treenode-content.p-highlight .p-treenode-icon {
    color: #151515;
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content.p-highlight .p-tree-toggler:hover,
  .p-tree .p-tree-container .p-treenode .p-treenode-content.p-highlight .p-treenode-icon:hover {
    color: #151515;
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content.p-treenode-selectable:not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tree .p-tree-container .p-treenode .p-treenode-content.p-treenode-dragover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tree .p-tree-filter-container {
    margin-bottom: 0.5rem;
  }
  .p-tree .p-tree-filter-container .p-tree-filter {
    width: 100%;
    padding-right: 1.75rem;
  }
  .p-tree .p-tree-filter-container .p-tree-filter-icon {
    right: 0.75rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-tree .p-treenode-children {
    padding: 0 0 0 1rem;
  }
  .p-tree .p-tree-loading-icon {
    font-size: 2rem;
  }
  .p-tree .p-tree-loading-icon.p-icon {
    width: 2rem;
    height: 2rem;
  }
  .p-tree .p-treenode-droppoint {
    height: 0.5rem;
  }
  .p-tree .p-treenode-droppoint.p-treenode-droppoint-active {
    background: #3eafff;
  }
  .p-treetable {
    position: relative;
  }
  .p-treetable &gt; .p-treetable-wrapper {
    overflow: auto;
  }
  .p-treetable table {
    border-collapse: collapse;
    width: 100%;
    table-layout: fixed;
  }
  .p-treetable .p-sortable-column {
    cursor: pointer;
    user-select: none;
  }
  .p-treetable-selectable .p-treetable-tbody &gt; tr {
    cursor: pointer;
  }
  .p-treetable-toggler {
    cursor: pointer;
    user-select: none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    vertical-align: middle;
    overflow: hidden;
    position: relative;
  }
  .p-treetable-toggler + .p-checkbox {
    vertical-align: middle;
  }
  .p-treetable-toggler + .p-checkbox + span {
    vertical-align: middle;
  }
  /* Resizable */
  .p-treetable-resizable &gt; .p-treetable-wrapper {
    overflow-x: auto;
  }
  .p-treetable-resizable .p-treetable-thead &gt; tr &gt; th,
  .p-treetable-resizable .p-treetable-tfoot &gt; tr &gt; td,
  .p-treetable-resizable .p-treetable-tbody &gt; tr &gt; td {
    overflow: hidden;
  }
  .p-treetable-resizable .p-resizable-column {
    background-clip: padding-box;
    position: relative;
  }
  .p-treetable-resizable-fit .p-resizable-column:last-child .p-column-resizer {
    display: none;
  }
  .p-treetable .p-column-resizer {
    display: block;
    position: absolute;
    top: 0;
    right: 0;
    margin: 0;
    width: 0.5rem;
    height: 100%;
    padding: 0px;
    cursor: col-resize;
    border: 1px solid transparent;
  }
  .p-treetable .p-column-resizer-helper {
    width: 1px;
    position: absolute;
    z-index: 10;
    display: none;
  }
  /* Scrollable */
  .p-treetable-scrollable-wrapper {
    position: relative;
  }
  .p-treetable-scrollable-header,
  .p-treetable-scrollable-footer {
    overflow: hidden;
    border: 0 none;
  }
  .p-treetable-scrollable-body {
    overflow: auto;
    position: relative;
  }
  .p-treetable-virtual-table {
    position: absolute;
  }
  /* Frozen Columns */
  .p-treetable-frozen-view .p-treetable-scrollable-body {
    overflow: hidden;
  }
  .p-treetable-unfrozen-view {
    position: absolute;
    top: 0px;
    left: 0px;
  }
  /* Reorder */
  .p-treetable-reorder-indicator-up,
  .p-treetable-reorder-indicator-down {
    position: absolute;
    display: none;
  }
  /* Loader */
  .p-treetable .p-treetable-loading-overlay {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
  }
  /* Alignment */
  .p-treetable .p-treetable-thead &gt; tr &gt; th.p-align-left &gt; .p-column-header-content,
  .p-treetable .p-treetable-tbody &gt; tr &gt; td.p-align-left,
  .p-treetable .p-treetable-tfoot &gt; tr &gt; td.p-align-left {
    text-align: left;
    justify-content: flex-start;
  }
  .p-treetable .p-treetable-thead &gt; tr &gt; th.p-align-right &gt; .p-column-header-content,
  .p-treetable .p-treetable-tbody &gt; tr &gt; td.p-align-right,
  .p-treetable .p-treetable-tfoot &gt; tr &gt; td.p-align-right {
    text-align: right;
    justify-content: flex-end;
  }
  .p-treetable .p-treetable-thead &gt; tr &gt; th.p-align-center &gt; .p-column-header-content,
  .p-treetable .p-treetable-tbody &gt; tr &gt; td.p-align-center,
  .p-treetable .p-treetable-tfoot &gt; tr &gt; td.p-align-center {
    text-align: center;
    justify-content: center;
  }
  .p-treetable .p-paginator-top {
    border-width: 0;
    border-radius: 0;
  }
  .p-treetable .p-paginator-bottom {
    border-width: 1px 0 0 0;
    border-radius: 0;
  }
  .p-treetable .p-treetable-header {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.6);
    border: solid #3f4b5b;
    border-width: 1px 0 0 0;
    padding: 1rem 1rem;
    font-weight: 600;
  }
  .p-treetable .p-treetable-footer {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-width: 1px 0 1px 0;
    padding: 1rem 1rem;
    font-weight: 600;
  }
  .p-treetable .p-treetable-thead &gt; tr &gt; th {
    text-align: left;
    padding: 1rem 1rem;
    border: 1px solid #3f4b5b;
    border-width: 1px 0 2px 0;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    transition: box-shadow 0.15s;
  }
  .p-treetable .p-treetable-tfoot &gt; tr &gt; td {
    text-align: left;
    padding: 1rem 1rem;
    border: 1px solid #3f4b5b;
    border-width: 1px 0 1px 0;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
  }
  .p-treetable .p-sortable-column {
    outline-color: #e3f3fe;
  }
  .p-treetable .p-sortable-column .p-sortable-column-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-left: 0.5rem;
  }
  .p-treetable .p-sortable-column .p-sortable-column-badge {
    border-radius: 50%;
    height: 1.143rem;
    min-width: 1.143rem;
    line-height: 1.143rem;
    color: #151515;
    background: #8dd0ff;
    margin-left: 0.5rem;
  }
  .p-treetable .p-sortable-column:not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-treetable .p-sortable-column:not(.p-highlight):hover .p-sortable-column-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-treetable .p-sortable-column.p-highlight {
    background: #2a323d;
    color: #8dd0ff;
  }
  .p-treetable .p-sortable-column.p-highlight .p-sortable-column-icon {
    color: #8dd0ff;
  }
  .p-treetable .p-treetable-tbody &gt; tr {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
  }
  .p-treetable .p-treetable-tbody &gt; tr &gt; td {
    text-align: left;
    border: 1px solid #3f4b5b;
    border-width: 1px 0 0 0;
    padding: 1rem 1rem;
  }
  .p-treetable .p-treetable-tbody &gt; tr &gt; td .p-treetable-toggler {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
    margin-right: 0.5rem;
  }
  .p-treetable .p-treetable-tbody &gt; tr &gt; td .p-treetable-toggler:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-treetable .p-treetable-tbody &gt; tr &gt; td .p-treetable-toggler:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-treetable .p-treetable-tbody &gt; tr &gt; td .p-treetable-toggler + .p-checkbox {
    margin-right: 0.5rem;
  }
  .p-treetable .p-treetable-tbody &gt; tr &gt; td .p-treetable-toggler + .p-checkbox .p-indeterminate .p-checkbox-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-treetable .p-treetable-tbody &gt; tr:focus-visible {
    outline: 0.15rem solid #e3f3fe;
    outline-offset: -0.15rem;
  }
  .p-treetable .p-treetable-tbody &gt; tr.p-highlight {
    background: #8dd0ff;
    color: #151515;
  }
  .p-treetable .p-treetable-tbody &gt; tr.p-highlight .p-treetable-toggler {
    color: #151515;
  }
  .p-treetable .p-treetable-tbody &gt; tr.p-highlight .p-treetable-toggler:hover {
    color: #151515;
  }
  .p-treetable.p-treetable-selectable .p-treetable-tbody &gt; tr:not(.p-highlight):hover, .p-treetable.p-treetable-hoverable-rows .p-treetable-tbody &gt; tr:not(.p-highlight):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-treetable.p-treetable-selectable .p-treetable-tbody &gt; tr:not(.p-highlight):hover .p-treetable-toggler, .p-treetable.p-treetable-hoverable-rows .p-treetable-tbody &gt; tr:not(.p-highlight):hover .p-treetable-toggler {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-treetable .p-column-resizer-helper {
    background: #8dd0ff;
  }
  .p-treetable .p-treetable-scrollable-header,
  .p-treetable .p-treetable-scrollable-footer {
    background: #2a323d;
  }
  .p-treetable .p-treetable-loading-icon {
    font-size: 2rem;
  }
  .p-treetable .p-treetable-loading-icon.p-icon {
    width: 2rem;
    height: 2rem;
  }
  .p-treetable.p-treetable-gridlines .p-treetable-header {
    border-width: 1px 1px 0 1px;
  }
  .p-treetable.p-treetable-gridlines .p-treetable-footer {
    border-width: 0 1px 1px 1px;
  }
  .p-treetable.p-treetable-gridlines .p-treetable-top {
    border-width: 0 1px 0 1px;
  }
  .p-treetable.p-treetable-gridlines .p-treetable-bottom {
    border-width: 0 1px 1px 1px;
  }
  .p-treetable.p-treetable-gridlines .p-treetable-thead &gt; tr &gt; th {
    border-width: 1px;
  }
  .p-treetable.p-treetable-gridlines .p-treetable-tbody &gt; tr &gt; td {
    border-width: 1px;
  }
  .p-treetable.p-treetable-gridlines .p-treetable-tfoot &gt; tr &gt; td {
    border-width: 1px;
  }
  .p-treetable.p-treetable-striped .p-treetable-tbody &gt; tr.p-row-odd {
    background: #2f3641;
  }
  .p-treetable.p-treetable-striped .p-treetable-tbody &gt; tr.p-row-odd.p-highlight {
    background: #8dd0ff;
    color: #151515;
  }
  .p-treetable.p-treetable-striped .p-treetable-tbody &gt; tr.p-row-odd.p-highlight .p-row-toggler {
    color: #151515;
  }
  .p-treetable.p-treetable-striped .p-treetable-tbody &gt; tr.p-row-odd.p-highlight .p-row-toggler:hover {
    color: #151515;
  }
  .p-treetable.p-treetable-striped .p-treetable-tbody &gt; tr.p-row-odd + .p-row-expanded {
    background: #2f3641;
  }
  .p-treetable.p-treetable-sm .p-treetable-header {
    padding: 0.875rem 0.875rem;
  }
  .p-treetable.p-treetable-sm .p-treetable-thead &gt; tr &gt; th {
    padding: 0.5rem 0.5rem;
  }
  .p-treetable.p-treetable-sm .p-treetable-tbody &gt; tr &gt; td {
    padding: 0.5rem 0.5rem;
  }
  .p-treetable.p-treetable-sm .p-treetable-tfoot &gt; tr &gt; td {
    padding: 0.5rem 0.5rem;
  }
  .p-treetable.p-treetable-sm .p-treetable-footer {
    padding: 0.5rem 0.5rem;
  }
  .p-treetable.p-treetable-lg .p-treetable-header {
    padding: 1.25rem 1.25rem;
  }
  .p-treetable.p-treetable-lg .p-treetable-thead &gt; tr &gt; th {
    padding: 1.25rem 1.25rem;
  }
  .p-treetable.p-treetable-lg .p-treetable-tbody &gt; tr &gt; td {
    padding: 1.25rem 1.25rem;
  }
  .p-treetable.p-treetable-lg .p-treetable-tfoot &gt; tr &gt; td {
    padding: 1.25rem 1.25rem;
  }
  .p-treetable.p-treetable-lg .p-treetable-footer {
    padding: 1.25rem 1.25rem;
  }
  .p-timeline .p-timeline-event-marker {
    border: 0 none;
    border-radius: 50%;
    width: 1rem;
    height: 1rem;
    background-color: #8dd0ff;
  }
  .p-timeline .p-timeline-event-connector {
    background-color: #3f4b5b;
  }
  .p-timeline.p-timeline-vertical .p-timeline-event-opposite,
  .p-timeline.p-timeline-vertical .p-timeline-event-content {
    padding: 0 1rem;
  }
  .p-timeline.p-timeline-vertical .p-timeline-event-connector {
    width: 2px;
  }
  .p-timeline.p-timeline-horizontal .p-timeline-event-opposite,
  .p-timeline.p-timeline-horizontal .p-timeline-event-content {
    padding: 1rem 0;
  }
  .p-timeline.p-timeline-horizontal .p-timeline-event-connector {
    height: 2px;
  }
  .p-accordion .p-accordion-header .p-accordion-header-link {
    padding: 1rem 1.25rem;
    border: 1px solid #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    font-weight: 600;
    border-radius: 4px;
    transition: box-shadow 0.15s;
  }
  .p-accordion .p-accordion-header .p-accordion-header-link .p-accordion-toggle-icon {
    margin-right: 0.5rem;
  }
  .p-accordion .p-accordion-header:not(.p-disabled) .p-accordion-header-link:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-accordion .p-accordion-header:not(.p-highlight):not(.p-disabled):hover .p-accordion-header-link {
    background: rgba(255, 255, 255, 0.04);
    border-color: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-accordion .p-accordion-header:not(.p-disabled).p-highlight .p-accordion-header-link {
    background: #2a323d;
    border-color: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
  }
  .p-accordion .p-accordion-header:not(.p-disabled).p-highlight:hover .p-accordion-header-link {
    border-color: #3f4b5b;
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-accordion .p-accordion-content {
    padding: 1.25rem;
    border: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border-top: 0;
    border-top-right-radius: 0;
    border-top-left-radius: 0;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-accordion .p-accordion-tab {
    margin-bottom: 0;
  }
  .p-accordion .p-accordion-tab .p-accordion-header .p-accordion-header-link {
    border-radius: 0;
  }
  .p-accordion .p-accordion-tab .p-accordion-content {
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
  }
  .p-accordion .p-accordion-tab:not(:first-child) .p-accordion-header .p-accordion-header-link {
    border-top: 0 none;
  }
  .p-accordion .p-accordion-tab:not(:first-child) .p-accordion-header:not(.p-highlight):not(.p-disabled):hover .p-accordion-header-link, .p-accordion .p-accordion-tab:not(:first-child) .p-accordion-header:not(.p-disabled).p-highlight:hover .p-accordion-header-link {
    border-top: 0 none;
  }
  .p-accordion .p-accordion-tab:first-child .p-accordion-header .p-accordion-header-link {
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-accordion .p-accordion-tab:last-child .p-accordion-header:not(.p-highlight) .p-accordion-header-link {
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-accordion .p-accordion-tab:last-child .p-accordion-header:not(.p-highlight) .p-accordion-content {
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-card {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    box-shadow: 0 2px 1px -1px rgba(0, 0, 0, 0.2), 0 1px 1px 0 rgba(0, 0, 0, 0.14), 0 1px 3px 0 rgba(0, 0, 0, 0.12);
    border-radius: 4px;
  }
  .p-card .p-card-body {
    padding: 1.5rem;
  }
  .p-card .p-card-title {
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
  }
  .p-card .p-card-subtitle {
    font-weight: 400;
    margin-bottom: 0.5rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-card .p-card-content {
    padding: 1rem 0;
  }
  .p-card .p-card-footer {
    padding: 1rem 0 0 0;
  }
  .p-fieldset {
    border: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border-radius: 4px;
  }
  .p-fieldset .p-fieldset-legend {
    padding: 1rem 1.25rem;
    border: 1px solid #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    font-weight: 600;
    border-radius: 4px;
  }
  .p-fieldset.p-fieldset-toggleable .p-fieldset-legend {
    padding: 0;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-fieldset.p-fieldset-toggleable .p-fieldset-legend a {
    padding: 1rem 1.25rem;
    color: rgba(255, 255, 255, 0.87);
    border-radius: 4px;
    transition: box-shadow 0.15s;
  }
  .p-fieldset.p-fieldset-toggleable .p-fieldset-legend a .p-fieldset-toggler {
    margin-right: 0.5rem;
  }
  .p-fieldset.p-fieldset-toggleable .p-fieldset-legend a:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-fieldset.p-fieldset-toggleable .p-fieldset-legend:hover {
    background: rgba(255, 255, 255, 0.04);
    border-color: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-fieldset .p-fieldset-content {
    padding: 1.25rem;
  }
  .p-divider .p-divider-content {
    background-color: #2a323d;
  }
  .p-divider.p-divider-horizontal {
    margin: 1rem 0;
    padding: 0 1rem;
  }
  .p-divider.p-divider-horizontal:before {
    border-top: 1px #3f4b5b;
  }
  .p-divider.p-divider-horizontal .p-divider-content {
    padding: 0 0.5rem;
  }
  .p-divider.p-divider-vertical {
    margin: 0 1rem;
    padding: 1rem 0;
  }
  .p-divider.p-divider-vertical:before {
    border-left: 1px #3f4b5b;
  }
  .p-divider.p-divider-vertical .p-divider-content {
    padding: 0.5rem 0;
  }
  .p-panel .p-panel-header {
    border: 1px solid #3f4b5b;
    padding: 1rem 1.25rem;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-panel .p-panel-header .p-panel-title {
    font-weight: 600;
  }
  .p-panel .p-panel-header .p-panel-header-icon {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-panel .p-panel-header .p-panel-header-icon:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-panel .p-panel-header .p-panel-header-icon:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-panel.p-panel-toggleable .p-panel-header {
    padding: 0.5rem 1.25rem;
  }
  .p-panel .p-panel-content {
    padding: 1.25rem;
    border: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
    border-top: 0 none;
  }
  .p-panel .p-panel-footer {
    padding: 0.5rem 1.25rem;
    border: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border-top: 0 none;
  }
  .p-splitter {
    border: 1px solid #3f4b5b;
    background: #2a323d;
    border-radius: 4px;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-splitter .p-splitter-gutter {
    transition: color 0.15s, box-shadow 0.15s;
    background: rgba(255, 255, 255, 0.04);
  }
  .p-splitter .p-splitter-gutter .p-splitter-gutter-handle {
    background: #3f4b5b;
  }
  .p-splitter .p-splitter-gutter .p-splitter-gutter-handle:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-splitter .p-splitter-gutter-resizing {
    background: #3f4b5b;
  }
  .p-stepper .p-stepper-nav {
    display: flex;
    justify-content: space-between;
    margin: 0;
    padding: 0;
    list-style-type: none;
  }
  .p-stepper .p-stepper-header {
    padding: 0.5rem;
  }
  .p-stepper .p-stepper-header .p-stepper-action {
    transition: box-shadow 0.15s;
    border-radius: 4px;
    background: transparent;
    outline-color: transparent;
  }
  .p-stepper .p-stepper-header .p-stepper-action .p-stepper-number {
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-width: 2px;
    background: transparent;
    min-width: 2rem;
    height: 2rem;
    line-height: 2rem;
    font-size: 1.143rem;
    border-radius: 4px;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-stepper .p-stepper-header .p-stepper-action .p-stepper-title {
    margin-left: 0.5rem;
    color: rgba(255, 255, 255, 0.6);
    font-weight: 600;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-stepper .p-stepper-header .p-stepper-action:not(.p-disabled):focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-stepper .p-stepper-header.p-highlight .p-stepper-number {
    background: #8dd0ff;
    color: #151515;
  }
  .p-stepper .p-stepper-header.p-highlight .p-stepper-title {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-stepper .p-stepper-header:not(.p-disabled):focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-stepper .p-stepper-header:has(~ .p-highlight) .p-stepper-separator {
    background-color: #8dd0ff;
  }
  .p-stepper .p-stepper-panels {
    background: #2a323d;
    padding: 1.25rem;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-stepper .p-stepper-separator {
    background-color: #3f4b5b;
    width: 100%;
    height: 2px;
    margin-inline-start: 1rem;
    transition: box-shadow 0.15s;
  }
  .p-stepper.p-stepper-vertical {
    display: flex;
    flex-direction: column;
  }
  .p-stepper.p-stepper-vertical .p-stepper-toggleable-content {
    display: flex;
    flex: 1 1 auto;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-stepper.p-stepper-vertical .p-stepper-panel {
    display: flex;
    flex-direction: column;
    flex: initial;
  }
  .p-stepper.p-stepper-vertical .p-stepper-panel.p-stepper-panel-active {
    flex: 1 1 auto;
  }
  .p-stepper.p-stepper-vertical .p-stepper-panel .p-stepper-header {
    flex: initial;
  }
  .p-stepper.p-stepper-vertical .p-stepper-panel .p-stepper-content {
    width: 100%;
    padding-left: 1rem;
  }
  .p-stepper.p-stepper-vertical .p-stepper-panel .p-stepper-separator {
    flex: 0 0 auto;
    width: 2px;
    height: auto;
    margin-inline-start: calc(1.75rem + 2px);
  }
  .p-stepper.p-stepper-vertical .p-stepper-panel:has(~ .p-stepper-panel-active) .p-stepper-separator {
    background-color: #8dd0ff;
  }
  .p-stepper.p-stepper-vertical .p-stepper-panel:last-of-type .p-stepper-content {
    padding-left: 3rem;
  }
  .p-scrollpanel .p-scrollpanel-bar {
    background: #3f4b5b;
    border: 0 none;
  }
  .p-scrollpanel .p-scrollpanel-bar:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-tabview .p-tabview-nav {
    background: transparent;
    border: 1px solid #3f4b5b;
    border-width: 0 0 1px 0;
  }
  .p-tabview .p-tabview-nav li {
    margin-right: 0;
  }
  .p-tabview .p-tabview-nav li .p-tabview-nav-link {
    border: solid;
    border-width: 1px;
    border-color: #2a323d #2a323d #3f4b5b #2a323d;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.6);
    padding: 0.75rem 1rem;
    font-weight: 600;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
    transition: box-shadow 0.15s;
    margin: 0 0 -1px 0;
  }
  .p-tabview .p-tabview-nav li .p-tabview-nav-link:not(.p-disabled):focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: inset 0 0 0 1px #e3f3fe;
  }
  .p-tabview .p-tabview-nav li:not(.p-highlight):not(.p-disabled):hover .p-tabview-nav-link {
    background: #2a323d;
    border-color: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tabview .p-tabview-nav li.p-highlight .p-tabview-nav-link {
    background: #2a323d;
    border-color: #3f4b5b #3f4b5b #2a323d #3f4b5b;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-tabview .p-tabview-close {
    margin-left: 0.5rem;
  }
  .p-tabview .p-tabview-nav-btn.p-link {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.6);
    width: 2.357rem;
    box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
    border-radius: 0;
  }
  .p-tabview .p-tabview-nav-btn.p-link:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: inset 0 0 0 1px #e3f3fe;
  }
  .p-tabview .p-tabview-panels {
    background: #2a323d;
    padding: 1.25rem;
    border: 0 none;
    color: rgba(255, 255, 255, 0.87);
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-toolbar {
    background: #2a323d;
    border: 1px solid #3f4b5b;
    padding: 1rem 1.25rem;
    border-radius: 4px;
    gap: 0.5rem;
  }
  .p-toolbar .p-toolbar-separator {
    margin: 0 0.5rem;
  }
  .p-confirm-popup {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    box-shadow: none;
  }
  .p-confirm-popup .p-confirm-popup-content {
    padding: 1.25rem;
  }
  .p-confirm-popup .p-confirm-popup-footer {
    text-align: right;
    padding: 0 1.25rem 1.25rem 1.25rem;
  }
  .p-confirm-popup .p-confirm-popup-footer button {
    margin: 0 0.5rem 0 0;
    width: auto;
  }
  .p-confirm-popup .p-confirm-popup-footer button:last-child {
    margin: 0;
  }
  .p-confirm-popup:after {
    border: solid transparent;
    border-color: rgba(42, 50, 61, 0);
    border-bottom-color: #2a323d;
  }
  .p-confirm-popup:before {
    border: solid transparent;
    border-color: rgba(63, 75, 91, 0);
    border-bottom-color: #3c4756;
  }
  .p-confirm-popup.p-confirm-popup-flipped:after {
    border-top-color: #2a323d;
  }
  .p-confirm-popup.p-confirm-popup-flipped:before {
    border-top-color: #3f4b5b;
  }
  .p-confirm-popup .p-confirm-popup-icon {
    font-size: 1.5rem;
  }
  .p-confirm-popup .p-confirm-popup-icon.p-icon {
    width: 1.5rem;
    height: 1.5rem;
  }
  .p-confirm-popup .p-confirm-popup-message {
    margin-left: 1rem;
  }
  .p-dialog {
    border-radius: 4px;
    box-shadow: none;
    border: 1px solid #3f4b5b;
  }
  .p-dialog .p-dialog-header {
    border-bottom: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    padding: 1rem;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-dialog .p-dialog-header .p-dialog-title {
    font-weight: 600;
    font-size: 1.25rem;
  }
  .p-dialog .p-dialog-header .p-dialog-header-icon {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
    margin-right: 0.5rem;
  }
  .p-dialog .p-dialog-header .p-dialog-header-icon:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-dialog .p-dialog-header .p-dialog-header-icon:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-dialog .p-dialog-header .p-dialog-header-icon:last-child {
    margin-right: 0;
  }
  .p-dialog .p-dialog-content {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    padding: 1rem;
  }
  .p-dialog .p-dialog-content:last-of-type {
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-dialog .p-dialog-footer {
    border-top: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    padding: 1rem;
    text-align: right;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-dialog .p-dialog-footer button {
    margin: 0 0.5rem 0 0;
    width: auto;
  }
  .p-dialog.p-dialog-maximized .p-dialog-header, .p-dialog.p-dialog-maximized .p-dialog-content:last-of-type {
    border-radius: 0;
  }
  .p-dialog.p-confirm-dialog .p-confirm-dialog-icon {
    font-size: 2rem;
  }
  .p-dialog.p-confirm-dialog .p-confirm-dialog-icon.p-icon {
    width: 2rem;
    height: 2rem;
  }
  .p-dialog.p-confirm-dialog .p-confirm-dialog-message {
    margin-left: 1rem;
  }
  .p-overlaypanel {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    box-shadow: none;
  }
  .p-overlaypanel .p-overlaypanel-content {
    padding: 1.25rem;
  }
  .p-overlaypanel .p-overlaypanel-close {
    background: #8dd0ff;
    color: #151515;
    width: 2rem;
    height: 2rem;
    transition: color 0.15s, box-shadow 0.15s;
    border-radius: 50%;
    position: absolute;
    top: -1rem;
    right: -1rem;
  }
  .p-overlaypanel .p-overlaypanel-close:enabled:hover {
    background: #56bdff;
    color: #151515;
  }
  .p-overlaypanel:after {
    border: solid transparent;
    border-color: rgba(42, 50, 61, 0);
    border-bottom-color: #2a323d;
  }
  .p-overlaypanel:before {
    border: solid transparent;
    border-color: rgba(63, 75, 91, 0);
    border-bottom-color: #3c4756;
  }
  .p-overlaypanel.p-overlaypanel-flipped:after {
    border-top-color: #2a323d;
  }
  .p-overlaypanel.p-overlaypanel-flipped:before {
    border-top-color: #3f4b5b;
  }
  .p-sidebar {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    box-shadow: none;
  }
  .p-sidebar .p-sidebar-header {
    padding: 1rem 1.25rem;
  }
  .p-sidebar .p-sidebar-header .p-sidebar-close,
  .p-sidebar .p-sidebar-header .p-sidebar-icon {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    background: transparent;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-sidebar .p-sidebar-header .p-sidebar-close:enabled:hover,
  .p-sidebar .p-sidebar-header .p-sidebar-icon:enabled:hover {
    color: rgba(255, 255, 255, 0.87);
    border-color: transparent;
    background: transparent;
  }
  .p-sidebar .p-sidebar-header .p-sidebar-close:focus-visible,
  .p-sidebar .p-sidebar-header .p-sidebar-icon:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-sidebar .p-sidebar-header + .p-sidebar-content {
    padding-top: 0;
  }
  .p-sidebar .p-sidebar-content {
    padding: 1.25rem;
  }
  .p-tooltip .p-tooltip-text {
    background: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    padding: 0.5rem 0.75rem;
    box-shadow: none;
    border-radius: 4px;
  }
  .p-tooltip.p-tooltip-right .p-tooltip-arrow {
    border-right-color: #3f4b5b;
  }
  .p-tooltip.p-tooltip-left .p-tooltip-arrow {
    border-left-color: #3f4b5b;
  }
  .p-tooltip.p-tooltip-top .p-tooltip-arrow {
    border-top-color: #3f4b5b;
  }
  .p-tooltip.p-tooltip-bottom .p-tooltip-arrow {
    border-bottom-color: #3f4b5b;
  }
  .p-fileupload .p-fileupload-buttonbar {
    background: #2a323d;
    padding: 1rem 1.25rem;
    border: 1px solid #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    border-bottom: 0 none;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
    gap: 0.5rem;
  }
  .p-fileupload .p-fileupload-buttonbar .p-button {
    margin-right: 0.5rem;
  }
  .p-fileupload .p-fileupload-content {
    background: #2a323d;
    padding: 2rem 1rem;
    border: 1px solid #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-fileupload .p-progressbar {
    height: 0.25rem;
  }
  .p-fileupload .p-fileupload-row &gt; div {
    padding: 1rem 1rem;
  }
  .p-fileupload.p-fileupload-advanced .p-message {
    margin-top: 0;
  }
  .p-breadcrumb {
    background: #343e4d;
    border: 0 none;
    border-radius: 4px;
    padding: 1rem;
  }
  .p-breadcrumb .p-breadcrumb-list li .p-menuitem-link {
    transition: box-shadow 0.15s;
    border-radius: 4px;
  }
  .p-breadcrumb .p-breadcrumb-list li .p-menuitem-link:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-breadcrumb .p-breadcrumb-list li .p-menuitem-link .p-menuitem-text {
    color: #8dd0ff;
  }
  .p-breadcrumb .p-breadcrumb-list li .p-menuitem-link .p-menuitem-icon {
    color: #8dd0ff;
  }
  .p-breadcrumb .p-breadcrumb-list li.p-menuitem-separator {
    margin: 0 0.5rem 0 0.5rem;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-breadcrumb .p-breadcrumb-list li:last-child .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-breadcrumb .p-breadcrumb-list li:last-child .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-contextmenu {
    padding: 0.5rem 0;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    box-shadow: none;
    border-radius: 4px;
    width: 12.5rem;
  }
  .p-contextmenu .p-contextmenu-root-list {
    outline: 0 none;
  }
  .p-contextmenu .p-submenu-list {
    padding: 0.5rem 0;
    background: #2a323d;
    border: 1px solid #3f4b5b;
    box-shadow: none;
    border-radius: 4px;
  }
  .p-contextmenu .p-menuitem &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-contextmenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link {
    color: rgba(255, 255, 255, 0.87);
    padding: 0.75rem 1rem;
    user-select: none;
  }
  .p-contextmenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-contextmenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-right: 0.5rem;
  }
  .p-contextmenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-contextmenu .p-menuitem.p-highlight &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: #20262e;
  }
  .p-contextmenu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-contextmenu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-contextmenu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-contextmenu .p-menuitem.p-highlight.p-focus &gt; .p-menuitem-content {
    background: #20262e;
  }
  .p-contextmenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.12);
  }
  .p-contextmenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-contextmenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-contextmenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-contextmenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-contextmenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-contextmenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
  .p-contextmenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-contextmenu .p-menuitem-separator {
    border-top: 1px solid #3f4b5b;
    margin: 0.5rem 0;
  }
  .p-contextmenu .p-submenu-icon {
    font-size: 0.875rem;
  }
  .p-contextmenu .p-submenu-icon.p-icon {
    width: 0.875rem;
    height: 0.875rem;
  }
  .p-dock .p-dock-list-container {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    padding: 0.5rem 0.5rem;
    border-radius: 0.5rem;
  }
  .p-dock .p-dock-list-container .p-dock-list {
    outline: 0 none;
  }
  .p-dock .p-dock-item {
    padding: 0.5rem;
    border-radius: 4px;
  }
  .p-dock .p-dock-item.p-focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: inset 0 0 0 0.15rem #e3f3fe;
  }
  .p-dock .p-dock-action {
    width: 4rem;
    height: 4rem;
  }
  .p-dock.p-dock-top .p-dock-item-second-prev,
  .p-dock.p-dock-top .p-dock-item-second-next, .p-dock.p-dock-bottom .p-dock-item-second-prev,
  .p-dock.p-dock-bottom .p-dock-item-second-next {
    margin: 0 0.9rem;
  }
  .p-dock.p-dock-top .p-dock-item-prev,
  .p-dock.p-dock-top .p-dock-item-next, .p-dock.p-dock-bottom .p-dock-item-prev,
  .p-dock.p-dock-bottom .p-dock-item-next {
    margin: 0 1.3rem;
  }
  .p-dock.p-dock-top .p-dock-item-current, .p-dock.p-dock-bottom .p-dock-item-current {
    margin: 0 1.5rem;
  }
  .p-dock.p-dock-left .p-dock-item-second-prev,
  .p-dock.p-dock-left .p-dock-item-second-next, .p-dock.p-dock-right .p-dock-item-second-prev,
  .p-dock.p-dock-right .p-dock-item-second-next {
    margin: 0.9rem 0;
  }
  .p-dock.p-dock-left .p-dock-item-prev,
  .p-dock.p-dock-left .p-dock-item-next, .p-dock.p-dock-right .p-dock-item-prev,
  .p-dock.p-dock-right .p-dock-item-next {
    margin: 1.3rem 0;
  }
  .p-dock.p-dock-left .p-dock-item-current, .p-dock.p-dock-right .p-dock-item-current {
    margin: 1.5rem 0;
  }
  .p-dock.p-dock-mobile.p-dock-top .p-dock-list-container, .p-dock.p-dock-mobile.p-dock-bottom .p-dock-list-container {
    overflow-x: auto;
    width: 100%;
  }
  .p-dock.p-dock-mobile.p-dock-top .p-dock-list-container .p-dock-list, .p-dock.p-dock-mobile.p-dock-bottom .p-dock-list-container .p-dock-list {
    margin: 0 auto;
  }
  .p-dock.p-dock-mobile.p-dock-left .p-dock-list-container, .p-dock.p-dock-mobile.p-dock-right .p-dock-list-container {
    overflow-y: auto;
    height: 100%;
  }
  .p-dock.p-dock-mobile.p-dock-left .p-dock-list-container .p-dock-list, .p-dock.p-dock-mobile.p-dock-right .p-dock-list-container .p-dock-list {
    margin: auto 0;
  }
  .p-dock.p-dock-mobile .p-dock-list .p-dock-item {
    transform: none;
    margin: 0;
  }
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-top .p-dock-item-second-prev,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-top .p-dock-item-second-next,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-top .p-dock-item-prev,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-top .p-dock-item-next,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-top .p-dock-item-current, .p-dock.p-dock-mobile.p-dock-magnification.p-dock-bottom .p-dock-item-second-prev,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-bottom .p-dock-item-second-next,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-bottom .p-dock-item-prev,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-bottom .p-dock-item-next,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-bottom .p-dock-item-current, .p-dock.p-dock-mobile.p-dock-magnification.p-dock-left .p-dock-item-second-prev,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-left .p-dock-item-second-next,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-left .p-dock-item-prev,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-left .p-dock-item-next,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-left .p-dock-item-current, .p-dock.p-dock-mobile.p-dock-magnification.p-dock-right .p-dock-item-second-prev,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-right .p-dock-item-second-next,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-right .p-dock-item-prev,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-right .p-dock-item-next,
  .p-dock.p-dock-mobile.p-dock-magnification.p-dock-right .p-dock-item-current {
    transform: none;
    margin: 0;
  }
  .p-megamenu {
    padding: 0.5rem 1rem;
    background: #343e4d;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    border-radius: 4px;
  }
  .p-megamenu .p-megamenu-root-list {
    outline: 0 none;
  }
  .p-megamenu .p-menuitem &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-megamenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link {
    color: rgba(255, 255, 255, 0.87);
    padding: 0.75rem 1rem;
    user-select: none;
  }
  .p-megamenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-right: 0.5rem;
  }
  .p-megamenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-megamenu .p-menuitem.p-highlight &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: #20262e;
  }
  .p-megamenu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-megamenu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu .p-menuitem.p-highlight.p-focus &gt; .p-menuitem-content {
    background: #20262e;
  }
  .p-megamenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.12);
  }
  .p-megamenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-megamenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-megamenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
  .p-megamenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu .p-megamenu-panel {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    box-shadow: none;
  }
  .p-megamenu .p-submenu-header {
    margin: 0;
    padding: 0.75rem 1rem;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    font-weight: 600;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-megamenu .p-submenu-list {
    padding: 0.5rem 0;
    width: 12.5rem;
  }
  .p-megamenu .p-submenu-list .p-menuitem-separator {
    border-top: 1px solid #3f4b5b;
    margin: 0.5rem 0;
  }
  .p-megamenu.p-megamenu-vertical {
    width: 12.5rem;
    padding: 0.5rem 0;
  }
  .p-megamenu .p-megamenu-button {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-megamenu .p-megamenu-button:hover {
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
  }
  .p-megamenu .p-megamenu-button:focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-megamenu.p-megamenu-horizontal .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.6);
    transition: box-shadow 0.15s;
    border-radius: 4px;
  }
  .p-megamenu.p-megamenu-horizontal .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-content .p-menuitem-link {
    padding: 1rem;
    user-select: none;
  }
  .p-megamenu.p-megamenu-horizontal .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-megamenu.p-megamenu-horizontal .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-right: 0.5rem;
  }
  .p-megamenu.p-megamenu-horizontal .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-left: 0.5rem;
  }
  .p-megamenu.p-megamenu-horizontal .p-megamenu-root-list &gt; .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
  }
  .p-megamenu.p-megamenu-horizontal .p-megamenu-root-list &gt; .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu.p-megamenu-horizontal .p-megamenu-root-list &gt; .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
  .p-megamenu.p-megamenu-horizontal .p-megamenu-root-list &gt; .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list {
    padding: 0.5rem 0;
    background: #2a323d;
    border: 1px solid #3f4b5b;
    box-shadow: none;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list .p-menu-separator {
    border-top: 1px solid #3f4b5b;
    margin: 0.5rem 0;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list .p-submenu-icon {
    font-size: 0.875rem;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list .p-submenu-icon.p-icon {
    width: 0.875rem;
    height: 0.875rem;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem {
    width: 100%;
    position: static;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link {
    color: rgba(255, 255, 255, 0.87);
    padding: 0.75rem 1rem;
    user-select: none;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-right: 0.5rem;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link.p-highlight &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: #20262e;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link.p-highlight.p-focus &gt; .p-menuitem-content {
    background: #20262e;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.12);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-submenu-icon {
    margin-left: auto;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list &gt; .p-menuitem.p-menuitem-active &gt; .p-menuitem-link &gt; .p-submenu-icon {
    transform: rotate(-180deg);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list .p-submenu-list {
    width: 100%;
    position: static;
    box-shadow: none;
    border: 0 none;
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list .p-submenu-list .p-submenu-icon {
    transition: transform 0.15s;
    transform: rotate(90deg);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list .p-submenu-list .p-menuitem-active &gt; .p-menuitem-link &gt; .p-submenu-icon {
    transform: rotate(-90deg);
  }
  .p-megamenu.p-megamenu-mobile-active .p-megamenu-root-list .p-menuitem {
    width: 100%;
    position: static;
  }
  .p-menu {
    padding: 0.5rem 0;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    width: 12.5rem;
  }
  .p-menu .p-menuitem &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-menu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link {
    color: rgba(255, 255, 255, 0.87);
    padding: 0.75rem 1rem;
    user-select: none;
  }
  .p-menu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-right: 0.5rem;
  }
  .p-menu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-menu .p-menuitem.p-highlight &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: #20262e;
  }
  .p-menu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-menu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menu .p-menuitem.p-highlight.p-focus &gt; .p-menuitem-content {
    background: #20262e;
  }
  .p-menu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.12);
  }
  .p-menu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-menu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-menu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
  .p-menu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menu.p-menu-overlay {
    background: #2a323d;
    border: 1px solid #3f4b5b;
    box-shadow: none;
  }
  .p-menu .p-submenu-header {
    margin: 0;
    padding: 0.75rem 1rem;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    font-weight: 600;
    border-top-right-radius: 0;
    border-top-left-radius: 0;
  }
  .p-menu .p-menu-separator {
    border-top: 1px solid #3f4b5b;
    margin: 0.5rem 0;
  }
  .p-menubar {
    padding: 0.5rem 1rem;
    background: #343e4d;
    color: rgba(255, 255, 255, 0.6);
    border: 0 none;
    border-radius: 4px;
  }
  .p-menubar .p-menubar-root-list {
    outline: 0 none;
  }
  .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.6);
    transition: box-shadow 0.15s;
    border-radius: 4px;
  }
  .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-content .p-menuitem-link {
    padding: 1rem;
    user-select: none;
  }
  .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-right: 0.5rem;
  }
  .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-left: 0.5rem;
  }
  .p-menubar .p-menubar-root-list &gt; .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
  }
  .p-menubar .p-menubar-root-list &gt; .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menubar .p-menubar-root-list &gt; .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
  .p-menubar .p-menubar-root-list &gt; .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menubar .p-menuitem &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-menubar .p-menuitem &gt; .p-menuitem-content .p-menuitem-link {
    color: rgba(255, 255, 255, 0.87);
    padding: 0.75rem 1rem;
    user-select: none;
  }
  .p-menubar .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menubar .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-right: 0.5rem;
  }
  .p-menubar .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-menubar .p-menuitem.p-highlight &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: #20262e;
  }
  .p-menubar .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menubar .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-menubar .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menubar .p-menuitem.p-highlight.p-focus &gt; .p-menuitem-content {
    background: #20262e;
  }
  .p-menubar .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.12);
  }
  .p-menubar .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menubar .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-menubar .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menubar .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-menubar .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menubar .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
  .p-menubar .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-menubar .p-submenu-list {
    padding: 0.5rem 0;
    background: #2a323d;
    border: 1px solid #3f4b5b;
    box-shadow: none;
    width: 12.5rem;
  }
  .p-menubar .p-submenu-list .p-menuitem-separator {
    border-top: 1px solid #3f4b5b;
    margin: 0.5rem 0;
  }
  .p-menubar .p-submenu-list .p-submenu-icon {
    font-size: 0.875rem;
  }
  .p-menubar.p-menubar-mobile .p-menubar-button {
    width: 2rem;
    height: 2rem;
    color: rgba(255, 255, 255, 0.6);
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-menubar.p-menubar-mobile .p-menubar-button:hover {
    color: rgba(255, 255, 255, 0.87);
    background: transparent;
  }
  .p-menubar.p-menubar-mobile .p-menubar-button:focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list {
    padding: 0.5rem 0;
    background: #2a323d;
    border: 1px solid #3f4b5b;
    box-shadow: none;
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list .p-menuitem-separator {
    border-top: 1px solid #3f4b5b;
    margin: 0.5rem 0;
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list .p-submenu-icon {
    font-size: 0.875rem;
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list .p-menuitem .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    margin-left: auto;
    transition: transform 0.15s;
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list .p-menuitem.p-menuitem-active &gt; .p-menuitem-content &gt; .p-menuitem-link &gt; .p-submenu-icon {
    transform: rotate(-180deg);
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list .p-submenu-list .p-submenu-icon {
    transition: transform 0.15s;
    transform: rotate(90deg);
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list .p-submenu-list .p-menuitem-active &gt; .p-menuitem-content &gt; .p-menuitem-link &gt; .p-submenu-icon {
    transform: rotate(-90deg);
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list ul li a {
    padding-left: 2.25rem;
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list ul li ul li a {
    padding-left: 3.75rem;
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list ul li ul li ul li a {
    padding-left: 5.25rem;
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list ul li ul li ul li ul li a {
    padding-left: 6.75rem;
  }
  .p-menubar.p-menubar-mobile .p-menubar-root-list ul li ul li ul li ul li ul li a {
    padding-left: 8.25rem;
  }
  @media screen and (max-width: 960px) {
    .p-menubar {
      position: relative;
    }
    .p-menubar .p-menubar-button {
      display: flex;
      width: 2rem;
      height: 2rem;
      color: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      transition: color 0.15s, box-shadow 0.15s;
    }
    .p-menubar .p-menubar-button:hover {
      color: rgba(255, 255, 255, 0.87);
      background: transparent;
    }
    .p-menubar .p-menubar-button:focus {
      outline: 0 none;
      outline-offset: 0;
      box-shadow: 0 0 0 1px #e3f3fe;
    }
    .p-menubar .p-menubar-root-list {
      position: absolute;
      display: none;
      padding: 0.5rem 0;
      background: #2a323d;
      border: 1px solid #3f4b5b;
      box-shadow: none;
      width: 100%;
    }
    .p-menubar .p-menubar-root-list .p-menu-separator {
      border-top: 1px solid #3f4b5b;
      margin: 0.5rem 0;
    }
    .p-menubar .p-menubar-root-list .p-submenu-icon {
      font-size: 0.875rem;
    }
    .p-menubar .p-menubar-root-list .p-submenu-icon.p-icon {
      width: 0.875rem;
      height: 0.875rem;
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem {
      width: 100%;
      position: static;
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-menuitem-content {
      color: rgba(255, 255, 255, 0.87);
      transition: box-shadow 0.15s;
      border-radius: 0;
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link {
      color: rgba(255, 255, 255, 0.87);
      padding: 0.75rem 1rem;
      user-select: none;
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
      color: rgba(255, 255, 255, 0.87);
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
      color: rgba(255, 255, 255, 0.6);
      margin-right: 0.5rem;
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
      color: rgba(255, 255, 255, 0.6);
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link.p-highlight &gt; .p-menuitem-content {
      color: rgba(255, 255, 255, 0.87);
      background: #20262e;
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
      color: rgba(255, 255, 255, 0.87);
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
      color: rgba(255, 255, 255, 0.87);
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link.p-highlight.p-focus &gt; .p-menuitem-content {
      background: #20262e;
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content {
      color: rgba(255, 255, 255, 0.87);
      background: rgba(255, 255, 255, 0.12);
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
      color: rgba(255, 255, 255, 0.87);
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
      color: rgba(255, 255, 255, 0.87);
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
      color: rgba(255, 255, 255, 0.87);
      background: rgba(255, 255, 255, 0.04);
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
      color: rgba(255, 255, 255, 0.87);
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
      color: rgba(255, 255, 255, 0.87);
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem &gt; .p-menuitem-link &gt; .p-submenu-icon {
      margin-left: auto;
      transition: transform 0.15s;
    }
    .p-menubar .p-menubar-root-list &gt; .p-menuitem.p-menuitem-active &gt; .p-menuitem-link &gt; .p-submenu-icon {
      transform: rotate(-180deg);
    }
    .p-menubar .p-menubar-root-list .p-submenu-list {
      width: 100%;
      position: static;
      box-shadow: none;
      border: 0 none;
    }
    .p-menubar .p-menubar-root-list .p-submenu-list .p-submenu-icon {
      transition: transform 0.15s;
      transform: rotate(90deg);
    }
    .p-menubar .p-menubar-root-list .p-submenu-list .p-menuitem-active &gt; .p-menuitem-link &gt; .p-submenu-icon {
      transform: rotate(-90deg);
    }
    .p-menubar .p-menubar-root-list .p-menuitem {
      width: 100%;
      position: static;
    }
    .p-menubar .p-menubar-root-list ul li a {
      padding-left: 2.25rem;
    }
    .p-menubar .p-menubar-root-list ul li ul li a {
      padding-left: 3.75rem;
    }
    .p-menubar .p-menubar-root-list ul li ul li ul li a {
      padding-left: 5.25rem;
    }
    .p-menubar .p-menubar-root-list ul li ul li ul li ul li a {
      padding-left: 6.75rem;
    }
    .p-menubar .p-menubar-root-list ul li ul li ul li ul li ul li a {
      padding-left: 8.25rem;
    }
    .p-menubar.p-menubar-mobile-active .p-menubar-root-list {
      display: flex;
      flex-direction: column;
      top: 100%;
      left: 0;
      z-index: 1;
    }
  }
  .p-panelmenu .p-panelmenu-header {
    outline: 0 none;
  }
  .p-panelmenu .p-panelmenu-header .p-panelmenu-header-content {
    border: 1px solid #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    background: #2a323d;
    border-radius: 4px;
    transition: box-shadow 0.15s;
  }
  .p-panelmenu .p-panelmenu-header .p-panelmenu-header-content .p-panelmenu-header-link {
    color: rgba(255, 255, 255, 0.87);
    padding: 1rem 1.25rem;
    font-weight: 600;
  }
  .p-panelmenu .p-panelmenu-header .p-panelmenu-header-content .p-panelmenu-header-link .p-submenu-icon {
    margin-right: 0.5rem;
  }
  .p-panelmenu .p-panelmenu-header .p-panelmenu-header-content .p-panelmenu-header-link .p-menuitem-icon {
    margin-right: 0.5rem;
  }
  .p-panelmenu .p-panelmenu-header:not(.p-disabled):focus-visible .p-panelmenu-header-content {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: inset 0 0 0 1px #e3f3fe;
  }
  .p-panelmenu .p-panelmenu-header:not(.p-highlight):not(.p-disabled):hover .p-panelmenu-header-content {
    background: rgba(255, 255, 255, 0.04);
    border-color: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-panelmenu .p-panelmenu-header:not(.p-disabled).p-highlight .p-panelmenu-header-content {
    background: #2a323d;
    border-color: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
    margin-bottom: 0;
  }
  .p-panelmenu .p-panelmenu-header:not(.p-disabled).p-highlight:hover .p-panelmenu-header-content {
    border-color: #3f4b5b;
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-panelmenu .p-panelmenu-content {
    padding: 0.5rem 0;
    border: 1px solid #3f4b5b;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border-top: 0;
    border-top-right-radius: 0;
    border-top-left-radius: 0;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-panelmenu .p-panelmenu-content .p-panelmenu-root-list {
    outline: 0 none;
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem &gt; .p-menuitem-content .p-menuitem-link {
    color: rgba(255, 255, 255, 0.87);
    padding: 0.75rem 1rem;
    user-select: none;
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-right: 0.5rem;
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem.p-highlight &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: #20262e;
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-panelmenu .p-panelmenu-content .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem.p-highlight.p-focus &gt; .p-menuitem-content {
    background: #20262e;
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.12);
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-panelmenu .p-panelmenu-content .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
  .p-panelmenu .p-panelmenu-content .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    margin-right: 0.5rem;
  }
  .p-panelmenu .p-panelmenu-content .p-menuitem-separator {
    border-top: 1px solid #3f4b5b;
    margin: 0.5rem 0;
  }
  .p-panelmenu .p-panelmenu-content .p-submenu-list:not(.p-panelmenu-root-list) {
    padding: 0 0 0 1rem;
  }
  .p-panelmenu .p-panelmenu-panel {
    margin-bottom: 0;
  }
  .p-panelmenu .p-panelmenu-panel .p-panelmenu-header .p-panelmenu-header-content {
    border-radius: 0;
  }
  .p-panelmenu .p-panelmenu-panel .p-panelmenu-content {
    border-radius: 0;
  }
  .p-panelmenu .p-panelmenu-panel:not(:first-child) .p-panelmenu-header .p-panelmenu-header-content {
    border-top: 0 none;
  }
  .p-panelmenu .p-panelmenu-panel:not(:first-child) .p-panelmenu-header:not(.p-highlight):not(.p-disabled):hover .p-panelmenu-header-content, .p-panelmenu .p-panelmenu-panel:not(:first-child) .p-panelmenu-header:not(.p-disabled).p-highlight:hover .p-panelmenu-header-content {
    border-top: 0 none;
  }
  .p-panelmenu .p-panelmenu-panel:first-child .p-panelmenu-header .p-panelmenu-header-content {
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
  }
  .p-panelmenu .p-panelmenu-panel:last-child .p-panelmenu-header:not(.p-highlight) .p-panelmenu-header-content {
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-panelmenu .p-panelmenu-panel:last-child .p-panelmenu-content {
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-slidemenu {
    padding: 0.5rem 0;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    width: 12.5rem;
  }
  .p-slidemenu .p-menuitem-link &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-slidemenu .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link {
    color: rgba(255, 255, 255, 0.87);
    padding: 0.75rem 1rem;
    user-select: none;
  }
  .p-slidemenu .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-slidemenu .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-right: 0.5rem;
  }
  .p-slidemenu .p-menuitem-link &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-slidemenu .p-menuitem-link.p-highlight &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: #20262e;
  }
  .p-slidemenu .p-menuitem-link.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-slidemenu .p-menuitem-link.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-slidemenu .p-menuitem-link.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-slidemenu .p-menuitem-link.p-highlight.p-focus &gt; .p-menuitem-content {
    background: #20262e;
  }
  .p-slidemenu .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.12);
  }
  .p-slidemenu .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-slidemenu .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-slidemenu .p-menuitem-link:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-slidemenu .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-slidemenu .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-slidemenu .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
  .p-slidemenu .p-menuitem-link:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-slidemenu.p-slidemenu-overlay {
    background: #2a323d;
    border: 1px solid #3f4b5b;
    box-shadow: none;
  }
  .p-slidemenu .p-slidemenu-list {
    padding: 0.5rem 0;
    background: #2a323d;
    border: 1px solid #3f4b5b;
    box-shadow: none;
  }
  .p-slidemenu .p-slidemenu.p-slidemenu-active &gt; .p-slidemenu-link {
    background: #20262e;
  }
  .p-slidemenu .p-slidemenu.p-slidemenu-active &gt; .p-slidemenu-link .p-slidemenu-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-slidemenu .p-slidemenu.p-slidemenu-active &gt; .p-slidemenu-link .p-slidemenu-icon, .p-slidemenu .p-slidemenu.p-slidemenu-active &gt; .p-slidemenu-link .p-slidemenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-slidemenu .p-slidemenu-separator {
    border-top: 1px solid #3f4b5b;
    margin: 0.5rem 0;
  }
  .p-slidemenu .p-slidemenu-icon {
    font-size: 0.875rem;
  }
  .p-slidemenu .p-slidemenu-icon.p-icon {
    width: 0.875rem;
    height: 0.875rem;
  }
  .p-slidemenu .p-slidemenu-backward {
    padding: 0.75rem 1rem;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-steps .p-steps-item .p-menuitem-link {
    background: transparent;
    transition: box-shadow 0.15s;
    border-radius: 4px;
    background: transparent;
  }
  .p-steps .p-steps-item .p-menuitem-link .p-steps-number {
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    background: transparent;
    min-width: 2rem;
    height: 2rem;
    line-height: 2rem;
    font-size: 1.143rem;
    z-index: 1;
    border-radius: 4px;
  }
  .p-steps .p-steps-item .p-menuitem-link .p-steps-title {
    margin-top: 0.5rem;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-steps .p-steps-item .p-menuitem-link:not(.p-disabled):focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-steps .p-steps-item.p-highlight .p-steps-number {
    background: #8dd0ff;
    color: #151515;
  }
  .p-steps .p-steps-item.p-highlight .p-steps-title {
    font-weight: 600;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-steps .p-steps-item:before {
    content: &quot; &quot;;
    border-top: 1px solid #3f4b5b;
    width: 100%;
    top: 50%;
    left: 0;
    display: block;
    position: absolute;
    margin-top: -1rem;
  }
  .p-tabmenu .p-tabmenu-nav {
    background: transparent;
    border: 1px solid #3f4b5b;
    border-width: 0 0 1px 0;
  }
  .p-tabmenu .p-tabmenu-nav .p-tabmenuitem {
    margin-right: 0;
  }
  .p-tabmenu .p-tabmenu-nav .p-tabmenuitem .p-menuitem-link {
    border: solid;
    border-width: 1px;
    border-color: #2a323d #2a323d #3f4b5b #2a323d;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.6);
    padding: 0.75rem 1rem;
    font-weight: 600;
    border-top-right-radius: 4px;
    border-top-left-radius: 4px;
    transition: box-shadow 0.15s;
    margin: 0 0 -1px 0;
    height: calc(100% + 1px);
  }
  .p-tabmenu .p-tabmenu-nav .p-tabmenuitem .p-menuitem-link .p-menuitem-icon {
    margin-right: 0.5rem;
  }
  .p-tabmenu .p-tabmenu-nav .p-tabmenuitem .p-menuitem-link:not(.p-disabled):focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: inset 0 0 0 1px #e3f3fe;
  }
  .p-tabmenu .p-tabmenu-nav .p-tabmenuitem:not(.p-highlight):not(.p-disabled):hover .p-menuitem-link {
    background: #2a323d;
    border-color: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tabmenu .p-tabmenu-nav .p-tabmenuitem.p-highlight .p-menuitem-link {
    background: #2a323d;
    border-color: #3f4b5b #3f4b5b #2a323d #3f4b5b;
    color: rgba(255, 255, 255, 0.6);
  }
  .p-tieredmenu {
    padding: 0.5rem 0;
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    border-radius: 4px;
    width: 12.5rem;
  }
  .p-tieredmenu.p-tieredmenu-overlay {
    background: #2a323d;
    border: 1px solid #3f4b5b;
    box-shadow: none;
  }
  .p-tieredmenu .p-tieredmenu-root-list {
    outline: 0 none;
  }
  .p-tieredmenu .p-submenu-list {
    padding: 0.5rem 0;
    background: #2a323d;
    border: 1px solid #3f4b5b;
    box-shadow: none;
  }
  .p-tieredmenu .p-menuitem &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    transition: box-shadow 0.15s;
    border-radius: 0;
  }
  .p-tieredmenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link {
    color: rgba(255, 255, 255, 0.87);
    padding: 0.75rem 1rem;
    user-select: none;
  }
  .p-tieredmenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tieredmenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon {
    color: rgba(255, 255, 255, 0.6);
    margin-right: 0.5rem;
  }
  .p-tieredmenu .p-menuitem &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.6);
  }
  .p-tieredmenu .p-menuitem.p-highlight &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: #20262e;
  }
  .p-tieredmenu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tieredmenu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-tieredmenu .p-menuitem.p-highlight &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tieredmenu .p-menuitem.p-highlight.p-focus &gt; .p-menuitem-content {
    background: #20262e;
  }
  .p-tieredmenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.12);
  }
  .p-tieredmenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tieredmenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-menuitem-icon,
  .p-tieredmenu .p-menuitem:not(.p-highlight):not(.p-disabled).p-focus &gt; .p-menuitem-content .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tieredmenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover {
    color: rgba(255, 255, 255, 0.87);
    background: rgba(255, 255, 255, 0.04);
  }
  .p-tieredmenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-text {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tieredmenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-menuitem-icon,
  .p-tieredmenu .p-menuitem:not(.p-highlight):not(.p-disabled) &gt; .p-menuitem-content:hover .p-menuitem-link .p-submenu-icon {
    color: rgba(255, 255, 255, 0.87);
  }
  .p-tieredmenu .p-menuitem-separator {
    border-top: 1px solid #3f4b5b;
    margin: 0.5rem 0;
  }
  .p-tieredmenu .p-submenu-icon {
    font-size: 0.875rem;
  }
  .p-tieredmenu .p-submenu-icon.p-icon {
    width: 0.875rem;
    height: 0.875rem;
  }
  .p-inline-message {
    padding: 0.5rem 0.75rem;
    margin: 0;
    border-radius: 4px;
  }
  .p-inline-message.p-inline-message-info {
    background: #cce5ff;
    border: solid #b8daff;
    border-width: 0px;
    color: #004085;
  }
  .p-inline-message.p-inline-message-info .p-inline-message-icon {
    color: #004085;
  }
  .p-inline-message.p-inline-message-success {
    background: #d4edda;
    border: solid #c3e6cb;
    border-width: 0px;
    color: #155724;
  }
  .p-inline-message.p-inline-message-success .p-inline-message-icon {
    color: #155724;
  }
  .p-inline-message.p-inline-message-warn {
    background: #fff3cd;
    border: solid #ffeeba;
    border-width: 0px;
    color: #856404;
  }
  .p-inline-message.p-inline-message-warn .p-inline-message-icon {
    color: #856404;
  }
  .p-inline-message.p-inline-message-error {
    background: #f8d7da;
    border: solid #f5c6cb;
    border-width: 0px;
    color: #721c24;
  }
  .p-inline-message.p-inline-message-error .p-inline-message-icon {
    color: #721c24;
  }
  .p-inline-message .p-inline-message-icon {
    font-size: 1rem;
    margin-right: 0.5rem;
  }
  .p-inline-message .p-inline-message-icon.p-icon {
    width: 1rem;
    height: 1rem;
  }
  .p-inline-message .p-inline-message-text {
    font-size: 1rem;
  }
  .p-inline-message.p-inline-message-icon-only .p-inline-message-icon {
    margin-right: 0;
  }
  .p-message {
    margin: 1rem 0;
    border-radius: 4px;
  }
  .p-message .p-message-wrapper {
    padding: 1rem 1.25rem;
  }
  .p-message .p-message-close {
    width: 2rem;
    height: 2rem;
    border-radius: 50%;
    background: transparent;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-message .p-message-close:hover {
    background: rgba(255, 255, 255, 0.5);
  }
  .p-message .p-message-close:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-message.p-message-info {
    background: #cce5ff;
    border: solid #b8daff;
    border-width: 1px;
    color: #004085;
  }
  .p-message.p-message-info .p-message-icon {
    color: #004085;
  }
  .p-message.p-message-info .p-message-close {
    color: #004085;
  }
  .p-message.p-message-success {
    background: #d4edda;
    border: solid #c3e6cb;
    border-width: 1px;
    color: #155724;
  }
  .p-message.p-message-success .p-message-icon {
    color: #155724;
  }
  .p-message.p-message-success .p-message-close {
    color: #155724;
  }
  .p-message.p-message-warn {
    background: #fff3cd;
    border: solid #ffeeba;
    border-width: 1px;
    color: #856404;
  }
  .p-message.p-message-warn .p-message-icon {
    color: #856404;
  }
  .p-message.p-message-warn .p-message-close {
    color: #856404;
  }
  .p-message.p-message-error {
    background: #f8d7da;
    border: solid #f5c6cb;
    border-width: 1px;
    color: #721c24;
  }
  .p-message.p-message-error .p-message-icon {
    color: #721c24;
  }
  .p-message.p-message-error .p-message-close {
    color: #721c24;
  }
  .p-message .p-message-text {
    font-size: 1rem;
    font-weight: 500;
  }
  .p-message .p-message-icon {
    font-size: 1.5rem;
    margin-right: 0.5rem;
  }
  .p-message .p-message-icon.p-icon {
    width: 1.5rem;
    height: 1.5rem;
  }
  .p-message .p-message-summary {
    font-weight: 700;
  }
  .p-message .p-message-detail {
    margin-left: 0.5rem;
  }
  .p-toast {
    opacity: 1;
  }
  .p-toast .p-toast-message {
    margin: 0 0 1rem 0;
    box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.1);
    border-radius: 4px;
  }
  .p-toast .p-toast-message .p-toast-message-content {
    padding: 1rem;
    border-width: 0;
  }
  .p-toast .p-toast-message .p-toast-message-content .p-toast-message-text {
    margin: 0 0 0 1rem;
  }
  .p-toast .p-toast-message .p-toast-message-content .p-toast-message-icon {
    font-size: 2rem;
  }
  .p-toast .p-toast-message .p-toast-message-content .p-toast-message-icon.p-icon {
    width: 2rem;
    height: 2rem;
  }
  .p-toast .p-toast-message .p-toast-message-content .p-toast-summary {
    font-weight: 700;
  }
  .p-toast .p-toast-message .p-toast-message-content .p-toast-detail {
    margin: 0.5rem 0 0 0;
  }
  .p-toast .p-toast-message .p-toast-icon-close {
    width: 2rem;
    height: 2rem;
    border-radius: 50%;
    background: transparent;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-toast .p-toast-message .p-toast-icon-close:hover {
    background: rgba(255, 255, 255, 0.5);
  }
  .p-toast .p-toast-message .p-toast-icon-close:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-toast .p-toast-message.p-toast-message-info {
    background: #cce5ff;
    border: solid #b8daff;
    border-width: 1px;
    color: #004085;
  }
  .p-toast .p-toast-message.p-toast-message-info .p-toast-message-icon,
  .p-toast .p-toast-message.p-toast-message-info .p-toast-icon-close {
    color: #004085;
  }
  .p-toast .p-toast-message.p-toast-message-success {
    background: #d4edda;
    border: solid #c3e6cb;
    border-width: 1px;
    color: #155724;
  }
  .p-toast .p-toast-message.p-toast-message-success .p-toast-message-icon,
  .p-toast .p-toast-message.p-toast-message-success .p-toast-icon-close {
    color: #155724;
  }
  .p-toast .p-toast-message.p-toast-message-warn {
    background: #fff3cd;
    border: solid #ffeeba;
    border-width: 1px;
    color: #856404;
  }
  .p-toast .p-toast-message.p-toast-message-warn .p-toast-message-icon,
  .p-toast .p-toast-message.p-toast-message-warn .p-toast-icon-close {
    color: #856404;
  }
  .p-toast .p-toast-message.p-toast-message-error {
    background: #f8d7da;
    border: solid #f5c6cb;
    border-width: 1px;
    color: #721c24;
  }
  .p-toast .p-toast-message.p-toast-message-error .p-toast-message-icon,
  .p-toast .p-toast-message.p-toast-message-error .p-toast-icon-close {
    color: #721c24;
  }
  .p-galleria .p-galleria-close {
    margin: 0.5rem;
    background: transparent;
    color: rgba(255, 255, 255, 0.6);
    width: 4rem;
    height: 4rem;
    transition: color 0.15s, box-shadow 0.15s;
    border-radius: 4px;
  }
  .p-galleria .p-galleria-close .p-galleria-close-icon {
    font-size: 2rem;
  }
  .p-galleria .p-galleria-close .p-galleria-close-icon.p-icon {
    width: 2rem;
    height: 2rem;
  }
  .p-galleria .p-galleria-close:hover {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-galleria .p-galleria-item-nav {
    background: transparent;
    color: rgba(255, 255, 255, 0.6);
    width: 4rem;
    height: 4rem;
    transition: color 0.15s, box-shadow 0.15s;
    border-radius: 4px;
    margin: 0 0.5rem;
  }
  .p-galleria .p-galleria-item-nav .p-galleria-item-prev-icon,
  .p-galleria .p-galleria-item-nav .p-galleria-item-next-icon {
    font-size: 2rem;
  }
  .p-galleria .p-galleria-item-nav .p-galleria-item-prev-icon.p-icon,
  .p-galleria .p-galleria-item-nav .p-galleria-item-next-icon.p-icon {
    width: 2rem;
    height: 2rem;
  }
  .p-galleria .p-galleria-item-nav:not(.p-disabled):hover {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.6);
  }
  .p-galleria .p-galleria-caption {
    background: rgba(0, 0, 0, 0.5);
    color: rgba(255, 255, 255, 0.6);
    padding: 1rem;
  }
  .p-galleria .p-galleria-indicators {
    padding: 1rem;
  }
  .p-galleria .p-galleria-indicators .p-galleria-indicator button {
    background-color: #7789a1;
    width: 1rem;
    height: 1rem;
    transition: color 0.15s, box-shadow 0.15s;
    border-radius: 4px;
  }
  .p-galleria .p-galleria-indicators .p-galleria-indicator button:hover {
    background: #687c97;
  }
  .p-galleria .p-galleria-indicators .p-galleria-indicator.p-highlight button {
    background: #8dd0ff;
    color: #151515;
  }
  .p-galleria.p-galleria-indicators-bottom .p-galleria-indicator, .p-galleria.p-galleria-indicators-top .p-galleria-indicator {
    margin-right: 0.5rem;
  }
  .p-galleria.p-galleria-indicators-left .p-galleria-indicator, .p-galleria.p-galleria-indicators-right .p-galleria-indicator {
    margin-bottom: 0.5rem;
  }
  .p-galleria.p-galleria-indicator-onitem .p-galleria-indicators {
    background: rgba(0, 0, 0, 0.5);
  }
  .p-galleria.p-galleria-indicator-onitem .p-galleria-indicators .p-galleria-indicator button {
    background: rgba(255, 255, 255, 0.4);
  }
  .p-galleria.p-galleria-indicator-onitem .p-galleria-indicators .p-galleria-indicator button:hover {
    background: rgba(255, 255, 255, 0.6);
  }
  .p-galleria.p-galleria-indicator-onitem .p-galleria-indicators .p-galleria-indicator.p-highlight button {
    background: #8dd0ff;
    color: #151515;
  }
  .p-galleria .p-galleria-thumbnail-container {
    background: rgba(0, 0, 0, 0.9);
    padding: 1rem 0.25rem;
  }
  .p-galleria .p-galleria-thumbnail-container .p-galleria-thumbnail-prev,
  .p-galleria .p-galleria-thumbnail-container .p-galleria-thumbnail-next {
    margin: 0.5rem;
    background-color: transparent;
    color: rgba(255, 255, 255, 0.6);
    width: 2rem;
    height: 2rem;
    transition: color 0.15s, box-shadow 0.15s;
    border-radius: 4px;
  }
  .p-galleria .p-galleria-thumbnail-container .p-galleria-thumbnail-prev:hover,
  .p-galleria .p-galleria-thumbnail-container .p-galleria-thumbnail-next:hover {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.6);
  }
  .p-galleria .p-galleria-thumbnail-container .p-galleria-thumbnail-item-content {
    transition: box-shadow 0.15s;
  }
  .p-galleria .p-galleria-thumbnail-container .p-galleria-thumbnail-item-content:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-galleria-mask {
    --maskbg: rgba(0, 0, 0, 0.9);
  }
  .p-image-mask {
    --maskbg: rgba(0, 0, 0, 0.9);
  }
  .p-image-preview-indicator {
    background-color: transparent;
    color: #f8f9fa;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-image-preview-indicator .p-icon {
    width: 1.5rem;
    height: 1.5rem;
  }
  .p-image-preview-container:hover &gt; .p-image-preview-indicator {
    background-color: rgba(0, 0, 0, 0.5);
  }
  .p-image-toolbar {
    padding: 1rem;
  }
  .p-image-action.p-link {
    color: #f8f9fa;
    background-color: transparent;
    width: 3rem;
    height: 3rem;
    border-radius: 50%;
    transition: color 0.15s, box-shadow 0.15s;
    margin-right: 0.5rem;
  }
  .p-image-action.p-link:last-child {
    margin-right: 0;
  }
  .p-image-action.p-link:hover {
    color: #f8f9fa;
    background-color: rgba(255, 255, 255, 0.1);
  }
  .p-image-action.p-link span {
    font-size: 1.5rem;
  }
  .p-image-action.p-link .p-icon {
    width: 1.5rem;
    height: 1.5rem;
  }
  .p-avatar {
    background-color: #3f4b5b;
    border-radius: 4px;
  }
  .p-avatar.p-avatar-lg {
    width: 3rem;
    height: 3rem;
    font-size: 1.5rem;
  }
  .p-avatar.p-avatar-lg .p-avatar-icon {
    font-size: 1.5rem;
  }
  .p-avatar.p-avatar-xl {
    width: 4rem;
    height: 4rem;
    font-size: 2rem;
  }
  .p-avatar.p-avatar-xl .p-avatar-icon {
    font-size: 2rem;
  }
  .p-avatar-circle {
    border-radius: 50%;
  }
  .p-avatar-group .p-avatar {
    border: 2px solid #2a323d;
  }
  .p-chip {
    background-color: #3f4b5b;
    color: rgba(255, 255, 255, 0.87);
    border-radius: 16px;
    padding: 0 0.75rem;
  }
  .p-chip .p-chip-text {
    line-height: 1.5;
    margin-top: 0.25rem;
    margin-bottom: 0.25rem;
  }
  .p-chip .p-chip-icon {
    margin-right: 0.5rem;
  }
  .p-chip img {
    width: 2rem;
    height: 2rem;
    margin-left: -0.75rem;
    margin-right: 0.5rem;
  }
  .p-chip .p-chip-remove-icon {
    border-radius: 4px;
    transition: color 0.15s, box-shadow 0.15s;
    margin-left: 0.5rem;
  }
  .p-chip .p-chip-remove-icon:focus-visible {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-chip .p-chip-remove-icon:focus {
    outline: 0 none;
  }
  .p-scrolltop {
    width: 3rem;
    height: 3rem;
    border-radius: 4px;
    box-shadow: none;
    transition: color 0.15s, box-shadow 0.15s;
  }
  .p-scrolltop.p-link {
    background: #8dd0ff;
  }
  .p-scrolltop.p-link:hover {
    background: #56bdff;
  }
  .p-scrolltop .p-scrolltop-icon {
    font-size: 1.5rem;
    color: #151515;
  }
  .p-scrolltop .p-scrolltop-icon.p-icon {
    width: 1.5rem;
    height: 1.5rem;
  }
  .p-skeleton {
    background-color: rgba(255, 255, 255, 0.06);
    border-radius: 4px;
  }
  .p-skeleton:after {
    background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0));
  }
  .p-tag {
    background: #8dd0ff;
    color: #151515;
    font-size: 0.75rem;
    font-weight: 700;
    padding: 0.25rem 0.4rem;
    border-radius: 4px;
  }
  .p-tag.p-tag-success {
    background-color: #9fdaa8;
    color: #151515;
  }
  .p-tag.p-tag-info {
    background-color: #7fd8e6;
    color: #151515;
  }
  .p-tag.p-tag-warning {
    background-color: #ffe082;
    color: #151515;
  }
  .p-tag.p-tag-danger {
    background-color: #f19ea6;
    color: #151515;
  }
  .p-tag .p-tag-icon {
    margin-right: 0.25rem;
    font-size: 0.75rem;
  }
  .p-tag .p-tag-icon.p-icon {
    width: 0.75rem;
    height: 0.75rem;
  }
  .p-inplace .p-inplace-display {
    padding: 0.5rem 0.75rem;
    border-radius: 4px;
    transition: background-color 0.15s, border-color 0.15s, box-shadow 0.15s;
  }
  .p-inplace .p-inplace-display:not(.p-disabled):hover {
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.87);
  }
  .p-inplace .p-inplace-display:focus {
    outline: 0 none;
    outline-offset: 0;
    box-shadow: 0 0 0 1px #e3f3fe;
  }
  .p-metergroup .p-metergroup-meter-container {
    background: #3f4b5b;
    border-radius: 4px;
  }
  .p-metergroup .p-metergroup-meter {
    border: 0 none;
    background: #8dd0ff;
  }
  .p-metergroup .p-metergroup-label-list .p-metergroup-label-list-item {
    line-height: 1.5rem;
  }
  .p-metergroup .p-metergroup-label-list .p-metergroup-label-type {
    background: #8dd0ff;
    width: 0.5rem;
    height: 0.5rem;
    border-radius: 100%;
    margin-right: 0.5rem;
  }
  .p-metergroup .p-metergroup-label-list .p-metergroup-label {
    margin-right: 1rem;
  }
  .p-metergroup .p-metergroup-label-list .p-metergroup-label-icon {
    width: 1rem;
    height: 1rem;
    margin-right: 0.5rem;
  }
  .p-metergroup.p-metergroup-horizontal .p-metergroup-meter-container {
    height: 0.5rem;
  }
  .p-metergroup.p-metergroup-horizontal .p-metergroup-meter:first-of-type {
    border-top-left-radius: 4px;
    border-bottom-left-radius: 4px;
  }
  .p-metergroup.p-metergroup-horizontal .p-metergroup-meter:last-of-type {
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
  }
  .p-metergroup.p-metergroup-horizontal .p-metergroup-label-list-start {
    margin-bottom: 1rem;
  }
  .p-metergroup.p-metergroup-horizontal .p-metergroup-label-list-end {
    margin-top: 1rem;
  }
  .p-metergroup.p-metergroup-vertical .p-metergroup-meter-container {
    width: 0.5rem;
    height: 100%;
  }
  .p-metergroup.p-metergroup-vertical .p-metergroup-meter:first-of-type {
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
  }
  .p-metergroup.p-metergroup-vertical .p-metergroup-meter:last-of-type {
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
  }
  .p-metergroup.p-metergroup-vertical .p-metergroup-label-list:not(.p-metergroup-label-list-start) {
    margin-left: 1rem;
  }
  .p-progressbar {
    border: 0 none;
    height: 1.5rem;
    background: #3f4b5b;
    border-radius: 4px;
  }
  .p-progressbar .p-progressbar-value {
    border: 0 none;
    margin: 0;
    background: #8dd0ff;
  }
  .p-progressbar .p-progressbar-label {
    color: #151515;
    line-height: 1.5rem;
  }
  .p-terminal {
    background: #2a323d;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid #3f4b5b;
    padding: 1.25rem;
  }
  .p-terminal .p-terminal-input {
    font-family: var(--font-family);
    font-feature-settings: var(--font-feature-settings, normal);
    font-size: 1rem;
  }
  .p-badge {
    background: #8dd0ff;
    color: #151515;
    font-size: 0.75rem;
    font-weight: 700;
    min-width: 1.5rem;
    height: 1.5rem;
    line-height: 1.5rem;
  }
  .p-badge.p-badge-secondary {
    background-color: #6c757d;
    color: #ffffff;
  }
  .p-badge.p-badge-success {
    background-color: #9fdaa8;
    color: #151515;
  }
  .p-badge.p-badge-info {
    background-color: #7fd8e6;
    color: #151515;
  }
  .p-badge.p-badge-warning {
    background-color: #ffe082;
    color: #151515;
  }
  .p-badge.p-badge-danger {
    background-color: #f19ea6;
    color: #151515;
  }
  .p-badge.p-badge-lg {
    font-size: 1.125rem;
    min-width: 2.25rem;
    height: 2.25rem;
    line-height: 2.25rem;
  }
  .p-badge.p-badge-xl {
    font-size: 1.5rem;
    min-width: 3rem;
    height: 3rem;
    line-height: 3rem;
  }
  .p-tag {
    background: #8dd0ff;
    color: #151515;
    font-size: 0.75rem;
    font-weight: 700;
    padding: 0.25rem 0.4rem;
    border-radius: 4px;
  }
  .p-tag.p-tag-success {
    background-color: #9fdaa8;
    color: #151515;
  }
  .p-tag.p-tag-info {
    background-color: #7fd8e6;
    color: #151515;
  }
  .p-tag.p-tag-warning {
    background-color: #ffe082;
    color: #151515;
  }
  .p-tag.p-tag-danger {
    background-color: #f19ea6;
    color: #151515;
  }
}
/* Vendor extensions to the designer enhanced bootstrap compatibility */
@layer primereact {
  .p-breadcrumb .p-breadcrumb-chevron {
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;
  }
  .p-breadcrumb .p-breadcrumb-chevron:before {
    content: &quot;/&quot;;
  }
}
/* Customizations to the designer theme should be defined here */</file><file path="assets/js/hooks/Mapper/common-styles/context-menu.scss">.p-menuitem:not(:last-child) {
  //border-bottom: 1px solid #a1a1a13d;
}</file><file path="assets/js/hooks/Mapper/common-styles/custom-scrollbar.scss">.custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.5) transparent;
}

.custom-scrollbar::-webkit-scrollbar {
  width: 10px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background-color: rgba(255, 255, 255, 0.5);
  border-radius: 5px;
  border: 2px solid transparent;
  background-clip: content-box;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background-color: rgba(255, 255, 255, 0.7);
}

.custom-scrollbar::-webkit-scrollbar-button {
  display: none;
  height: 0;
  width: 0;
}</file><file path="assets/js/hooks/Mapper/common-styles/fixes.scss">/* TODO all of this styles need for fixing
     problems with PrimeFlex because of tailwind broke them

     IMPORTANT: here should not be set any design - only original PrimeFlex behaviour
     e.g. paddings, margins, positions and other.
*/

.p-virtualscroller {
  position: relative;

  .p-virtualscroller-spacer {
    position: absolute;
    pointer-events: none;
    top: 0;
    width: 100%;
  }
}

.p-tooltip {
  position: absolute;
}

.p-menuitem, .p-menuitem-content {
  height: 36px;
  flex-grow: 1;
}

.p-menuitem &gt; .p-menuitem-content &gt; a {
  width: 100%;
  height: 100%;

  display: flex;
  align-items: center;
  justify-content: flex-start;

  padding: 0 12px;
}

.p-contextmenu .p-menuitem {
  position: relative;
}

.p-contextmenu .p-submenu-list {
  position: absolute;
  min-width: 100%;
  z-index: 1;
}

.p-contextmenu .p-menuitem-link .p-submenu-icon {
  margin-left: auto;
}

.p-contextmenu .p-submenu-list {
  padding: 0.5rem 0;
  //border: 0 none;
  border-radius: 6px;
  //border: 1px solid #383838;
}

.p-icon-field {
  .p-inputtext {
    width: 100%;
  }

  .p-input-icon {
    right: 0.75rem;
  }
}

.p-datatable-thead {
  th, th.p-sortable-column {
    font-size: 12px;
    font-weight: bold;
    padding: 3px 4px;
  }
}

.p-selectable-row td {
  padding: 4px 4px;
}

.p-datatable.p-datatable-sm .p-datatable-tbody &gt; tr &gt; td {
  padding: 3px 4px;
}

.p-sortable-column &gt; .p-column-header-content &gt; span:last-child {
  transform: scale(0.7);

  &amp; &gt; svg {
    margin-left: 4px;
  }
}

.p-dropdown-label, .p-inputtext {
  padding: 0.25rem 0.75rem;
  font-size: 14px;
}

.p-dropdown-item {
  padding: 0.25rem 0.5rem;
  font-size: 14px;
  width: 100%;

  .p-dropdown-item-label {
    width: 100%;
  }
}

.p-dropdown-item-group {
  padding: 0.25rem 0.75rem;
  font-size: 14px;
}

.p-dropdown-trigger {
  width: 14px;
  margin: 0 12px;
}

.p-dropdown-empty-message {
  padding: 0.25rem 0.5rem;
}

.p-autocomplete .p-autocomplete-multiple-container .p-autocomplete-token {
  margin-right: 0 !important;
}

/* Fixed sizes of Input switch */
.p-inputswitch {
  width: 2.0rem;
  height: 1.15rem;

  .p-inputswitch-slider:before {
    width: 0.8rem;
    height: 0.8rem;
    left: 0.14rem;
    margin-top: -0.385rem;
  }

  &amp;.p-highlight .p-inputswitch-slider:before {
    transform: translateX(0.8rem);
  }

  &amp;:not(.p-disabled):has(.p-inputswitch-input:hover) .p-inputswitch-slider {
    background: rgb(255 255 255 / 21%);
  }

  &amp;.p-highlight .p-inputswitch-slider {
    background: #966d3d;
  }
}

.p-datatable-wrapper {
  height: 100%;
  &amp; {
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.5) transparent;
  }

  &amp;::-webkit-scrollbar {
    width: 10px;
  }

  &amp;::-webkit-scrollbar-track {
    background: transparent;
  }

  &amp;::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.5);
    border-radius: 5px;
    border: 2px solid transparent;
    background-clip: content-box;
  }

  &amp;::-webkit-scrollbar-thumb:hover {
    background-color: rgba(255, 255, 255, 0.7);
  }

  &amp;::-webkit-scrollbar-button {
    display: none;
    height: 0;
    width: 0;
  }
}

.p-datatable .p-datatable-tbody &gt; tr.p-highlight {
  background: initial;
}

.suppress-menu-behaviour {
  pointer-events: none;

  .p-menuitem-content {
    pointer-events: initial;
    background-color: initial !important;
  }
  .p-menuitem-content:hover {
    background-color: initial !important;
  }
}</file><file path="assets/js/hooks/Mapper/common-styles/main.scss">// import &apos;./tailwind.css&apos;;
//@import &apos;primereact/resources/themes/bootstrap4-dark-blue/theme.css&apos;;
//@import &apos;primereact/resources/themes/lara-dark-purple/theme.css&apos;;
//@import &quot;prime-fixes&quot;;
@import &apos;primereact/resources/primereact.min.css&apos;;
//@import &apos;primeflex/primeflex.css&apos;;
@import &apos;primeicons/primeicons.css&apos;;
//@import &apos;primereact/resources/primereact.css&apos;;


@import &quot;fixes&quot;;
@import &quot;prime-fixes&quot;;
@import &quot;custom-scrollbar&quot;;
@import &quot;tooltip&quot;;
@import &quot;context-menu&quot;;


.fixedImportant {
  position: fixed !important;
}</file><file path="assets/js/hooks/Mapper/common-styles/tooltip.scss">.p-tooltip {
  opacity: 0;
  transition: opacity 0.3s ease-in-out;

  &amp; &gt; .p-tooltip-text {
    background-color: initial;
  }
}

.p-tooltip.p-tooltip-active {
  opacity: 1;
}</file><file path="assets/js/hooks/Mapper/components/characters/Characters.module.scss">.Docked {
  content: &quot; &quot;;
  display: inline-block;
  width: 11px;
  height: 11px;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  position: absolute;
  z-index: 1;
  overflow: hidden;
  border-radius: 1px;

  background-image: url(/images/citadelLarge.png);
  left: 2px;
  top: 22px;
  transform: rotateZ(0deg);
}</file><file path="assets/js/hooks/Mapper/components/characters/Characters.tsx">import { useCallback } from &apos;react&apos;;
import clsx from &apos;clsx&apos;;
import { useAutoAnimate } from &apos;@formkit/auto-animate/react&apos;;
import { Commands } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { CharacterTypeRaw } from &apos;@/hooks/Mapper/types&apos;;
import { emitMapEvent } from &apos;@/hooks/Mapper/events&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import classes from &apos;./Characters.module.scss&apos;;
import { isDocked } from &apos;@/hooks/Mapper/helpers/isDocked.ts&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;

interface CharactersProps {
  data: CharacterTypeRaw[];
}

export const Characters = ({ data }: CharactersProps) =&gt; {
  const [parent] = useAutoAnimate();

  const {
    data: { mainCharacterEveId, followingCharacterEveId },
  } = useMapRootState();

  const handleSelect = useCallback((character: CharacterTypeRaw) =&gt; {
    emitMapEvent({
      name: Commands.centerSystem,
      data: character?.location?.solar_system_id?.toString(),
    });
  }, []);

  const items = data.map(character =&gt; (
    &lt;li
      key={character.eve_id}
      className=&quot;flex flex-col items-center justify-center&quot;
      onClick={() =&gt; handleSelect(character)}
    &gt;
      &lt;div
        className={clsx(
          &apos;overflow-hidden relative&apos;,
          &apos;flex w-[35px] h-[35px] rounded-[4px] border-[1px] border-solid bg-transparent cursor-pointer&apos;,
          &apos;transition-colors duration-250&apos;,
          {
            [&apos;border-stone-800/90&apos;]: !character.online,
            [&apos;border-lime-600/70&apos;]: character.online,
          },
        )}
        title={character.name}
      &gt;
        {mainCharacterEveId === character.eve_id &amp;&amp; (
          &lt;span
            className={clsx(
              &apos;absolute top-[2px] left-[22px] w-[9px] h-[9px]&apos;,
              &apos;text-yellow-500 text-[9px] rounded-[1px] z-10&apos;,
              &apos;pi&apos;,
              PrimeIcons.STAR_FILL,
            )}
          /&gt;
        )}
        {followingCharacterEveId === character.eve_id &amp;&amp; (
          &lt;span
            className={clsx(
              &apos;absolute top-[23px] left-[22px] w-[10px] h-[10px]&apos;,
              &apos;text-sky-300 text-[10px] rounded-[1px] z-10&apos;,
              &apos;pi pi-angle-double-right&apos;,
            )}
          /&gt;
        )}
        {isDocked(character.location) &amp;&amp; &lt;div className={classes.Docked} /&gt;}
        &lt;div
          className={clsx(
            &apos;flex w-full h-full bg-transparent cursor-pointer&apos;,
            &apos;bg-center bg-no-repeat bg-[length:100%]&apos;,
            &apos;transition-opacity&apos;,
            &apos;shadow-[inset_0_1px_6px_1px_#000000]&apos;,
            {
              [&apos;opacity-60&apos;]: !character.online,
              [&apos;opacity-100&apos;]: character.online,
            },
          )}
          style={{ backgroundImage: `url(https://images.evetech.net/characters/${character.eve_id}/portrait)` }}
        &gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/li&gt;
  ));

  return (
    &lt;ul className=&quot;flex gap-1 characters&quot; id=&quot;characters&quot; ref={parent}&gt;
      {items}
    &lt;/ul&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/contexts/components/FastSystemActions/FastSystemActions.module.scss">.Links {
  &amp; &gt; * {
    opacity: 1 !important;
  }
}</file><file path="assets/js/hooks/Mapper/components/contexts/components/FastSystemActions/FastSystemActions.tsx">import { useCallback, useRef } from &apos;react&apos;;
import { LayoutEventBlocker, WdImageSize, WdImgButton } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { ANOIK_ICON, DOTLAN_ICON, ZKB_ICON } from &apos;@/hooks/Mapper/icons&apos;;

import classes from &apos;./FastSystemActions.module.scss&apos;;
import clsx from &apos;clsx&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;

export interface FastSystemActionsProps {
  systemId: string;
  systemName: string;
  regionName: string;
  isWH: boolean;
  showEdit?: boolean;
  onOpenSettings(): void;
}

export const FastSystemActions = ({
  systemId,
  systemName,
  regionName,
  isWH,
  onOpenSettings,
  showEdit,
}: FastSystemActionsProps) =&gt; {
  const ref = useRef({ systemId, systemName, regionName, isWH });
  ref.current = { systemId, systemName, regionName, isWH };

  const handleOpenZKB = useCallback(
    () =&gt; window.open(`https://zkillboard.com/system/${ref.current.systemId}`, &apos;_blank&apos;),
    [],
  );

  const handleOpenAnoikis = useCallback(
    () =&gt; window.open(`http://anoik.is/systems/${ref.current.systemName}`, &apos;_blank&apos;),
    [],
  );

  const handleOpenDotlan = useCallback(() =&gt; {
    if (ref.current.isWH) {
      window.open(`https://evemaps.dotlan.net/system/${ref.current.systemName}`, &apos;_blank&apos;);
      return;
    }

    return window.open(
      `https://evemaps.dotlan.net/map/${ref.current.regionName.replace(/ /gim, &apos;_&apos;)}/${ref.current.systemName}#jumps`,
      &apos;_blank&apos;,
    );
  }, []);

  const copySystemNameToClipboard = useCallback(async () =&gt; {
    try {
      await navigator.clipboard.writeText(ref.current.systemName);
    } catch (err) {
      console.error(err);
    }
  }, []);

  return (
    &lt;LayoutEventBlocker className={clsx(&apos;flex px-2 gap-2 justify-between items-center h-full&apos;)}&gt;
      &lt;div className={clsx(&apos;flex gap-2 items-center h-full&apos;, classes.Links)}&gt;
        &lt;WdImgButton tooltip={{ content: &apos;Open zkillboard&apos; }} source={ZKB_ICON} onClick={handleOpenZKB} /&gt;
        &lt;WdImgButton tooltip={{ content: &apos;Open Anoikis&apos; }} source={ANOIK_ICON} onClick={handleOpenAnoikis} /&gt;
        &lt;WdImgButton tooltip={{ content: &apos;Open Dotlan&apos; }} source={DOTLAN_ICON} onClick={handleOpenDotlan} /&gt;
      &lt;/div&gt;

      &lt;div className=&quot;flex gap-2 items-center pl-1&quot;&gt;
        &lt;WdImgButton
          textSize={WdImageSize.off}
          className={PrimeIcons.COPY}
          onClick={copySystemNameToClipboard}
          tooltip={{ content: &apos;Copy system name&apos; }}
        /&gt;
        {showEdit &amp;&amp; (
          &lt;WdImgButton
            textSize={WdImageSize.off}
            className=&quot;pi pi-pen-to-square text-base&quot;
            onClick={onOpenSettings}
            tooltip={{ content: &apos;Edit system name and description&apos; }}
          /&gt;
        )}
      &lt;/div&gt;
    &lt;/LayoutEventBlocker&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/contexts/components/FastSystemActions/index.ts">export * from &apos;./FastSystemActions&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/components/index.ts">export * from &apos;./FastSystemActions&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/hooks/useLabelsMenu/index.ts">export * from &apos;./useLabelsMenu.ts&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/hooks/useLabelsMenu/useLabelsMenu.ts">import { MenuItem } from &apos;primereact/menuitem&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { SolarSystemRawType } from &apos;@/hooks/Mapper/types&apos;;
import { getSystemById } from &apos;@/hooks/Mapper/helpers&apos;;
import clsx from &apos;clsx&apos;;
import { LABELS, LABELS_INFO, LABELS_ORDER } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { GRADIENT_MENU_ACTIVE_CLASSES } from &apos;@/hooks/Mapper/constants.ts&apos;;
import { LabelsManager } from &apos;@/hooks/Mapper/utils/labelsManager.ts&apos;;

export const getLabels = (labels: string | null) =&gt; (labels ? (labels ?? &apos;&apos;).split(&apos;,&apos;) : []);
export const updateLabels = (labels: string | null, label: string) =&gt; {
  const parsedLabels = new Set(getLabels(labels));

  if (parsedLabels.has(label)) {
    parsedLabels.delete(label);
  } else {
    parsedLabels.add(label);
  }

  return [...parsedLabels].join(&apos;,&apos;);
};

export const useLabelsMenu = (
  systems: SolarSystemRawType[],
  systemId: string | undefined,
  onSystemLabels: (val: string) =&gt; void,
  onCustomLabelDialog: () =&gt; void,
): (() =&gt; MenuItem[]) =&gt; {
  const ref = useRef({ onSystemLabels, systemId, systems, onCustomLabelDialog });
  ref.current = { onSystemLabels, systemId, systems, onCustomLabelDialog };

  return useCallback(() =&gt; {
    const { onSystemLabels, systemId, systems, onCustomLabelDialog } = ref.current;
    const system = systemId ? getSystemById(systems, systemId) : undefined;
    const labels = new LabelsManager(system?.labels ?? &apos;&apos;);

    if (!system) {
      return [
        {
          label: &apos;Labels&apos;,
          icon: PrimeIcons.BOLT,
          items: [],
        },
      ];
    }

    // const labels = getLabels(system.labels);
    const hasLabels = labels?.list?.length &gt; 0;
    const statusList = hasLabels ? LABELS_ORDER : LABELS_ORDER.slice(1);

    return [
      {
        label: &apos;Labels&apos;,
        icon: PrimeIcons.BOOKMARK,
        className: clsx({ [GRADIENT_MENU_ACTIVE_CLASSES]: hasLabels }),
        items: [
          ...(labels.customLabel.length &gt; 0
            ? [
                {
                  label: &apos;Clear custom label&apos;,
                  icon: &apos;pi pi-trash&apos;,
                  command: () =&gt; {
                    labels.updateCustomLabel(&apos;&apos;);
                    onSystemLabels(labels.toString());
                  },
                },
              ]
            : []),
          {
            label: &apos;Custom label&apos;,
            icon: &apos;pi pi-language&apos;,
            command: onCustomLabelDialog,
          },
          { separator: true },
          ...statusList.map(x =&gt; ({
            label: LABELS_INFO[x].name,
            icon: x === LABELS.clear ? PrimeIcons.TRASH : PrimeIcons.BOOKMARK,
            command: () =&gt; {
              if (x === LABELS.clear) {
                labels.clearLabels();
                onSystemLabels(labels.toString());
                return;
              }

              labels.toggleLabel(x);
              onSystemLabels(labels.toString());
            },
            className: clsx({ [GRADIENT_MENU_ACTIVE_CLASSES]: labels.hasLabel(x) }),
          })),
        ],
      },
    ];
  }, []);
};</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/hooks/useStatusMenu/index.ts">export * from &apos;./useStatusMenu.ts&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/hooks/useStatusMenu/useStatusMenu.ts">import { MenuItem } from &apos;primereact/menuitem&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { SolarSystemRawType } from &apos;@/hooks/Mapper/types&apos;;
import { getSystemById } from &apos;@/hooks/Mapper/helpers&apos;;
import clsx from &apos;clsx&apos;;
import { STATUS_COLOR_CLASSES, STATUS_NAMES, STATUSES_ORDER } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { GRADIENT_MENU_ACTIVE_CLASSES } from &apos;@/hooks/Mapper/constants.ts&apos;;

export const useStatusMenu = (
  systems: SolarSystemRawType[],
  systemId: string | undefined,
  onSystemStatus: (val: number) =&gt; void,
): (() =&gt; MenuItem) =&gt; {
  const ref = useRef({ onSystemStatus, systemId, systems });
  ref.current = { onSystemStatus, systemId, systems };

  return useCallback(() =&gt; {
    const { onSystemStatus, systemId, systems } = ref.current;
    const system = systemId ? getSystemById(systems, systemId) : undefined;

    if (!system) {
      return {
        label: &apos;Status&apos;,
        icon: PrimeIcons.BOLT,
        items: [],
      };
    }

    const isSelectedStatus = system.status;
    const statusList = system.status ? STATUSES_ORDER : STATUSES_ORDER.slice(1);

    const menuItem: MenuItem = {
      label: &apos;Status&apos;,
      icon: PrimeIcons.BOLT,
      className: clsx({ [GRADIENT_MENU_ACTIVE_CLASSES]: isSelectedStatus }),
      items: statusList.map(x =&gt; ({
        label: STATUS_NAMES[x],
        icon: x !== 0 ? `${PrimeIcons.BOLT} ${STATUS_COLOR_CLASSES[x]}` : PrimeIcons.BAN,
        command: () =&gt; onSystemStatus(x),
        className: clsx({ [GRADIENT_MENU_ACTIVE_CLASSES]: x === system.status }),
      })),
    };

    return menuItem;
  }, []);
};</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/hooks/useTagMenu/index.ts">export * from &apos;./useTagMenu.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/hooks/useTagMenu/useTagMenu.tsx">import { MenuItem } from &apos;primereact/menuitem&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { SolarSystemRawType } from &apos;@/hooks/Mapper/types&apos;;
import { getSystemById } from &apos;@/hooks/Mapper/helpers&apos;;
import clsx from &apos;clsx&apos;;
import { GRADIENT_MENU_ACTIVE_CLASSES } from &apos;@/hooks/Mapper/constants.ts&apos;;
import { LayoutEventBlocker } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { Button } from &apos;primereact/button&apos;;

const AVAILABLE_TAGS = [
  &apos;A&apos;,
  &apos;B&apos;,
  &apos;C&apos;,
  &apos;D&apos;,
  &apos;E&apos;,
  &apos;F&apos;,
  &apos;G&apos;,
  &apos;H&apos;,
  &apos;I&apos;,
  &apos;X&apos;,
  &apos;Y&apos;,
  &apos;Z&apos;,
  &apos;0&apos;,
  &apos;1&apos;,
  &apos;2&apos;,
  &apos;3&apos;,
  &apos;4&apos;,
  &apos;5&apos;,
  &apos;6&apos;,
  &apos;7&apos;,
  &apos;8&apos;,
  &apos;9&apos;,
];

export const useTagMenu = (
  systems: SolarSystemRawType[],
  systemId: string | undefined,
  onSystemTag: (val?: string) =&gt; void,
): (() =&gt; MenuItem) =&gt; {
  const ref = useRef({ onSystemTag, systems, systemId });
  ref.current = { onSystemTag, systems, systemId };

  return useCallback(() =&gt; {
    const { onSystemTag, systemId, systems } = ref.current;
    const system = systemId ? getSystemById(systems, systemId) : undefined;

    const isSelectedTag = AVAILABLE_TAGS.includes(system?.tag ?? &apos;&apos;);

    const menuItem: MenuItem = {
      label: &apos;Tag&apos;,
      icon: PrimeIcons.HASHTAG,
      className: clsx({ [GRADIENT_MENU_ACTIVE_CLASSES]: isSelectedTag }),
      items: [
        {
          label: &apos;Digit&apos;,
          icon: PrimeIcons.TAGS,
          className: &apos;!h-[128px] suppress-menu-behaviour&apos;,
          template: () =&gt; {
            return (
              &lt;LayoutEventBlocker className=&quot;flex flex-col gap-1 w-[200px] h-full px-2&quot;&gt;
                &lt;div className=&quot;grid grid-cols-[auto_auto_auto_auto_auto_auto] gap-1&quot;&gt;
                  {AVAILABLE_TAGS.map(x =&gt; (
                    &lt;Button
                      outlined={system?.tag !== x}
                      severity=&quot;warning&quot;
                      key={x}
                      value={x}
                      size=&quot;small&quot;
                      className=&quot;p-[3px] justify-center&quot;
                      onClick={() =&gt; system?.tag !== x &amp;&amp; onSystemTag(x)}
                    &gt;
                      {x}
                    &lt;/Button&gt;
                  ))}
                  &lt;Button
                    disabled={!isSelectedTag}
                    icon=&quot;pi pi-ban&quot;
                    size=&quot;small&quot;
                    className=&quot;!p-0 !w-[initial] justify-center&quot;
                    outlined
                    severity=&quot;help&quot;
                    onClick={() =&gt; onSystemTag()}
                  &gt;&lt;/Button&gt;
                &lt;/div&gt;
              &lt;/LayoutEventBlocker&gt;
            );
          },
        },
      ],
    };

    return menuItem;
  }, []);
};</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/hooks/index.ts">export * from &apos;./useTagMenu&apos;;
export * from &apos;./useStatusMenu&apos;;
export * from &apos;./useLabelsMenu&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/constants.ts">export const GRADIENT_MENU_ACTIVE_CLASSES = &apos;bg-gradient-to-br from-transparent/10 to-fuchsia-300/10&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/ContextMenuSystem.module.scss">.FastActions {
  :global {
    .p-menuitem-content {
      background-color: initial !important;
    }
    .p-menuitem-content:hover {
      background-color: initial !important;
    }
  }
}</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/ContextMenuSystem.tsx">import React, { RefObject } from &apos;react&apos;;
import { ContextMenu } from &apos;primereact/contextmenu&apos;;
import { SolarSystemRawType } from &apos;@/hooks/Mapper/types&apos;;
import { useContextMenuSystemItems } from &apos;@/hooks/Mapper/components/contexts/ContextMenuSystem/useContextMenuSystemItems.tsx&apos;;
import { WaypointSetContextHandler } from &apos;@/hooks/Mapper/components/contexts/types.ts&apos;;

export interface ContextMenuSystemProps {
  hubs: string[];
  userHubs: string[];
  contextMenuRef: RefObject&lt;ContextMenu&gt;;
  systemId: string | undefined;
  systems: SolarSystemRawType[];
  onDeleteSystem(): void;
  onLockToggle(): void;
  onOpenSettings(): void;
  onHubToggle(): void;
  onUserHubToggle(): void;
  onSystemTag(val?: string): void;
  onSystemStatus(val: number): void;
  onSystemLabels(val: string): void;
  onCustomLabelDialog(): void;
  onWaypointSet: WaypointSetContextHandler;
}

export const ContextMenuSystem: React.FC&lt;ContextMenuSystemProps&gt; = ({ contextMenuRef, ...props }) =&gt; {
  const items = useContextMenuSystemItems(props);

  return (
    &lt;&gt;
      &lt;ContextMenu className=&quot;min-w-[200px]&quot; model={items} ref={contextMenuRef} breakpoint=&quot;767px&quot; /&gt;
    &lt;/&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/index.ts">export * from &apos;./ContextMenuSystem&apos;;
export * from &apos;./useContextMenuSystemHandlers&apos;;
export * from &apos;./useContextMenuSystemItems&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/useContextMenuSystemHandlers.ts">import { useCallback, useRef, useState } from &apos;react&apos;;
import { ContextMenu } from &apos;primereact/contextmenu&apos;;
import { OutCommand, OutCommandHandler } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { SolarSystemRawType } from &apos;@/hooks/Mapper/types&apos;;
import { WaypointSetContextHandler } from &apos;@/hooks/Mapper/components/contexts/types.ts&apos;;
import { ctxManager } from &apos;@/hooks/Mapper/utils/contextManager.ts&apos;;
import { useDeleteSystems } from &apos;@/hooks/Mapper/components/contexts/hooks&apos;;

interface UseContextMenuSystemHandlersProps {
  hubs: string[];
  userHubs: string[];
  systems: SolarSystemRawType[];
  outCommand: OutCommandHandler;
}

export const useContextMenuSystemHandlers = ({
  systems,
  hubs,
  userHubs,
  outCommand,
}: UseContextMenuSystemHandlersProps) =&gt; {
  const contextMenuRef = useRef&lt;ContextMenu | null&gt;(null);

  const [system, setSystem] = useState&lt;string&gt;();

  const { deleteSystems } = useDeleteSystems();

  const ref = useRef({ hubs, userHubs, system, systems, outCommand, deleteSystems });
  ref.current = { hubs, userHubs, system, systems, outCommand, deleteSystems };

  const open = useCallback((ev: any, systemId: string) =&gt; {
    setSystem(systemId);
    ev.preventDefault();
    ctxManager.next(&apos;ctxSys&apos;, contextMenuRef.current);
    contextMenuRef.current?.show(ev);
  }, []);

  const onDeleteSystem = useCallback(() =&gt; {
    const { system, deleteSystems } = ref.current;
    if (!system) {
      return;
    }

    deleteSystems([system]);
    setSystem(undefined);
  }, []);

  const onLockToggle = useCallback(() =&gt; {
    const { system, systems, outCommand } = ref.current;
    if (!system) {
      return;
    }

    const sysInfo = systems.find(x =&gt; x.id === system)!;

    outCommand({
      type: OutCommand.updateSystemLocked,
      data: {
        system_id: system,
        value: !sysInfo.locked,
      },
    });
    setSystem(undefined);
  }, []);

  const onHubToggle = useCallback(() =&gt; {
    const { hubs, system, outCommand } = ref.current;
    if (!system) {
      return;
    }

    outCommand({
      type: !hubs.includes(system) ? OutCommand.addHub : OutCommand.deleteHub,
      data: {
        system_id: system,
      },
    });
    setSystem(undefined);
  }, []);

  const onUserHubToggle = useCallback(() =&gt; {
    const { userHubs, system, outCommand } = ref.current;
    if (!system) {
      return;
    }

    outCommand({
      type: !userHubs.includes(system) ? OutCommand.addUserHub : OutCommand.deleteUserHub,
      data: {
        system_id: system,
      },
    });
    setSystem(undefined);
  }, []);

  const onSystemTag = useCallback((tag?: string) =&gt; {
    const { system, outCommand } = ref.current;
    if (!system) {
      return;
    }

    outCommand({
      type: OutCommand.updateSystemTag,
      data: {
        system_id: system,
        value: tag ?? &apos;&apos;,
      },
    });
    setSystem(undefined);
  }, []);

  const onSystemTemporaryName = useCallback((temporaryName?: string) =&gt; {
    const { system, outCommand } = ref.current;
    if (!system) {
      return;
    }

    outCommand({
      type: OutCommand.updateSystemTemporaryName,
      data: {
        system_id: system,
        value: temporaryName ?? &apos;&apos;,
      },
    });
    setSystem(undefined);
  }, []);

  const onSystemStatus = useCallback((status: number) =&gt; {
    const { system, outCommand } = ref.current;
    if (!system) {
      return;
    }

    outCommand({
      type: OutCommand.updateSystemStatus,
      data: {
        system_id: system,
        value: status,
      },
    });
    setSystem(undefined);
  }, []);

  const onSystemLabels = useCallback((labels: string) =&gt; {
    const { system, outCommand } = ref.current;
    if (!system) {
      return;
    }

    outCommand({
      type: OutCommand.updateSystemLabels,
      data: {
        system_id: system,
        value: labels,
      },
    });
    setSystem(undefined);
  }, []);

  const onOpenSettings = useCallback(() =&gt; {
    const { system, outCommand } = ref.current;
    if (!system) {
      return;
    }

    outCommand({
      type: OutCommand.openSettings,
      data: {
        system_id: system,
      },
    });
    setSystem(undefined);
  }, []);

  const onWaypointSet: WaypointSetContextHandler = useCallback(({ charIds, clearWay, fromBeginning, destination }) =&gt; {
    const { system, outCommand } = ref.current;
    if (!system) {
      return;
    }

    outCommand({
      type: OutCommand.setAutopilotWaypoint,
      data: {
        character_eve_ids: charIds,
        add_to_beginning: fromBeginning,
        clear_other_waypoints: clearWay,
        destination_id: destination,
      },
    });
    setSystem(undefined);
  }, []);

  return {
    open,

    contextMenuRef,
    onDeleteSystem,
    onLockToggle,
    onHubToggle,
    onUserHubToggle,
    onSystemTag,
    onSystemTemporaryName,
    onSystemStatus,
    onSystemLabels,
    onOpenSettings,
    onWaypointSet,
    systemId: system,
  };
};</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystem/useContextMenuSystemItems.tsx">import { useLabelsMenu, useStatusMenu, useTagMenu } from &apos;@/hooks/Mapper/components/contexts/ContextMenuSystem/hooks&apos;;
import { useMemo } from &apos;react&apos;;
import { getSystemById } from &apos;@/hooks/Mapper/helpers&apos;;
import classes from &apos;./ContextMenuSystem.module.scss&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { ContextMenuSystemProps } from &apos;@/hooks/Mapper/components/contexts&apos;;
import { useWaypointMenu } from &apos;@/hooks/Mapper/components/contexts/hooks&apos;;
import { FastSystemActions } from &apos;@/hooks/Mapper/components/contexts/components&apos;;
import { useMapCheckPermissions } from &apos;@/hooks/Mapper/mapRootProvider/hooks/api&apos;;
import { UserPermission } from &apos;@/hooks/Mapper/types/permissions.ts&apos;;
import { isWormholeSpace } from &apos;@/hooks/Mapper/components/map/helpers/isWormholeSpace.ts&apos;;
import { getSystemStaticInfo } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic&apos;;
import { MapAddIcon, MapDeleteIcon, MapUserAddIcon, MapUserDeleteIcon } from &apos;@/hooks/Mapper/icons&apos;;

export const useContextMenuSystemItems = ({
  onDeleteSystem,
  onLockToggle,
  onHubToggle,
  onUserHubToggle,
  onSystemTag,
  onSystemStatus,
  onSystemLabels,
  onCustomLabelDialog,
  onOpenSettings,
  onWaypointSet,
  systemId,
  hubs,
  userHubs,
  systems,
}: Omit&lt;ContextMenuSystemProps, &apos;contextMenuRef&apos;&gt;) =&gt; {
  const getTags = useTagMenu(systems, systemId, onSystemTag);
  const getStatus = useStatusMenu(systems, systemId, onSystemStatus);
  const getLabels = useLabelsMenu(systems, systemId, onSystemLabels, onCustomLabelDialog);
  const getWaypointMenu = useWaypointMenu(onWaypointSet);
  const canLockSystem = useMapCheckPermissions([UserPermission.LOCK_SYSTEM]);

  return useMemo(() =&gt; {
    const system = systemId ? getSystemById(systems, systemId) : undefined;
    const systemStaticInfo = getSystemStaticInfo(systemId)!;

    if (!system || !systemId) {
      return [];
    }

    return [
      {
        className: classes.FastActions,
        template: () =&gt; {
          return (
            &lt;FastSystemActions
              systemId={systemId}
              systemName={systemStaticInfo.solar_system_name}
              regionName={systemStaticInfo.region_name}
              isWH={isWormholeSpace(systemStaticInfo.system_class)}
              showEdit
              onOpenSettings={onOpenSettings}
            /&gt;
          );
        },
      },
      { separator: true },
      getTags(),
      getStatus(),
      ...getLabels(),
      ...getWaypointMenu(systemId, systemStaticInfo.system_class),
      {
        label: !hubs.includes(systemId) ? &apos;Add Route&apos; : &apos;Remove Route&apos;,
        icon: !hubs.includes(systemId) ? (
          &lt;MapAddIcon className=&quot;mr-1 relative left-[-2px]&quot; /&gt;
        ) : (
          &lt;MapDeleteIcon className=&quot;mr-1 relative left-[-2px]&quot; /&gt;
        ),
        command: onHubToggle,
      },
      {
        label: !userHubs.includes(systemId) ? &apos;Add User Route&apos; : &apos;Remove User Route&apos;,
        icon: !userHubs.includes(systemId) ? (
          &lt;MapUserAddIcon className=&quot;mr-1 relative left-[-2px]&quot; /&gt;
        ) : (
          &lt;MapUserDeleteIcon className=&quot;mr-1 relative left-[-2px]&quot; /&gt;
        ),
        command: onUserHubToggle,
      },
      ...(system.locked
        ? canLockSystem
          ? [
              {
                label: &apos;Unlock&apos;,
                icon: PrimeIcons.LOCK_OPEN,
                command: onLockToggle,
              },
            ]
          : []
        : [
            ...(canLockSystem
              ? [
                  {
                    label: &apos;Lock&apos;,
                    icon: PrimeIcons.LOCK,
                    command: onLockToggle,
                  },
                ]
              : []),
            { separator: true },
            {
              label: &apos;Delete&apos;,
              icon: PrimeIcons.TRASH,
              command: onDeleteSystem,
            },
          ]),
    ];
  }, [
    canLockSystem,
    systems,
    systemId,
    getTags,
    getStatus,
    getLabels,
    getWaypointMenu,
    hubs,
    onHubToggle,
    onOpenSettings,
    onLockToggle,
    onDeleteSystem,
  ]);
};</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystemInfo/constants.ts">export const GRADIENT_MENU_ACTIVE_CLASSES = &apos;bg-gradient-to-br from-transparent/10 to-fuchsia-300/10&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystemInfo/ContextMenuSystemInfo.module.scss">.FastActions {
  :global {
    .p-menuitem-content {
      background-color: initial !important;
    }
    .p-menuitem-content:hover {
      background-color: initial !important;
    }
  }
}</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystemInfo/ContextMenuSystemInfo.tsx">import React, { RefObject, useMemo } from &apos;react&apos;;
import { ContextMenu } from &apos;primereact/contextmenu&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { MenuItem } from &apos;primereact/menuitem&apos;;
import { SolarSystemRawType, SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types&apos;;
import classes from &apos;./ContextMenuSystemInfo.module.scss&apos;;
import { getSystemById } from &apos;@/hooks/Mapper/helpers&apos;;
import { useWaypointMenu } from &apos;@/hooks/Mapper/components/contexts/hooks&apos;;
import { WaypointSetContextHandler } from &apos;@/hooks/Mapper/components/contexts/types.ts&apos;;
import { FastSystemActions } from &apos;@/hooks/Mapper/components/contexts/components&apos;;
import { useJumpPlannerMenu } from &apos;@/hooks/Mapper/components/contexts/hooks&apos;;
import { Route } from &apos;@/hooks/Mapper/types/routes.ts&apos;;
import { isWormholeSpace } from &apos;@/hooks/Mapper/components/map/helpers/isWormholeSpace.ts&apos;;
import { MapAddIcon, MapDeleteIcon } from &apos;@/hooks/Mapper/icons&apos;;

export interface ContextMenuSystemInfoProps {
  systemStatics: Map&lt;number, SolarSystemStaticInfoRaw&gt;;
  hubs: string[];
  contextMenuRef: RefObject&lt;ContextMenu&gt;;
  systemId: string | undefined;
  systemIdFrom?: string | undefined;
  systems: SolarSystemRawType[];
  onOpenSettings(): void;
  onHubToggle(): void;
  onAddSystem(): void;
  onWaypointSet: WaypointSetContextHandler;
  routes: Route[];
}

export const ContextMenuSystemInfo: React.FC&lt;ContextMenuSystemInfoProps&gt; = ({
  systems,
  systemStatics,
  contextMenuRef,
  onHubToggle,
  onOpenSettings,
  onAddSystem,
  onWaypointSet,
  systemId,
  systemIdFrom,
  hubs,
  routes,
}) =&gt; {
  const getWaypointMenu = useWaypointMenu(onWaypointSet);
  const getJumpPlannerMenu = useJumpPlannerMenu(systems, systemIdFrom);

  const items: MenuItem[] = useMemo(() =&gt; {
    const system = systemId ? systemStatics.get(parseInt(systemId)) : undefined;
    const systemOnMap = systemId ? getSystemById(systems, systemId) : undefined;

    if (!systemId || !system) {
      return [];
    }
    return [
      {
        className: classes.FastActions,
        template: () =&gt; {
          return (
            &lt;FastSystemActions
              systemId={systemId}
              systemName={system.solar_system_name}
              regionName={system.region_name}
              isWH={isWormholeSpace(system.system_class)}
              onOpenSettings={onOpenSettings}
            /&gt;
          );
        },
      },

      { separator: true },
      ...getJumpPlannerMenu(system, routes),
      ...getWaypointMenu(systemId, system.system_class),
      {
        label: !hubs.includes(systemId) ? &apos;Add Route&apos; : &apos;Remove Route&apos;,
        icon: !hubs.includes(systemId) ? (
          &lt;MapAddIcon className=&quot;mr-1 relative left-[-2px]&quot; /&gt;
        ) : (
          &lt;MapDeleteIcon className=&quot;mr-1 relative left-[-2px]&quot; /&gt;
        ),
        command: onHubToggle,
      },
      ...(!systemOnMap
        ? [
            {
              label: &apos;Add to map&apos;,
              icon: PrimeIcons.PLUS,
              command: onAddSystem,
            },
          ]
        : []),
    ];
  }, [
    systemId,
    systemStatics,
    systems,
    getJumpPlannerMenu,
    getWaypointMenu,
    hubs,
    onHubToggle,
    onAddSystem,
    onOpenSettings,
  ]);

  return (
    &lt;&gt;
      &lt;ContextMenu model={items} ref={contextMenuRef} breakpoint=&quot;767px&quot; /&gt;
    &lt;/&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystemInfo/index.ts">export * from &apos;./ContextMenuSystemInfo.tsx&apos;;
export * from &apos;./useContextMenuSystemInfoHandlers.ts&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystemInfo/useContextMenuSystemInfoHandlers.ts">import * as React from &apos;react&apos;;
import { useCallback, useRef, useState } from &apos;react&apos;;
import { ContextMenu } from &apos;primereact/contextmenu&apos;;
import { Commands, OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { WaypointSetContextHandler } from &apos;@/hooks/Mapper/components/contexts/types.ts&apos;;
import { ctxManager } from &apos;@/hooks/Mapper/utils/contextManager.ts&apos;;
import { SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types&apos;;
import { emitMapEvent } from &apos;@/hooks/Mapper/events&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useRouteProvider } from &apos;@/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesProvider.tsx&apos;;

export const useContextMenuSystemInfoHandlers = () =&gt; {
  const { outCommand } = useMapRootState();
  const { hubs = [], toggleHubCommand } = useRouteProvider();

  const contextMenuRef = useRef&lt;ContextMenu | null&gt;(null);

  const [system, setSystem] = useState&lt;string&gt;();
  const routeRef = useRef&lt;(SolarSystemStaticInfoRaw | undefined)[]&gt;([]);

  const ref = useRef({ hubs, system, outCommand, toggleHubCommand });
  ref.current = { hubs, system, outCommand, toggleHubCommand };

  const open = useCallback(
    (ev: React.SyntheticEvent, systemId: string, route: (SolarSystemStaticInfoRaw | undefined)[]) =&gt; {
      setSystem(systemId);
      routeRef.current = route;
      ev.preventDefault();
      ctxManager.next(&apos;ctxSysInfo&apos;, contextMenuRef.current);
      contextMenuRef.current?.show(ev);
    },
    [],
  );

  const onHubToggle = useCallback(() =&gt; {
    const { system } = ref.current;
    if (!system) {
      return;
    }

    ref.current.toggleHubCommand(system);
    setSystem(undefined);
  }, []);

  const onAddSystem = useCallback(() =&gt; {
    const { system: solarSystemId, outCommand } = ref.current;
    if (!solarSystemId) {
      return;
    }

    outCommand({
      type: OutCommand.addSystem,
      data: {
        system_id: solarSystemId,
      },
    });

    // TODO add it to some queue
    setTimeout(() =&gt; {
      emitMapEvent({
        name: Commands.centerSystem,
        data: solarSystemId,
      });

      setSystem(undefined);
    }, 200);
  }, []);

  const onOpenSettings = useCallback(() =&gt; {
    const { system, outCommand } = ref.current;
    if (!system) {
      return;
    }

    outCommand({
      type: OutCommand.openSettings,
      data: {
        system_id: system,
      },
    });
    setSystem(undefined);
  }, []);

  const onWaypointSet: WaypointSetContextHandler = useCallback(({ charIds, clearWay, fromBeginning, destination }) =&gt; {
    const { system, outCommand } = ref.current;
    if (!system) {
      return;
    }

    outCommand({
      type: OutCommand.setAutopilotWaypoint,
      data: {
        character_eve_ids: charIds,
        add_to_beginning: fromBeginning,
        clear_other_waypoints: clearWay,
        destination_id: destination,
      },
    });
    setSystem(undefined);
  }, []);

  return {
    open,
    contextMenuRef,
    onAddSystem,
    onHubToggle,
    onOpenSettings,
    onWaypointSet,
    systemId: system,
  };
};</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystemMultiple/ContextMenuSystemMultiple.tsx">import React, { RefObject, useMemo } from &apos;react&apos;;
import { ContextMenu } from &apos;primereact/contextmenu&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { MenuItem } from &apos;primereact/menuitem&apos;;

export interface ContextMenuSystemMultipleProps {
  contextMenuRef: RefObject&lt;ContextMenu&gt;;
  onDeleteSystems(): void;
}

export const ContextMenuSystemMultiple: React.FC&lt;ContextMenuSystemMultipleProps&gt; = ({
  contextMenuRef,
  onDeleteSystems,
}) =&gt; {
  const items: MenuItem[] = useMemo(() =&gt; {
    return [
      {
        label: &apos;Delete&apos;,
        icon: PrimeIcons.TRASH,
        command: onDeleteSystems,
      },
    ];
  }, [onDeleteSystems]);

  return (
    &lt;&gt;
      &lt;ContextMenu model={items} ref={contextMenuRef} breakpoint=&quot;767px&quot; /&gt;
    &lt;/&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystemMultiple/index.ts">export * from &apos;./ContextMenuSystemMultiple.tsx&apos;;
export * from &apos;./useContextMenuSystemMultipleHandlers.ts&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/ContextMenuSystemMultiple/useContextMenuSystemMultipleHandlers.ts">import { Node } from &apos;reactflow&apos;;
import { useCallback, useRef, useState } from &apos;react&apos;;
import { ContextMenu } from &apos;primereact/contextmenu&apos;;
import { SolarSystemRawType } from &apos;@/hooks/Mapper/types&apos;;
import { ctxManager } from &apos;@/hooks/Mapper/utils/contextManager.ts&apos;;
import { NodeSelectionMouseHandler } from &apos;@/hooks/Mapper/components/contexts/types.ts&apos;;
import { useDeleteSystems } from &apos;@/hooks/Mapper/components/contexts/hooks&apos;;

export const useContextMenuSystemMultipleHandlers = () =&gt; {
  const contextMenuRef = useRef&lt;ContextMenu | null&gt;(null);
  const [systems, setSystems] = useState&lt;Node&lt;SolarSystemRawType&gt;[]&gt;();

  const { deleteSystems } = useDeleteSystems();

  const handleSystemMultipleContext: NodeSelectionMouseHandler = (ev, systems_) =&gt; {
    setSystems(systems_);
    ev.preventDefault();
    ctxManager.next(&apos;ctxSysMult&apos;, contextMenuRef.current);
    contextMenuRef.current?.show(ev);
  };

  const onDeleteSystems = useCallback(() =&gt; {
    if (!systems) {
      return;
    }

    const sysToDel = systems.filter(x =&gt; !x.data.locked).map(x =&gt; x.id);
    if (sysToDel.length === 0) {
      return;
    }

    deleteSystems(sysToDel);
  }, [deleteSystems, systems]);

  return {
    handleSystemMultipleContext,
    contextMenuRef,
    onDeleteSystems,
  };
};</file><file path="assets/js/hooks/Mapper/components/contexts/hooks/useJumpPlannerMenu/index.ts">export * from &apos;./useJumpPlannerMenu.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/hooks/useJumpPlannerMenu/useJumpPlannerMenu.tsx">import { MenuItem } from &apos;primereact/menuitem&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { useCallback } from &apos;react&apos;;
import { isPossibleSpace } from &apos;@/hooks/Mapper/components/map/helpers/isKnownSpace.ts&apos;;
import { Route } from &apos;@/hooks/Mapper/types/routes.ts&apos;;
import { SolarSystemRawType, SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types&apos;;
import { SOLAR_SYSTEM_CLASS_IDS } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { getSystemStaticInfo } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic&apos;;

const imperialSpace = [SOLAR_SYSTEM_CLASS_IDS.hs, SOLAR_SYSTEM_CLASS_IDS.ls, SOLAR_SYSTEM_CLASS_IDS.ns];
const criminalSpace = [SOLAR_SYSTEM_CLASS_IDS.ls, SOLAR_SYSTEM_CLASS_IDS.ns];

enum JUMP_SHIP_TYPE {
  BLACK_OPS = &apos;Marshal&apos;,
  JUMP_FREIGHTER = &apos;Anshar&apos;,
  RORQUAL = &apos;Rorqual&apos;,
  CAPITAL = &apos;Thanatos&apos;,
  SUPER_CAPITAL = &apos;Avatar&apos;,
}

export const openJumpPlan = (jumpShipType: JUMP_SHIP_TYPE, from: string, to: string) =&gt; {
  return window.open(`https://evemaps.dotlan.net/jump/${jumpShipType},544/${from}:${to}`, &apos;_blank&apos;);
};

const BRACKET_ICONS = {
  npcsuperCarrier_32: &apos;/icons/brackets/npcsuperCarrier_32.png&apos;,
  carrier_32: &apos;/icons/brackets/carrier_32.png&apos;,
  battleship_32: &apos;/icons/brackets/battleship_32.png&apos;,
  freighter_32: &apos;/icons/brackets/freighter_32.png&apos;,
};

const renderIcon = (icon: string) =&gt; {
  return (
    &lt;div className=&quot;flex justify-center items-center mr-1.5 pt-px&quot;&gt;
      &lt;img src={icon} style={{ width: 20, height: 20 }} /&gt;
    &lt;/div&gt;
  );
};

export const useJumpPlannerMenu = (
  systems: SolarSystemRawType[],
  systemIdFrom?: string | undefined,
): ((systemId: SolarSystemStaticInfoRaw, routes: Route[]) =&gt; MenuItem[]) =&gt; {
  return useCallback(
    (destination: SolarSystemStaticInfoRaw) =&gt; {
      if (!destination || !systemIdFrom) {
        return [];
      }

      const origin = getSystemStaticInfo(systemIdFrom);

      if (!origin) {
        return [];
      }

      const isShowBOorJumpFreighter =
        isPossibleSpace(imperialSpace, origin.system_class) &amp;&amp; isPossibleSpace(criminalSpace, destination.system_class);

      const isShowCapital =
        isPossibleSpace(criminalSpace, origin.system_class) &amp;&amp; isPossibleSpace(criminalSpace, destination.system_class);

      if (!isShowBOorJumpFreighter &amp;&amp; !isShowCapital) {
        return [];
      }

      return [
        {
          label: &apos;In Jump Planner&apos;,
          icon: PrimeIcons.SEND,
          items: [
            ...(isShowBOorJumpFreighter
              ? [
                  {
                    label: &apos;Black Ops&apos;,
                    icon: renderIcon(BRACKET_ICONS.battleship_32),
                    command: () =&gt; {
                      openJumpPlan(JUMP_SHIP_TYPE.BLACK_OPS, origin.solar_system_name, destination.solar_system_name);
                    },
                  },
                  {
                    label: &apos;Jump Freighter&apos;,
                    icon: renderIcon(BRACKET_ICONS.freighter_32),
                    command: () =&gt; {
                      openJumpPlan(
                        JUMP_SHIP_TYPE.JUMP_FREIGHTER,
                        origin.solar_system_name,
                        destination.solar_system_name,
                      );
                    },
                  },
                  {
                    label: &apos;Rorqual&apos;,
                    icon: renderIcon(BRACKET_ICONS.freighter_32),
                    command: () =&gt; {
                      openJumpPlan(JUMP_SHIP_TYPE.RORQUAL, origin.solar_system_name, destination.solar_system_name);
                    },
                  },
                ]
              : []),

            ...(isShowCapital
              ? [
                  {
                    label: &apos;Capital&apos;,
                    icon: renderIcon(BRACKET_ICONS.carrier_32),
                    command: () =&gt; {
                      openJumpPlan(JUMP_SHIP_TYPE.CAPITAL, origin.solar_system_name, destination.solar_system_name);
                    },
                  },
                  {
                    label: &apos;Super Capital&apos;,
                    icon: renderIcon(BRACKET_ICONS.npcsuperCarrier_32),
                    command: () =&gt; {
                      openJumpPlan(
                        JUMP_SHIP_TYPE.SUPER_CAPITAL,
                        origin.solar_system_name,
                        destination.solar_system_name,
                      );
                    },
                  },
                ]
              : []),
          ],
        },
      ];
    },
    [systems, systemIdFrom],
  );
};</file><file path="assets/js/hooks/Mapper/components/contexts/hooks/useWaypointMenu/index.ts">export * from &apos;./useWaypointMenu&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/hooks/useWaypointMenu/useWaypointMenu.ts">import { MenuItem } from &apos;primereact/menuitem&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { CharacterTypeRaw } from &apos;@/hooks/Mapper/types&apos;;
import { useGetOwnOnlineCharacters } from &apos;@/hooks/Mapper/components/hooks/useGetOwnOnlineCharacters.ts&apos;;
import { isKnownSpace } from &apos;@/hooks/Mapper/components/map/helpers/isKnownSpace.ts&apos;;
import { isPochvenSpace } from &apos;@/hooks/Mapper/components/map/helpers/isPochvenSpace.ts&apos;;
import { WaypointSetContextHandler } from &apos;@/hooks/Mapper/components/contexts/types.ts&apos;;

const getItemsByChars = (onWaypointSet: WaypointSetContextHandler, systemId: string, chars: CharacterTypeRaw[]) =&gt; {
  return [
    {
      label: &apos;Set Destination&apos;,
      icon: PrimeIcons.SEND,
      command: () =&gt; {
        onWaypointSet({
          fromBeginning: true,
          clearWay: true,
          destination: systemId,
          charIds: chars.map(char =&gt; char.eve_id),
        });
      },
    },
    {
      label: &apos;Add Waypoint&apos;,
      icon: PrimeIcons.DIRECTIONS_ALT,
      command: () =&gt; {
        onWaypointSet({
          fromBeginning: false,
          clearWay: false,
          destination: systemId,
          charIds: chars.map(char =&gt; char.eve_id),
        });
      },
    },
    {
      label: &apos;Add Waypoint Front&apos;,
      icon: PrimeIcons.DIRECTIONS,
      command: () =&gt; {
        onWaypointSet({
          fromBeginning: true,
          clearWay: false,
          destination: systemId,
          charIds: chars.map(char =&gt; char.eve_id),
        });
      },
    },
  ];
};

export const useWaypointMenu = (
  onWaypointSet: WaypointSetContextHandler,
): ((systemId: string | undefined, systemClass: number) =&gt; MenuItem[]) =&gt; {
  const getOwnOnlineCharacters = useGetOwnOnlineCharacters();

  const ref = useRef({ getOwnOnlineCharacters, onWaypointSet });
  ref.current = { getOwnOnlineCharacters, onWaypointSet };

  return useCallback((systemId: string | undefined, systemClass: number) =&gt; {
    const { getOwnOnlineCharacters, onWaypointSet } = ref.current;
    if (!systemId) {
      return [];
    }

    const chars = getOwnOnlineCharacters().filter(x =&gt; x.online);

    const isSuggestedRegion = isKnownSpace(systemClass) || isPochvenSpace(systemClass);

    if (!isSuggestedRegion || chars.length === 0) {
      return [];
    }

    if (chars.length === 1) {
      return [
        {
          label: &apos;Waypoint&apos;,
          icon: PrimeIcons.COMPASS,
          items: getItemsByChars(onWaypointSet, systemId, chars.slice(0, 1)),
        },
      ];
    }

    return [
      {
        label: &apos;Waypoint&apos;,
        icon: PrimeIcons.COMPASS,
        items: [
          {
            label: &apos;All&apos;,
            icon: PrimeIcons.USERS,
            items: getItemsByChars(onWaypointSet, systemId, chars),
          },
          ...chars.map(char =&gt; ({
            label: char.name,
            icon: PrimeIcons.USER,
            items: getItemsByChars(onWaypointSet, systemId, [char]),
          })),
        ],
      },
    ];
  }, []);
};</file><file path="assets/js/hooks/Mapper/components/contexts/hooks/index.ts">export * from &apos;./useWaypointMenu&apos;;
export * from &apos;./useJumpPlannerMenu&apos;;
export * from &apos;./useDeleteSystems&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/hooks/useDeleteSystems.ts">import { OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

export const useDeleteSystems = () =&gt; {
  const { outCommand } = useMapRootState();

  const deleteSystems = (systemIds: string[]) =&gt; {
    if (!systemIds || !systemIds.length) {
      return;
    }

    outCommand({ type: OutCommand.deleteSystems, data: systemIds });
  };

  return {
    deleteSystems,
  };
};</file><file path="assets/js/hooks/Mapper/components/contexts/index.ts">export * from &apos;./ContextMenuSystem&apos;;
export * from &apos;./ContextMenuSystemInfo&apos;;</file><file path="assets/js/hooks/Mapper/components/contexts/types.ts">import React from &apos;react&apos;;
import { Node } from &apos;reactflow&apos;;

export type WaypointSetContextHandlerProps = {
  charIds: string[];
  fromBeginning: boolean;
  clearWay: boolean;
  destination: string;
};
export type WaypointSetContextHandler = (props: WaypointSetContextHandlerProps) =&gt; void;
export type NodeSelectionMouseHandler =
  | ((event: React.MouseEvent&lt;Element, MouseEvent&gt;, nodes: Node[]) =&gt; void)
  | undefined;</file><file path="assets/js/hooks/Mapper/components/hooks/index.ts">export * from &apos;./useSystemInfo&apos;;
export * from &apos;./useGetOwnOnlineCharacters&apos;;
export * from &apos;./useElementWidth&apos;;</file><file path="assets/js/hooks/Mapper/components/hooks/useElementWidth.ts">import { useState, useLayoutEffect, RefObject } from &apos;react&apos;;

/**
 * useElementWidth
 *
 * A custom hook that accepts a ref to an HTML element and returns its current width.
 * It uses a ResizeObserver and window resize listener to update the width when necessary.
 *
 * @param ref - A RefObject pointing to an HTML element.
 * @returns The current width of the element.
 */
export function useElementWidth&lt;T extends HTMLElement&gt;(ref: RefObject&lt;T&gt;): number {
  const [width, setWidth] = useState&lt;number&gt;(0);

  useLayoutEffect(() =&gt; {
    const updateWidth = () =&gt; {
      if (ref.current) {
        const newWidth = ref.current.getBoundingClientRect().width;
        if (newWidth &gt; 0) {
          setWidth(newWidth);
        }
      }
    };

    updateWidth(); // Initial measurement

    const observer = new ResizeObserver(() =&gt; {
      const id = setTimeout(updateWidth, 100);
      return () =&gt; clearTimeout(id);
    });

    if (ref.current) {
      observer.observe(ref.current);
    }
    window.addEventListener(&quot;resize&quot;, updateWidth);
    return () =&gt; {
      observer.disconnect();
      window.removeEventListener(&quot;resize&quot;, updateWidth);
    };
  }, [ref]);

  return width;
}</file><file path="assets/js/hooks/Mapper/components/hooks/useGetOwnOnlineCharacters.ts">import { CharacterTypeRaw } from &apos;@/hooks/Mapper/types&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback, useRef } from &apos;react&apos;;

export const sortOnlineFunc = (a: CharacterTypeRaw, b: CharacterTypeRaw) =&gt;
  a.online === b.online ? a.name.localeCompare(b.name) : a.online ? -1 : 1;

export const useGetOwnOnlineCharacters = () =&gt; {
  const {
    data: { characters, userCharacters },
  } = useMapRootState();

  const ref = useRef({ characters, userCharacters });
  ref.current = { characters, userCharacters };

  return useCallback(() =&gt; {
    const { characters, userCharacters } = ref.current;
    return characters.filter(x =&gt; userCharacters.includes(x.eve_id)).sort(sortOnlineFunc);
  }, []);
};</file><file path="assets/js/hooks/Mapper/components/hooks/useSystemInfo.ts">import { getSystemById } from &apos;@/hooks/Mapper/helpers&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useMemo } from &apos;react&apos;;
import { getSystemStaticInfo } from &apos;../../mapRootProvider/hooks/useLoadSystemStatic&apos;;

interface UseSystemInfoProps {
  systemId: string;
}

export const useSystemInfo = ({ systemId }: UseSystemInfoProps) =&gt; {
  const {
    data: { systems, connections },
  } = useMapRootState();

  return useMemo(() =&gt; {
    const staticInfo = getSystemStaticInfo(parseInt(systemId));
    const dynamicInfo = getSystemById(systems, systemId);

    if (!staticInfo || !dynamicInfo) {
      return { dynamicInfo, staticInfo, leadsTo: [] };
    }

    const leadsTo = connections
      .filter(x =&gt; [x.source, x.target].includes(systemId))
      .map(x =&gt; [x.source, x.target])
      .flat()
      .filter(x =&gt; x !== systemId);

    return { dynamicInfo, staticInfo, leadsTo };
  }, [systemId, systems, connections]);
};</file><file path="assets/js/hooks/Mapper/components/layout/Layout.module.scss">.LayoutContainer {
  width: 100%;
  height: 100%;
}</file><file path="assets/js/hooks/Mapper/components/layout/Layout.tsx">import { ReactNode } from &apos;react&apos;;

interface LayoutProps {
  map: ReactNode;
  children: ReactNode;
}

const Layout = ({ map, children }: LayoutProps) =&gt; {
  return (
    &lt;&gt;
      &lt;section className=&quot;flex-1 mb-0 min-h-full min-w-full w-full h-full&quot;&gt;
        &lt;div className=&quot;flex flex-col lg:flex-row&quot;&gt;
          &lt;div className=&quot;lg:flex-1 min-h-0 min-w-0 &quot;&gt;
            &lt;div className=&quot;flex h-[calc(100vh)]&quot;&gt;{map}&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;
      {children}
    &lt;/&gt;
  );
};

// eslint-disable-next-line react/display-name
export default Layout;</file><file path="assets/js/hooks/Mapper/components/map/components/ContextMenuConnection/ContextMenuConnection.module.scss">@import &apos;@/hooks/Mapper/components/map/styles/eve-common-variables&apos;;

.ConnectionTimeEOL {
  background-image: linear-gradient(207deg, transparent, var(--conn-time-eol));
}

.ConnectionFrigate {
  background-image: linear-gradient(207deg, transparent, var(--conn-frigate));
}

.ConnectionSave {
  background-image: linear-gradient(207deg, transparent, var(--conn-save));
}

.SelectedItem {
  background-color: var(--selected-item-bg);
}</file><file path="assets/js/hooks/Mapper/components/map/components/ContextMenuConnection/ContextMenuConnection.tsx">import React, { RefObject, useMemo } from &apos;react&apos;;
import { ContextMenu } from &apos;primereact/contextmenu&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { MenuItem } from &apos;primereact/menuitem&apos;;
import { ConnectionType, MassState, ShipSizeStatus, SolarSystemConnection, TimeStatus } from &apos;@/hooks/Mapper/types&apos;;
import clsx from &apos;clsx&apos;;
import classes from &apos;./ContextMenuConnection.module.scss&apos;;
import {
  MASS_STATE_NAMES,
  MASS_STATE_NAMES_ORDER,
  SHIP_SIZES_NAMES,
  SHIP_SIZES_NAMES_ORDER,
  SHIP_SIZES_NAMES_SHORT,
  SHIP_SIZES_SIZE,
} from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { Edge } from &apos;reactflow&apos;;

export interface ContextMenuConnectionProps {
  contextMenuRef: RefObject&lt;ContextMenu&gt;;
  onDeleteConnection(): void;
  onChangeTimeState(): void;
  onChangeMassState(state: MassState): void;
  onChangeShipSizeStatus(state: ShipSizeStatus): void;
  onToggleMassSave(isLocked: boolean): void;
  onHide(): void;
  edge?: Edge&lt;SolarSystemConnection&gt;;
}

export const ContextMenuConnection: React.FC&lt;ContextMenuConnectionProps&gt; = ({
  contextMenuRef,
  onDeleteConnection,
  onChangeTimeState,
  onChangeMassState,
  onChangeShipSizeStatus,
  onToggleMassSave,
  onHide,
  edge,
}) =&gt; {
  const items: MenuItem[] = useMemo(() =&gt; {
    if (!edge) {
      return [];
    }

    const isFrigateSize = edge.data?.ship_size_type === ShipSizeStatus.small;
    const isWormhole = edge.data?.type !== ConnectionType.gate;

    return [
      ...(isWormhole
        ? [
            {
              label: `EOL`,
              className: clsx({
                [classes.ConnectionTimeEOL]: edge.data?.time_status === TimeStatus.eol,
              }),
              icon: PrimeIcons.CLOCK,
              command: onChangeTimeState,
            },
            {
              label: `Frigate`,
              className: clsx({
                [classes.ConnectionFrigate]: isFrigateSize,
              }),
              icon: PrimeIcons.CLOUD,
              command: () =&gt;
                onChangeShipSizeStatus(
                  edge.data?.ship_size_type === ShipSizeStatus.small ? ShipSizeStatus.large : ShipSizeStatus.small,
                ),
            },
            {
              label: `Save mass`,
              className: clsx({
                [classes.ConnectionSave]: edge.data?.locked,
              }),
              icon: PrimeIcons.LOCK,
              command: () =&gt; onToggleMassSave(!edge.data?.locked),
            },
            ...(!isFrigateSize
              ? [
                  {
                    label: `Mass status`,
                    icon: PrimeIcons.CHART_PIE,
                    items: MASS_STATE_NAMES_ORDER.map(x =&gt; ({
                      label: MASS_STATE_NAMES[x],
                      className: clsx({
                        [classes.SelectedItem]: edge.data?.mass_status === x,
                      }),
                      command: () =&gt; onChangeMassState(x),
                    })),
                  },
                ]
              : []),

            {
              label: `Ship Size`,
              icon: PrimeIcons.CLOUD,
              items: SHIP_SIZES_NAMES_ORDER.map(x =&gt; ({
                label: (
                  &lt;div className=&quot;grid grid-cols-[20px_120px_1fr_40px] gap-2 items-center&quot;&gt;
                    &lt;div className=&quot;text-[12px] font-bold text-stone-400&quot;&gt;{SHIP_SIZES_NAMES_SHORT[x]}&lt;/div&gt;
                    &lt;div&gt;{SHIP_SIZES_NAMES[x]}&lt;/div&gt;
                    &lt;div&gt;&lt;/div&gt;
                    &lt;div className=&quot;flex justify-end whitespace-nowrap text-[12px] font-bold text-stone-500&quot;&gt;
                      {SHIP_SIZES_SIZE[x]} t.
                    &lt;/div&gt;
                  &lt;/div&gt;
                ) as unknown as string, // TODO my lovely kostyl
                className: clsx({
                  [classes.SelectedItem]: edge.data?.ship_size_type === x,
                }),
                command: () =&gt; onChangeShipSizeStatus(x),
              })),
            },
          ]
        : []),
      {
        label: &apos;Disconnect&apos;,
        icon: PrimeIcons.TRASH,
        command: onDeleteConnection,
      },
    ];
  }, [edge, onChangeTimeState, onDeleteConnection, onChangeShipSizeStatus, onToggleMassSave, onChangeMassState]);

  return (
    &lt;&gt;
      &lt;ContextMenu model={items} ref={contextMenuRef} onHide={onHide} breakpoint=&quot;767px&quot; /&gt;
    &lt;/&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/map/components/ContextMenuConnection/index.ts">export * from &apos;./ContextMenuConnection.tsx&apos;;
export * from &apos;./useContextMenuConnectionHandlers.ts&apos;;</file><file path="assets/js/hooks/Mapper/components/map/components/ContextMenuConnection/useContextMenuConnectionHandlers.ts">import { Edge, EdgeMouseHandler } from &apos;reactflow&apos;;
import { useCallback, useRef, useState } from &apos;react&apos;;
import { ContextMenu } from &apos;primereact/contextmenu&apos;;
import { useMapState } from &apos;../../MapProvider.tsx&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { ConnectionType, MassState, ShipSizeStatus, SolarSystemConnection, TimeStatus } from &apos;@/hooks/Mapper/types&apos;;
import { ctxManager } from &apos;@/hooks/Mapper/utils/contextManager.ts&apos;;

export const useContextMenuConnectionHandlers = () =&gt; {
  const contextMenuRef = useRef&lt;ContextMenu | null&gt;(null);
  const { outCommand } = useMapState();
  const [edge, setEdge] = useState&lt;Edge&lt;SolarSystemConnection&gt;&gt;();

  const ref = useRef({ edge, outCommand });
  ref.current = { edge, outCommand };

  const handleConnectionContext: EdgeMouseHandler = (ev, edge_) =&gt; {
    setEdge(edge_);
    ev.preventDefault();
    ctxManager.next(&apos;ctxConn&apos;, contextMenuRef.current);
    contextMenuRef.current?.show(ev);
  };

  const onDeleteConnection = () =&gt; {
    if (!edge) {
      return;
    }

    outCommand({ type: OutCommand.manualDeleteConnection, data: { source: edge.source, target: edge.target } });
    setEdge(undefined);
  };

  const onChangeTimeState = () =&gt; {
    if (!edge || !edge.data) {
      return;
    }

    outCommand({
      type: OutCommand.updateConnectionTimeStatus,
      data: {
        source: edge.source,
        target: edge.target,
        value: edge.data.time_status === TimeStatus.default ? TimeStatus.eol : TimeStatus.default,
      },
    });
    setEdge(undefined);
  };

  const onChangeType = useCallback((type: ConnectionType) =&gt; {
    const { edge, outCommand } = ref.current;

    if (!edge) {
      return;
    }

    outCommand({
      type: OutCommand.updateConnectionType,
      data: {
        source: edge.source,
        target: edge.target,
        value: type,
      },
    });
  }, []);

  const onChangeMassState = useCallback((status: MassState) =&gt; {
    const { edge, outCommand } = ref.current;

    if (!edge) {
      return;
    }

    outCommand({
      type: OutCommand.updateConnectionMassStatus,
      data: {
        source: edge.source,
        target: edge.target,
        value: status,
      },
    });
  }, []);

  const onChangeShipSizeStatus = useCallback((status: ShipSizeStatus) =&gt; {
    const { edge, outCommand } = ref.current;

    if (!edge) {
      return;
    }

    outCommand({
      type: OutCommand.updateConnectionShipSizeType,
      data: {
        source: edge.source,
        target: edge.target,
        value: status,
      },
    });

    if (status === ShipSizeStatus.small) {
      outCommand({
        type: OutCommand.updateConnectionMassStatus,
        data: {
          source: edge.source,
          target: edge.target,
          value: MassState.normal,
        },
      });
    }
  }, []);

  const onToggleMassSave = useCallback((locked: boolean) =&gt; {
    const { edge, outCommand } = ref.current;

    if (!edge) {
      return;
    }

    outCommand({
      type: OutCommand.updateConnectionLocked,
      data: {
        source: edge.source,
        target: edge.target,
        value: locked,
      },
    });
  }, []);

  const onHide = useCallback(() =&gt; {
    setEdge(undefined);
  }, []);

  return {
    handleConnectionContext,
    edge,

    contextMenuRef,
    onDeleteConnection,
    onChangeTimeState,
    onChangeType,
    onChangeMassState,
    onChangeShipSizeStatus,
    onToggleMassSave,
    onHide,
  };
};</file><file path="assets/js/hooks/Mapper/components/map/components/ContextMenuRoot/ContextMenuRoot.tsx">import React, { RefObject, useMemo } from &apos;react&apos;;
import { ContextMenu } from &apos;primereact/contextmenu&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { MenuItem } from &apos;primereact/menuitem&apos;;

export interface ContextMenuRootProps {
  contextMenuRef: RefObject&lt;ContextMenu&gt;;
  onAddSystem(): void;
}

export const ContextMenuRoot: React.FC&lt;ContextMenuRootProps&gt; = ({ contextMenuRef, onAddSystem }) =&gt; {
  const items: MenuItem[] = useMemo(() =&gt; {
    return [
      {
        label: &apos;Add System&apos;,
        icon: PrimeIcons.PLUS,
        command: onAddSystem,
      },
    ];
  }, [onAddSystem]);

  return (
    &lt;&gt;
      &lt;ContextMenu model={items} ref={contextMenuRef} breakpoint=&quot;767px&quot; /&gt;
    &lt;/&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/map/components/ContextMenuRoot/index.ts">export * from &apos;./ContextMenuRoot.tsx&apos;;
export * from &apos;./useContextMenuRootHandlers.ts&apos;;</file><file path="assets/js/hooks/Mapper/components/map/components/ContextMenuRoot/useContextMenuRootHandlers.ts">import { useReactFlow, XYPosition } from &apos;reactflow&apos;;
import React, { useCallback, useRef, useState } from &apos;react&apos;;
import { ContextMenu } from &apos;primereact/contextmenu&apos;;
import { ctxManager } from &apos;@/hooks/Mapper/utils/contextManager.ts&apos;;
import { OnMapAddSystemCallback } from &apos;@/hooks/Mapper/components/map/map.types.ts&apos;;

type UseContextMenuRootHandlers = {
  onAddSystem?: OnMapAddSystemCallback;
};

export const useContextMenuRootHandlers = ({ onAddSystem }: UseContextMenuRootHandlers = {}) =&gt; {
  const rf = useReactFlow();
  const contextMenuRef = useRef&lt;ContextMenu | null&gt;(null);
  const [position, setPosition] = useState&lt;XYPosition | null&gt;(null);

  const handleRootContext = (e: React.MouseEvent&lt;HTMLDivElement&gt;) =&gt; {
    setPosition(rf.project({ x: e.clientX, y: e.clientY }));
    e.preventDefault();
    ctxManager.next(&apos;ctxRoot&apos;, contextMenuRef.current);
    contextMenuRef.current?.show(e);
  };

  const ref = useRef({ onAddSystem, position });
  ref.current = { onAddSystem, position };

  const onAddSystemCallback = useCallback(() =&gt; {
    ref.current.onAddSystem?.({ coordinates: position });
  }, [position]);

  return {
    handleRootContext,

    contextMenuRef,
    onAddSystem: onAddSystemCallback,
  };
};</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemEdge/index.ts">export * from &apos;./SolarSystemEdge&apos;;</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemEdge/SolarSystemEdge.module.scss">@import &apos;@/hooks/Mapper/components/map/styles/eve-common-variables&apos;;

.EdgePathBack {
  fill: none;
  stroke: #80a5c5;
  stroke-width: 3px;

  &amp;.TimeCrit {
    stroke: #f11ab2;
    stroke-width: 4px;
  }

  &amp;.Hovered {
    stroke: #b5c8d9;

    &amp;.TimeCrit {
      stroke: #ef7dce;
    }
  }

  &amp;.Tick {
    stroke-width: 5px;

    &amp;.TimeCrit {
      stroke-width: 6px;
    }
  }

  &amp;.Gate {
    stroke: #9aff40;
  }
}

.EdgePathFront {
  fill: none;
  stroke: #2c3844;
  stroke-width: 2px;

  &amp;.MassVerge:not(&amp;.Frigate) {
    stroke: #af0000;
  }

  &amp;.MassHalf:not(&amp;.Frigate) {
    stroke: #ffd700;
  }

  &amp;.Frigate {
    stroke: #d4f0ff;
  }

  &amp;.Gate {
    stroke: #1c1e15;
  }

  &amp;.Hovered {
    stroke: #4e5d6c;
    stroke-width: 2px;

    &amp;.MassVerge:not(&amp;.Frigate) {
      stroke: #9d4c34;
    }

    &amp;.MassHalf:not(&amp;.Frigate) {
      stroke: #ec992c;
    }

    &amp;.Frigate {
      stroke: #d4f0ff;
    }
  }

  &amp;.Tick {
    stroke-width: 3px;

    &amp;.Hovered {
      stroke-width: 3px;
    }
  }
}

.ClickPath {
  fill: none;
  stroke: none;
  stroke-width: 8px;
}

.Handle {
  border: 1px solid var(--pastel-blue);
  width: 5px;
  height: 5px;
  z-index: 1001;

  &amp;.Tick {
    width: 7px;
    height: 7px;
  }

  &amp;.Right {
    margin-left: 0px;
  }
}

.LinkLabel {
  font-size: 9px;
  line-height: 10px;
  padding: 2px 4px;
  opacity: 1;

  &amp; &gt; span {
    font-weight: bold;
  }
}

.icon {
  width: 8px;
  height: 8px;
  font-size: 8px;
}</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemEdge/SolarSystemEdge.tsx">import { useCallback, useMemo, useState } from &apos;react&apos;;

import classes from &apos;./SolarSystemEdge.module.scss&apos;;
import { EdgeLabelRenderer, EdgeProps, getBezierPath, getSmoothStepPath, Position, useStore } from &apos;reactflow&apos;;
import { getEdgeParams } from &apos;@/hooks/Mapper/components/map/utils.ts&apos;;
import clsx from &apos;clsx&apos;;
import { ConnectionType, MassState, ShipSizeStatus, SolarSystemConnection, TimeStatus } from &apos;@/hooks/Mapper/types&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;
import { useMapState } from &apos;@/hooks/Mapper/components/map/MapProvider.tsx&apos;;
import { SHIP_SIZES_DESCRIPTION, SHIP_SIZES_NAMES_SHORT } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;

const MAP_TRANSLATES: Record&lt;string, string&gt; = {
  [Position.Top]: &apos;translate(-48%, 0%)&apos;,
  [Position.Bottom]: &apos;translate(-50%, -100%)&apos;,
  [Position.Left]: &apos;translate(0%, -50%)&apos;,
  [Position.Right]: &apos;translate(-100%, -50%)&apos;,
};

const MAP_OFFSETS_TICK: Record&lt;string, { x: number; y: number }&gt; = {
  [Position.Top]: { x: 0, y: 3 },
  [Position.Bottom]: { x: 0, y: -3 },
  [Position.Left]: { x: 3, y: 0 },
  [Position.Right]: { x: -3, y: 0 },
};

const MAP_OFFSETS: Record&lt;string, { x: number; y: number }&gt; = {
  [Position.Top]: { x: 0, y: 0 },
  [Position.Bottom]: { x: 0, y: 0 },
  [Position.Left]: { x: 0, y: 0 },
  [Position.Right]: { x: 0, y: 0 },
};

export const SHIP_SIZES_COLORS = {
  [ShipSizeStatus.small]: &apos;bg-indigo-400&apos;,
  [ShipSizeStatus.medium]: &apos;bg-cyan-500&apos;,
  [ShipSizeStatus.large]: &apos;&apos;,
  [ShipSizeStatus.freight]: &apos;bg-lime-400&apos;,
  [ShipSizeStatus.capital]: &apos;bg-red-400&apos;,
};

export const SolarSystemEdge = ({ id, source, target, markerEnd, style, data }: EdgeProps&lt;SolarSystemConnection&gt;) =&gt; {
  const sourceNode = useStore(useCallback(store =&gt; store.nodeInternals.get(source), [source]));
  const targetNode = useStore(useCallback(store =&gt; store.nodeInternals.get(target), [target]));
  const isWormhole = data?.type !== ConnectionType.gate;

  const {
    data: { isThickConnections },
  } = useMapState();

  const [hovered, setHovered] = useState(false);

  const [path, labelX, labelY, sx, sy, tx, ty, sourcePos, targetPos] = useMemo(() =&gt; {
    const { sx, sy, tx, ty, sourcePos, targetPos } = getEdgeParams(sourceNode, targetNode);

    const offset = isThickConnections ? MAP_OFFSETS_TICK[targetPos] : MAP_OFFSETS[targetPos];

    const method = isWormhole ? getBezierPath : getSmoothStepPath;

    const [edgePath, labelX, labelY] = method({
      sourceX: sx - offset.x,
      sourceY: sy - offset.y,
      sourcePosition: sourcePos,
      targetPosition: targetPos,
      targetX: tx + offset.x,
      targetY: ty + offset.y,
    });

    return [edgePath, labelX, labelY, sx, sy, tx, ty, sourcePos, targetPos];
  }, [isThickConnections, sourceNode, targetNode, isWormhole]);

  if (!sourceNode || !targetNode || !data) {
    return null;
  }

  return (
    &lt;&gt;
      &lt;path
        id={`back_${id}`}
        className={clsx(classes.EdgePathBack, {
          [classes.Tick]: isThickConnections,
          [classes.TimeCrit]: isWormhole &amp;&amp; data.time_status === TimeStatus.eol,
          [classes.Hovered]: hovered,
          [classes.Gate]: !isWormhole,
        })}
        d={path}
        markerEnd={markerEnd}
        style={style}
      /&gt;
      &lt;path
        id={`front_${id}`}
        className={clsx(classes.EdgePathFront, {
          [classes.Tick]: isThickConnections,
          [classes.Hovered]: hovered,
          [classes.MassVerge]: isWormhole &amp;&amp; data.mass_status === MassState.verge,
          [classes.MassHalf]: isWormhole &amp;&amp; data.mass_status === MassState.half,
          [classes.Frigate]: isWormhole &amp;&amp; data.ship_size_type === ShipSizeStatus.small,
          [classes.Gate]: !isWormhole,
        })}
        d={path}
        markerEnd={markerEnd}
        style={style}
      /&gt;
      &lt;path
        id={id}
        className={classes.ClickPath}
        d={path}
        markerEnd={markerEnd}
        style={style}
        onMouseEnter={() =&gt; setHovered(true)}
        onMouseLeave={() =&gt; setHovered(false)}
      /&gt;

      &lt;EdgeLabelRenderer&gt;
        &lt;div
          className={clsx(
            classes.Handle,
            { [classes.Tick]: isThickConnections, [classes.Right]: Position.Right === sourcePos },
            &apos;react-flow__handle absolute nodrag pointer-events-none&apos;,
          )}
          style={{ transform: `${MAP_TRANSLATES[sourcePos]} translate(${sx}px,${sy}px)` }}
        /&gt;
        &lt;div
          className={clsx(
            classes.Handle,
            { [classes.Tick]: isThickConnections },
            &apos;react-flow__handle absolute nodrag pointer-events-none&apos;,
          )}
          style={{ transform: `${MAP_TRANSLATES[targetPos]} translate(${tx}px,${ty}px)` }}
        /&gt;

        &lt;div
          className=&quot;absolute flex items-center gap-1 pointer-events-none&quot;
          style={{
            transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
          }}
        &gt;
          {isWormhole &amp;&amp; data.locked &amp;&amp; (
            &lt;WdTooltipWrapper
              content=&quot;Save mass&quot;
              className={clsx(
                classes.LinkLabel,
                &apos;pointer-events-auto bg-amber-300 rounded opacity-100 cursor-auto text-neutral-900&apos;,
              )}
            &gt;
              &lt;span className={clsx(PrimeIcons.LOCK, classes.icon)} /&gt;
            &lt;/WdTooltipWrapper&gt;
          )}

          {isWormhole &amp;&amp; data.ship_size_type !== ShipSizeStatus.large &amp;&amp; (
            &lt;WdTooltipWrapper
              content={SHIP_SIZES_DESCRIPTION[data.ship_size_type]}
              className={clsx(
                classes.LinkLabel,
                &apos;pointer-events-auto rounded opacity-100 cursor-auto text-neutral-900 font-bold&apos;,
                SHIP_SIZES_COLORS[data.ship_size_type],
              )}
            &gt;
              {SHIP_SIZES_NAMES_SHORT[data.ship_size_type]}
            &lt;/WdTooltipWrapper&gt;
          )}
        &lt;/div&gt;
      &lt;/EdgeLabelRenderer&gt;
    &lt;/&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemNode/index.ts">export * from &apos;./SolarSystemNodeDefault&apos;;
export * from &apos;./SolarSystemNodeTheme&apos;;</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemNode/SolarSystemKillsCounter.module.scss">.KillsBookmark {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 8px;
    font-weight: 700;
    border: 0;
    border-radius: 5px 5px 0 0;
    padding: 4px 3px;

  }
  
.KillsBookmarkWithIcon {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: -2px;
    text-shadow: 0 0 3px #000;
    padding-right: 2px;
    height: 8px;
    font-size: 8px;
    line-height: 12px;
    font-weight: 700;
    text-size-adjust: 100%;

    .pi {
        font-size: 9px;
    }

    .text {
        font-size: 9px;
        font-family: var(--rf-node-font-family, inherit) !important;
        font-weight: var(--rf-node-font-weight, inherit) !important;
    }
}

.TooltipContainer {
    background-color: #1a1a1a;
    color: #fff;
    padding: 3px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    border-radius: 2px;
    pointer-events: auto;
    max-width: 500px;
    max-height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
  }</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemNode/SolarSystemKillsCounter.tsx">import { useMemo } from &apos;react&apos;;
import { useKillsCounter } from &apos;../../hooks/useKillsCounter&apos;;
import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;
import { WithChildren, WithClassName } from &apos;@/hooks/Mapper/types/common&apos;;
import {
  KILLS_ROW_HEIGHT,
  SystemKillsList,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/WSystemKills/SystemKillsList&apos;;
import { TooltipSize } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper/utils.ts&apos;;

const MIN_TOOLTIP_HEIGHT = 40;

type KillsBookmarkTooltipProps = {
  killsCount: number;
  killsActivityType: string | null;
  systemId: string;
  className?: string;
  size?: TooltipSize;
} &amp; WithChildren &amp;
  WithClassName;

export const KillsCounter = ({
  killsCount,
  systemId,
  className,
  children,
  size = TooltipSize.xs,
}: KillsBookmarkTooltipProps) =&gt; {
  const { isLoading, kills: detailedKills } = useKillsCounter({
    realSystemId: systemId,
  });

  const limitedKills = useMemo(() =&gt; {
    if (!detailedKills || detailedKills.length === 0) return [];
    return detailedKills.slice(0, killsCount);
  }, [detailedKills, killsCount]);

  if (!killsCount || limitedKills.length === 0 || !systemId || isLoading) {
    return null;
  }

  // Calculate height based on number of kills, but ensure a minimum height
  const killsNeededHeight = limitedKills.length * KILLS_ROW_HEIGHT;
  // Add a small buffer (10px) to prevent scrollbar from appearing unnecessarily
  const tooltipHeight = Math.max(MIN_TOOLTIP_HEIGHT, Math.min(killsNeededHeight + 10, 500));

  return (
    &lt;WdTooltipWrapper
      content={
        &lt;div className=&quot;overflow-hidden flex w-[450px] flex-col&quot; style={{ height: `${tooltipHeight}px` }}&gt;
          &lt;div className=&quot;flex-1 h-full&quot;&gt;
            &lt;SystemKillsList kills={limitedKills} onlyOneSystem /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      }
      className={className}
      tooltipClassName=&quot;!px-0&quot;
      size={size}
      interactive={true}
    &gt;
      {children}
    &lt;/WdTooltipWrapper&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemNode/SolarSystemLocalCounter.module.scss">.TooltipActive {
  pointer-events: auto !important;
  position: relative;
  z-index: 3;
}

.hoverTarget {
  padding: 0.5rem;
  margin: -0.5rem;
  display: inline-block;
}

.localCounter {
  mix-blend-mode: screen;
  display: flex;
  align-items: center;
  gap: 1px;
  position: relative;
  top: 1px;
  color: var(--rf-node-local-counter);

  &amp;.hasUserCharacters {
    color: var(--rf-has-user-characters);
  }

  &amp; &gt; i {
    font-size: 9px;
    position: relative;
  }

  &amp; &gt; span {
    font-size: 9px;
    line-height: 9px;
    font-weight: var(--rf-local-counter-font-weight, 500);

    @-moz-document url-prefix() {
      position: relative;
      top: -1px;
    }
  }
}

.Pathfinder {
  .localCounter {
    @-moz-document url-prefix() {
      top: 0;
    }

    &amp; &gt; span {
      position: relative;
      top: -1px;
    }
  }
}</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemNode/SolarSystemLocalCounter.tsx">import { useMemo } from &apos;react&apos;;
import clsx from &apos;clsx&apos;;
import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;
import { TooltipPosition } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltip&apos;;
import { CharItemProps, LocalCharactersList } from &apos;../../../mapInterface/widgets/LocalCharacters/components&apos;;
import { useLocalCharactersItemTemplate } from &apos;../../../mapInterface/widgets/LocalCharacters/hooks/useLocalCharacters&apos;;
import { useLocalCharacterWidgetSettings } from &apos;../../../mapInterface/widgets/LocalCharacters/hooks/useLocalWidgetSettings&apos;;
import classes from &apos;./SolarSystemLocalCounter.module.scss&apos;;
import { useTheme } from &apos;@/hooks/Mapper/hooks/useTheme.ts&apos;;
import { AvailableThemes } from &apos;@/hooks/Mapper/mapRootProvider/types.ts&apos;;

interface LocalCounterProps {
  localCounterCharacters: Array&lt;CharItemProps&gt;;
  hasUserCharacters: boolean;
  showIcon?: boolean;
}

export const LocalCounter = ({ localCounterCharacters, hasUserCharacters, showIcon = true }: LocalCounterProps) =&gt; {
  const [settings] = useLocalCharacterWidgetSettings();
  const itemTemplate = useLocalCharactersItemTemplate(settings.showShipName);
  const theme = useTheme();

  const pilotTooltipContent = useMemo(() =&gt; {
    return (
      &lt;div
        style={{
          width: &apos;100%&apos;,
          minWidth: &apos;300px&apos;,
          overflow: &apos;hidden&apos;,
        }}
      &gt;
        &lt;LocalCharactersList items={localCounterCharacters} itemTemplate={itemTemplate} itemSize={26} autoSize={true} /&gt;
      &lt;/div&gt;
    );
  }, [localCounterCharacters, itemTemplate]);

  if (localCounterCharacters.length === 0) {
    return null;
  }

  return (
    &lt;div
      className={clsx(classes.TooltipActive, {
        [classes.Pathfinder]: theme === AvailableThemes.pathfinder,
      })}
    &gt;
      &lt;WdTooltipWrapper content={pilotTooltipContent} position={TooltipPosition.right} offset={0} interactive={true}&gt;
        &lt;div className={clsx(classes.hoverTarget)}&gt;
          &lt;div
            className={clsx(classes.localCounter, {
              [classes.hasUserCharacters]: hasUserCharacters,
            })}
          &gt;
            {showIcon &amp;&amp; &lt;i className=&quot;pi pi-users&quot; /&gt;}
            &lt;span&gt;{localCounterCharacters.length}&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/WdTooltipWrapper&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemNode/SolarSystemNodeDefault.module.scss">@import &apos;@/hooks/Mapper/components/map/styles/eve-common-variables&apos;;

$pastel-blue: #5a7d9a;
$pastel-pink: #d291bc;
$dark-bg: #2d2d2d;
$text-color: #ffffff;
$tooltip-bg: #202020;

.RootCustomNode {
  display: flex;
  width: 130px;
  height: 34px;

  font-family: var(--rf-node-font-family, inherit) !important;
  font-weight: var(--rf-node-font-weight, inherit) !important;

  flex-direction: column;
  padding: 2px 6px;
  font-size: 10px;

  background-color: var(--rf-node-bg-color, #202020) !important;
  color: var(--rf-text-color, #ffffff);

  box-shadow: 0 0 5px rgba($dark-bg, 0.5);
  border: 1px solid darken($pastel-blue, 10%);
  border-radius: 5px;
  position: relative;
  z-index: 3;
  overflow: hidden;

  &amp;.Mataria,
  &amp;.Amarria,
  &amp;.Gallente,
  &amp;.Caldaria {
    &amp;::before {
      content: &apos;&apos;;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-size: cover;
      background-position: 50% 50%;
      z-index: -1;
      background-repeat: no-repeat;
      border-radius: 3px;
    }
  }

  &amp;.Mataria {
    &amp;::before {
      background-image: url(&apos;/images/mataria-180.png&apos;);
      opacity: 0.6;
      background-position-x: 1px;
      background-position-y: -14px;
    }
  }

  &amp;.Caldaria {
    &amp;::before {
      background-image: url(&apos;/images/caldaria-180.png&apos;);
      opacity: 0.6;
      background-position-x: 1px;
      background-position-y: -10px;
    }
  }

  &amp;.Amarria {
    &amp;::before {
      opacity: 0.45;
      background-image: url(&apos;/images/amarr-180.png&apos;);
      background-position-x: 0;
      background-position-y: -13px;
    }
  }

  &amp;.Gallente {
    &amp;::before {
      opacity: 0.5;
      background-image: url(&apos;/images/gallente-180.png&apos;);
      background-position-x: 1px;
      background-position-y: 0;
    }
  }

  &amp;.selected {
    border-color: $pastel-pink;
    box-shadow: 0 0 10px #9a1af1c2;
  }

  &amp;.eve-system-status-home {
    border: 1px solid var(--eve-solar-system-status-color-home-dark30);
    background-image: linear-gradient(45deg, var(--eve-solar-system-status-color-background), transparent);
    &amp;.selected {
      border-color: var(--eve-solar-system-status-color-home);
    }
  }

  &amp;.eve-system-status-friendly {
    border: 1px solid var(--eve-solar-system-status-color-friendly-dark20);
    background-image: linear-gradient(275deg, var(--eve-solar-system-status-friendly-dark30), transparent);
    &amp;.selected {
      border-color: var(--eve-solar-system-status-color-friendly-dark5);
    }
  }

  &amp;.eve-system-status-lookingFor {
    border: 1px solid var(--eve-solar-system-status-color-lookingFor-dark15);
    background-image: linear-gradient(275deg, #45ff8f2f, #457fff2f);
    &amp;.selected {
      border-color: $pastel-pink;
    }
  }

  &amp;.eve-system-status-warning {
    background-image: linear-gradient(275deg, var(--eve-solar-system-status-warning), transparent);
  }

  &amp;.eve-system-status-dangerous {
    background-image: linear-gradient(275deg, var(--eve-solar-system-status-dangerous), transparent);
  }

  &amp;.eve-system-status-target {
    background-image: linear-gradient(275deg, var(--eve-solar-system-status-target), transparent);
  }
}

.Bookmarks {
  position: absolute;
  width: 100%;
  z-index: 1;
  display: flex;
  left: 4px;

  &amp; &gt; .Bookmark {
    min-width: 13px;
    height: 22px;
    position: relative;
    top: -13px;
    border-radius: 5px;
    color: #ffffff;
    font-size: 8px;
    text-align: center;
    padding-top: 2px;
    font-weight: bolder;
    padding-left: 3px;
    padding-right: 3px;

    &amp;:not(:first-child) {
      box-shadow: inset 4px -3px 4px rgba(0, 0, 0, 0.3);
    }
  }

  .BookmarkWithIcon {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: -2px;
    text-shadow: 0 0 3px rgba(0, 0, 0, 1);
    padding-right: 2px;

    &amp; &gt; .icon {
      width: 8px;
      height: 8px;
      font-size: 8px;
    }

    &amp; &gt; .text {
      margin-top: 1px;
      font-size: 9px;
    }
  }
}

.Unsplashed {
  position: absolute;
  width: calc(50% - 4px);
  z-index: -1;
  display: flex;
  flex-wrap: wrap;
  gap: 2px;
  left: 2px;

  &amp;--right {
    left: calc(50% + 6px);
  }

  &amp; &gt; .Signature {
    width: 13px;
    height: 4px;
    position: relative;
    top: 3px;
    border-radius: 5px;
    color: #ffffff;
    font-size: 8px;
    text-align: center;
    padding-top: 2px;
    font-weight: bolder;
    padding-left: 3px;
    padding-right: 3px;
    display: block;

    background-color: #833ca4;

    &amp;:not(:first-child) {
      box-shadow: inset 4px -3px 4px rgba(0, 0, 0, 0.3);
    }
  }
}

.icon {
  width: 8px;
  height: 8px;
  font-size: 8px;
}

.HeadRow {
  display: flex;
  align-items: center;
  gap: 3px;
  font-size: 11px;
  line-height: 14px;
  font-weight: 500;
  position: relative;
  top: 1px;

  .classTitle {
    font-size: 11px;
    font-weight: bold;
    text-shadow: 0 0 2px rgb(0 0 0 / 73%);
  }

  .TagTitle {
    font-size: 11px;
    font-weight: 500;
    text-shadow: 0 0 2px rgba(231, 146, 52, 0.73);
    color: var(--rf-tag-color, #38bdf8);
  }

  /* Firefox kostyl */
  @-moz-document url-prefix() {
    .classSystemName {
      font-weight: bold;
    }
  }
}

.BottomRow {
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 19px;

  .hasLocalCounter {
    margin-right: 2px;
    &amp;.countAbove9 {
      margin-right: 1.5rem;
    }
  }

  .lockIcon {
    font-size: 0.45rem;
    font-weight: bold;
    position: relative;
  }

  .mapMarker {
    font-size: 0.45rem;
    font-weight: bold;
    position: relative;
  }
}

.effect {
  width: 8px;
  height: 8px;
  margin-top: -2px;
  box-sizing: border-box;
  border-radius: 2px;
  margin-left: 1px;
}

.statics {
  display: flex;
  gap: 2px;
  font-size: 8px;

  &amp; &gt; * {
    line-height: 10px;
  }

  /* Firefox kostyl */
  @-moz-document url-prefix() {
    position: relative;
    top: -1px;
  }
}

.Handlers {
  position: absolute;
  z-index: 4;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.Handle {
  min-width: initial;
  min-height: initial;
  border: 1px solid $pastel-blue;
  width: 5px;
  height: 5px;
  pointer-events: auto;

  &amp;.selected {
    border-color: $pastel-pink;
  }

  &amp;.HandleTop {
    top: -2px;
  }

  &amp;.HandleRight {
    right: -2px;
  }

  &amp;.HandleBottom {
    bottom: -2px;
  }

  &amp;.HandleLeft {
    left: -2px;
  }

  &amp;.Tick {
    width: 7px;
    height: 7px;

    &amp;.HandleTop {
      top: -3px;
    }

    &amp;.HandleRight {
      right: -3px;
    }

    &amp;.HandleBottom {
      bottom: -3px;
    }

    &amp;.HandleLeft {
      left: -3px;
    }
  }
}

.ShatteredIcon {
  position: relative;
  //top: -1px;
  left: -1px;

  background-size: 100%;
  background-repeat: no-repeat;
  background-position: center;

  background-image: url(/images/chart-network-svgrepo-com.svg)
}</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemNode/SolarSystemNodeDefault.tsx">import { memo } from &apos;react&apos;;
import { MapSolarSystemType } from &apos;../../map.types&apos;;
import { Handle, NodeProps, Position } from &apos;reactflow&apos;;
import clsx from &apos;clsx&apos;;
import classes from &apos;./SolarSystemNodeDefault.module.scss&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { useLocalCounter, useNodeKillsCount, useSolarSystemNode } from &apos;../../hooks&apos;;
import {
  EFFECT_BACKGROUND_STYLES,
  MARKER_BOOKMARK_BG_STYLES,
  STATUS_CLASSES,
} from &apos;@/hooks/Mapper/components/map/constants&apos;;
import { WormholeClassComp } from &apos;@/hooks/Mapper/components/map/components/WormholeClassComp&apos;;
import { UnsplashedSignature } from &apos;@/hooks/Mapper/components/map/components/UnsplashedSignature&apos;;
import { LocalCounter } from &apos;./SolarSystemLocalCounter&apos;;
import { KillsCounter } from &apos;./SolarSystemKillsCounter&apos;;
import { TooltipSize } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper/utils.ts&apos;;
import { TooltipPosition, WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { Tag } from &apos;primereact/tag&apos;;

// let render = 0;
export const SolarSystemNodeDefault = memo((props: NodeProps&lt;MapSolarSystemType&gt;) =&gt; {
  const nodeVars = useSolarSystemNode(props);
  const { localCounterCharacters } = useLocalCounter(nodeVars);
  const localKillsCount = useNodeKillsCount(nodeVars.solarSystemId, nodeVars.killsCount);

  // console.log(&apos;JOipP&apos;, `render ${nodeVars.id}`, render++);

  return (
    &lt;&gt;
      {nodeVars.visible &amp;&amp; (
        &lt;div className={classes.Bookmarks}&gt;
          {nodeVars.isShattered &amp;&amp; (
            &lt;div className={clsx(classes.Bookmark, MARKER_BOOKMARK_BG_STYLES.shattered, &apos;!pr-[2px]&apos;)}&gt;
              &lt;WdTooltipWrapper content=&quot;Shattered&quot; position={TooltipPosition.top}&gt;
                &lt;span className={clsx(&apos;block w-[10px] h-[10px]&apos;, classes.ShatteredIcon)} /&gt;
              &lt;/WdTooltipWrapper&gt;
            &lt;/div&gt;
          )}

          {localKillsCount &amp;&amp; localKillsCount &gt; 0 &amp;&amp; nodeVars.solarSystemId &amp;&amp; (
            &lt;KillsCounter
              killsCount={localKillsCount}
              systemId={nodeVars.solarSystemId}
              size={TooltipSize.lg}
              killsActivityType={nodeVars.killsActivityType}
              className={clsx(classes.Bookmark, MARKER_BOOKMARK_BG_STYLES[nodeVars.killsActivityType!])}
            &gt;
              &lt;div className={clsx(classes.BookmarkWithIcon)}&gt;
                &lt;span className={clsx(PrimeIcons.BOLT, classes.icon)} /&gt;
                &lt;span className={clsx(classes.text)}&gt;{nodeVars.killsCount}&lt;/span&gt;
              &lt;/div&gt;
            &lt;/KillsCounter&gt;
          )}

          {nodeVars.labelCustom !== &apos;&apos; &amp;&amp; (
            &lt;div className={clsx(classes.Bookmark, MARKER_BOOKMARK_BG_STYLES.custom)}&gt;
              &lt;span className=&quot;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)]&quot;&gt;{nodeVars.labelCustom}&lt;/span&gt;
            &lt;/div&gt;
          )}

          {nodeVars.labelsInfo.map(x =&gt; (
            &lt;div key={x.id} className={clsx(classes.Bookmark, MARKER_BOOKMARK_BG_STYLES[x.id])}&gt;
              {x.shortName}
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
      )}

      &lt;div
        className={clsx(
          classes.RootCustomNode,
          nodeVars.regionClass &amp;&amp; classes[nodeVars.regionClass],
          nodeVars.status !== undefined ? classes[STATUS_CLASSES[nodeVars.status]] : &apos;&apos;,
          { [classes.selected]: nodeVars.selected },
        )}
        onMouseDownCapture={e =&gt; nodeVars.dbClick(e)}
      &gt;
        {nodeVars.visible &amp;&amp; (
          &lt;&gt;
            &lt;div className={classes.HeadRow}&gt;
              &lt;div
                className={clsx(
                  classes.classTitle,
                  nodeVars.classTitleColor,
                  &apos;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)]&apos;,
                )}
              &gt;
                {nodeVars.classTitle ?? &apos;-&apos;}
              &lt;/div&gt;

              {nodeVars.tag != null &amp;&amp; nodeVars.tag !== &apos;&apos; &amp;&amp; (
                &lt;Tag
                  value={nodeVars.tag}
                  severity=&quot;warning&quot;
                  className=&quot;py-0 px-[2px] text-[9px] [&amp;_.p-tag-value]:leading-[1.3]&quot;
                &gt;&lt;/Tag&gt;
              )}

              &lt;div
                className={clsx(
                  classes.classSystemName,
                  &apos;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)] flex-grow overflow-hidden text-ellipsis whitespace-nowrap font-sans&apos;,
                )}
              &gt;
                {nodeVars.systemName}
              &lt;/div&gt;

              {nodeVars.isWormhole &amp;&amp; (
                &lt;div className={classes.statics}&gt;
                  {nodeVars.sortedStatics.map(whClass =&gt; (
                    &lt;WormholeClassComp key={String(whClass)} id={String(whClass)} /&gt;
                  ))}
                &lt;/div&gt;
              )}

              {nodeVars.effectName !== null &amp;&amp; nodeVars.isWormhole &amp;&amp; (
                &lt;div className={clsx(classes.effect, EFFECT_BACKGROUND_STYLES[nodeVars.effectName])} /&gt;
              )}
            &lt;/div&gt;

            &lt;div className={clsx(classes.BottomRow, &apos;flex items-center justify-between&apos;)}&gt;
              {nodeVars.customName &amp;&amp; (
                &lt;div className=&quot;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)] text-blue-300 whitespace-nowrap overflow-hidden text-ellipsis mr-0.5&quot;&gt;
                  {nodeVars.customName}
                &lt;/div&gt;
              )}

              {!nodeVars.isWormhole &amp;&amp; !nodeVars.customName &amp;&amp; (
                &lt;div className=&quot;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)] text-stone-300 whitespace-nowrap overflow-hidden text-ellipsis mr-0.5&quot;&gt;
                  {nodeVars.regionName}
                &lt;/div&gt;
              )}

              {nodeVars.isWormhole &amp;&amp; !nodeVars.customName &amp;&amp; &lt;div /&gt;}

              &lt;div className=&quot;flex items-center gap-1 justify-end&quot;&gt;
                &lt;div className={clsx(&apos;flex items-center gap-1&apos;)}&gt;
                  {nodeVars.locked &amp;&amp; &lt;i className={clsx(PrimeIcons.LOCK, classes.lockIcon)} /&gt;}
                  {nodeVars.hubs.includes(nodeVars.solarSystemId) &amp;&amp; (
                    &lt;i className={clsx(PrimeIcons.MAP_MARKER, classes.mapMarker)} /&gt;
                  )}
                &lt;/div&gt;

                &lt;LocalCounter
                  hasUserCharacters={nodeVars.hasUserCharacters}
                  localCounterCharacters={localCounterCharacters}
                /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/&gt;
        )}
      &lt;/div&gt;

      {nodeVars.visible &amp;&amp; (
        &lt;&gt;
          {nodeVars.unsplashedLeft.length &gt; 0 &amp;&amp; (
            &lt;div className={classes.Unsplashed}&gt;
              {nodeVars.unsplashedLeft.map(sig =&gt; (
                &lt;UnsplashedSignature key={sig.eve_id} signature={sig} /&gt;
              ))}
            &lt;/div&gt;
          )}

          {nodeVars.unsplashedRight.length &gt; 0 &amp;&amp; (
            &lt;div className={clsx(classes.Unsplashed, classes[&apos;Unsplashed--right&apos;])}&gt;
              {nodeVars.unsplashedRight.map(sig =&gt; (
                &lt;UnsplashedSignature key={sig.eve_id} signature={sig} /&gt;
              ))}
            &lt;/div&gt;
          )}
        &lt;/&gt;
      )}

      &lt;div className={classes.Handlers}&gt;
        &lt;Handle
          type=&quot;source&quot;
          className={clsx(classes.Handle, classes.HandleTop, {
            [classes.selected]: nodeVars.selected,
            [classes.Tick]: nodeVars.isThickConnections,
          })}
          style={{ visibility: nodeVars.showHandlers ? &apos;visible&apos; : &apos;hidden&apos; }}
          position={Position.Top}
          id=&quot;a&quot;
        /&gt;
        &lt;Handle
          type=&quot;source&quot;
          className={clsx(classes.Handle, classes.HandleRight, {
            [classes.selected]: nodeVars.selected,
            [classes.Tick]: nodeVars.isThickConnections,
          })}
          style={{ visibility: nodeVars.showHandlers ? &apos;visible&apos; : &apos;hidden&apos; }}
          position={Position.Right}
          id=&quot;b&quot;
        /&gt;
        &lt;Handle
          type=&quot;source&quot;
          className={clsx(classes.Handle, classes.HandleBottom, {
            [classes.selected]: nodeVars.selected,
            [classes.Tick]: nodeVars.isThickConnections,
          })}
          style={{ visibility: nodeVars.showHandlers ? &apos;visible&apos; : &apos;hidden&apos; }}
          position={Position.Bottom}
          id=&quot;c&quot;
        /&gt;
        &lt;Handle
          type=&quot;source&quot;
          className={clsx(classes.Handle, classes.HandleLeft, {
            [classes.selected]: nodeVars.selected,
            [classes.Tick]: nodeVars.isThickConnections,
          })}
          style={{ visibility: nodeVars.showHandlers ? &apos;visible&apos; : &apos;hidden&apos; }}
          position={Position.Left}
          id=&quot;d&quot;
        /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
});

SolarSystemNodeDefault.displayName = &apos;SolarSystemNodeDefault&apos;;</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemNode/SolarSystemNodeTheme.module.scss">@import &apos;./SolarSystemNodeDefault.module.scss&apos;;

/* ---------------------------------------------
   Only override what&apos;s different from the base
   Currently none required
---------------------------------------------- */

.RootCustomNode {
  &amp;.eve-system-status-home {
    border: 1px solid var(--eve-solar-system-status-color-home-dark30);
    background-image: linear-gradient(
        275deg,
        var(--eve-solar-system-status-home),
        transparent
    );
    &amp;.selected {
      border-color: var(--eve-solar-system-status-color-home);
    }
  }
}</file><file path="assets/js/hooks/Mapper/components/map/components/SolarSystemNode/SolarSystemNodeTheme.tsx">import { memo } from &apos;react&apos;;
import { MapSolarSystemType } from &apos;../../map.types&apos;;
import { Handle, NodeProps, Position } from &apos;reactflow&apos;;
import clsx from &apos;clsx&apos;;
import classes from &apos;./SolarSystemNodeTheme.module.scss&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { useLocalCounter, useNodeKillsCount, useSolarSystemNode } from &apos;../../hooks&apos;;
import {
  EFFECT_BACKGROUND_STYLES,
  MARKER_BOOKMARK_BG_STYLES,
  STATUS_CLASSES,
} from &apos;@/hooks/Mapper/components/map/constants&apos;;
import { WormholeClassComp } from &apos;@/hooks/Mapper/components/map/components/WormholeClassComp&apos;;
import { UnsplashedSignature } from &apos;@/hooks/Mapper/components/map/components/UnsplashedSignature&apos;;
import { LocalCounter } from &apos;./SolarSystemLocalCounter&apos;;
import { KillsCounter } from &apos;./SolarSystemKillsCounter&apos;;
import { TooltipPosition, WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { TooltipSize } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper/utils.ts&apos;;

// let render = 0;
export const SolarSystemNodeTheme = memo((props: NodeProps&lt;MapSolarSystemType&gt;) =&gt; {
  const nodeVars = useSolarSystemNode(props);
  const { localCounterCharacters } = useLocalCounter(nodeVars);
  const localKillsCount = useNodeKillsCount(nodeVars.solarSystemId, nodeVars.killsCount);

  // console.log(&apos;JOipP&apos;, `render ${nodeVars.id}`, render++);

  return (
    &lt;&gt;
      {nodeVars.visible &amp;&amp; (
        &lt;div className={classes.Bookmarks}&gt;
          {nodeVars.isShattered &amp;&amp; (
            &lt;div className={clsx(classes.Bookmark, MARKER_BOOKMARK_BG_STYLES.shattered, &apos;!pr-[2px]&apos;)}&gt;
              &lt;WdTooltipWrapper content=&quot;Shattered&quot; position={TooltipPosition.top}&gt;
                &lt;span className={clsx(&apos;block w-[10px] h-[10px]&apos;, classes.ShatteredIcon)} /&gt;
              &lt;/WdTooltipWrapper&gt;
            &lt;/div&gt;
          )}

          {localKillsCount &amp;&amp; localKillsCount &gt; 0 &amp;&amp; nodeVars.solarSystemId &amp;&amp; (
            &lt;KillsCounter
              killsCount={localKillsCount}
              systemId={nodeVars.solarSystemId}
              size={TooltipSize.lg}
              killsActivityType={nodeVars.killsActivityType}
              className={clsx(classes.Bookmark, MARKER_BOOKMARK_BG_STYLES[nodeVars.killsActivityType!])}
            &gt;
              &lt;div className={clsx(classes.BookmarkWithIcon)}&gt;
                &lt;span className={clsx(PrimeIcons.BOLT, classes.icon)} /&gt;
                &lt;span className={clsx(classes.text)}&gt;{nodeVars.killsCount}&lt;/span&gt;
              &lt;/div&gt;
            &lt;/KillsCounter&gt;
          )}

          {nodeVars.labelCustom !== &apos;&apos; &amp;&amp; (
            &lt;div className={clsx(classes.Bookmark, MARKER_BOOKMARK_BG_STYLES.custom)}&gt;
              &lt;span className=&quot;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)]&quot;&gt;{nodeVars.labelCustom}&lt;/span&gt;
            &lt;/div&gt;
          )}

          {nodeVars.labelsInfo.map(x =&gt; (
            &lt;div key={x.id} className={clsx(classes.Bookmark, MARKER_BOOKMARK_BG_STYLES[x.id])}&gt;
              {x.shortName}
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
      )}

      &lt;div
        className={clsx(
          classes.RootCustomNode,
          nodeVars.regionClass &amp;&amp; classes[nodeVars.regionClass],
          nodeVars.status !== undefined ? classes[STATUS_CLASSES[nodeVars.status]] : &apos;&apos;,
          { [classes.selected]: nodeVars.selected },
        )}
        onMouseDownCapture={e =&gt; nodeVars.dbClick(e)}
      &gt;
        {nodeVars.visible &amp;&amp; (
          &lt;&gt;
            &lt;div className={classes.HeadRow}&gt;
              &lt;div
                className={clsx(
                  classes.classTitle,
                  nodeVars.classTitleColor,
                  &apos;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)]&apos;,
                )}
              &gt;
                {nodeVars.classTitle ?? &apos;-&apos;}
              &lt;/div&gt;

              {nodeVars.tag != null &amp;&amp; nodeVars.tag !== &apos;&apos; &amp;&amp; (
                &lt;div className={clsx(classes.TagTitle)}&gt;{nodeVars.tag}&lt;/div&gt;
              )}

              &lt;div
                className={clsx(
                  classes.classSystemName,
                  &apos;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)] flex-grow overflow-hidden text-ellipsis whitespace-nowrap&apos;,
                )}
              &gt;
                {nodeVars.systemName}
              &lt;/div&gt;

              {nodeVars.isWormhole &amp;&amp; (
                &lt;div className={classes.statics}&gt;
                  {nodeVars.sortedStatics.map(whClass =&gt; (
                    &lt;WormholeClassComp key={String(whClass)} id={String(whClass)} /&gt;
                  ))}
                &lt;/div&gt;
              )}

              {nodeVars.effectName !== null &amp;&amp; nodeVars.isWormhole &amp;&amp; (
                &lt;div className={clsx(classes.effect, EFFECT_BACKGROUND_STYLES[nodeVars.effectName])} /&gt;
              )}
            &lt;/div&gt;

            &lt;div className={clsx(classes.BottomRow, &apos;flex items-center justify-between&apos;)}&gt;
              {nodeVars.customName &amp;&amp; (
                &lt;div
                  className={clsx(
                    classes.CustomName,
                    &apos;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)] whitespace-nowrap overflow-hidden text-ellipsis mr-0.5&apos;,
                  )}
                &gt;
                  {nodeVars.customName}
                &lt;/div&gt;
              )}

              {!nodeVars.isWormhole &amp;&amp; !nodeVars.customName &amp;&amp; (
                &lt;div
                  className={clsx(
                    classes.RegionName,
                    &apos;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)] whitespace-nowrap overflow-hidden text-ellipsis mr-0.5&apos;,
                  )}
                &gt;
                  {nodeVars.regionName}
                &lt;/div&gt;
              )}

              {nodeVars.isWormhole &amp;&amp; !nodeVars.customName &amp;&amp; &lt;div /&gt;}

              &lt;div className=&quot;flex items-center gap-1 justify-end&quot;&gt;
                &lt;div className={clsx(&apos;flex items-center gap-1&apos;)}&gt;
                  {nodeVars.locked &amp;&amp; &lt;i className={clsx(PrimeIcons.LOCK, classes.lockIcon)} /&gt;}
                  {nodeVars.hubs.includes(nodeVars.solarSystemId) &amp;&amp; (
                    &lt;i className={clsx(PrimeIcons.MAP_MARKER, classes.mapMarker)} /&gt;
                  )}
                &lt;/div&gt;

                &lt;LocalCounter
                  hasUserCharacters={nodeVars.hasUserCharacters}
                  localCounterCharacters={localCounterCharacters}
                /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/&gt;
        )}
      &lt;/div&gt;

      {nodeVars.visible &amp;&amp; (
        &lt;&gt;
          {nodeVars.unsplashedLeft.length &gt; 0 &amp;&amp; (
            &lt;div className={classes.Unsplashed}&gt;
              {nodeVars.unsplashedLeft.map(sig =&gt; (
                &lt;UnsplashedSignature key={sig.eve_id} signature={sig} /&gt;
              ))}
            &lt;/div&gt;
          )}

          {nodeVars.unsplashedRight.length &gt; 0 &amp;&amp; (
            &lt;div className={clsx(classes.Unsplashed, classes[&apos;Unsplashed--right&apos;])}&gt;
              {nodeVars.unsplashedRight.map(sig =&gt; (
                &lt;UnsplashedSignature key={sig.eve_id} signature={sig} /&gt;
              ))}
            &lt;/div&gt;
          )}
        &lt;/&gt;
      )}

      &lt;div className={classes.Handlers}&gt;
        &lt;Handle
          type=&quot;source&quot;
          className={clsx(classes.Handle, classes.HandleTop, {
            [classes.selected]: nodeVars.selected,
            [classes.Tick]: nodeVars.isThickConnections,
          })}
          style={{ visibility: nodeVars.showHandlers ? &apos;visible&apos; : &apos;hidden&apos; }}
          position={Position.Top}
          id=&quot;a&quot;
        /&gt;
        &lt;Handle
          type=&quot;source&quot;
          className={clsx(classes.Handle, classes.HandleRight, {
            [classes.selected]: nodeVars.selected,
            [classes.Tick]: nodeVars.isThickConnections,
          })}
          style={{ visibility: nodeVars.showHandlers ? &apos;visible&apos; : &apos;hidden&apos; }}
          position={Position.Right}
          id=&quot;b&quot;
        /&gt;
        &lt;Handle
          type=&quot;source&quot;
          className={clsx(classes.Handle, classes.HandleBottom, {
            [classes.selected]: nodeVars.selected,
            [classes.Tick]: nodeVars.isThickConnections,
          })}
          style={{ visibility: nodeVars.showHandlers ? &apos;visible&apos; : &apos;hidden&apos; }}
          position={Position.Bottom}
          id=&quot;c&quot;
        /&gt;
        &lt;Handle
          type=&quot;source&quot;
          className={clsx(classes.Handle, classes.HandleLeft, {
            [classes.selected]: nodeVars.selected,
            [classes.Tick]: nodeVars.isThickConnections,
          })}
          style={{ visibility: nodeVars.showHandlers ? &apos;visible&apos; : &apos;hidden&apos; }}
          position={Position.Left}
          id=&quot;d&quot;
        /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
});

SolarSystemNodeTheme.displayName = &apos;SolarSystemNodeTheme&apos;;</file><file path="assets/js/hooks/Mapper/components/map/components/UnsplashedSignature/index.ts">export * from &apos;./UnsplashedSignature.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/map/components/UnsplashedSignature/UnsplashedSignature.module.scss">@import &apos;@/hooks/Mapper/components/map/styles/eve-common-variables&apos;;

.Signature {
  position: relative;
  top: 3px;
  display: block;

  &amp; &gt; .Box {
    width: 13px;
    height: 4px;
    border-radius: 4px;
    color: var(--text-color);
    font-size: 8px;
    text-align: center;
    font-weight: bolder;
    display: block;
  }

  &amp; &gt; .Eol {
    display: block;
  }
}</file><file path="assets/js/hooks/Mapper/components/map/components/UnsplashedSignature/UnsplashedSignature.tsx">import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;
import { InfoDrawer } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

import classes from &apos;./UnsplashedSignature.module.scss&apos;;
import { SystemSignature } from &apos;@/hooks/Mapper/types/signatures&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { WORMHOLE_CLASS_STYLES, WORMHOLES_ADDITIONAL_INFO } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { useMemo } from &apos;react&apos;;
import clsx from &apos;clsx&apos;;
import { renderInfoColumn } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders&apos;;
import { K162_TYPES_MAP } from &apos;@/hooks/Mapper/constants.ts&apos;;
import { parseSignatureCustomInfo } from &apos;@/hooks/Mapper/helpers/parseSignatureCustomInfo.ts&apos;;

interface UnsplashedSignatureProps {
  signature: SystemSignature;
}
export const UnsplashedSignature = ({ signature }: UnsplashedSignatureProps) =&gt; {
  const {
    data: { wormholesData },
  } = useMapRootState();

  const whData = useMemo(() =&gt; wormholesData[signature.type], [signature.type, wormholesData]);
  const whClass = useMemo(() =&gt; (whData ? WORMHOLES_ADDITIONAL_INFO[whData.dest] : null), [whData]);

  const customInfo = useMemo(() =&gt; {
    return parseSignatureCustomInfo(signature.custom_info);
  }, [signature]);

  const k162TypeOption = useMemo(() =&gt; {
    if (!customInfo?.k162Type) {
      return null;
    }

    return K162_TYPES_MAP[customInfo.k162Type];
  }, [customInfo]);

  const isEOL = useMemo(() =&gt; {
    return customInfo?.isEOL;
  }, [customInfo]);

  const whClassStyle = useMemo(() =&gt; {
    if (signature.type === &apos;K162&apos; &amp;&amp; k162TypeOption) {
      const k162Data = wormholesData[k162TypeOption.whClassName];
      const k162Class = k162Data ? WORMHOLES_ADDITIONAL_INFO[k162Data.dest] : null;
      return k162Class ? WORMHOLE_CLASS_STYLES[k162Class.wormholeClassID] : &apos;&apos;;
    }
    return whClass ? WORMHOLE_CLASS_STYLES[whClass.wormholeClassID] : &apos;&apos;;
  }, [signature, whClass, k162TypeOption, wormholesData]);

  return (
    &lt;WdTooltipWrapper
      className={clsx(classes.Signature)}
      // @ts-ignore
      content={
        &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
          &lt;InfoDrawer title={&lt;b className=&quot;text-slate-50&quot;&gt;{signature.eve_id}&lt;/b&gt;}&gt;
            {renderInfoColumn(signature)}
          &lt;/InfoDrawer&gt;
        &lt;/div&gt;
      }
    &gt;
      &lt;div className={clsx(classes.Box, whClassStyle)}&gt;
        &lt;svg width=&quot;13&quot; height=&quot;8&quot; viewBox=&quot;0 0 13 8&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
          &lt;rect y=&quot;1&quot; width=&quot;13&quot; height=&quot;4&quot; rx=&quot;2&quot; className={whClassStyle} fill=&quot;currentColor&quot; /&gt;
          {isEOL &amp;&amp; &lt;rect x=&quot;4&quot; width=&quot;5&quot; height=&quot;6&quot; rx=&quot;1&quot; className={clsx(classes.Eol)} fill=&quot;#a153ac&quot; /&gt;}
        &lt;/svg&gt;
      &lt;/div&gt;
    &lt;/WdTooltipWrapper&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/map/components/WormholeClassComp/index.ts">export * from &apos;./WormholeClassComp.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/map/components/WormholeClassComp/WormholeClassComp.tsx">import { useMapState } from &apos;@/hooks/Mapper/components/map/MapProvider.tsx&apos;;
import { WORMHOLE_CLASS_STYLES, WORMHOLES_ADDITIONAL_INFO } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import clsx from &apos;clsx&apos;;

interface WormholeClassComp {
  id: string;
}
export const WormholeClassComp = ({ id }: WormholeClassComp) =&gt; {
  const {
    data: { wormholesData },
  } = useMapState();

  const wormholeData = wormholesData[id];
  const wormholeDataAdditional = WORMHOLES_ADDITIONAL_INFO[wormholeData.dest];

  if (!wormholeData || !wormholeDataAdditional) {
    return null;
  }

  const colorClass = WORMHOLE_CLASS_STYLES[wormholeDataAdditional.wormholeClassID.toString()];
  return (
    &lt;div className={clsx(colorClass, &apos;[text-shadow:_0_1px_0_rgb(0_0_0_/_40%)]&apos;)}&gt;
      {wormholeDataAdditional.shortName}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/map/components/index.ts">export * from &apos;./ContextMenuRoot&apos;;
export * from &apos;./ContextMenuConnection&apos;;
export * from &apos;../../contexts/ContextMenuSystemMultiple&apos;;
export * from &apos;./SolarSystemEdge&apos;;
export * from &apos;./SolarSystemNode&apos;;</file><file path="assets/js/hooks/Mapper/components/map/helpers/convertConnection2Edge.ts">import { SolarSystemConnection } from &apos;@/hooks/Mapper/types/connection.ts&apos;;

export const convertConnection2Edge = (conn: SolarSystemConnection) =&gt; {
  return {
    sourceHandle: &apos;c&apos;,
    targetHandle: &apos;a&apos;,
    type: &apos;floating&apos;,
    label: &apos;updatable edge&apos;,

    id: conn.id,
    source: conn.source,
    target: conn.target,
    data: conn,
  };
};</file><file path="assets/js/hooks/Mapper/components/map/helpers/convertSystem2Node.ts">import { SolarSystemRawType } from &apos;@/hooks/Mapper/types/system.ts&apos;;
import { Node } from &apos;reactflow&apos;;

export const convertSystem2Node = (sys: SolarSystemRawType): Node =&gt; {
  return {
    type: &apos;custom&apos;,
    width: 130,
    height: 34,
    id: sys.id,
    position: sys.position,
    data: sys,
    draggable: !sys.locked,
    deletable: !sys.locked,
  };
};</file><file path="assets/js/hooks/Mapper/components/map/helpers/getBackgroundClass.ts">import { isZarzakhSpace } from &apos;@/hooks/Mapper/components/map/helpers/isZarzakhSpace.ts&apos;;
import {
  SECURITY_BACKGROUND_CLASSES,
  SYSTEM_CLASS_BACKGROUND_CLASSES,
  WORMHOLE_CLASS_BACKGROUND_CLASSES,
} from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { isKnownSpace } from &apos;@/hooks/Mapper/components/map/helpers/isKnownSpace.ts&apos;;
import { isWormholeSpace } from &apos;@/hooks/Mapper/components/map/helpers/isWormholeSpace.ts&apos;;

export const getBackgroundClass = (systemClass: number, security: string) =&gt; {
  if (isZarzakhSpace(systemClass)) {
    return SYSTEM_CLASS_BACKGROUND_CLASSES[systemClass];
  } else if (isKnownSpace(systemClass)) {
    return SECURITY_BACKGROUND_CLASSES[security];
  } else if (isWormholeSpace(systemClass)) {
    return WORMHOLE_CLASS_BACKGROUND_CLASSES[systemClass];
  } else {
    return SYSTEM_CLASS_BACKGROUND_CLASSES[systemClass];
  }
};</file><file path="assets/js/hooks/Mapper/components/map/helpers/getShapeClass.ts">import { isKnownSpace } from &apos;./isKnownSpace.ts&apos;;
import { isWormholeSpace } from &apos;./isWormholeSpace.ts&apos;;
import { isPochvenSpace } from &apos;./isPochvenSpace.ts&apos;;
import { isTriglavianInvasion } from &apos;./isTriglavianInvasion.ts&apos;;

export const getShapeClass = (systemClass: number, triglavianInvasionStatus: string) =&gt; {
  if (isPochvenSpace(systemClass) || (isKnownSpace(systemClass) &amp;&amp; isTriglavianInvasion(triglavianInvasionStatus))) {
    return &apos;wd-route-system-shape-triangle&apos;;
  }

  if (isWormholeSpace(systemClass)) {
    return &apos;wd-route-system-shape-circle&apos;;
  }

  return &apos;&apos;;
};</file><file path="assets/js/hooks/Mapper/components/map/helpers/getSystemClassStyles.ts">import { isKnownSpace } from &apos;@/hooks/Mapper/components/map/helpers/isKnownSpace.ts&apos;;
import {
  SECURITY_FOREGROUND_CLASSES,
  SYSTEM_CLASS_STYLES,
  WORMHOLE_CLASS_STYLES,
} from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { isWormholeSpace } from &apos;@/hooks/Mapper/components/map/helpers/isWormholeSpace.ts&apos;;
import { SolarSystemStaticInfo } from &apos;@/hooks/Mapper/types&apos;;

type SystemClassStylesProps = Pick&lt;SolarSystemStaticInfo, &apos;systemClass&apos; | &apos;security&apos;&gt;;

export const getSystemClassStyles = ({ systemClass, security }: SystemClassStylesProps) =&gt; {
  if (isKnownSpace(systemClass)) {
    return SECURITY_FOREGROUND_CLASSES[security];
  }

  if (isWormholeSpace(systemClass)) {
    return WORMHOLE_CLASS_STYLES[systemClass];
  }

  return SYSTEM_CLASS_STYLES[systemClass];
};</file><file path="assets/js/hooks/Mapper/components/map/helpers/getThemeBehavior.ts">import { SolarSystemNodeDefault, SolarSystemNodeTheme } from &apos;../components/SolarSystemNode&apos;;
import type { NodeProps } from &apos;reactflow&apos;;
import type { ComponentType } from &apos;react&apos;;
import { MapSolarSystemType } from &apos;../map.types&apos;;
import { ConnectionMode } from &apos;reactflow&apos;;

export type SolarSystemNodeComponent = ComponentType&lt;NodeProps&lt;MapSolarSystemType&gt;&gt;;

interface ThemeBehavior {
  isPanAndDrag: boolean;
  nodeComponent: SolarSystemNodeComponent;
  connectionMode: ConnectionMode;
}

const THEME_BEHAVIORS: {
  [key: string]: ThemeBehavior;
} = {
  default: {
    isPanAndDrag: false,
    nodeComponent: SolarSystemNodeDefault,
    connectionMode: ConnectionMode.Loose,
  },
  pathfinder: {
    isPanAndDrag: true,
    nodeComponent: SolarSystemNodeTheme,
    connectionMode: ConnectionMode.Loose,
  },
};

export function getBehaviorForTheme(themeName: string) {
  return THEME_BEHAVIORS[themeName] ?? THEME_BEHAVIORS.default;
}</file><file path="assets/js/hooks/Mapper/components/map/helpers/index.ts">export * from &apos;./convertConnection2Edge&apos;;
export * from &apos;./convertSystem2Node&apos;;
export * from &apos;./getSystemClassStyles&apos;;
export * from &apos;./getShapeClass&apos;;
export * from &apos;./getBackgroundClass&apos;;
export * from &apos;./prepareUnsplashedChunks&apos;;</file><file path="assets/js/hooks/Mapper/components/map/helpers/isKnownSpace.ts">import { SOLAR_SYSTEM_CLASS_IDS } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;

export const isKnownSpace = (wormholeClassID: number) =&gt; {
  switch (wormholeClassID) {
    case SOLAR_SYSTEM_CLASS_IDS.hs:
    case SOLAR_SYSTEM_CLASS_IDS.ls:
    case SOLAR_SYSTEM_CLASS_IDS.ns:
    case SOLAR_SYSTEM_CLASS_IDS.zarzakh:
      return true;
  }

  return false;
};

export const isPossibleSpace = (spaces: number[], wormholeClassID: number) =&gt; {
  return spaces.includes(wormholeClassID);
};</file><file path="assets/js/hooks/Mapper/components/map/helpers/isPochvenSpace.ts">import { SOLAR_SYSTEM_CLASS_IDS } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;

export const isPochvenSpace = (wormholeClassID: number) =&gt; {
  switch (wormholeClassID) {
    case SOLAR_SYSTEM_CLASS_IDS.pochven:
      return true;
  }

  return false;
};</file><file path="assets/js/hooks/Mapper/components/map/helpers/isTriglavianInvasion.ts">export const isTriglavianInvasion = (triglavianInvasionStatus: string) =&gt; {
  switch (triglavianInvasionStatus) {
    case &apos;Normal&apos;:
      return false;
    case &apos;Final&apos;:
    case &apos;Edencom&apos;:
    case &apos;Triglavian&apos;:
      return true;
  }
};</file><file path="assets/js/hooks/Mapper/components/map/helpers/isWormholeSpace.ts">import { SOLAR_SYSTEM_CLASS_IDS } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;

export const isWormholeSpace = (wormholeClassID: number) =&gt; {
  switch (wormholeClassID) {
    case SOLAR_SYSTEM_CLASS_IDS.c1:
    case SOLAR_SYSTEM_CLASS_IDS.c2:
    case SOLAR_SYSTEM_CLASS_IDS.c3:
    case SOLAR_SYSTEM_CLASS_IDS.c4:
    case SOLAR_SYSTEM_CLASS_IDS.c5:
    case SOLAR_SYSTEM_CLASS_IDS.c6:
    case SOLAR_SYSTEM_CLASS_IDS.c13:
    case SOLAR_SYSTEM_CLASS_IDS.thera:
    case SOLAR_SYSTEM_CLASS_IDS.barbican:
    case SOLAR_SYSTEM_CLASS_IDS.vidette:
    case SOLAR_SYSTEM_CLASS_IDS.conflux:
    case SOLAR_SYSTEM_CLASS_IDS.redoubt:
    case SOLAR_SYSTEM_CLASS_IDS.sentinel:
      return true;
  }

  return false;
};</file><file path="assets/js/hooks/Mapper/components/map/helpers/isZarzakhSpace.ts">import { SOLAR_SYSTEM_CLASS_IDS } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;

export const isZarzakhSpace = (wormholeClassID: number) =&gt; {
  switch (wormholeClassID) {
    case SOLAR_SYSTEM_CLASS_IDS.zarzakh:
      return true;
  }

  return false;
};</file><file path="assets/js/hooks/Mapper/components/map/helpers/prepareUnsplashedChunks.ts">// Helper function to split an array into chunks of size
const chunkArray = (array: any[], size: number) =&gt; {
  const chunks = [];
  for (let i = 0; i &lt; array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
};

export const prepareUnsplashedChunks = (items: any[]) =&gt; {
  // Split the items into chunks of 4
  const chunks = chunkArray(items, 4);

  // Get the column elements
  const leftColumn: any[] = [];
  const rightColumn: any[] = [];

  chunks.forEach((chunk, index) =&gt; {
    const column = index % 2 === 0 ? leftColumn : rightColumn;

    chunk.forEach(item =&gt; {
      column.push(item);
    });
  });

  return [leftColumn, rightColumn];
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/api/index.ts">export * from &apos;./useMapInit&apos;;
export * from &apos;./useMapAddSystems&apos;;
export * from &apos;./useMapUpdateSystems&apos;;
export * from &apos;./useMapRemoveSystems&apos;;
export * from &apos;./useCommandsCharacters&apos;;
export * from &apos;./useCommandsConnections&apos;;
export * from &apos;./useCommandsConnections&apos;;
export * from &apos;./useCenterSystem&apos;;
export * from &apos;./useSelectSystem&apos;;
export * from &apos;./useMapCommands&apos;;</file><file path="assets/js/hooks/Mapper/components/map/hooks/api/useCenterSystem.ts">import { useReactFlow } from &apos;reactflow&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { CommandCenterSystem } from &apos;@/hooks/Mapper/types&apos;;

export const useCenterSystem = () =&gt; {
  const rf = useReactFlow();

  const ref = useRef({ rf });
  ref.current = { rf };

  return useCallback((systemId: CommandCenterSystem) =&gt; {
    const systemNode = ref.current.rf.getNodes().find(x =&gt; x.data.id === systemId);
    if (!systemNode) {
      return;
    }
    ref.current.rf.setCenter(systemNode.position.x, systemNode.position.y, { duration: 1000 });
  }, []);
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/api/useCommandsCharacters.ts">import { useMapState } from &apos;@/hooks/Mapper/components/map/MapProvider.tsx&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import {
  CommandCharacterAdded,
  CommandCharacterRemoved,
  CommandCharactersUpdated,
  CommandCharacterUpdated,
  CommandPresentCharacters,
} from &apos;@/hooks/Mapper/types&apos;;

export const useCommandsCharacters = () =&gt; {
  const { update } = useMapState();

  const ref = useRef({ update });
  ref.current = { update };

  const charactersUpdated = useCallback((characters: CommandCharactersUpdated) =&gt; {
    ref.current.update(() =&gt; ({ characters: characters.slice() }));
  }, []);

  const characterAdded = useCallback((value: CommandCharacterAdded) =&gt; {
    ref.current.update(state =&gt; {
      return { characters: [...state.characters.filter(x =&gt; x.eve_id !== value.eve_id), value] };
    });
  }, []);

  const characterRemoved = useCallback((value: CommandCharacterRemoved) =&gt; {
    ref.current.update(state =&gt; {
      return { characters: [...state.characters.filter(x =&gt; x.eve_id !== value.eve_id)] };
    });
  }, []);

  const characterUpdated = useCallback((value: CommandCharacterUpdated) =&gt; {
    ref.current.update(state =&gt; {
      return { characters: [...state.characters.filter(x =&gt; x.eve_id !== value.eve_id), value] };
    });
  }, []);

  const presentCharacters = useCallback((value: CommandPresentCharacters) =&gt; {
    ref.current.update(() =&gt; ({ presentCharacters: value }));
  }, []);

  return { charactersUpdated, presentCharacters, characterAdded, characterRemoved, characterUpdated };
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/api/useCommandsConnections.ts">import { useReactFlow } from &apos;reactflow&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { CommandAddConnections, CommandRemoveConnections, CommandUpdateConnection } from &apos;@/hooks/Mapper/types&apos;;
import { convertConnection2Edge } from &apos;@/hooks/Mapper/components/map/helpers&apos;;

export const useCommandsConnections = () =&gt; {
  const rf = useReactFlow();
  const ref = useRef({ rf });
  ref.current = { rf };

  const addConnections = useCallback((systems: CommandAddConnections) =&gt; {
    ref.current.rf.addEdges(systems.map(convertConnection2Edge));
  }, []);

  const removeConnections = useCallback((connections: CommandRemoveConnections) =&gt; {
    ref.current.rf.deleteElements({ edges: connections.map(x =&gt; ({ id: x })) });
  }, []);

  const updateConnection = useCallback((value: CommandUpdateConnection) =&gt; {
    ref.current.rf.deleteElements({ edges: [value] });
    ref.current.rf.addEdges([convertConnection2Edge(value)]);
  }, []);

  return { addConnections, removeConnections, updateConnection };
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/api/useMapAddSystems.ts">import { Node, useReactFlow } from &apos;reactflow&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { CommandAddSystems } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { convertSystem2Node } from &apos;../../helpers&apos;;
import { useLoadSystemStatic } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic&apos;;

export const useMapAddSystems = () =&gt; {
  const rf = useReactFlow();

  const { addSystemStatic } = useLoadSystemStatic({ systems: [] });

  const ref = useRef({ rf });
  ref.current = { rf };

  return useCallback((systems: CommandAddSystems) =&gt; {
    const { rf } = ref.current;
    const nodes = rf.getNodes();

    const newSystems = systems.filter(x =&gt; !nodes.some(y =&gt; x.id === y.id));
    newSystems.forEach(x =&gt; addSystemStatic(x.system_static_info));

    const prepared: Node[] = newSystems.map(convertSystem2Node);
    rf.addNodes(prepared);
  }, []);
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/api/useMapCommands.ts">import { MapData, useMapState } from &apos;@/hooks/Mapper/components/map/MapProvider.tsx&apos;;
import { CommandKillsUpdated, CommandMapUpdated } from &apos;@/hooks/Mapper/types&apos;;
import { useCallback, useRef } from &apos;react&apos;;

export const useMapCommands = () =&gt; {
  const { update } = useMapState();

  const ref = useRef({ update });
  ref.current = { update };

  const mapUpdated = useCallback(({ hubs, system_signatures, kills }: CommandMapUpdated) =&gt; {
    const out: Partial&lt;MapData&gt; = {};

    if (hubs) {
      out.hubs = hubs;
    }

    if (system_signatures) {
      out.systemSignatures = system_signatures;
    }

    if (kills) {
      out.kills = kills.reduce((acc, x) =&gt; ({ ...acc, [x.solar_system_id]: x.kills }), {});
    }

    ref.current.update(out);
  }, []);

  const killsUpdated = useCallback((updated_kills: CommandKillsUpdated) =&gt; {
    ref.current.update(({ kills }) =&gt; {
      updated_kills.forEach(kill =&gt; {
        kills[kill.solar_system_id] = kill.kills;
      });

      return { kills: { ...kills } };
    });
  }, []);

  return { mapUpdated, killsUpdated };
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/api/useMapInit.ts">import { useReactFlow } from &apos;reactflow&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { CommandInit } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { convertConnection2Edge, convertSystem2Node } from &apos;../../helpers&apos;;
import { MapData, useMapState } from &apos;@/hooks/Mapper/components/map/MapProvider.tsx&apos;;

export const useMapInit = () =&gt; {
  const rf = useReactFlow();
  const { data, update } = useMapState();

  const ref = useRef({ rf, data, update });
  ref.current = { update, data, rf };

  return useCallback(
    ({
      systems,
      system_signatures,
      kills,
      connections,
      wormholes,
      characters,
      user_characters,
      present_characters,
      hubs,
    }: CommandInit) =&gt; {
      const { update } = ref.current;
      const { rf } = ref.current;

      const updateData: Partial&lt;MapData&gt; = {};

      if (wormholes) {
        updateData.wormholesData = wormholes.reduce((acc, x) =&gt; ({ ...acc, [x.name]: x }), {});
      }

      if (characters) {
        updateData.characters = characters.slice();
      }

      if (user_characters) {
        updateData.userCharacters = user_characters;
      }

      if (present_characters) {
        updateData.presentCharacters = present_characters;
      }

      if (hubs) {
        updateData.hubs = hubs;
      }

      if (systems) {
        updateData.systems = systems;
      }

      if (system_signatures) {
        updateData.systemSignatures = system_signatures;
      }

      if (kills) {
        updateData.kills = kills.reduce((acc, x) =&gt; ({ ...acc, [x.solar_system_id]: x.kills }), {});
      }

      update(updateData);

      if (systems) {
        rf.setNodes(systems.map(convertSystem2Node));
      }

      if (connections) {
        rf.setEdges(connections.map(convertConnection2Edge));
      }
    },
    [],
  );
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/api/useMapRemoveSystems.ts">import { useReactFlow } from &apos;reactflow&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { CommandRemoveSystems } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { OnMapSelectionChange } from &apos;@/hooks/Mapper/components/map/map.types.ts&apos;;

export const useMapRemoveSystems = (onSelectionChange: OnMapSelectionChange) =&gt; {
  const rf = useReactFlow();
  const ref = useRef({ onSelectionChange, rf });
  ref.current = { onSelectionChange, rf };

  return useCallback((systems: CommandRemoveSystems) =&gt; {
    ref.current.rf.deleteElements({ nodes: systems.map(x =&gt; ({ id: `${x}` })) });

    const newSelection = ref.current.rf
      .getNodes()
      .filter(x =&gt; !systems.includes(parseInt(x.id)))
      .filter(x =&gt; x.selected)
      .map(x =&gt; x.id);

    ref.current.onSelectionChange({
      systems: newSelection,
      connections: [],
    });
  }, []);
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/api/useMapUpdateSystems.ts">import { Node, useReactFlow } from &apos;reactflow&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { CommandUpdateSystems } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { convertSystem2Node } from &apos;../../helpers/index.ts&apos;;
import { useMapState } from &apos;@/hooks/Mapper/components/map/MapProvider.tsx&apos;;

export const useMapUpdateSystems = () =&gt; {
  const rf = useReactFlow();

  const {
    update,
    data: { systems },
  } = useMapState();

  const ref = useRef({ systems, update });
  ref.current = { systems, update };

  return useCallback(
    (systems: CommandUpdateSystems) =&gt; {
      const nodes = rf.getNodes();
      const prepared: Node[] = nodes.map(node =&gt; {
        const system = systems.find(s =&gt; s.id === node.id);

        if (system) {
          return {
            ...node,
            ...convertSystem2Node(system),
          };
        } else {
          return node;
        }
      });

      rf.setNodes(prepared);

      const out = ref.current.systems.map(current =&gt; {
        const newSystem = systems.find(x =&gt; current.id === x.id);
        if (!newSystem) {
          return current;
        }

        return newSystem;
      });

      update({ systems: out }, true);
    },
    [rf, update],
  );
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/api/useSelectSystem.ts">import { useReactFlow } from &apos;reactflow&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { CommandSelectSystem } from &apos;@/hooks/Mapper/types&apos;;

export const useSelectSystem = () =&gt; {
  const rf = useReactFlow();

  const ref = useRef({ rf });
  ref.current = { rf };

  return useCallback((systemId: CommandSelectSystem) =&gt; {
    ref.current.rf.setNodes(nds =&gt;
      nds.map(node =&gt; {
        return {
          ...node,
          selected: node.id === systemId,
        };
      }),
    );
  }, []);
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/index.ts">export * from &apos;./useMapHandlers&apos;;
export * from &apos;./useUpdateNodes&apos;;
export * from &apos;./useNodesEdgesState&apos;;
export * from &apos;./useBackgroundVars&apos;;
export * from &apos;./useKillsCounter&apos;;
export * from &apos;./useSystemName&apos;;
export * from &apos;./useNodesEdgesState&apos;;
export * from &apos;./useSolarSystemNode&apos;;
export * from &apos;./useUnsplashedSignatures&apos;;
export * from &apos;./useUpdateNodes&apos;;
export * from &apos;./useNodeKillsCount&apos;;</file><file path="assets/js/hooks/Mapper/components/map/hooks/useBackgroundVars.ts">import { useEffect, useState } from &apos;react&apos;;
import { BackgroundVariant } from &apos;reactflow&apos;;

export function useBackgroundVars(themeName?: string) {
  const [variant, setVariant] = useState&lt;BackgroundVariant&gt;(BackgroundVariant.Dots);
  const [gap, setGap] = useState&lt;number&gt;(16);
  const [size, setSize] = useState&lt;number&gt;(1);
  const [color, setColor] = useState(&apos;#81818b&apos;);
  const [snapSize, setSnapSize] = useState&lt;number&gt;(25);

  useEffect(() =&gt; {
    // match any element whose entire `class` attribute ends with &quot;-theme&quot;
    let themeEl = document.querySelector(&apos;[class$=&quot;-theme&quot;]&apos;);

    // If none is found, fall back to the &lt;html&gt; element
    if (!themeEl) {
      themeEl = document.documentElement;
    }

    const style = getComputedStyle(themeEl as HTMLElement);

    const rawVariant = style.getPropertyValue(&apos;--rf-bg-variant&apos;).replace(/[&apos;&quot;]/g, &apos;&apos;).trim().toLowerCase();
    let finalVariant: BackgroundVariant = BackgroundVariant.Dots;

    if (rawVariant === &apos;lines&apos;) {
      finalVariant = BackgroundVariant.Lines;
    } else if (rawVariant === &apos;cross&apos;) {
      finalVariant = BackgroundVariant.Cross;
    }

    const cssVarGap = style.getPropertyValue(&apos;--rf-bg-gap&apos;);
    const cssVarSize = style.getPropertyValue(&apos;--rf-bg-size&apos;);
    const cssVarSnapSize = style.getPropertyValue(&apos;--rf-snap-size&apos;);
    const cssColor = style.getPropertyValue(&apos;--rf-bg-pattern-color&apos;);

    const gapNum = parseInt(cssVarGap, 10) || 16;
    const sizeNum = parseInt(cssVarSize, 10) || 1;
    const snapSize = parseInt(cssVarSnapSize, 10) || 25; //react-flow default

    setVariant(finalVariant);
    setGap(gapNum);
    setSize(sizeNum);
    setColor(cssColor);
    setSnapSize(snapSize);
  }, [themeName]);

  return { variant, gap, size, color, snapSize };
}</file><file path="assets/js/hooks/Mapper/components/map/hooks/useKillsCounter.ts">import { useMemo } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useSystemKills } from &apos;@/hooks/Mapper/components/mapInterface/widgets/WSystemKills/hooks/useSystemKills.ts&apos;;

interface UseKillsCounterProps {
  realSystemId: string;
}

export function useKillsCounter({ realSystemId }: UseKillsCounterProps) {
  const { data: mapData, outCommand } = useMapRootState();
  const { systems } = mapData;

  const systemNameMap = useMemo(() =&gt; {
    const m: Record&lt;string, string&gt; = {};
    systems.forEach(sys =&gt; {
      m[sys.id] = sys.temporary_name || sys.name || &apos;???&apos;;
    });
    return m;
  }, [systems]);

  const { kills: allKills, isLoading } = useSystemKills({
    systemId: realSystemId,
    outCommand,
    showAllVisible: false,
  });

  const filteredKills = useMemo(() =&gt; {
    if (!allKills || allKills.length === 0) return [];

    // Sort kills by time, most recent first, but don&apos;t limit the number of kills
    return [...allKills].sort((a, b) =&gt; {
      const aTime = a.kill_time ? new Date(a.kill_time).getTime() : 0;
      const bTime = b.kill_time ? new Date(b.kill_time).getTime() : 0;
      return bTime - aTime;
    });
  }, [allKills]);

  return {
    isLoading,
    kills: filteredKills,
    systemNameMap,
  };
}</file><file path="assets/js/hooks/Mapper/components/map/hooks/useLabelsInfo.ts">import { useMemo } from &apos;react&apos;;
import { LabelsManager } from &apos;@/hooks/Mapper/utils/labelsManager&apos;;
import { LABELS_INFO, LABELS_ORDER } from &apos;@/hooks/Mapper/components/map/constants&apos;;
interface UseLabelsInfoParams {
  labels: string | null;
  linkedSigPrefix: string | null;
  isShowLinkedSigId: boolean;
}

export type LabelInfo = {
  id: string;
  shortName: string;
};

function sortedLabels(labels: string[]): LabelInfo[] {
  if (!labels) return [];
  return LABELS_ORDER.filter(x =&gt; labels.includes(x)).map(x =&gt; LABELS_INFO[x] as LabelInfo);
}

export function useLabelsInfo({ labels, linkedSigPrefix, isShowLinkedSigId }: UseLabelsInfoParams) {
  const labelsManager = useMemo(() =&gt; new LabelsManager(labels ?? &apos;&apos;), [labels]);
  const labelsInfo = useMemo(() =&gt; sortedLabels(labelsManager.list), [labelsManager]);
  const labelCustom = useMemo(() =&gt; {
    if (isShowLinkedSigId &amp;&amp; linkedSigPrefix) {
      return labelsManager.customLabel ? `${linkedSigPrefix}„Éª${labelsManager.customLabel}` : linkedSigPrefix;
    }
    return labelsManager.customLabel;
  }, [linkedSigPrefix, isShowLinkedSigId, labelsManager]);

  return { labelsInfo, labelCustom };
}</file><file path="assets/js/hooks/Mapper/components/map/hooks/useMapHandlers.ts">import { ForwardedRef, useImperativeHandle, useRef } from &apos;react&apos;;
import {
  CommandAddConnections,
  CommandAddSystems,
  CommandCharacterAdded,
  CommandCharacterRemoved,
  CommandCharactersUpdated,
  CommandCharacterUpdated,
  CommandInit,
  CommandKillsUpdated,
  CommandMapUpdated,
  CommandPresentCharacters,
  CommandRemoveConnections,
  CommandRemoveSystems,
  Commands,
  CommandSelectSystem,
  CommandUpdateConnection,
  CommandUpdateSystems,
  MapHandlers,
} from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;

import {
  useCommandsCharacters,
  useCommandsConnections,
  useMapAddSystems,
  useMapCommands,
  useMapInit,
  useMapRemoveSystems,
  useMapUpdateSystems,
  useCenterSystem,
  useSelectSystem,
} from &apos;./api&apos;;
import { OnMapSelectionChange } from &apos;@/hooks/Mapper/components/map/map.types.ts&apos;;

export const useMapHandlers = (ref: ForwardedRef&lt;MapHandlers&gt;, onSelectionChange: OnMapSelectionChange) =&gt; {
  const mapInit = useMapInit();
  const mapAddSystems = useMapAddSystems();
  const mapUpdateSystems = useMapUpdateSystems();
  const removeSystems = useMapRemoveSystems(onSelectionChange);
  const centerSystem = useCenterSystem();
  const selectSystem = useSelectSystem();

  const selectRef = useRef({ onSelectionChange });
  selectRef.current = { onSelectionChange };

  const { addConnections, removeConnections, updateConnection } = useCommandsConnections();
  const { mapUpdated, killsUpdated } = useMapCommands();
  const { charactersUpdated, presentCharacters, characterAdded, characterRemoved, characterUpdated } =
    useCommandsCharacters();

  useImperativeHandle(
    ref,
    () =&gt; {
      return {
        command(type, data) {
          switch (type) {
            case Commands.init:
              mapInit(data as CommandInit);
              break;
            case Commands.addSystems:
              setTimeout(() =&gt; mapAddSystems(data as CommandAddSystems), 100);
              break;
            case Commands.updateSystems:
              mapUpdateSystems(data as CommandUpdateSystems);
              break;
            case Commands.removeSystems:
              setTimeout(() =&gt; removeSystems(data as CommandRemoveSystems), 100);
              break;
            case Commands.addConnections:
              setTimeout(() =&gt; addConnections(data as CommandAddConnections), 100);
              break;
            case Commands.removeConnections:
              setTimeout(() =&gt; removeConnections(data as CommandRemoveConnections), 100);
              break;
            case Commands.charactersUpdated:
              charactersUpdated(data as CommandCharactersUpdated);
              break;
            case Commands.characterAdded:
              characterAdded(data as CommandCharacterAdded);
              break;
            case Commands.characterRemoved:
              characterRemoved(data as CommandCharacterRemoved);
              break;
            case Commands.characterUpdated:
              characterUpdated(data as CommandCharacterUpdated);
              break;
            case Commands.presentCharacters:
              presentCharacters(data as CommandPresentCharacters);
              break;
            case Commands.updateConnection:
              updateConnection(data as CommandUpdateConnection);
              break;
            case Commands.mapUpdated:
              mapUpdated(data as CommandMapUpdated);
              break;
            case Commands.killsUpdated:
              killsUpdated(data as CommandKillsUpdated);
              break;

            case Commands.centerSystem:
              setTimeout(() =&gt; {
                const systemId = `${data}`;
                centerSystem(systemId as CommandSelectSystem);
              }, 100);
              break;

            case Commands.selectSystem:
              setTimeout(() =&gt; {
                const systemId = `${data}`;
                selectRef.current.onSelectionChange({
                  systems: [systemId],
                  connections: [],
                });
                selectSystem(systemId as CommandSelectSystem);
              }, 500);
              break;

            case Commands.routes:
              // do nothing here
              break;

            case Commands.signaturesUpdated:
              // do nothing here
              break;

            case Commands.linkSignatureToSystem:
              // do nothing here
              break;

            case Commands.detailedKillsUpdated:
              // do nothing here
              break;

            case Commands.characterActivityData:
              break;

            case Commands.trackingCharactersData:
              break;

            case Commands.updateActivity:
              break;

            case Commands.updateTracking:
              break;

            case Commands.userSettingsUpdated:
              break;

            default:
              console.warn(`Map handlers: Unknown command: ${type}`, data);
              break;
          }
        },
      };
    },
    [],
  );
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/useNodeKillsCount.ts">import { useEffect, useState, useCallback } from &apos;react&apos;;
import { useMapEventListener } from &apos;@/hooks/Mapper/events&apos;;
import { Commands } from &apos;@/hooks/Mapper/types&apos;;

interface Kill {
  solar_system_id: number | string;
  kills: number;
}

interface MapEvent {
  name: Commands;
  data?: any;
  payload?: Kill[];
}

export function useNodeKillsCount(systemId: number | string, initialKillsCount: number | null): number | null {
  const [killsCount, setKillsCount] = useState&lt;number | null&gt;(initialKillsCount);

  useEffect(() =&gt; {
    setKillsCount(initialKillsCount);
  }, [initialKillsCount]);

  const handleEvent = useCallback(
    (event: MapEvent): boolean =&gt; {
      if (event.name === Commands.killsUpdated &amp;&amp; Array.isArray(event.payload)) {
        const killForSystem = event.payload.find(kill =&gt; kill.solar_system_id.toString() === systemId.toString());
        if (killForSystem &amp;&amp; typeof killForSystem.kills === &apos;number&apos;) {
          setKillsCount(killForSystem.kills);
        }
        return true;
      }
      return false;
    },
    [systemId],
  );

  useMapEventListener(handleEvent);

  return killsCount;
}</file><file path="assets/js/hooks/Mapper/components/map/hooks/useNodesEdgesState.ts">import { useState, useCallback, type Dispatch, type SetStateAction } from &apos;react&apos;;

import { applyNodeChanges, applyEdgeChanges } from &apos;../utils/changes&apos;;
import { OnNodesChange, Edge, OnEdgesChange, Node } from &apos;reactflow&apos;;

/**
 * Hook for managing the state of nodes - should only be used for prototyping / simple use cases.
 *
 * @public
 * @param initialNodes
 * @returns an array [nodes, setNodes, onNodesChange]
 */
export function useNodesState&lt;NodeType extends Node&gt;(
  initialNodes: NodeType[],
): [NodeType[], Dispatch&lt;SetStateAction&lt;NodeType[]&gt;&gt;, OnNodesChange] {
  const [nodes, setNodes] = useState(initialNodes);
  const onNodesChange: OnNodesChange = useCallback(changes =&gt; setNodes(nds =&gt; applyNodeChanges(changes, nds)), []);

  return [nodes, setNodes, onNodesChange];
}

/**
 * Hook for managing the state of edges - should only be used for prototyping / simple use cases.
 *
 * @public
 * @param initialEdges
 * @returns an array [edges, setEdges, onEdgesChange]
 */
export function useEdgesState&lt;EdgeType extends Edge = Edge&gt;(
  initialEdges: EdgeType[],
): [EdgeType[], Dispatch&lt;SetStateAction&lt;EdgeType[]&gt;&gt;, OnEdgesChange] {
  const [edges, setEdges] = useState(initialEdges);
  const onEdgesChange: OnEdgesChange = useCallback(changes =&gt; setEdges(eds =&gt; applyEdgeChanges(changes, eds)), []);

  return [edges, setEdges, onEdgesChange];
}</file><file path="assets/js/hooks/Mapper/components/map/hooks/useSolarSystemNode.ts">import { useMemo } from &apos;react&apos;;
import { MapSolarSystemType } from &apos;../map.types&apos;;
import { NodeProps } from &apos;reactflow&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useMapGetOption } from &apos;@/hooks/Mapper/mapRootProvider/hooks/api&apos;;
import { useMapState } from &apos;@/hooks/Mapper/components/map/MapProvider&apos;;
import { useDoubleClick } from &apos;@/hooks/Mapper/hooks/useDoubleClick&apos;;
import { REGIONS_MAP, Spaces } from &apos;@/hooks/Mapper/constants&apos;;
import { isWormholeSpace } from &apos;@/hooks/Mapper/components/map/helpers/isWormholeSpace&apos;;
import { getSystemClassStyles } from &apos;@/hooks/Mapper/components/map/helpers&apos;;
import { sortWHClasses } from &apos;@/hooks/Mapper/helpers&apos;;
import { CharacterTypeRaw, OutCommand, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { useUnsplashedSignatures } from &apos;./useUnsplashedSignatures&apos;;
import { useSystemName } from &apos;./useSystemName&apos;;
import { LabelInfo, useLabelsInfo } from &apos;./useLabelsInfo&apos;;
import { getSystemStaticInfo } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic&apos;;

function getActivityType(count: number): string {
  if (count &lt;= 5) return &apos;activityNormal&apos;;
  if (count &lt;= 30) return &apos;activityWarn&apos;;
  return &apos;activityDanger&apos;;
}

const SpaceToClass: Record&lt;string, string&gt; = {
  [Spaces.Caldari]: &apos;Caldaria&apos;,
  [Spaces.Matar]: &apos;Mataria&apos;,
  [Spaces.Amarr]: &apos;Amarria&apos;,
  [Spaces.Gallente]: &apos;Gallente&apos;,
};

export function useLocalCounter(nodeVars: SolarSystemNodeVars) {
  const localCounterCharacters = useMemo(() =&gt; {
    return nodeVars.charactersInSystem
      .map(char =&gt; ({
        ...char,
        compact: true,
        isOwn: nodeVars.userCharacters.includes(char.eve_id),
      }))
      .sort((a, b) =&gt; a.name.localeCompare(b.name));
  }, [nodeVars.charactersInSystem, nodeVars.userCharacters]);
  return { localCounterCharacters };
}

export function useSolarSystemNode(props: NodeProps&lt;MapSolarSystemType&gt;): SolarSystemNodeVars {
  const { id, data, selected } = props;
  const {
    id: solar_system_id,
    locked,
    name,
    tag,
    status,
    labels,
    temporary_name,
    linked_sig_eve_id: linkedSigEveId = &apos;&apos;,
  } = data;

  const {
    storedSettings: { interfaceSettings },
    data: { systemSignatures: mapSystemSignatures },
  } = useMapRootState();

  const systemStaticInfo = useMemo(() =&gt; {
    return getSystemStaticInfo(solar_system_id)!;
  }, [solar_system_id]);

  const {
    system_class,
    security,
    class_title,
    statics,
    effect_name,
    region_name,
    region_id,
    is_shattered,
    solar_system_name,
  } = systemStaticInfo;

  const { isShowUnsplashedSignatures } = interfaceSettings;
  const isTempSystemNameEnabled = useMapGetOption(&apos;show_temp_system_name&apos;) === &apos;true&apos;;
  const isShowLinkedSigId = useMapGetOption(&apos;show_linked_signature_id&apos;) === &apos;true&apos;;
  const isShowLinkedSigIdTempName = useMapGetOption(&apos;show_linked_signature_id_temp_name&apos;) === &apos;true&apos;;

  const {
    data: {
      characters,
      wormholesData,
      hubs,
      kills,
      userCharacters,
      isConnecting,
      hoverNodeId,
      visibleNodes,
      showKSpaceBG,
      isThickConnections,
    },
    outCommand,
  } = useMapState();

  const visible = useMemo(() =&gt; visibleNodes.has(id), [id, visibleNodes]);

  const systemSigs = useMemo(() =&gt; mapSystemSignatures[solar_system_id] || [], [solar_system_id, mapSystemSignatures]);

  const charactersInSystem = useMemo(() =&gt; {
    return characters.filter(c =&gt; c.location?.solar_system_id === parseInt(solar_system_id) &amp;&amp; c.online);
  }, [characters, solar_system_id]);

  const isWormhole = isWormholeSpace(system_class);

  const classTitleColor = useMemo(
    () =&gt; getSystemClassStyles({ systemClass: system_class, security }),
    [security, system_class],
  );

  const sortedStatics = useMemo(() =&gt; sortWHClasses(wormholesData, statics), [wormholesData, statics]);

  const linkedSigPrefix = useMemo(() =&gt; (linkedSigEveId ? linkedSigEveId.split(&apos;-&apos;)[0] : null), [linkedSigEveId]);

  const { labelsInfo, labelCustom } = useLabelsInfo({
    labels,
    linkedSigPrefix,
    isShowLinkedSigId,
  });

  const killsCount = useMemo(() =&gt; kills[parseInt(solar_system_id)] ?? null, [kills, solar_system_id]);
  const killsActivityType = killsCount ? getActivityType(killsCount) : null;

  const hasUserCharacters = useMemo(
    () =&gt; charactersInSystem.some(x =&gt; userCharacters.includes(x.eve_id)),
    [charactersInSystem, userCharacters],
  );

  const dbClick = useDoubleClick(() =&gt; {
    outCommand({
      type: OutCommand.openSettings,
      data: { system_id: solar_system_id },
    });
  });

  const showHandlers = isConnecting || hoverNodeId === id;

  const space = showKSpaceBG ? REGIONS_MAP[region_id] : &apos;&apos;;
  const regionClass = showKSpaceBG ? SpaceToClass[space] || null : null;

  const { systemName, computedTemporaryName, customName } = useSystemName({
    isTempSystemNameEnabled,
    temporary_name,
    isShowLinkedSigIdTempName,
    linkedSigPrefix,
    name,
    systemStaticInfo,
  });

  const { unsplashedLeft, unsplashedRight } = useUnsplashedSignatures(systemSigs, isShowUnsplashedSignatures);

  const hubsAsStrings = useMemo(() =&gt; hubs.map(item =&gt; item.toString()), [hubs]);

  const nodeVars: SolarSystemNodeVars = {
    id,
    selected,
    visible,
    isWormhole,
    classTitleColor,
    killsCount,
    killsActivityType,
    hasUserCharacters,
    userCharacters,
    showHandlers,
    regionClass,
    systemName,
    customName,
    labelCustom,
    isShattered: is_shattered,
    tag,
    status,
    labelsInfo,
    dbClick,
    sortedStatics,
    effectName: effect_name,
    solarSystemId: solar_system_id.toString(),
    locked,
    hubs: hubsAsStrings,
    name,
    isConnecting,
    hoverNodeId,
    charactersInSystem,
    unsplashedLeft,
    unsplashedRight,
    isThickConnections,
    classTitle: class_title,
    temporaryName: computedTemporaryName,
    regionName: region_name,
    solarSystemName: solar_system_name,
  };

  return nodeVars;
}

export interface SolarSystemNodeVars {
  id: string;
  selected: boolean;
  visible: boolean;
  isWormhole: boolean;
  classTitleColor: string | null;
  killsCount: number | null;
  killsActivityType: string | null;
  hasUserCharacters: boolean;
  showHandlers: boolean;
  regionClass: string | null;
  systemName: string;
  customName?: string | null;
  labelCustom: string | null;
  isShattered: boolean;
  tag?: string | null;
  status?: number;
  labelsInfo: LabelInfo[];
  dbClick: (event: React.MouseEvent&lt;HTMLDivElement&gt;) =&gt; void;
  sortedStatics: Array&lt;string | number&gt;;
  effectName: string | null;
  regionName: string | null;
  solarSystemId: string;
  solarSystemName: string | null;
  locked: boolean;
  hubs: string[];
  name: string | null;
  isConnecting: boolean;
  hoverNodeId: string | null;
  charactersInSystem: Array&lt;CharacterTypeRaw&gt;;
  userCharacters: string[];
  unsplashedLeft: Array&lt;SystemSignature&gt;;
  unsplashedRight: Array&lt;SystemSignature&gt;;
  isThickConnections: boolean;
  classTitle: string | null;
  temporaryName?: string | null;
}</file><file path="assets/js/hooks/Mapper/components/map/hooks/useSystemName.ts">import { useMemo } from &apos;react&apos;;
import { SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types&apos;;

interface UseSystemNameParams {
  isTempSystemNameEnabled: boolean;
  temporary_name?: string | null;
  isShowLinkedSigIdTempName: boolean;
  linkedSigPrefix: string | null;
  name?: string | null;
  systemStaticInfo: SolarSystemStaticInfoRaw;
}

export const useSystemName = ({
  isTempSystemNameEnabled,
  temporary_name,
  isShowLinkedSigIdTempName,
  linkedSigPrefix,
  name,
  systemStaticInfo,
}: UseSystemNameParams) =&gt; {
  const { solar_system_name = &apos;&apos; } = systemStaticInfo;

  const computedTemporaryName = useMemo(() =&gt; {
    if (!isTempSystemNameEnabled) {
      return &apos;&apos;;
    }

    if (isShowLinkedSigIdTempName &amp;&amp; linkedSigPrefix) {
      return temporary_name ? `${linkedSigPrefix}„Éª${temporary_name}` : `${linkedSigPrefix}„Éª${solar_system_name}`;
    }

    return temporary_name ?? &apos;&apos;;
  }, [isTempSystemNameEnabled, temporary_name, solar_system_name, isShowLinkedSigIdTempName, linkedSigPrefix]);

  const systemName = useMemo(() =&gt; {
    if (isTempSystemNameEnabled &amp;&amp; computedTemporaryName) {
      return computedTemporaryName;
    }

    return solar_system_name;
  }, [isTempSystemNameEnabled, computedTemporaryName, solar_system_name]);

  const customName = useMemo(() =&gt; {
    if (isTempSystemNameEnabled &amp;&amp; computedTemporaryName &amp;&amp; name) {
      return name;
    }

    if (solar_system_name !== name &amp;&amp; name) {
      return name;
    }

    return null;
  }, [isTempSystemNameEnabled, computedTemporaryName, name, solar_system_name]);

  return { systemName, computedTemporaryName, customName };
};</file><file path="assets/js/hooks/Mapper/components/map/hooks/useUnsplashedSignatures.ts">import { useMemo } from &apos;react&apos;;
import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { prepareUnsplashedChunks } from &apos;@/hooks/Mapper/components/map/helpers&apos;;

export type UnsplashedSignatureType = SystemSignature &amp; { sig_id: string };

export function useUnsplashedSignatures(systemSigs: SystemSignature[], isShowUnsplashedSignatures: boolean) {
  return useMemo(() =&gt; {
    if (!isShowUnsplashedSignatures) {
      return {
        unsplashedLeft: [] as SystemSignature[],
        unsplashedRight: [] as SystemSignature[],
      };
    }
    const chunks = prepareUnsplashedChunks(
      systemSigs
        .filter(s =&gt; s.group === &apos;Wormhole&apos; &amp;&amp; !s.linked_system)
        .map(s =&gt; ({
          eve_id: s.eve_id,
          type: s.type,
          custom_info: s.custom_info,
          kind: s.kind,
          name: s.name,
          group: s.group,
        })) as UnsplashedSignatureType[],
    );
    const [unsplashedLeft, unsplashedRight] = chunks;
    return { unsplashedLeft, unsplashedRight };
  }, [isShowUnsplashedSignatures, systemSigs]);
}</file><file path="assets/js/hooks/Mapper/components/map/hooks/useUpdateNodes.ts">import { useCallback, useEffect, useRef } from &apos;react&apos;;
import { Node, useOnViewportChange, useReactFlow } from &apos;reactflow&apos;;
import { useMapState } from &apos;@/hooks/Mapper/components/map/MapProvider.tsx&apos;;
import { SolarSystemRawType } from &apos;@/hooks/Mapper/types&apos;;

const useThrottle = () =&gt; {
  const throttleSeed = useRef&lt;number | null&gt;(null);

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const throttleFunction = useRef((func: any, delay = 200) =&gt; {
    if (!throttleSeed.current) {
      func();
      throttleSeed.current = setTimeout(() =&gt; {
        throttleSeed.current = null;
      }, delay);
    }
  });

  return throttleFunction.current;
};

const X_OFFSET = 50;
const Y_OFFSET = 50;

const isNodeVisible = (node: Node, viewport: { x: number; y: number; width: number; height: number }) =&gt; {
  const { x: nodeX, y: nodeY } = node.position;
  const { width, height } = node;

  return (
    nodeX + (width ?? 0) + X_OFFSET &gt; viewport.x &amp;&amp;
    nodeX - X_OFFSET &lt; viewport.x + viewport.width &amp;&amp;
    nodeY + (height ?? 0) + Y_OFFSET &gt; viewport.y &amp;&amp;
    nodeY - Y_OFFSET &lt; viewport.y + viewport.height
  );
};

export const useUpdateNodes = (nodes: Node&lt;SolarSystemRawType&gt;[]) =&gt; {
  const { screenToFlowPosition } = useReactFlow();
  const throttle = useThrottle();
  const { update } = useMapState();

  const ref = useRef({ screenToFlowPosition });
  ref.current = { screenToFlowPosition };

  const getViewport = useCallback(() =&gt; {
    const clientRect = document.querySelector(&apos;.react-flow__renderer&apos;)?.getBoundingClientRect();

    if (!clientRect) {
      return;
    }

    const { screenToFlowPosition } = ref.current;

    const topLeft = screenToFlowPosition({ x: clientRect.left, y: clientRect.top });
    const bottomRight = screenToFlowPosition({ x: clientRect.right, y: clientRect.bottom });
    return {
      x: topLeft.x,
      y: topLeft.y,
      width: bottomRight.x - topLeft.x,
      height: bottomRight.y - topLeft.y,
    };
  }, []);

  const updateNodesVisibility = useCallback(() =&gt; {
    if (!nodes) {
      return;
    }

    const viewport = getViewport();
    if (!viewport) {
      const visibleNodes = new Set(nodes.map(x =&gt; x.id));
      update({ visibleNodes });
      return;
    }

    const visibleNodes = new Set(nodes.filter(x =&gt; isNodeVisible(x, viewport)).map(x =&gt; x.id));
    update({ visibleNodes });
  }, [getViewport, nodes, update]);

  useOnViewportChange({
    onChange: () =&gt; throttle(updateNodesVisibility.bind(this)),
    onEnd: () =&gt; throttle(updateNodesVisibility.bind(this)),
  });

  useEffect(() =&gt; {
    updateNodesVisibility();
  }, [nodes, updateNodesVisibility]);
};</file><file path="assets/js/hooks/Mapper/components/map/styles/default-theme.scss">@import &apos;./eve-common-variables&apos;;
@import &apos;./eve-common&apos;;

.default-theme {
  --rf-bg-color: #0C0A09;
  --rf-soft-bg-color: #171717;

  --rf-node-bg-color: #202020;
  --rf-node-soft-bg-color: #202020;
  --rf-text-color: #ffffff;
  --rf-tag-color:  #38BDF8;
  --rf-region-name: #D6D3D1;
  --rf-custom-name: #93C5FD;
  --rf-node-font-family: &apos;Shentox&apos;, &apos;Rogan&apos;, sans-serif !important;
  --rf-node-font-weight: 500;

  --rf-bg-variant: &quot;dots&quot;;
  --rf-bg-gap: 15;
  --rf-bg-size: 1;
  --rf-bg-pattern-color: #81818a;

  --pastel-blue: #5a7d9a;
  --pastel-pink: #d291bc;
  --pastel-green: #88b04b;
  --pastel-yellow: #ffdd59;

  --dark-bg: #2d2d2d;
  --text-color: #ffffff;
  --tooltip-bg: #202020;

  --window-corner: #72716f;

  --rf-local-counter-font-weight: 500;
  --rf-node-local-counter: inherit;
  --rf-has-user-characters: #ffc75d;
}</file><file path="assets/js/hooks/Mapper/components/map/styles/eve-common-variables.scss">$friendlyBase: #3bbd39;
$friendlyAlpha: #3bbd3952;
$friendlyDark20: darken($friendlyBase, 20%);
$friendlyDark30: darken($friendlyBase, 30%);
$friendlyDark5:  darken($friendlyBase, 5%);

$lookingForBase: #43c2fd;
$lookingForAlpha: rgba(67, 176, 253, 0.48);
$lookingForDark15: darken($lookingForBase, 15%);

$homeBase: rgb(179, 253, 67);
$homeAlpha: rgba(186, 248, 48, 0.32);
$homeBackground: #a0fa5636;
$homeDark30: darken($homeBase, 30%);

:root {
  --pastel-blue: #5a7d9a;
  --pastel-pink: #d291bc;
  --pastel-green: #88b04b;
  --pastel-yellow: #ffdd59;
  --dark-bg: #2d2d2d;
  --text-color: #ffffff;
  --tooltip-bg: #202020;

  --pastel-blue-darken10: #4f6b86;
  --pastel-blue-lighten10: #6da3af;
  --pastel-pink-darken10: #bb7ca9;
  --pastel-pink-lighten10: #e0a6cb;
  --pastel-green-darken10: #79a244;
  --pastel-green-lighten10: #99cf52;
  --pastel-yellow-darken10: #e6c44f;
  --pastel-yellow-lighten10: #ffe874;

  --eve-link-color-default: #333;
  --eve-link-color-top-mass-0: #333;
  --eve-link-color-top-mass-1: #5a4520;
  --eve-link-color-top-mass-2: #672c2c;
  --eve-link-color-middle-mass-0: #333;
  --eve-link-color-middle-mass-1: #333;
  --eve-link-color-middle-mass-2: #333;
  --eve-link-color-middle-time-0: #5c5c5c;
  --eve-link-color-middle-time-1: #ff00cd;
  --eve-link-color-middle-time-1-border: #99f3ff;
  --eve-link-color-top-mass-1-time-1: #796300;
  --eve-link-color-top-mass-2-time-1: #8c1717;
  --eve-link-color-temp: orange;

  --eve-effect-pulsar: #40aef5;
  --eve-effect-magnetar: #f058f8;
  --eve-effect-wolfRayet: #ef7843;
  --eve-effect-blackHole: #1b1b1b;
  --eve-effect-cataclysmicVariable: #ffea90;
  --eve-effect-redGiant: #fd3c3c;
  --eve-effect-dazhLiminalityLocus: #ff6464;
  --eve-effect-imperialStellarObservatory: #6991ce;
  --eve-effect-stateStellarObservatory: #6991ce;
  --eve-effect-republicStellarObservatory: #6991ce;
  --eve-effect-federalStellarObservatory: #6991ce;

  --eve-wh-type-color-high: #5dffd2;
  --eve-wh-type-color-low: #f79400;
  --eve-wh-type-color-null: #fc3c3c;
  --eve-wh-type-color-c1: #69bfce;
  --eve-wh-type-color-c2: #6991ce;
  --eve-wh-type-color-c3: #a8cb70;
  --eve-wh-type-color-c4: #e39c68;
  --eve-wh-type-color-c5: #de8686;
  --eve-wh-type-color-c6: #e76363;
  --eve-wh-type-color-c13: #988cb5;
  --eve-wh-type-color-drifter: #ff44f6;
  --eve-wh-type-color-thera: #ffffff;
  --eve-wh-type-color-zarzakh: #212121;

  --eve-security-color-10: #2c74df;
  --eve-security-color-09: #3998e8;
  --eve-security-color-08: #4dcbf5;
  --eve-security-color-07: #60d8a2;
  --eve-security-color-06: #71e454;
  --eve-security-color-05: #f2fc81;
  --eve-security-color-04: #d96c07;
  --eve-security-color-03: #cb440f;
  --eve-security-color-02: #b91117;
  --eve-security-color-01: #732020;
  --eve-security-color-00: #8b3263;
  --eve-security-color-m-01: #8b3263;
  --eve-security-color-m-02: #8b3263;
  --eve-security-color-m-03: #8b3263;
  --eve-security-color-m-04: #8b3263;
  --eve-security-color-m-05: #8b3263;
  --eve-security-color-m-06: #8b3263;
  --eve-security-color-m-07: #8b3263;
  --eve-security-color-m-08: #8b3263;
  --eve-security-color-m-09: #8b3263;
  --eve-security-color-m-10: #8b3263;

  --eve-solar-system-status-unknown: transparent;
  --eve-solar-system-status-color-unknown: transparent;
  --eve-solar-system-status-home:                #{$homeAlpha};
  --eve-solar-system-status-color-home:          #{$homeBase};
  --eve-solar-system-status-color-background:    #{$homeBackground};
  --eve-solar-system-status-color-home-dark30:   #{$homeDark30};
  --eve-solar-system-status-friendly:            #{$friendlyAlpha};
  --eve-solar-system-status-color-friendly:      #{$friendlyBase};
  --eve-solar-system-status-friendly-dark30:     #{$friendlyDark30};
  --eve-solar-system-status-color-friendly-dark20: #{$friendlyDark20};
  --eve-solar-system-status-color-friendly-dark5:  #{$friendlyDark5};
  --eve-solar-system-status-lookingFor:              #{$lookingForAlpha};
  --eve-solar-system-status-color-lookingFor:        #{$lookingForBase};
  --eve-solar-system-status-color-lookingFor-dark15: #{$lookingForDark15};
  --eve-solar-system-status-warning: #906518a6;
  --eve-solar-system-status-color-warning: #ffb93b;
  --eve-solar-system-status-target: #b439ff6b;
  --eve-solar-system-status-color-target: #b439ff;
  --eve-solar-system-status-dangerous: #d54040;
  --eve-solar-system-status-color-dangerous: #d54040;

  --conn-time-eol: #7452c3e3;
  --conn-frigate: #325d88;
  --conn-save: rgba(155, 102, 45, 0.85);
  --selected-item-bg: rgba(98, 98, 98, 0.33);
}</file><file path="assets/js/hooks/Mapper/components/map/styles/eve-common.scss">@import &apos;./eve-common-variables&apos;;


.eve-wh-effect-color-pulsar {
  fill: var(--eve-effect-pulsar);
  background-color: var(--eve-effect-pulsar);
}

.eve-wh-effect-color-magnetar {
  fill: var(--eve-effect-magnetar);
  background-color: var(--eve-effect-magnetar);
}

.eve-wh-effect-color-wolfRayet {
  fill: var(--eve-effect-wolfRayet);
  background-color: var(--eve-effect-wolfRayet);
}

.eve-wh-effect-color-blackHole {
  fill: var(--eve-effect-blackHole);
  background-color: var(--eve-effect-blackHole);
  box-shadow: 0 0 8px rgba(255, 255, 255, 0.33);
}

.eve-wh-effect-color-cataclysmicVariable {
  fill: var(--eve-effect-cataclysmicVariable);
  background-color: var(--eve-effect-cataclysmicVariable);
}

.eve-wh-effect-color-redGiant {
  fill: var(--eve-effect-redGiant);
  background-color: var(--eve-effect-redGiant);
}

.text-eve-wh-effect-color-pulsar {
  color: var(--eve-effect-pulsar);
}
.text-eve-wh-effect-color-magnetar {
  color: var(--eve-effect-magnetar);
}
.text-eve-wh-effect-color-wolfRayet {
  color: var(--eve-effect-wolfRayet);
}
.text-eve-wh-effect-color-blackHole {
  color: #fff;
}
.text-eve-wh-effect-color-cataclysmicVariable {
  color: var(--eve-effect-cataclysmicVariable);
}
.text-eve-wh-effect-color-redGiant {
  color: var(--eve-effect-redGiant);
}
.text-eve-wh-effect-color-dazhLiminalityLocus {
  color: var(--eve-effect-dazhLiminalityLocus);
}
.text-eve-wh-effect-color-imperialStellarObservatory {
  color: var(--eve-effect-imperialStellarObservatory);
}
.text-eve-wh-effect-color-stateStellarObservatory {
  color: var(--eve-effect-stateStellarObservatory);
}
.text-eve-wh-effect-color-republicStellarObservatory {
  color: var(--eve-effect-republicStellarObservatory);
}
.text-eve-wh-effect-color-federalStellarObservatory {
  color: var(--eve-effect-federalStellarObservatory);
}

/* Security color classes */
.eve-security-color-10 {
  color: var(--eve-security-color-10) !important;
  fill: var(--eve-security-color-10);
}
.eve-security-color-09 {
  color: var(--eve-security-color-09) !important;
  fill: var(--eve-security-color-09);
}
.eve-security-color-08 {
  color: var(--eve-security-color-08) !important;
  fill: var(--eve-security-color-08);
}
.eve-security-color-07 {
  color: var(--eve-security-color-07) !important;
  fill: var(--eve-security-color-07);
}
.eve-security-color-06 {
  color: var(--eve-security-color-06) !important;
  fill: var(--eve-security-color-06);
}
.eve-security-color-05 {
  color: var(--eve-security-color-05) !important;
  fill: var(--eve-security-color-05);
}
.eve-security-color-04 {
  color: var(--eve-security-color-04) !important;
  fill: var(--eve-security-color-04);
}
.eve-security-color-03 {
  color: var(--eve-security-color-03) !important;
  fill: var(--eve-security-color-03);
}
.eve-security-color-02 {
  color: var(--eve-security-color-02) !important;
  fill: var(--eve-security-color-02);
}
.eve-security-color-01 {
  color: var(--eve-security-color-01) !important;
  fill: var(--eve-security-color-01);
}
.eve-security-color-00 {
  color: var(--eve-security-color-00) !important;
  fill: var(--eve-security-color-00);
}
.eve-security-color-m-01 {
  color: var(--eve-security-color-m-01) !important;
  fill: var(--eve-security-color-m-01);
}
.eve-security-color-m-02 {
  color: var(--eve-security-color-m-02) !important;
  fill: var(--eve-security-color-m-02);
}
.eve-security-color-m-03 {
  color: var(--eve-security-color-m-03) !important;
  fill: var(--eve-security-color-m-03);
}
.eve-security-color-m-04 {
  color: var(--eve-security-color-m-04) !important;
  fill: var(--eve-security-color-m-04);
}
.eve-security-color-m-05 {
  color: var(--eve-security-color-m-05) !important;
  fill: var(--eve-security-color-m-05);
}
.eve-security-color-m-06 {
  color: var(--eve-security-color-m-06) !important;
  fill: var(--eve-security-color-m-06);
}
.eve-security-color-m-07 {
  color: var(--eve-security-color-m-07) !important;
  fill: var(--eve-security-color-m-07);
}
.eve-security-color-m-08 {
  color: var(--eve-security-color-m-08) !important;
  fill: var(--eve-security-color-m-08);
}
.eve-security-color-m-09 {
  color: var(--eve-security-color-m-09) !important;
  fill: var(--eve-security-color-m-09);
}
.eve-security-color-m-10 {
  color: var(--eve-security-color-m-10) !important;
  fill: var(--eve-security-color-m-10);
}

/* Security backgrounds */
.eve-security-background-10 {
  background-color: var(--eve-security-color-10);
  fill: var(--eve-security-color-10);
}
.eve-security-background-09 {
  background-color: var(--eve-security-color-09);
  fill: var(--eve-security-color-09);
}
.eve-security-background-08 {
  background-color: var(--eve-security-color-08);
  fill: var(--eve-security-color-08);
}
.eve-security-background-07 {
  background-color: var(--eve-security-color-07);
  fill: var(--eve-security-color-07);
}
.eve-security-background-06 {
  background-color: var(--eve-security-color-06);
  fill: var(--eve-security-color-06);
}
.eve-security-background-05 {
  background-color: var(--eve-security-color-05);
  fill: var(--eve-security-color-05);
}
.eve-security-background-04 {
  background-color: var(--eve-security-color-04);
  fill: var(--eve-security-color-04);
}
.eve-security-background-03 {
  background-color: var(--eve-security-color-03);
  fill: var(--eve-security-color-03);
}
.eve-security-background-02 {
  background-color: var(--eve-security-color-02);
  fill: var(--eve-security-color-02);
}
.eve-security-background-01 {
  background-color: var(--eve-security-color-01);
  fill: var(--eve-security-color-01);
}
.eve-security-background-00 {
  background-color: var(--eve-security-color-00);
  fill: var(--eve-security-color-00);
}
.eve-security-background-m-01 {
  background-color: var(--eve-security-color-m-01);
  fill: var(--eve-security-color-m-01);
}
.eve-security-background-m-02 {
  background-color: var(--eve-security-color-m-02);
  fill: var(--eve-security-color-m-02);
}
.eve-security-background-m-03 {
  background-color: var(--eve-security-color-m-03);
  fill: var(--eve-security-color-m-03);
}
.eve-security-background-m-04 {
  background-color: var(--eve-security-color-m-04);
  fill: var(--eve-security-color-m-04);
}
.eve-security-background-m-05 {
  background-color: var(--eve-security-color-m-05);
  fill: var(--eve-security-color-m-05);
}
.eve-security-background-m-06 {
  background-color: var(--eve-security-color-m-06);
  fill: var(--eve-security-color-m-06);
}
.eve-security-background-m-07 {
  background-color: var(--eve-security-color-m-07);
  fill: var(--eve-security-color-m-07);
}
.eve-security-background-m-08 {
  background-color: var(--eve-security-color-m-08);
  fill: var(--eve-security-color-m-08);
}
.eve-security-background-m-09 {
  background-color: var(--eve-security-color-m-09);
  fill: var(--eve-security-color-m-09);
}
.eve-security-background-m-10 {
  background-color: var(--eve-security-color-m-10);
  fill: var(--eve-security-color-m-10);
}

/* WH Type color classes */
.eve-wh-type-color-high {
  color: var(--eve-wh-type-color-high) !important;
  fill: var(--eve-wh-type-color-high);
  font-weight: bold !important;
}
.eve-wh-type-color-low {
  color: var(--eve-wh-type-color-low) !important;
  fill: var(--eve-wh-type-color-low);
  font-weight: bold !important;
}
.eve-wh-type-color-null {
  color: var(--eve-wh-type-color-null) !important;
  fill: var(--eve-wh-type-color-null);
  font-weight: bold !important;
}
.eve-wh-type-color-c1 {
  color: var(--eve-wh-type-color-c1) !important;
  fill: var(--eve-wh-type-color-c1);
  font-weight: bold !important;
}
.eve-wh-type-color-c2 {
  color: var(--eve-wh-type-color-c2) !important;
  fill: var(--eve-wh-type-color-c2);
  font-weight: bold !important;
}
.eve-wh-type-color-c3 {
  color: var(--eve-wh-type-color-c3) !important;
  fill: var(--eve-wh-type-color-c3);
  font-weight: bold !important;
}
.eve-wh-type-color-c4 {
  color: var(--eve-wh-type-color-c4) !important;
  fill: var(--eve-wh-type-color-c4);
  font-weight: bold !important;
}
.eve-wh-type-color-c5 {
  color: var(--eve-wh-type-color-c5) !important;
  fill: var(--eve-wh-type-color-c5);
  font-weight: bold !important;
}
.eve-wh-type-color-c6 {
  color: var(--eve-wh-type-color-c6) !important;
  fill: var(--eve-wh-type-color-c6);
  font-weight: bold !important;
}
.eve-wh-type-color-c13 {
  color: var(--eve-wh-type-color-c13) !important;
  fill: var(--eve-wh-type-color-c13);
}
.eve-wh-type-color-drifter {
  color: var(--eve-wh-type-color-drifter) !important;
  fill: var(--eve-wh-type-color-drifter);
}
.eve-wh-type-color-thera {
  color: var(--eve-wh-type-color-thera) !important;
  fill: var(--eve-wh-type-color-thera);
}

/* WH Type backgrounds */
.eve-wh-type-background-high {
  background-color: var(--eve-wh-type-color-high);
}
.eve-wh-type-background-low {
  background-color: var(--eve-wh-type-color-low);
}
.eve-wh-type-background-null {
  background-color: var(--eve-wh-type-color-null);
}
.eve-wh-type-background-c1 {
  background-color: var(--eve-wh-type-color-c1);
}
.eve-wh-type-background-c2 {
  background-color: var(--eve-wh-type-color-c2);
}
.eve-wh-type-background-c3 {
  background-color: var(--eve-wh-type-color-c3);
}
.eve-wh-type-background-c4 {
  background-color: var(--eve-wh-type-color-c4);
}
.eve-wh-type-background-c5 {
  background-color: var(--eve-wh-type-color-c5);
}
.eve-wh-type-background-c6 {
  background-color: var(--eve-wh-type-color-c6);
}
.eve-wh-type-background-c13 {
  background-color: var(--eve-wh-type-color-c13);
}
.eve-wh-type-background-drifter {
  background-color: var(--eve-wh-type-color-drifter);
}
.eve-wh-type-background-thera {
  background-color: var(--eve-wh-type-color-thera);
}
.eve-wh-type-background-zarzakh {
  background-color: var(--eve-wh-type-color-zarzakh);
}

/* Kind color classes */
.eve-kind-color-high {
  color: var(--eve-wh-type-color-high);
  fill: var(--eve-wh-type-color-high);
}
.eve-kind-color-low {
  color: var(--eve-wh-type-color-low);
  fill: var(--eve-wh-type-color-low);
  font-weight: bold;
}
.eve-kind-color-null {
  color: var(--eve-wh-type-color-null);
  fill: var(--eve-wh-type-color-null);
}
.eve-kind-color-wh {
  color: var(--eve-wh-type-color-c6);
  fill: var(--eve-wh-type-color-c6);
}
.eve-kind-color-thera {
  color: var(--eve-wh-type-color-thera);
  fill: var(--eve-wh-type-color-thera);
}
.eve-kind-color-abyss {
  color: var(--eve-wh-type-color-c6);
  fill: var(--eve-wh-type-color-c6);
}
.eve-kind-color-penalty {
  color: var(--eve-wh-type-color-c6);
  fill: var(--eve-wh-type-color-c6);
}
.eve-kind-color-pochven {
  color: var(--eve-wh-type-color-c6);
  fill: var(--eve-wh-type-color-c6);
}
.eve-kind-color-zarzakh {
  color: var(--eve-wh-type-color-zarzakh);
  fill: var(--eve-wh-type-color-zarzakh);
}

/* Kind backgrounds */
.eve-kind-background-high {
  background-color: var(--eve-wh-type-color-high);
}
.eve-kind-background-low {
  background-color: var(--eve-wh-type-color-low);
}
.eve-kind-background-null {
  background-color: var(--eve-wh-type-color-null);
}
.eve-kind-background-wh {
  background-color: var(--eve-wh-type-color-c6);
}
.eve-kind-background-thera {
  background-color: var(--eve-wh-type-color-thera);
}
.eve-kind-background-abyss {
  background-color: var(--eve-wh-type-color-c6);
}
.eve-kind-background-penalty {
  background-color: var(--eve-wh-type-color-c6);
}
.eve-kind-background-pochven {
  background-color: var(--eve-wh-type-color-c6);
}
.eve-kind-background-zarzakh {
  background-color: var(--eve-wh-type-color-zarzakh);
}

/* System status color classes */
.eve-system-status-color-clear {
  color: var(--eve-solar-system-status-color-unknown);
}
.eve-system-status-color-home {
  color: var(--eve-solar-system-status-color-home);
}
.eve-system-status-color-friendly {
  color: var(--eve-solar-system-status-color-friendly);
}
.eve-system-status-color-lookingFor {
  color: var(--eve-solar-system-status-color-lookingFor);
}
.eve-system-status-color-warning {
  color: var(--eve-solar-system-status-color-warning);
}
.eve-system-status-color-target {
  color: var(--eve-solar-system-status-color-target);
}
.eve-system-status-color-dangerous {
  color: var(--eve-solar-system-status-color-dangerous);
}

.eve-system-status-clear {
  background-color: var(--eve-solar-system-status-unknown);
}
.eve-system-status-home {
  background-color: var(--eve-solar-system-status-home);
}
.eve-system-status-friendly {
  background-color: var(--eve-solar-system-status-friendly);
}
.eve-system-status-lookingFor {
  background-color: var(--eve-solar-system-status-lookingFor);
}
.eve-system-status-warning {
  background-color: var(--eve-solar-system-status-warning);
}
.eve-system-status-target {
  background-color: var(--eve-solar-system-status-target);
}
.eve-system-status-dangerous {
  background-color: var(--eve-solar-system-status-dangerous);
}

.eve-system-status-clear {
  background-color: var(--eve-solar-system-status-unknown);
  color: var(--eve-solar-system-status-color-unknown);
}

.eve-system-status-home {
  background-color: var(--eve-solar-system-status-home);
  color: var(--eve-solar-system-status-color-home);
}

.eve-system-status-friendly {
  background-color: var(--eve-solar-system-status-friendly);
  color: var(--eve-solar-system-status-color-friendly);
}

.eve-system-status-lookingFor {
  background-color: var(--eve-solar-system-status-lookingFor);
  color: var(--eve-solar-system-status-color-lookingFor);
}

.eve-system-status-warning {
  background-color: var(--eve-solar-system-status-warning);
  color: var(--eve-solar-system-status-color-warning);
}

.eve-system-status-target {
  background-color: var(--eve-solar-system-status-target);
  color: var(--eve-solar-system-status-color-target);
}

.eve-system-status-dangerous {
  background-color: var(--eve-solar-system-status-dangerous);
  color: var(--eve-solar-system-status-color-dangerous);
}

.wd-route-system-shape-triangle {
  clip-path: polygon(50% 0, 0 100%, 100% 100%);
}
.wd-route-system-shape-circle {
  border-radius: 40%;
}

/* Some additional background classes */
.wd-marker-bookmark-color-shattered {
  background-color: #833ca4;
  margin-top: 1px;
}

.wd-marker-bookmark-color-custom {
  background-color: #282828;
  border: 1px solid #4c4c4c;
  color: #ffffff !important;
  padding-top: 1px !important;
}

.wd-marker-bookmark-color-a0 {
  background-color: #3d94af;
}

.wd-marker-bookmark-color-average {
  background-color: #2d803b;
}

.wd-marker-bookmark-color-ytirium {
  background-color: #3d94af;
}

.wd-marker-bookmark-color-l1 {
  background-color: #563daf;
}

.wd-marker-bookmark-color-l2 {
  background-color: #8f3daf;
}

.wd-marker-bookmark-color-l3 {
  background-color: #3d65af;
}

.wd-marker-bookmark-color-normal {
  background-color: #ffa200;
}

.wd-marker-bookmark-color-warn {
  background-color: #f15600;
}

.wd-marker-bookmark-color-danger {
  background-color: #d10600;
}


.react-flow__minimap-node {
  fill: #ffb03a;
}

.react-flow__minimap {
  border: 1px solid #282828;
  border-radius: 4px;
  background-color: rgb(47 37 37) !important;
  overflow: hidden;
}

.react-flow__minimap-mask {
  stroke-width: 2px;
  fill: rgba(0, 0, 0, 0.5);
  mix-blend-mode: overlay;
}

.react-flow__minimap-mask {
  stroke-width: 2px;
  fill: rgb(0 0 0 / 50%) !important;
  mix-blend-mode: inherit;
  opacity: 1;
  stroke: #fff;
}

.context-menu-active {
  background-color: rgba(131, 131, 131, 0.33);
}</file><file path="assets/js/hooks/Mapper/components/map/styles/index.scss">@import &apos;./default-theme.scss&apos;; 
@import &apos;./pathfinder-theme.scss&apos;;</file><file path="assets/js/hooks/Mapper/components/map/styles/pathfinder-theme.scss">@import &apos;./eve-common-variables&apos;;
@import &apos;./eve-common&apos;;
@import url(&apos;https://fonts.googleapis.com/css2?family=Oxygen:wght@300;400;700&amp;display=swap&apos;);

$homeBase: rgb(197, 253, 67);
$homeAlpha: rgba(197, 253, 67, 0.32);
$homeDark30: darken($homeBase, 30%);

.pathfinder-theme {
  /* -- Override values from the default theme -- */
  --rf-bg-color: #000000;
  --rf-soft-bg-color: #282828;
  --rf-node-soft-bg-color: #313335;
  --rf-node-font-weight: bold;
  --rf-text-color: #adadad;
  --rf-region-name: var(--rf-text-color);
  --rf-custom-name: var(--rf-text-color);
  --rf-bg-variant: &quot;lines&quot;;
  --rf-bg-gap: 34;
  --rf-snap-size: 17;
  --rf-bg-pattern-color: #313131;
  --rf-local-counter-font-weight: 700;

  /* Additional node-specific overrides */
  --rf-node-line-height: normal;
  --rf-node-font-family: &apos;Oxygen&apos;, sans-serif;
  --rf-tag-color: #fbbf24;

  /* -- theme-specific variables -- */
  --eve-effect-pulsar: #428bca;
  --eve-effect-magnetar: #e06fdf;
  --eve-effect-wolfRayet: #e28a0d;
  --eve-effect-blackHole: #000000;
  --eve-effect-cataclysmicVariable: #ffffbb;
  --eve-effect-redGiant: #d9534f;

  --eve-wh-type-color-high: #5cb85c;
  --eve-wh-type-color-low: #e28a0d;
  --eve-wh-type-color-null: #d9534f;
  --eve-wh-type-color-c1: #428bca;
  --eve-wh-type-color-c2: #428bca;
  --eve-wh-type-color-c3: #e28a0d;
  --eve-wh-type-color-c4: #e28a0d;
  --eve-wh-type-color-c5: #d9534f;
  --eve-wh-type-color-c6: #d9534f;
  --eve-wh-type-color-c13: #7986cb;
  --eve-wh-type-color-drifter: #44aa82;

  --rf-node-local-counter: #5cb85c;
  --rf-has-user-characters: #ffc75d;

  --eve-solar-system-status-home:                #{$homeAlpha};
  --eve-solar-system-status-color-home:          #{$homeBase};
}</file><file path="assets/js/hooks/Mapper/components/map/utils/changes.ts">/* eslint-disable @typescript-eslint/no-explicit-any */
import { EdgeChange, NodeChange, Node, Edge } from &apos;reactflow&apos;;

// This function applies changes to nodes or edges that are triggered by React Flow internally.
// When you drag a node for example, React Flow will send a position change update.
// This function then applies the changes and returns the updated elements.
function applyChanges(changes: any[], elements: any[]): any[] {
  // we need this hack to handle the setNodes and setEdges function of the useReactFlow hook for controlled flows
  if (changes.some(c =&gt; c.type === &apos;reset&apos;)) {
    return changes.filter(c =&gt; c.type === &apos;reset&apos;).map(c =&gt; c.item);
  }

  const updatedElements: any[] = [];
  // By storing a map of changes for each element, we can a quick lookup as we
  // iterate over the elements array!
  const changesMap = new Map&lt;any, any[]&gt;();
  const addItemChanges: any[] = [];

  for (const change of changes) {
    if (change.type === &apos;add&apos;) {
      addItemChanges.push(change);
      continue;
    } else if (change.type === &apos;remove&apos; || change.type === &apos;replace&apos;) {
      // For a &apos;remove&apos; change we can safely ignore any other changes queued for
      // the same element, it&apos;s going to be removed anyway!
      changesMap.set(change.id, [change]);
    } else {
      const elementChanges = changesMap.get(change.id);

      if (elementChanges) {
        // If we have some changes queued already, we can do a mutable update of
        // that array and save ourselves some copying.
        elementChanges.push(change);
      } else {
        changesMap.set(change.id, [change]);
      }
    }
  }

  for (const element of elements) {
    const changes = changesMap.get(element.id);

    // When there are no changes for an element we can just push it unmodified,
    // no need to copy it.
    if (!changes) {
      updatedElements.push(element);
      continue;
    }

    // If we have a &apos;remove&apos; change queued, it&apos;ll be the only change in the array
    if (changes[0].type === &apos;remove&apos;) {
      continue;
    }

    if (changes[0].type === &apos;replace&apos;) {
      updatedElements.push({ ...changes[0].item });
      continue;
    }

    // For other types of changes, we want to start with a shallow copy of the
    // object so React knows this element has changed. Sequential changes will
    /// each _mutate_ this object, so there&apos;s only ever one copy.
    const updatedElement = { ...element };

    for (const change of changes) {
      applyChange(change, updatedElement);
    }

    updatedElements.push(updatedElement);
  }

  // we need to wait for all changes to be applied before adding new items
  // to be able to add them at the correct index
  if (addItemChanges.length) {
    addItemChanges.forEach(change =&gt; {
      if (change.index !== undefined) {
        updatedElements.splice(change.index, 0, { ...change.item });
      } else {
        updatedElements.push({ ...change.item });
      }
    });
  }

  return updatedElements;
}

// Applies a single change to an element. This is a *mutable* update.
function applyChange(change: any, element: any): any {
  switch (change.type) {
    case &apos;select&apos;: {
      element.selected = change.selected;
      break;
    }

    case &apos;position&apos;: {
      if (typeof change.position !== &apos;undefined&apos;) {
        element.position = change.position;
      }

      if (typeof change.dragging !== &apos;undefined&apos;) {
        element.dragging = change.dragging;
      }

      break;
    }

    case &apos;dimensions&apos;: {
      if (typeof change.dimensions !== &apos;undefined&apos;) {
        element.measured ??= {};
        element.measured.width = change.dimensions.width;
        element.measured.height = change.dimensions.height;

        if (change.setAttributes) {
          element.width = change.dimensions.width;
          element.height = change.dimensions.height;
        }
      }

      if (typeof change.resizing === &apos;boolean&apos;) {
        element.resizing = change.resizing;
      }

      break;
    }
  }
}

/**
 * Drop in function that applies node changes to an array of nodes.
 * @public
 * @remarks Various events on the &lt;ReactFlow /&gt; component can produce an {@link NodeChange} that describes how to update the edges of your flow in some way.
 If you don&apos;t need any custom behaviour, this util can be used to take an array of these changes and apply them to your edges.
 * @param changes - Array of changes to apply
 * @param nodes - Array of nodes to apply the changes to
 * @returns Array of updated nodes
 * @example
 *  const onNodesChange = useCallback(
      (changes) =&gt; {
        setNodes((oldNodes) =&gt; applyNodeChanges(changes, oldNodes));
      },
      [setNodes],
    );

    return (
      &lt;ReactFLow nodes={nodes} edges={edges} onNodesChange={onNodesChange} /&gt;
    );
 */
export function applyNodeChanges&lt;NodeType extends Node = Node&gt;(changes: NodeChange[], nodes: NodeType[]): NodeType[] {
  return applyChanges(changes, nodes) as NodeType[];
}

/**
 * Drop in function that applies edge changes to an array of edges.
 * @public
 * @remarks Various events on the &lt;ReactFlow /&gt; component can produce an {@link EdgeChange} that describes how to update the edges of your flow in some way.
 If you don&apos;t need any custom behaviour, this util can be used to take an array of these changes and apply them to your edges.
 * @param changes - Array of changes to apply
 * @param edges - Array of edge to apply the changes to
 * @returns Array of updated edges
 * @example
 *  const onEdgesChange = useCallback(
      (changes) =&gt; {
        setEdges((oldEdges) =&gt; applyEdgeChanges(changes, oldEdges));
      },
      [setEdges],
    );

    return (
      &lt;ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} /&gt;
    );
 */
export function applyEdgeChanges&lt;EdgeType extends Edge = Edge&gt;(changes: EdgeChange[], edges: EdgeType[]): EdgeType[] {
  return applyChanges(changes, edges) as EdgeType[];
}</file><file path="assets/js/hooks/Mapper/components/map/constants.ts">import { ConnectionType, MassState, ShipSizeStatus } from &apos;@/hooks/Mapper/types&apos;;

export enum SOLAR_SYSTEM_CLASS_IDS {
  ccp1 = -1,
  c1 = 1,
  c2 = 2,
  c3 = 3,
  c4 = 4,
  c5 = 5,
  c6 = 6,
  hs = 7,
  ls = 8,
  ns = 9,
  ccp2 = 10,
  ccp3 = 11,
  thera = 12,
  c13 = 13,
  sentinel = 14,
  barbican = 15,
  vidette = 16,
  conflux = 17,
  redoubt = 18,
  a1 = 19,
  a2 = 20,
  a3 = 21,
  a4 = 22,
  a5 = 23,
  ccp4 = 24,
  pochven = 25,
  zarzakh = 10100,
}

export enum SOLAR_SYSTEM_CLASS_GROUPS {
  ccp = &apos;ccp&apos;,
  c1 = &apos;c1&apos;,
  c2 = &apos;c2&apos;,
  c3 = &apos;c3&apos;,
  c4 = &apos;c4&apos;,
  c5 = &apos;c5&apos;,
  c6 = &apos;c6&apos;,
  hs = &apos;hs&apos;,
  ls = &apos;ls&apos;,
  ns = &apos;ns&apos;,
  thera = &apos;thera&apos;,
  c13 = &apos;c13&apos;,
  drifter = &apos;drifter&apos;,
  unknown = &apos;unknown&apos;,
  pochven = &apos;pochven&apos;,
  jovian = &apos;jovian&apos;,
}

export const SOLAR_SYSTEM_TO_CLASS_GROUPS_CLASSES = {
  c1: [&apos;c1&apos;],
  c2: [&apos;c2&apos;],
  c3: [&apos;c3&apos;],
  c4: [&apos;c4&apos;],
  c5: [&apos;c5&apos;],
  c6: [&apos;c6&apos;],
  hs: [&apos;hs&apos;],
  ls: [&apos;ls&apos;],
  ns: [&apos;ns&apos;],
  thera: [&apos;thera&apos;],
  c13: [&apos;c13&apos;],
  pochven: [&apos;pochven&apos;],
  drifter: [&apos;sentinel&apos;, &apos;barbican&apos;, &apos;vidette&apos;, &apos;conflux&apos;, &apos;redoubt&apos;],
  jove: [&apos;jove&apos;],
};

export const SOLAR_SYSTEM_CLASSES_TO_CLASS_GROUPS = {
  ccp1: SOLAR_SYSTEM_CLASS_GROUPS.ccp,
  c1: SOLAR_SYSTEM_CLASS_GROUPS.c1,
  c2: SOLAR_SYSTEM_CLASS_GROUPS.c2,
  c3: SOLAR_SYSTEM_CLASS_GROUPS.c3,
  c4: SOLAR_SYSTEM_CLASS_GROUPS.c4,
  c5: SOLAR_SYSTEM_CLASS_GROUPS.c5,
  c6: SOLAR_SYSTEM_CLASS_GROUPS.c6,
  hs: SOLAR_SYSTEM_CLASS_GROUPS.hs,
  ls: SOLAR_SYSTEM_CLASS_GROUPS.ls,
  ns: SOLAR_SYSTEM_CLASS_GROUPS.ns,
  ccp2: SOLAR_SYSTEM_CLASS_GROUPS.ccp,
  ccp3: SOLAR_SYSTEM_CLASS_GROUPS.ccp,
  thera: SOLAR_SYSTEM_CLASS_GROUPS.thera,
  c13: SOLAR_SYSTEM_CLASS_GROUPS.c13,
  sentinel: SOLAR_SYSTEM_CLASS_GROUPS.drifter,
  barbican: SOLAR_SYSTEM_CLASS_GROUPS.drifter,
  vidette: SOLAR_SYSTEM_CLASS_GROUPS.drifter,
  conflux: SOLAR_SYSTEM_CLASS_GROUPS.drifter,
  redoubt: SOLAR_SYSTEM_CLASS_GROUPS.drifter,
  a1: SOLAR_SYSTEM_CLASS_GROUPS.unknown,
  a2: SOLAR_SYSTEM_CLASS_GROUPS.unknown,
  a3: SOLAR_SYSTEM_CLASS_GROUPS.unknown,
  a4: SOLAR_SYSTEM_CLASS_GROUPS.unknown,
  a5: SOLAR_SYSTEM_CLASS_GROUPS.unknown,
  ccp4: SOLAR_SYSTEM_CLASS_GROUPS.ccp,
  pochven: SOLAR_SYSTEM_CLASS_GROUPS.pochven,
};

type WormholesAdditionalInfoType = {
  id: string;
  shortName: string;
  wormholeClassID: number;
  title: string;
  shortTitle: string;
  effectPower?: number;
};

// TODO - maybe we need store it on backend. But not sure
export const WORMHOLES_ADDITIONAL_INFO_RAW: WormholesAdditionalInfoType[] = [
  {
    id: &apos;ccp1&apos;,
    shortName: &apos;CCP&apos;,
    wormholeClassID: -1,
    title: &apos;CCP System&apos;,
    shortTitle: &apos;CCP&apos;,
  },
  {
    id: &apos;c1&apos;,
    shortName: &apos;C1&apos;,
    wormholeClassID: 1,
    effectPower: 1,
    title: &apos;Class 1&apos;,
    shortTitle: &apos;C1&apos;,
  },
  {
    id: &apos;c2&apos;,
    shortName: &apos;C2&apos;,
    wormholeClassID: 2,
    effectPower: 2,
    title: &apos;Class 2&apos;,
    shortTitle: &apos;C2&apos;,
  },
  {
    id: &apos;c3&apos;,
    shortName: &apos;C3&apos;,
    wormholeClassID: 3,
    effectPower: 3,
    title: &apos;Class 3&apos;,
    shortTitle: &apos;C3&apos;,
  },
  {
    id: &apos;c4&apos;,
    shortName: &apos;C4&apos;,
    wormholeClassID: 4,
    effectPower: 4,
    title: &apos;Class 4&apos;,
    shortTitle: &apos;C4&apos;,
  },
  {
    id: &apos;c5&apos;,
    shortName: &apos;C5&apos;,
    wormholeClassID: 5,
    effectPower: 5,
    title: &apos;Class 5&apos;,
    shortTitle: &apos;C5&apos;,
  },
  {
    id: &apos;c6&apos;,
    shortName: &apos;C6&apos;,
    wormholeClassID: 6,
    effectPower: 6,
    title: &apos;Class 6&apos;,
    shortTitle: &apos;C6&apos;,
  },
  {
    id: &apos;hs&apos;,
    shortName: &apos;H&apos;,
    wormholeClassID: 7,
    title: &apos;High-sec&apos;,
    shortTitle: &apos;High-sec&apos;,
  },
  {
    id: &apos;ls&apos;,
    shortName: &apos;L&apos;,
    wormholeClassID: 8,
    title: &apos;Low-sec&apos;,
    shortTitle: &apos;Low-sec&apos;,
  },
  {
    id: &apos;ns&apos;,
    shortName: &apos;N&apos;,
    wormholeClassID: 9,
    title: &apos;Null-sec&apos;,
    shortTitle: &apos;Null-sec&apos;,
  },
  {
    id: &apos;ccp2&apos;,
    shortName: &apos;CCP&apos;,
    wormholeClassID: 10,
    title: &apos;CCP System&apos;,
    shortTitle: &apos;CCP&apos;,
  },
  {
    id: &apos;ccp3&apos;,
    shortName: &apos;CCP&apos;,
    wormholeClassID: 11,
    title: &apos;CCP System&apos;,
    shortTitle: &apos;CCP&apos;,
  },
  {
    id: &apos;thera&apos;,
    shortName: &apos;T&apos;,
    wormholeClassID: 12,
    title: &apos;Class 12 (Thera)&apos;,
    shortTitle: &apos;Thera&apos;,
  },
  {
    id: &apos;c13&apos;,
    shortName: &apos;C13&apos;,
    wormholeClassID: 13,
    effectPower: 6,
    title: &apos;Class 13 (Shattered Frigate)&apos;,
    shortTitle: &apos;C13&apos;,
  },
  {
    id: &apos;sentinel&apos;,
    shortName: &apos;D&apos;,
    wormholeClassID: 14,
    effectPower: 2,
    title: &apos;Class 14 (Sentinel Drifter)&apos;,
    shortTitle: &apos;Sentinel MZ&apos;,
  },
  {
    id: &apos;barbican&apos;,
    shortName: &apos;D&apos;,
    wormholeClassID: 15,
    effectPower: 2,
    title: &apos;Class 15 (Barbican Drifter)&apos;,
    shortTitle: &apos;Liberated Barbican&apos;,
  },
  {
    id: &apos;vidette&apos;,
    shortName: &apos;D&apos;,
    wormholeClassID: 16,
    effectPower: 2,
    title: &apos;Class 16 (Vidette Drifter)&apos;,
    shortTitle: &apos;Sanctified Vidette&apos;,
  },
  {
    id: &apos;conflux&apos;,
    shortName: &apos;D&apos;,
    wormholeClassID: 17,
    effectPower: 2,
    title: &apos;Class 17 (Conflux Drifter)&apos;,
    shortTitle: &apos;Conflux Eyrie&apos;,
  },
  {
    id: &apos;redoubt&apos;,
    shortName: &apos;D&apos;,
    wormholeClassID: 18,
    effectPower: 2,
    title: &apos;Class 18 (Redoubt Drifter)&apos;,
    shortTitle: &apos;Azdaja Redoubt&apos;,
  },
  {
    id: &apos;a1&apos;,
    shortName: &apos;A1&apos;,
    wormholeClassID: 19,
    title: &apos;(Abyssal class 1)&apos;,
    shortTitle: &apos;A1&apos;,
  },
  {
    id: &apos;a2&apos;,
    shortName: &apos;A2&apos;,
    wormholeClassID: 20,
    title: &apos;(Abyssal class 2)&apos;,
    shortTitle: &apos;A2&apos;,
  },
  {
    id: &apos;a3&apos;,
    shortName: &apos;A3&apos;,
    wormholeClassID: 21,
    title: &apos;(Abyssal class 3)&apos;,
    shortTitle: &apos;A3&apos;,
  },
  {
    id: &apos;a4&apos;,
    shortName: &apos;A4&apos;,
    wormholeClassID: 22,
    title: &apos;(Abyssal class 4)&apos;,
    shortTitle: &apos;A4&apos;,
  },
  {
    id: &apos;a5&apos;,
    shortName: &apos;A5&apos;,
    wormholeClassID: 23,
    title: &apos;(Abyssal class 5)&apos;,
    shortTitle: &apos;A5&apos;,
  },
  {
    id: &apos;ccp4&apos;,
    shortName: &apos;CCP&apos;,
    wormholeClassID: 24,
    title: &apos;CCP System (Penalty)&apos;,
    shortTitle: &apos;CCP&apos;,
  },
  {
    id: &apos;pochven&apos;,
    shortName: &apos;P&apos;,
    wormholeClassID: 25,
    title: &apos;Triglavian space (Pochven)&apos;,
    shortTitle: &apos;Pochven&apos;,
  },
  {
    id: &apos;zarzakh&apos;,
    shortName: &apos;N&apos;,
    wormholeClassID: 10100,
    title: &apos;Pirate space&apos;,
    shortTitle: &apos;Zarzakh&apos;,
  },
  {
    id: &apos;k162&apos;,
    shortName: &apos;K162&apos;,
    wormholeClassID: 10101,
    title: &apos;Reverse&apos;,
    shortTitle: &apos;K162&apos;,
  },
];

export const WORMHOLES_ADDITIONAL_INFO: Record&lt;string, WormholesAdditionalInfoType&gt; =
  WORMHOLES_ADDITIONAL_INFO_RAW.reduce((acc, x) =&gt; ({ ...acc, [x.id]: x }), {});

export const WORMHOLES_ADDITIONAL_INFO_BY_CLASS_ID: Record&lt;string, WormholesAdditionalInfoType&gt; =
  WORMHOLES_ADDITIONAL_INFO_RAW.reduce((acc, x) =&gt; ({ ...acc, [x.wormholeClassID]: x }), {});

export const WORMHOLES_ADDITIONAL_INFO_BY_SHORT_NAME: Record&lt;string, WormholesAdditionalInfoType&gt; =
  WORMHOLES_ADDITIONAL_INFO_RAW.reduce((acc, x) =&gt; ({ ...acc, [x.shortName]: x }), {});

// export const SOLAR_SYSTEM_CLASS_NAMES = {
//   ccp1 =  ,
//   c1 = ,
//   c2 = ,
//   c3 = ,
//   c4 = ,
//   c5 = ,
//   c6 = ,
//   hs = ,
//   ls = ,
//   ns = ,
//   ccp2 = ,
//   ccp3 = ,
//   thera = ,
//   c13 = ,
//   sentinel = ,
//   baribican = ,
//   vidette = ,
//   conflux = ,
//   redoubt = ,
//   a1 = ,
//   a2 = ,
//   a3 = ,
//   a4 = ,
//   a5 = ,
//   ccp4 = ,
//   pochven = ,
//   zarzakh = ,
// }

export const REGION_SHORT_NAME: Record&lt;string, string&gt; = {
  Aridia: &apos;Aridia&apos;,
  &apos;Black Rise&apos;: &apos;Black Rise&apos;,
  &apos;The Bleak Lands&apos;: &apos;Bl. Lands&apos;,
  &apos;The Citadel&apos;: &apos;The Citadel&apos;,
  Derelik: &apos;Derelik&apos;,
  Devoid: &apos;Devoid&apos;,
  Domain: &apos;Domain&apos;,
  Essence: &apos;Essence&apos;,
  Everyshore: &apos;Everyshore&apos;,
  &apos;The Forge&apos;: &apos;The Forge&apos;,
  Genesis: &apos;Genesis&apos;,
  Heimatar: &apos;Heimatar&apos;,
  Kador: &apos;Kador&apos;,
  Khanid: &apos;Khanid&apos;,
  &apos;Kor-Azor&apos;: &apos;Kor-Azor&apos;,
  Lonetrek: &apos;Lonetrek&apos;,
  Metropolis: &apos;Metropolis&apos;,
  &apos;Molden Heath&apos;: &apos;Molden H.&apos;,
  Placid: &apos;Placid&apos;,
  &apos;Sinq Laison&apos;: &apos;S. Laison&apos;,
  Solitude: &apos;Solitude&apos;,
  &apos;Tash-Murkon&apos;: &apos;Tash-M.&apos;,
  &apos;Verge Vendor&apos;: &apos;Verge V.&apos;,
  Branch: &apos;Branch&apos;,
  Cache: &apos;Cache&apos;,
  Catch: &apos;Catch&apos;,
  &apos;Cloud Ring&apos;: &apos;Cloud Ring&apos;,
  &apos;Cobalt Edge&apos;: &apos;Cobalt E.&apos;,
  Curse: &apos;Curse&apos;,
  Deklein: &apos;Deklein&apos;,
  Delve: &apos;Delve&apos;,
  Detorid: &apos;Detorid&apos;,
  Esoteria: &apos;Esoteria&apos;,
  &apos;Etherium Reach&apos;: &apos;Etherium R.&apos;,
  Fade: &apos;Fade&apos;,
  Feythabolis: &apos;Feythabolis&apos;,
  Fountain: &apos;Fountain&apos;,
  Geminate: &apos;Geminate&apos;,
  &apos;Great Wildlands&apos;: &apos;G. Wild.&apos;,
  Immensea: &apos;Immensea&apos;,
  Impass: &apos;Impass&apos;,
  Insmother: &apos;Insmother&apos;,
  &apos;The Kalevala Expanse&apos;: &apos;Kalevala E.&apos;,
  Malpais: &apos;Malpais&apos;,
  Oasa: &apos;Oasa&apos;,
  Omist: &apos;Omist&apos;,
  &apos;Outer Passage&apos;: &apos;O. Passage&apos;,
  &apos;Outer Ring&apos;: &apos;Outer Ring&apos;,
  &apos;Paragon Soul&apos;: &apos;Paragon S.&apos;,
  &apos;Period Basis&apos;: &apos;Period B.&apos;,
  &apos;Perrigen Falls&apos;: &apos;Perrigen F.&apos;,
  Pochven: &apos;Pochven&apos;,
  Providence: &apos;Providence&apos;,
  &apos;Pure Blind&apos;: &apos;Pure Blind&apos;,
  Querious: &apos;Querious&apos;,
  &apos;Scalding Pass&apos;: &apos;Scalding P.&apos;,
  &apos;The Spire&apos;: &apos;The Spire&apos;,
  Stain: &apos;Stain&apos;,
  Syndicate: &apos;Syndicate&apos;,
  Tenal: &apos;Tenal&apos;,
  Tenerifis: &apos;Tenerifis&apos;,
  Tribute: &apos;Tribute&apos;,
  &apos;Vale of the Silent&apos;: &apos;V. Silent&apos;,
  Venal: &apos;Venal&apos;,
  &apos;Wicked Creek&apos;: &apos;Wicked C.&apos;,
};

export const SECURITY_FOREGROUND_CLASSES: Record&lt;string, string&gt; = {
  &apos;1.0&apos;: &apos;eve-security-color-10&apos;,
  &apos;0.9&apos;: &apos;eve-security-color-09&apos;,
  &apos;0.8&apos;: &apos;eve-security-color-08&apos;,
  &apos;0.7&apos;: &apos;eve-security-color-07&apos;,
  &apos;0.6&apos;: &apos;eve-security-color-06&apos;,
  &apos;0.5&apos;: &apos;eve-security-color-05&apos;,
  &apos;0.4&apos;: &apos;eve-security-color-04&apos;,
  &apos;0.3&apos;: &apos;eve-security-color-03&apos;,
  &apos;0.2&apos;: &apos;eve-security-color-02&apos;,
  &apos;0.1&apos;: &apos;eve-security-color-01&apos;,
  &apos;0.0&apos;: &apos;eve-security-color-00&apos;,
  &apos;-0.0&apos;: &apos;eve-security-color-00&apos;,
  &apos;-0.1&apos;: &apos;eve-security-color-m-01&apos;,
  &apos;-0.2&apos;: &apos;eve-security-color-m-02&apos;,
  &apos;-0.3&apos;: &apos;eve-security-color-m-03&apos;,
  &apos;-0.4&apos;: &apos;eve-security-color-m-04&apos;,
  &apos;-0.5&apos;: &apos;eve-security-color-m-05&apos;,
  &apos;-0.6&apos;: &apos;eve-security-color-m-06&apos;,
  &apos;-0.7&apos;: &apos;eve-security-color-m-07&apos;,
  &apos;-0.8&apos;: &apos;eve-security-color-m-08&apos;,
  &apos;-0.9&apos;: &apos;eve-security-color-m-09&apos;,
  &apos;-1.0&apos;: &apos;eve-security-color-m-10&apos;,
};

export const SECURITY_BACKGROUND_CLASSES: Record&lt;string, string&gt; = {
  &apos;1.0&apos;: &apos;eve-security-background-10&apos;,
  &apos;0.9&apos;: &apos;eve-security-background-09&apos;,
  &apos;0.8&apos;: &apos;eve-security-background-08&apos;,
  &apos;0.7&apos;: &apos;eve-security-background-07&apos;,
  &apos;0.6&apos;: &apos;eve-security-background-06&apos;,
  &apos;0.5&apos;: &apos;eve-security-background-05&apos;,
  &apos;0.4&apos;: &apos;eve-security-background-04&apos;,
  &apos;0.3&apos;: &apos;eve-security-background-03&apos;,
  &apos;0.2&apos;: &apos;eve-security-background-02&apos;,
  &apos;0.1&apos;: &apos;eve-security-background-01&apos;,
  &apos;0.0&apos;: &apos;eve-security-background-00&apos;,
  &apos;-0.0&apos;: &apos;eve-security-background-00&apos;,
  &apos;-0.1&apos;: &apos;eve-security-background-m-01&apos;,
  &apos;-0.2&apos;: &apos;eve-security-background-m-02&apos;,
  &apos;-0.3&apos;: &apos;eve-security-background-m-03&apos;,
  &apos;-0.4&apos;: &apos;eve-security-background-m-04&apos;,
  &apos;-0.5&apos;: &apos;eve-security-background-m-05&apos;,
  &apos;-0.6&apos;: &apos;eve-security-background-m-06&apos;,
  &apos;-0.7&apos;: &apos;eve-security-background-m-07&apos;,
  &apos;-0.8&apos;: &apos;eve-security-background-m-08&apos;,
  &apos;-0.9&apos;: &apos;eve-security-background-m-09&apos;,
  &apos;-1.0&apos;: &apos;eve-security-background-m-10&apos;,
};

export const SYSTEM_CLASS_BACKGROUND_CLASSES: Record&lt;string, string&gt; = {
  &apos;-1&apos;: &apos;&apos;,
  &apos;1&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;2&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;3&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;4&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;5&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;6&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;7&apos;: &apos;eve-kind-background-high&apos;,
  &apos;8&apos;: &apos;eve-kind-background-low&apos;,
  &apos;9&apos;: &apos;eve-kind-background-null&apos;,
  &apos;10&apos;: &apos;&apos;,
  &apos;11&apos;: &apos;&apos;,
  &apos;12&apos;: &apos;eve-kind-background-thera&apos;,
  &apos;13&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;14&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;15&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;16&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;17&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;18&apos;: &apos;eve-kind-background-wh&apos;,
  &apos;19&apos;: &apos;eve-kind-background-abyss&apos;,
  &apos;20&apos;: &apos;eve-kind-background-abyss&apos;,
  &apos;21&apos;: &apos;eve-kind-background-abyss&apos;,
  &apos;22&apos;: &apos;eve-kind-background-abyss&apos;,
  &apos;23&apos;: &apos;eve-kind-background-abyss&apos;,
  &apos;24&apos;: &apos;eve-kind-background-penalty&apos;,
  &apos;25&apos;: &apos;eve-kind-background-pochven&apos;,
  &apos;10100&apos;: &apos;eve-kind-background-zarzakh&apos;,
};

export const WORMHOLE_CLASS_BACKGROUND_CLASSES: Record&lt;string, string&gt; = {
  &apos;1&apos;: &apos;eve-wh-type-background-c1&apos;,
  &apos;2&apos;: &apos;eve-wh-type-background-c2&apos;,
  &apos;3&apos;: &apos;eve-wh-type-background-c3&apos;,
  &apos;4&apos;: &apos;eve-wh-type-background-c4&apos;,
  &apos;5&apos;: &apos;eve-wh-type-background-c5&apos;,
  &apos;6&apos;: &apos;eve-wh-type-background-c6&apos;,
  &apos;7&apos;: &apos;eve-wh-type-background-high&apos;,
  &apos;8&apos;: &apos;eve-wh-type-background-low&apos;,
  &apos;9&apos;: &apos;eve-wh-type-background-null&apos;,
  &apos;12&apos;: &apos;eve-wh-type-background-thera&apos;,
  &apos;13&apos;: &apos;eve-wh-type-background-c13&apos;,
  &apos;14&apos;: &apos;eve-wh-type-background-drifter&apos;,
  &apos;15&apos;: &apos;eve-wh-type-background-drifter&apos;,
  &apos;16&apos;: &apos;eve-wh-type-background-drifter&apos;,
  &apos;17&apos;: &apos;eve-wh-type-background-drifter&apos;,
  &apos;18&apos;: &apos;eve-wh-type-background-drifter&apos;,
  &apos;25&apos;: &apos;eve-wh-type-background-null&apos;,
  &apos;10100&apos;: &apos;eve-wh-type-background-null&apos;,
};

export const WORMHOLE_CLASS_STYLES: Record&lt;string, string&gt; = {
  &apos;-1&apos;: &apos;&apos;,
  &apos;1&apos;: &apos;eve-wh-type-color-c1&apos;,
  &apos;2&apos;: &apos;eve-wh-type-color-c2&apos;,
  &apos;3&apos;: &apos;eve-wh-type-color-c3&apos;,
  &apos;4&apos;: &apos;eve-wh-type-color-c4&apos;,
  &apos;5&apos;: &apos;eve-wh-type-color-c5&apos;,
  &apos;6&apos;: &apos;eve-wh-type-color-c6&apos;,
  &apos;7&apos;: &apos;eve-wh-type-color-high&apos;,
  &apos;8&apos;: &apos;eve-wh-type-color-low&apos;,
  &apos;9&apos;: &apos;eve-wh-type-color-null&apos;,
  &apos;10&apos;: &apos;&apos;,
  &apos;11&apos;: &apos;&apos;,
  &apos;12&apos;: &apos;eve-wh-type-color-thera&apos;,
  &apos;13&apos;: &apos;eve-wh-type-color-c13&apos;,
  &apos;14&apos;: &apos;eve-wh-type-color-drifter&apos;,
  &apos;15&apos;: &apos;eve-wh-type-color-drifter&apos;,
  &apos;16&apos;: &apos;eve-wh-type-color-drifter&apos;,
  &apos;17&apos;: &apos;eve-wh-type-color-drifter&apos;,
  &apos;18&apos;: &apos;eve-wh-type-color-drifter&apos;,
  &apos;19&apos;: &apos;eve-kind-color-abyss&apos;,
  &apos;20&apos;: &apos;eve-kind-color-abyss&apos;,
  &apos;21&apos;: &apos;eve-kind-color-abyss&apos;,
  &apos;22&apos;: &apos;eve-kind-color-abyss&apos;,
  &apos;23&apos;: &apos;eve-kind-color-abyss&apos;,
  &apos;24&apos;: &apos;eve-kind-color-penalty&apos;,
  &apos;25&apos;: &apos;eve-wh-type-color-null&apos;,
  &apos;10100&apos;: &apos;eve-wh-type-color-thera&apos;,
};

export const SYSTEM_CLASS_STYLES: Record&lt;string, string&gt; = {
  &apos;-1&apos;: &apos;&apos;,
  &apos;1&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;2&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;3&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;4&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;5&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;6&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;7&apos;: &apos;eve-kind-color-high&apos;,
  &apos;8&apos;: &apos;eve-kind-color-low&apos;,
  &apos;9&apos;: &apos;eve-kind-color-null&apos;,
  &apos;10&apos;: &apos;&apos;,
  &apos;11&apos;: &apos;&apos;,
  &apos;12&apos;: &apos;eve-kind-color-thera&apos;,
  &apos;13&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;14&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;15&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;16&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;17&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;18&apos;: &apos;eve-kind-color-wh&apos;,
  &apos;19&apos;: &apos;eve-kind-color-abyss&apos;,
  &apos;20&apos;: &apos;eve-kind-color-abyss&apos;,
  &apos;21&apos;: &apos;eve-kind-color-abyss&apos;,
  &apos;22&apos;: &apos;eve-kind-color-abyss&apos;,
  &apos;23&apos;: &apos;eve-kind-color-abyss&apos;,
  &apos;24&apos;: &apos;eve-kind-color-penalty&apos;,
  &apos;25&apos;: &apos;eve-kind-color-pochven&apos;,
  &apos;10100&apos;: &apos;eve-kind-color-zarzakh&apos;,
};

export enum EFFECT_NAME {
  pulsar = &apos;Pulsar&apos;,
  magnetar = &apos;Magnetar&apos;,
  wolfRayetStar = &apos;Wolf-Rayet Star&apos;,
  blackHole = &apos;Black Hole&apos;,
  cataclysmicVariable = &apos;Cataclysmic Variable&apos;,
  redGiant = &apos;Red Giant&apos;,
  dazhLiminalityLocus = &apos;Dazh Liminality Locus&apos;,
  imperialStellarObservatory = &apos;Imperial Stellar Observatory&apos;,
  stateStellarObservatory = &apos;State Stellar Observatory&apos;,
  republicStellarObservatory = &apos;Republic Stellar Observatory&apos;,
  federalStellarObservatory = &apos;Federal Stellar Observatory&apos;,
}

export const EFFECT_FOREGROUND_STYLES: Record&lt;string, string&gt; = {
  Pulsar: &apos;text-eve-wh-effect-color-pulsar&apos;,
  Magnetar: &apos;text-eve-wh-effect-color-magnetar&apos;,
  &apos;Wolf-Rayet Star&apos;: &apos;text-eve-wh-effect-color-wolfRayet&apos;,
  &apos;Black Hole&apos;: &apos;text-eve-wh-effect-color-blackHole&apos;,
  &apos;Cataclysmic Variable&apos;: &apos;text-eve-wh-effect-color-cataclysmicVariable&apos;,
  &apos;Red Giant&apos;: &apos;text-eve-wh-effect-color-redGiant&apos;,

  &apos;Dazh Liminality Locus&apos;: &apos;text-eve-wh-effect-color-dazhLiminalityLocus&apos;,
  &apos;Imperial Stellar Observatory&apos;: &apos;text-eve-wh-effect-color-imperialStellarObservatory&apos;,
  &apos;State Stellar Observatory&apos;: &apos;text-eve-wh-effect-color-stateStellarObservatory&apos;,
  &apos;Republic Stellar Observatory&apos;: &apos;text-eve-wh-effect-color-republicStellarObservatory&apos;,
  &apos;Federal Stellar Observatory&apos;: &apos;text-eve-wh-effect-color-federalStellarObservatory&apos;,
};

export const EFFECT_BACKGROUND_STYLES: Record&lt;string, string&gt; = {
  Pulsar: &apos;eve-wh-effect-color-pulsar&apos;,
  Magnetar: &apos;eve-wh-effect-color-magnetar&apos;,
  &apos;Wolf-Rayet Star&apos;: &apos;eve-wh-effect-color-wolfRayet&apos;,
  &apos;Black Hole&apos;: &apos;eve-wh-effect-color-blackHole&apos;,
  &apos;Cataclysmic Variable&apos;: &apos;eve-wh-effect-color-cataclysmicVariable&apos;,
  &apos;Red Giant&apos;: &apos;eve-wh-effect-color-redGiant&apos;,
  &apos;Dazh Liminality Locus&apos;: &apos;eve-wh-effect-color-dazhLiminalityLocus&apos;,
  &apos;Imperial Stellar Observatory&apos;: &apos;eve-wh-effect-color-imperialStellarObservatory&apos;,
  &apos;State Stellar Observatory&apos;: &apos;eve-wh-effect-color-stateStellarObservatory&apos;,
  &apos;Republic Stellar Observatory&apos;: &apos;eve-wh-effect-color-republicStellarObservatory&apos;,
  &apos;Federal Stellar Observatory&apos;: &apos;eve-wh-effect-color-federalStellarObservatory&apos;,
};

export const MARKER_BOOKMARK_BG_STYLES: Record&lt;string, string&gt; = {
  custom: &apos;wd-marker-bookmark-color-custom&apos;,
  shattered: &apos;wd-marker-bookmark-color-shattered&apos;,
  a0: &apos;wd-marker-bookmark-color-a0&apos;,
  activityNormal: &apos;wd-marker-bookmark-color-normal&apos;,
  activityWarn: &apos;wd-marker-bookmark-color-warn&apos;,
  activityDanger: &apos;wd-marker-bookmark-color-danger&apos;,

  la: &apos;wd-marker-bookmark-color-average&apos;,
  lb: &apos;wd-marker-bookmark-color-ytirium&apos;,
  lc: &apos;wd-marker-bookmark-color-ytirium&apos;,
  l1: &apos;wd-marker-bookmark-color-l1&apos;,
  l2: &apos;wd-marker-bookmark-color-l2&apos;,
  l3: &apos;wd-marker-bookmark-color-l3&apos;,
};

export enum LABELS {
  clear = &apos;clear&apos;,
  la = &apos;a&apos;,
  lb = &apos;b&apos;,
  lc = &apos;c&apos;,
  l1 = &apos;1&apos;,
  l2 = &apos;2&apos;,
  l3 = &apos;3&apos;,
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const LABELS_INFO: Record&lt;string, any&gt; = {
  [LABELS.clear]: { id: &apos;clear&apos;, name: &apos;Clear&apos;, shortName: &apos;&apos;, icon: &apos;&apos; },
  [LABELS.la]: { id: &apos;la&apos;, name: &apos;Label A&apos;, shortName: &apos;A&apos;, icon: &apos;&apos; },
  [LABELS.lb]: { id: &apos;lb&apos;, name: &apos;Label B&apos;, shortName: &apos;B&apos;, icon: &apos;&apos; },
  [LABELS.lc]: { id: &apos;lc&apos;, name: &apos;Label C&apos;, shortName: &apos;C&apos;, icon: &apos;&apos; },
  [LABELS.l1]: { id: &apos;l1&apos;, name: &apos;Label 1&apos;, shortName: &apos;1&apos;, icon: &apos;&apos; },
  [LABELS.l2]: { id: &apos;l2&apos;, name: &apos;Label 2&apos;, shortName: &apos;2&apos;, icon: &apos;&apos; },
  [LABELS.l3]: { id: &apos;l3&apos;, name: &apos;Label 3&apos;, shortName: &apos;3&apos;, icon: &apos;&apos; },
};

export enum STATUSES {
  unknown,
  home,
  friendly,
  lookingFor,
  warning,
  target,
  dangerous,
}

export const STATUS_NAMES = {
  [STATUSES.unknown]: &apos;Clear&apos;,
  [STATUSES.home]: &apos;Home&apos;,
  [STATUSES.friendly]: &apos;Friendly&apos;,
  [STATUSES.lookingFor]: &apos;Looking for&apos;,
  [STATUSES.warning]: &apos;Warning&apos;,
  [STATUSES.target]: &apos;Target&apos;,
  [STATUSES.dangerous]: &apos;Dangerous&apos;,
};

export const STATUSES_ORDER = [
  STATUSES.unknown,
  STATUSES.home,
  STATUSES.friendly,
  STATUSES.lookingFor,
  STATUSES.warning,
  STATUSES.target,
  STATUSES.dangerous,
];

export const LABELS_ORDER = [LABELS.clear, LABELS.la, LABELS.lb, LABELS.lc, LABELS.l1, LABELS.l2, LABELS.l3];

export const STATUS_COLOR_CLASSES: Record&lt;number, string&gt; = {
  [STATUSES.unknown]: &apos;eve-system-status-color-clear&apos;,
  [STATUSES.home]: &apos;eve-system-status-color-home&apos;,
  [STATUSES.friendly]: &apos;eve-system-status-color-friendly&apos;,
  [STATUSES.lookingFor]: &apos;eve-system-status-color-lookingFor&apos;,
  [STATUSES.warning]: &apos;eve-system-status-color-warning&apos;,
  [STATUSES.target]: &apos;eve-system-status-color-target&apos;,
  [STATUSES.dangerous]: &apos;eve-system-status-color-dangerous&apos;,
};

export const STATUS_CLASSES: Record&lt;number, string&gt; = {
  [STATUSES.unknown]: &apos;eve-system-status-clear&apos;,
  [STATUSES.home]: &apos;eve-system-status-home&apos;,
  [STATUSES.friendly]: &apos;eve-system-status-friendly&apos;,
  [STATUSES.lookingFor]: &apos;eve-system-status-lookingFor&apos;,
  [STATUSES.warning]: &apos;eve-system-status-warning&apos;,
  [STATUSES.target]: &apos;eve-system-status-target&apos;,
  [STATUSES.dangerous]: &apos;eve-system-status-dangerous&apos;,
};

export const TYPE_NAMES_ORDER = [ConnectionType.wormhole, ConnectionType.gate];

export const TYPE_NAMES = {
  [ConnectionType.wormhole]: &apos;Wormhole&apos;,
  [ConnectionType.gate]: &apos;Gate&apos;,
};

export const MASS_STATE_NAMES_ORDER = [MassState.verge, MassState.half, MassState.normal];

export const MASS_STATE_NAMES = {
  [MassState.normal]: &apos;Normal&apos;,
  [MassState.half]: &apos;Half&apos;,
  [MassState.verge]: &apos;Verge of collapse&apos;,
};

export const SHIP_SIZES_NAMES_ORDER = [
  ShipSizeStatus.small,
  ShipSizeStatus.medium,
  ShipSizeStatus.large,
  ShipSizeStatus.freight,
  ShipSizeStatus.capital,
];

export const SHIP_SIZES_NAMES = {
  [ShipSizeStatus.small]: &apos;Frigate&apos;,
  [ShipSizeStatus.medium]: &apos;Medium&apos;,
  [ShipSizeStatus.large]: &apos;Normal&apos;,
  [ShipSizeStatus.freight]: &apos;Huge&apos;,
  [ShipSizeStatus.capital]: &apos;Capital&apos;,
};
export const SHIP_SIZES_SIZE = {
  [ShipSizeStatus.small]: &apos;5K&apos;,
  [ShipSizeStatus.medium]: &apos;62K&apos;,
  [ShipSizeStatus.large]: &apos;375K&apos;,
  [ShipSizeStatus.freight]: &apos;1M&apos;,
  [ShipSizeStatus.capital]: &apos;2M&apos;,
};

export const SHIP_MASSES_SIZE: Record&lt;number, ShipSizeStatus&gt; = {
  5_000_000: ShipSizeStatus.small,
  62_000_000: ShipSizeStatus.medium,
  300_000_000: ShipSizeStatus.large,
  375_000_000: ShipSizeStatus.large,
  1_000_000_000: ShipSizeStatus.freight,
  1_350_000_000: ShipSizeStatus.capital,
  1_800_000_000: ShipSizeStatus.capital,
  2_000_000_000: ShipSizeStatus.capital,
};

export const SHIP_SIZES_DESCRIPTION = {
  [ShipSizeStatus.small]: &apos;Frigate wormhole - up to Destroyer | 5K t.&apos;,
  [ShipSizeStatus.medium]: &apos;Cruise wormhole - up to Battlecruiser | 62K t.&apos;,
  [ShipSizeStatus.large]: &apos;Large wormhole - up to Battleship | 375K t.&apos;,
  [ShipSizeStatus.freight]: &apos;Huge wormhole - up to Freighter | 1M t.&apos;,
  [ShipSizeStatus.capital]: &apos;Capital wormhole - up to Capital | 2M t.&apos;,
};

export const SHIP_SIZES_NAMES_SHORT = {
  [ShipSizeStatus.small]: &apos;S&apos;,
  [ShipSizeStatus.medium]: &apos;M&apos;,
  [ShipSizeStatus.large]: &apos;L&apos;,
  [ShipSizeStatus.freight]: &apos;H&apos;,
  [ShipSizeStatus.capital]: &apos;XL&apos;,
};</file><file path="assets/js/hooks/Mapper/components/map/Map.module.scss">.MapRoot {
  width: 100%;
  height: 100%;

  background-color: var(--rf-bg-color, #0C0A09);

  &amp;.BackgroundAlternateColor {
    background-color: var(--rf-soft-bg-color, #171717);
    --rf-node-bg-color: var(--rf-node-soft-bg-color, #202020);
  }
}</file><file path="assets/js/hooks/Mapper/components/map/Map.tsx">import { ForwardedRef, forwardRef, MouseEvent, useCallback, useEffect, useMemo } from &apos;react&apos;;
import ReactFlow, {
  Background,
  Edge,
  MiniMap,
  Node,
  NodeChange,
  NodeDragHandler,
  OnConnect,
  OnMoveEnd,
  OnSelectionChangeFunc,
  SelectionDragHandler,
  SelectionMode,
  useReactFlow,
} from &apos;reactflow&apos;;
import &apos;reactflow/dist/style.css&apos;;
import classes from &apos;./Map.module.scss&apos;;
import { MapProvider, useMapState } from &apos;./MapProvider&apos;;
import { useEdgesState, useMapHandlers, useNodesState, useUpdateNodes } from &apos;./hooks&apos;;
import { MapHandlers, OutCommand, OutCommandHandler } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import {
  ContextMenuConnection,
  ContextMenuRoot,
  SolarSystemEdge,
  useContextMenuConnectionHandlers,
  useContextMenuRootHandlers,
} from &apos;./components&apos;;
import { getBehaviorForTheme } from &apos;./helpers/getThemeBehavior&apos;;
import { OnMapAddSystemCallback, OnMapSelectionChange } from &apos;./map.types&apos;;
import { SESSION_KEY } from &apos;@/hooks/Mapper/constants.ts&apos;;
import { SolarSystemConnection, SolarSystemRawType } from &apos;@/hooks/Mapper/types&apos;;
import { ctxManager } from &apos;@/hooks/Mapper/utils/contextManager.ts&apos;;
import { NodeSelectionMouseHandler } from &apos;@/hooks/Mapper/components/contexts/types.ts&apos;;
import clsx from &apos;clsx&apos;;
import { useBackgroundVars } from &apos;./hooks/useBackgroundVars&apos;;

const DEFAULT_VIEW_PORT = { zoom: 1, x: 0, y: 0 };

const getViewPortFromStore = () =&gt; {
  const restored = localStorage.getItem(SESSION_KEY.viewPort);

  if (!restored) {
    return { ...DEFAULT_VIEW_PORT };
  }

  return JSON.parse(restored);
};

const initialNodes: Node&lt;SolarSystemRawType&gt;[] = [
  // {
  //   id: &apos;31122321&apos;,
  //   width: 100,
  //   height: 28,
  //   position: { x: 0, y: 0 },
  //   data: {
  //     id: &apos;31122321&apos;,
  //     solarSystemName: &apos;J111447&apos;,
  //     classTitle: &apos;C6&apos;,
  //   },
  //   type: &apos;custom&apos;,
  // },
];

const initialEdges = [
  {
    id: &apos;1-2&apos;,
    source: &apos;_____kek&apos;,
    target: &apos;_____cheburek&apos;,
    sourceHandle: &apos;c&apos;,
    targetHandle: &apos;a&apos;,
    type: &apos;floating&apos;,
    // markerEnd: { type: MarkerType.Arrow },
    label: &apos;updatable edge&apos;,
  },
];

const edgeTypes = {
  floating: SolarSystemEdge,
};

export const MAP_ROOT_ID = &apos;MAP_ROOT_ID&apos;;

interface MapCompProps {
  refn: ForwardedRef&lt;MapHandlers&gt;;
  onCommand: OutCommandHandler;
  onSelectionChange: OnMapSelectionChange;
  onConnectionInfoClick?(e: SolarSystemConnection): void;
  onAddSystem?: OnMapAddSystemCallback;
  onSelectionContextMenu?: NodeSelectionMouseHandler;
  minimapClasses?: string;
  isShowMinimap?: boolean;
  onSystemContextMenu: (event: MouseEvent&lt;Element&gt;, systemId: string) =&gt; void;
  showKSpaceBG?: boolean;
  isThickConnections?: boolean;
  isShowBackgroundPattern?: boolean;
  isSoftBackground?: boolean;
  theme?: string;
}

const MapComp = ({
  refn,
  onCommand,
  minimapClasses,
  onSelectionChange,
  onSystemContextMenu,
  onConnectionInfoClick,
  onSelectionContextMenu,
  isShowMinimap,
  showKSpaceBG,
  isThickConnections,
  isShowBackgroundPattern,
  isSoftBackground,
  theme,
  onAddSystem,
}: MapCompProps) =&gt; {
  const { getNodes } = useReactFlow();
  const [nodes, , onNodesChange] = useNodesState&lt;Node&lt;SolarSystemRawType&gt;&gt;(initialNodes);
  const [edges, , onEdgesChange] = useEdgesState&lt;Edge&lt;SolarSystemConnection&gt;&gt;(initialEdges);

  useMapHandlers(refn, onSelectionChange);
  useUpdateNodes(nodes);
  const { handleRootContext, ...rootCtxProps } = useContextMenuRootHandlers({ onAddSystem });
  const { handleConnectionContext, ...connectionCtxProps } = useContextMenuConnectionHandlers();
  const { update } = useMapState();
  const { variant, gap, size, color } = useBackgroundVars(theme);
  const { isPanAndDrag, nodeComponent, connectionMode } = getBehaviorForTheme(theme || &apos;default&apos;);

  const nodeTypes = useMemo(() =&gt; {
    return {
      custom: nodeComponent,
    };
  }, [nodeComponent]);

  const onConnect: OnConnect = useCallback(
    params =&gt; {
      const { source, target } = params;

      onCommand({
        type: OutCommand.manualAddConnection,
        data: { source, target },
      });
    },
    [onCommand],
  );

  const handleDragStop: NodeDragHandler = useCallback(
    (_, node) =&gt; [
      // eslint-disable-next-line no-console
      setTimeout(() =&gt; {
        onCommand({
          type: OutCommand.updateSystemPosition,
          data: { solar_system_id: node.id, position: node.position },
        });
      }, 500),
    ],
    [onCommand],
  );

  const handleSelectionDragStop: SelectionDragHandler = useCallback(
    (_, nodes) =&gt; {
      setTimeout(() =&gt; {
        onCommand({
          type: OutCommand.updateSystemPositions,
          data: nodes.map(x =&gt; ({ solar_system_id: x.id, position: x.position })),
        });
      }, 500);
    },
    [onCommand],
  );

  const resetContexts = useCallback(() =&gt; ctxManager.reset(), []);

  const handleSelectionChange: OnSelectionChangeFunc = useCallback(
    ({ edges, nodes }) =&gt; {
      onSelectionChange({
        connections: edges.map(({ source, target }) =&gt; ({ source, target })),
        systems: nodes.map(x =&gt; x.id),
      });
    },
    [onSelectionChange],
  );

  const handleMoveEnd: OnMoveEnd = (_, viewport) =&gt; {
    localStorage.setItem(SESSION_KEY.viewPort, JSON.stringify(viewport));
  };

  const handleNodesChange = useCallback(
    (changes: NodeChange[]) =&gt; {
      // prevents single node deselection on background / same node click
      // allows deseletion of all nodes if multiple are currently selected
      if (changes.length === 1 &amp;&amp; changes[0].type == &apos;select&apos; &amp;&amp; changes[0].selected === false) {
        changes[0].selected = getNodes().filter(node =&gt; node.selected).length === 1;
      }

      const nextChanges = changes.reduce((acc, change) =&gt; {
        return [...acc, change];
      }, [] as NodeChange[]);

      onNodesChange(nextChanges);
    },
    [getNodes, onNodesChange],
  );

  useEffect(() =&gt; {
    update(x =&gt; ({
      ...x,
      showKSpaceBG: showKSpaceBG,
      isThickConnections: isThickConnections,
    }));
  }, [showKSpaceBG, isThickConnections, update]);

  return (
    &lt;&gt;
      &lt;div
        data-window-id={MAP_ROOT_ID}
        className={clsx(classes.MapRoot, { [classes.BackgroundAlternateColor]: isSoftBackground })}
      &gt;
        &lt;ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={handleNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          // TODO we need save into session all of this
          //      and on any action do either
          defaultViewport={getViewPortFromStore()}
          edgeTypes={edgeTypes}
          nodeTypes={nodeTypes}
          connectionMode={connectionMode}
          snapToGrid
          nodeDragThreshold={10}
          onNodeDragStop={handleDragStop}
          onSelectionDragStop={handleSelectionDragStop}
          onConnectStart={() =&gt; update({ isConnecting: true })}
          onConnectEnd={() =&gt; update({ isConnecting: false })}
          onNodeMouseEnter={(_, node) =&gt; update({ hoverNodeId: node.id })}
          onPaneClick={event =&gt; {
            event.preventDefault();
            event.stopPropagation();
          }}
          // onKeyUp=
          onNodeMouseLeave={() =&gt; update({ hoverNodeId: null })}
          onEdgeClick={(_, t) =&gt; {
            onConnectionInfoClick?.(t.data);
          }}
          onEdgeContextMenu={handleConnectionContext}
          onNodeContextMenu={(ev, node) =&gt; onSystemContextMenu(ev, node.id)}
          // TODO don&apos;t know why this error appear - but it annoying
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          onPaneContextMenu={handleRootContext}
          onSelectionContextMenu={(ev, nodes) =&gt; onSelectionContextMenu?.(ev, nodes)}
          onSelectionChange={handleSelectionChange} // TODO - somewhy calling 2 times. don&apos;t know why
          // onSelectionEnd={handleSelectionChange}
          onMoveStart={resetContexts}
          onMouseDown={resetContexts}
          onMoveEnd={handleMoveEnd}
          minZoom={0.2}
          maxZoom={1.5}
          elevateNodesOnSelect
          deleteKeyCode={[&apos;&apos;]}
          {...(isPanAndDrag
            ? {
                selectionOnDrag: true,
                panOnDrag: [2],
              }
            : {})}
          // TODO need create clear example with problem with that flag
          //  if system is not visible edge not drawing (and any render in Custom node is not happening)
          // onlyRenderVisibleElements
          selectionMode={SelectionMode.Partial}
        &gt;
          {isShowMinimap &amp;&amp; &lt;MiniMap pannable zoomable ariaLabel=&quot;Mini map&quot; className={minimapClasses} /&gt;}
          {isShowBackgroundPattern &amp;&amp; &lt;Background variant={variant} gap={gap} size={size} color={color} /&gt;}
        &lt;/ReactFlow&gt;
        {/* &lt;button className=&quot;z-auto btn btn-primary absolute top-20 right-20&quot; onClick={handleGetPassages}&gt;
          Test // DON NOT REMOVE
        &lt;/button&gt; */}
      &lt;/div&gt;

      &lt;ContextMenuRoot {...rootCtxProps} /&gt;
      &lt;ContextMenuConnection {...connectionCtxProps} /&gt;
    &lt;/&gt;
  );
};

export type MapPropsType = Omit&lt;MapCompProps, &apos;refn&apos;&gt;;

// TODO: INFO - this component needs for correct work map provider
// eslint-disable-next-line react/display-name
export const Map = forwardRef((props: MapPropsType, ref: ForwardedRef&lt;MapHandlers&gt;) =&gt; {
  return (
    &lt;MapProvider onCommand={props.onCommand}&gt;
      &lt;MapComp refn={ref} {...props} /&gt;
    &lt;/MapProvider&gt;
  );
});</file><file path="assets/js/hooks/Mapper/components/map/map.types.ts">import { SolarSystemRawType } from &apos;@/hooks/Mapper/types/system&apos;;
import { SolarSystemConnection } from &apos;@/hooks/Mapper/types&apos;;
import { XYPosition } from &apos;reactflow&apos;;

export type MapSolarSystemType = Omit&lt;SolarSystemRawType, &apos;position&apos;&gt;;

export type OnMapSelectionChange = (event: {
  systems: string[];
  connections: Pick&lt;SolarSystemConnection, &apos;source&apos; | &apos;target&apos;&gt;[];
}) =&gt; void;

export type OnMapAddSystemCallback = (props: { coordinates: XYPosition | null }) =&gt; void;</file><file path="assets/js/hooks/Mapper/components/map/MapProvider.tsx">import React, { createContext, useContext } from &apos;react&apos;;
import { OutCommandHandler } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { MapUnionTypes, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { ContextStoreDataUpdate, useContextStore } from &apos;@/hooks/Mapper/utils&apos;;

export type MapData = MapUnionTypes &amp; {
  isConnecting: boolean;
  hoverNodeId: string | null;
  visibleNodes: Set&lt;string&gt;;
  showKSpaceBG: boolean;
  isThickConnections: boolean;
  linkedSigEveId: string;
};

interface MapProviderProps {
  children: React.ReactNode;
  onCommand: OutCommandHandler;
}

const INITIAL_DATA: MapData = {
  wormholesData: {},
  wormholes: [],
  effects: {},
  characters: [],
  userCharacters: [],
  presentCharacters: [],
  systems: [],
  hubs: [],
  kills: {},
  isConnecting: false,
  connections: [],
  hoverNodeId: null,
  linkedSigEveId: &apos;&apos;,
  visibleNodes: new Set(),
  showKSpaceBG: false,
  isThickConnections: false,
  userPermissions: {},
  systemSignatures: {} as Record&lt;string, SystemSignature[]&gt;,
  options: {} as Record&lt;string, string | boolean&gt;,
  isSubscriptionActive: false,
  mainCharacterEveId: null,
  followingCharacterEveId: null,
};

export interface MapContextProps {
  update: ContextStoreDataUpdate&lt;MapData&gt;;
  data: MapData;
  outCommand: OutCommandHandler;
}

const MapContext = createContext&lt;MapContextProps&gt;({
  update: () =&gt; {},
  data: { ...INITIAL_DATA },
  // @ts-ignore
  outCommand: async () =&gt; void 0,
});

export const MapProvider = ({ children, onCommand }: MapProviderProps) =&gt; {
  const { update, ref } = useContextStore&lt;MapData&gt;({ ...INITIAL_DATA });

  return (
    &lt;MapContext.Provider
      value={{
        update,
        data: ref,
        outCommand: onCommand,
      }}
    &gt;
      {children}
    &lt;/MapContext.Provider&gt;
  );
};

export const useMapState = () =&gt; {
  const context = useContext&lt;MapContextProps&gt;(MapContext);
  return context;
};</file><file path="assets/js/hooks/Mapper/components/map/utils.ts">import { Position, internalsSymbol } from &apos;reactflow&apos;;

// returns the position (top,right,bottom or right) passed node compared to
function getParams(nodeA, nodeB) {
  const centerA = getNodeCenter(nodeA);
  const centerB = getNodeCenter(nodeB);

  const horizontalDiff = Math.abs(centerA.x - centerB.x);
  const verticalDiff = Math.abs(centerA.y - centerB.y);

  let position: Position;

  // when the horizontal difference between the nodes is bigger, we use Position.Left or Position.Right for the handle
  if (horizontalDiff &gt; verticalDiff) {
    position = centerA.x &gt; centerB.x ? Position.Left : Position.Right;
  } else {
    // here the vertical difference between the nodes is bigger, so we use Position.Top or Position.Bottom for the handle
    position = centerA.y &gt; centerB.y ? Position.Top : Position.Bottom;
  }

  const [x, y] = getHandleCoordsByPosition(nodeA, position);
  return [x, y, position];
}

function getHandleCoordsByPosition(node, handlePosition) {
  // all handles are from type source, that&apos;s why we use handleBounds.source here
  const handle = node[internalsSymbol].handleBounds.source.find(h =&gt; h.position === handlePosition);

  let offsetX = handle.width / 2;
  let offsetY = handle.height / 2;

  // this is a tiny detail to make the markerEnd of an edge visible.
  // The handle position that gets calculated has the origin top-left, so depending which side we are using, we add a little offset
  // when the handlePosition is Position.Right for example, we need to add an offset as big as the handle itself in order to get the correct position
  switch (handlePosition) {
    case Position.Left:
      offsetX = 0;
      break;
    case Position.Right:
      offsetX = handle.width;
      break;
    case Position.Top:
      offsetY = 0;
      break;
    case Position.Bottom:
      offsetY = handle.height;
      break;
  }

  const x = node.positionAbsolute.x + handle.x + offsetX;
  const y = node.positionAbsolute.y + handle.y + offsetY;

  return [x, y];
}

function getNodeCenter(node) {
  return {
    x: node.positionAbsolute.x + node.width / 2,
    y: node.positionAbsolute.y + node.height / 2,
  };
}

// returns the parameters (sx, sy, tx, ty, sourcePos, targetPos) you need to create an edge
export function getEdgeParams(source, target) {
  const [sx, sy, sourcePos] = getParams(source, target);
  const [tx, ty, targetPos] = getParams(target, source);

  return {
    sx,
    sy,
    tx,
    ty,
    sourcePos,
    targetPos,
  };
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/AddSystemDialog/AddSystemDialog.module.scss">.SearchItem {
  &amp; &gt; * {
    font-size: 13px !important;
  }
}

.SearchItemEffect {
  font-weight: initial !important;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/AddSystemDialog/AddSystemDialog.tsx">import { Dialog } from &apos;primereact/dialog&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback, useRef, useState } from &apos;react&apos;;
import { Button } from &apos;primereact/button&apos;;
import { IconField } from &apos;primereact/iconfield&apos;;
import { AutoComplete } from &apos;primereact/autocomplete&apos;;
import { OutCommand, SearchSystemItem } from &apos;@/hooks/Mapper/types&apos;;
import { SystemViewStandalone, WHClassView, WHEffectView } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import classes from &apos;./AddSystemDialog.module.scss&apos;;

import clsx from &apos;clsx&apos;;
import { isWormholeSpace } from &apos;@/hooks/Mapper/components/map/helpers/isWormholeSpace.ts&apos;;
import { sortWHClasses } from &apos;@/hooks/Mapper/helpers&apos;;

export type SearchOnSubmitCallback = (item: SearchSystemItem) =&gt; void;

interface AddSystemDialogProps {
  title?: string;
  visible: boolean;
  setVisible: (visible: boolean) =&gt; void;
  onSubmit?: SearchOnSubmitCallback;
  excludedSystems?: number[];
}

export const AddSystemDialog = ({
  title = &apos;Add system&apos;,
  visible,
  setVisible,
  onSubmit,
  excludedSystems = [],
}: AddSystemDialogProps) =&gt; {
  const {
    outCommand,
    data: { wormholesData },
  } = useMapRootState();

  const inputRef = useRef&lt;any&gt;();
  const onShow = useCallback(() =&gt; {
    inputRef.current?.focus();
  }, []);

  const [filteredItems, setFilteredItems] = useState&lt;SearchSystemItem[]&gt;([]);
  const [selectedItem, setSelectedItem] = useState&lt;SearchSystemItem[] | null&gt;(null);

  const searchItems = useCallback(
    async (event: { query: string }) =&gt; {
      if (event.query.length &lt; 2) {
        setFilteredItems([]);
        return;
      }

      const query = event.query;

      if (query.length === 0) {
        setFilteredItems([]);
      } else {
        try {
          const result = await outCommand({
            type: OutCommand.searchSystems,
            data: {
              text: query,
            },
          });

          let prepared = (result.systems as SearchSystemItem[]).sort((a, b) =&gt; {
            const amatch = a.label.indexOf(query);
            const bmatch = b.label.indexOf(query);
            return amatch - bmatch;
          });

          if (excludedSystems) {
            prepared = prepared.filter(x =&gt; !excludedSystems.includes(x.system_static_info.solar_system_id));
          }

          setFilteredItems(prepared);
        } catch (error) {
          console.error(&apos;Error fetching data:&apos;, error);
          setFilteredItems([]);
        }
      }
    },
    [excludedSystems, outCommand],
  );

  const ref = useRef({ onSubmit, selectedItem });
  ref.current = { onSubmit, selectedItem };

  const handleSubmit = useCallback(() =&gt; {
    const { onSubmit, selectedItem } = ref.current;
    setFilteredItems([]);
    setSelectedItem([]);

    if (!selectedItem) {
      setVisible(false);
      return;
    }

    onSubmit?.(selectedItem[0]);
    setVisible(false);
  }, [setVisible]);

  return (
    &lt;Dialog
      header={title}
      visible={visible}
      draggable={false}
      style={{ width: &apos;520px&apos; }}
      onShow={onShow}
      onHide={() =&gt; {
        if (!visible) {
          return;
        }

        setVisible(false);
      }}
    &gt;
      &lt;div className=&quot;flex flex-col gap-3 px-1.5&quot;&gt;
        &lt;div className=&quot;flex flex-col gap-2 py-3.5&quot;&gt;
          &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
            &lt;IconField&gt;
              &lt;AutoComplete
                ref={inputRef}
                multiple
                showEmptyMessage
                scrollHeight=&quot;300px&quot;
                value={selectedItem}
                suggestions={filteredItems}
                completeMethod={searchItems}
                onChange={e =&gt; {
                  setSelectedItem(e.value.length &lt; 2 ? e.value : [e.value[e.value.length - 1]]);
                }}
                emptyMessage=&quot;Not found any system...&quot;
                placeholder=&quot;Type here...&quot;
                field=&quot;label&quot;
                id=&quot;value&quot;
                className=&quot;w-full&quot;
                itemTemplate={(item: SearchSystemItem) =&gt; {
                  const { security, system_class, effect_power, effect_name, statics } = item.system_static_info;
                  const sortedStatics = sortWHClasses(wormholesData, statics);
                  const isWH = isWormholeSpace(system_class);

                  return (
                    &lt;div className={clsx(&apos;flex gap-1.5&apos;, classes.SearchItem)}&gt;
                      &lt;SystemViewStandalone
                        security={security}
                        system_class={system_class}
                        solar_system_id={item.value}
                        class_title={item.class_title}
                        solar_system_name={item.label}
                        region_name={item.region_name}
                      /&gt;

                      {effect_name &amp;&amp; isWH &amp;&amp; (
                        &lt;WHEffectView
                          effectName={effect_name}
                          effectPower={effect_power}
                          className={classes.SearchItemEffect}
                        /&gt;
                      )}

                      {isWH &amp;&amp; (
                        &lt;div className=&quot;flex gap-1 grow justify-between&quot;&gt;
                          &lt;div&gt;&lt;/div&gt;
                          &lt;div className=&quot;flex gap-1&quot;&gt;
                            {sortedStatics.map(x =&gt; (
                              &lt;WHClassView key={x} whClassName={x} /&gt;
                            ))}
                          &lt;/div&gt;
                        &lt;/div&gt;
                      )}
                    &lt;/div&gt;
                  );
                }}
                selectedItemTemplate={(item: SearchSystemItem) =&gt; (
                  &lt;SystemViewStandalone
                    security={item.system_static_info.security}
                    system_class={item.system_static_info.system_class}
                    solar_system_id={item.value}
                    class_title={item.class_title}
                    solar_system_name={item.label}
                    region_name={item.region_name}
                  /&gt;
                )}
              /&gt;
            &lt;/IconField&gt;

            &lt;span className=&quot;text-[12px] text-stone-400 ml-1&quot;&gt;*to search type at least 2 symbols.&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div className=&quot;flex gap-2 justify-end&quot;&gt;
          &lt;Button
            onClick={handleSubmit}
            outlined
            disabled={!selectedItem || selectedItem.length !== 1}
            size=&quot;small&quot;
            label=&quot;Submit&quot;
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/Dialog&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/AddSystemDialog/index.ts">export * from &apos;./AddSystemDialog&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/Comments/components/MarkdownComment/index.ts">export * from &apos;./MarkdownComment.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/Comments/components/MarkdownComment/MarkdownComment.module.scss">.MarkdownCommentRoot {
  border-left-width: 3px;

  @apply text-[12px] leading-[1.2] text-stone-300 break-words;
  @apply bg-gradient-to-r from-stone-600/40 via-stone-600/10 to-stone-600/0;

  .h1 {
    @apply text-[12px] font-normal m-0 p-0 border-none break-words whitespace-normal;
  }

  .h2 {
    @apply text-[12px] font-normal m-0 p-0 border-none break-words whitespace-normal;
  }

  .h3 {
    @apply text-[12px] font-normal m-0 p-0 border-none break-words whitespace-normal;
  }

  .h4 {
    @apply text-[12px] font-normal m-0 p-0 border-none break-words whitespace-normal;
  }

  .h5 {
    @apply text-[12px] font-normal m-0 p-0 border-none break-words whitespace-normal;
  }

  .h6 {
    @apply text-[12px] font-normal m-0 p-0 border-none break-words whitespace-normal;
  }

  p {
    @apply m-0 p-0 break-words whitespace-normal;
  }

  ul, ol {
    @apply m-0 p-0 list-none;
  }

  li {
    @apply m-0 break-words whitespace-normal;
  }

  blockquote {
    @apply border-l-4 border-cyan-400 p-2 m-0 font-normal text-stone-300 italic break-words whitespace-normal;
  }

  a {
    @apply text-violet-400 cursor-pointer transition-colors duration-200 break-words whitespace-normal;

    &amp;:hover {
      @apply underline;
    }
  }

  b, strong {
    @apply font-bold text-green-400 break-words whitespace-normal;
  }

  i, em {
    @apply italic text-pink-400 break-words whitespace-normal;
  }

  del {
    @apply line-through text-stone-500 break-words whitespace-normal;
  }

  hr {
    @apply border-none h-[1px] bg-cyan-400 opacity-50 my-2;
  }
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/Comments/components/MarkdownComment/MarkdownComment.tsx">import classes from &apos;./MarkdownComment.module.scss&apos;;
import clsx from &apos;clsx&apos;;
import Markdown from &apos;react-markdown&apos;;
import remarkGfm from &apos;remark-gfm&apos;;
import { InfoDrawer, TimeAgo, TooltipPosition, WdImgButton } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import remarkBreaks from &apos;remark-breaks&apos;;
import { useGetCacheCharacter } from &apos;@/hooks/Mapper/mapRootProvider/hooks/api&apos;;
import { useCallback, useRef, useState } from &apos;react&apos;;
import { WdTransition } from &apos;@/hooks/Mapper/components/ui-kit/WdTransition/WdTransition.tsx&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { ConfirmPopup } from &apos;primereact/confirmpopup&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types&apos;;

const TOOLTIP_PROPS = { content: &apos;Remove comment&apos;, position: TooltipPosition.top };
const REMARK_PLUGINS = [remarkGfm, remarkBreaks];

export interface MarkdownCommentProps {
  text: string;
  time: string;
  characterEveId: string;
  id: string;
}

export const MarkdownComment = ({ text, time, characterEveId, id }: MarkdownCommentProps) =&gt; {
  const char = useGetCacheCharacter(characterEveId);
  const [hovered, setHovered] = useState(false);

  const cpRemoveBtnRef = useRef&lt;HTMLElement&gt;();
  const [cpRemoveVisible, setCpRemoveVisible] = useState(false);

  const { outCommand } = useMapRootState();
  const ref = useRef({ outCommand, id });
  ref.current = { outCommand, id };

  const handleDelete = useCallback(async () =&gt; {
    await ref.current.outCommand({
      type: OutCommand.deleteSystemComment,
      data: ref.current.id,
    });
  }, []);

  const handleMouseEnter = useCallback(() =&gt; setHovered(true), []);
  const handleMouseLeave = useCallback(() =&gt; setHovered(false), []);

  const handleShowCP = useCallback(() =&gt; setCpRemoveVisible(true), []);
  const handleHideCP = useCallback(() =&gt; setCpRemoveVisible(false), []);

  return (
    &lt;&gt;
      &lt;InfoDrawer
        labelClassName=&quot;mb-[3px]&quot;
        className={clsx(classes.MarkdownCommentRoot, &apos;p-1 bg-stone-700/20 &apos;)}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        title={
          &lt;div className=&quot;flex items-center justify-between&quot;&gt;
            &lt;div&gt;
              &lt;span className=&quot;text-stone-500&quot;&gt;
                by &lt;span className=&quot;text-orange-300/70&quot;&gt;{char?.data?.name ?? &apos;&apos;}&lt;/span&gt;
              &lt;/span&gt;
            &lt;/div&gt;

            &lt;WdTransition active={hovered} timeout={100}&gt;
              &lt;div className=&quot;text-stone-500 max-h-[12px]&quot;&gt;
                {!hovered &amp;&amp; &lt;TimeAgo timestamp={time} /&gt;}
                {hovered &amp;&amp; (
                  // @ts-ignore
                  &lt;div ref={cpRemoveBtnRef}&gt;
                    &lt;WdImgButton
                      className={clsx(PrimeIcons.TRASH, &apos;hover:text-red-400&apos;)}
                      tooltip={TOOLTIP_PROPS}
                      onClick={handleShowCP}
                    /&gt;
                  &lt;/div&gt;
                )}
              &lt;/div&gt;
            &lt;/WdTransition&gt;
          &lt;/div&gt;
        }
      &gt;
        &lt;Markdown remarkPlugins={REMARK_PLUGINS}&gt;{text}&lt;/Markdown&gt;
      &lt;/InfoDrawer&gt;

      &lt;ConfirmPopup
        target={cpRemoveBtnRef.current}
        visible={cpRemoveVisible}
        onHide={handleHideCP}
        message=&quot;Are you sure you want to delete?&quot;
        icon=&quot;pi pi-exclamation-triangle&quot;
        accept={handleDelete}
      /&gt;
    &lt;/&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/Comments/components/index.ts">export * from &apos;./MarkdownComment&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/Comments/Comments.tsx">import { MarkdownComment } from &apos;@/hooks/Mapper/components/mapInterface/components/Comments/components&apos;;
import { useEffect, useRef, useState } from &apos;react&apos;;
import { CommentType } from &apos;@/hooks/Mapper/types&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

export interface CommentsProps {}

// eslint-disable-next-line no-empty-pattern
export const Comments = ({}: CommentsProps) =&gt; {
  const [commentsList, setCommentsList] = useState&lt;CommentType[]&gt;([]);

  const {
    data: { selectedSystems },
    comments: { loadComments, comments, lastUpdateKey },
  } = useMapRootState();

  const [systemId] = selectedSystems;

  const ref = useRef({ loadComments, systemId });
  ref.current = { loadComments, systemId };

  useEffect(() =&gt; {
    const commentsBySystem = comments.get(systemId);
    if (!commentsBySystem) {
      return;
    }

    const els = [...commentsBySystem.comments].sort((a, b) =&gt; +new Date(b.updated_at) - +new Date(a.updated_at));

    setCommentsList(els);
  }, [systemId, lastUpdateKey, comments]);

  useEffect(() =&gt; {
    ref.current.loadComments(systemId);
  }, [systemId]);

  if (commentsList.length === 0) {
    return (
      &lt;div className=&quot;w-full h-full flex justify-center items-center select-none text-stone-400/80 text-sm&quot;&gt;
        Not comments found here
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className=&quot;flex flex-col gap-1 whitespace-nowrap overflow-auto text-ellipsis custom-scrollbar&quot;&gt;
      {commentsList.map(({ id, text, updated_at, characterEveId }) =&gt; (
        &lt;MarkdownComment key={id} text={text} time={updated_at} characterEveId={characterEveId} id={id} /&gt;
      ))}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/Comments/index.ts">export * from &apos;./Comments&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/Comments/markdownexample.ts">export const markdown = `
  # Heading 1
  ## Heading 2
  ### Heading 3
  #### Heading 4
  ##### Heading 5
  ###### Heading 6

  ---

  ## Paragraphs
  This is a regular text paragraph.

  Another paragraph, but with **bold** and *italic* text, as well as ~~strikethrough~~.

  &gt; This is a block quote.
  &gt; Second line of the quote.

  ## Links
  [Link to Google](https://www.google.com)

  ## Horizontal Line
  A block quote with ~strikethrough~ and a URL: https://reactjs.org.
  ---

  `;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/CommentsEditor/CommentsEditor.tsx">import { TooltipPosition, WdImageSize, WdImgButton } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import clsx from &apos;clsx&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { MarkdownEditor } from &apos;@/hooks/Mapper/components/mapInterface/components/MarkdownEditor&apos;;
import { useHotkey } from &apos;@/hooks/Mapper/hooks&apos;;
import { useCallback, useRef, useState } from &apos;react&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

export interface CommentsEditorProps {}

export const CommentsEditor = ({}: CommentsEditorProps) =&gt; {
  const [textVal, setTextVal] = useState(&apos;&apos;);

  const {
    data: { selectedSystems },
    outCommand,
  } = useMapRootState();

  const [systemId] = selectedSystems;

  const ref = useRef({ outCommand, systemId, textVal });
  ref.current = { outCommand, systemId, textVal };

  const handleFinishEdit = useCallback(async () =&gt; {
    if (ref.current.textVal === &apos;&apos;) {
      return;
    }

    await ref.current.outCommand({
      type: OutCommand.addSystemComment,
      data: {
        solarSystemId: ref.current.systemId,
        value: ref.current.textVal,
      },
    });
    setTextVal(&apos;&apos;);
  }, []);

  const handleClick = async () =&gt; {
    await handleFinishEdit();
  };

  useHotkey(true, [&apos;Enter&apos;], async () =&gt; {
    await handleFinishEdit();
  });

  return (
    &lt;MarkdownEditor
      value={textVal}
      onChange={setTextVal}
      overlayContent={
        &lt;div className=&quot;w-full h-full flex justify-end items-end pointer-events-none pb-[1px] pr-[8px]&quot;&gt;
          &lt;WdImgButton
            disabled={textVal.length === 0}
            tooltip={{
              position: TooltipPosition.bottom,
              content: (
                &lt;span&gt;
                  Also you may use &lt;span className=&quot;text-cyan-400&quot;&gt;Meta + Enter&lt;/span&gt; hotkey.
                &lt;/span&gt;
              ),
            }}
            textSize={WdImageSize.large}
            className={clsx(PrimeIcons.SEND, &apos;text-[14px]&apos;)}
            onClick={handleClick}
          /&gt;
        &lt;/div&gt;
      }
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/CommentsEditor/index.ts">export * from &apos;./CommentsEditor&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/MarkdownEditor/index.ts">export * from &apos;./MarkdownEditor.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/MarkdownEditor/MarkdownEditor.module.scss">.CERoot {
  @apply border border-stone-400/30 rounded-[2px];

  :global {
    .cm-content {
      @apply bg-stone-600/40;
    }

    .cm-scroller {
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 255, 255, 0.5) transparent;
    }

    .cm-scroller::-webkit-scrollbar {
      width: 10px;
    }

    .cm-scroller::-webkit-scrollbar-track {
      background: transparent;
    }

    .cm-scroller::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.5);
      border-radius: 5px;
      border: 2px solid transparent;
      background-clip: content-box;
    }

    .cm-scroller::-webkit-scrollbar-thumb:hover {
      background-color: rgba(255, 255, 255, 0.7);
    }

    .cm-scroller::-webkit-scrollbar-button {
      display: none;
      height: 0;
      width: 0;
    }

  }
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/MarkdownEditor/MarkdownEditor.tsx">import { ReactNode, useCallback, useRef, useState } from &apos;react&apos;;
import CodeMirror, { ViewPlugin } from &apos;@uiw/react-codemirror&apos;;
import { markdown } from &apos;@codemirror/lang-markdown&apos;;
import { oneDark } from &apos;@codemirror/theme-one-dark&apos;;
import { EditorView, type ViewUpdate } from &apos;@codemirror/view&apos;;

import classes from &apos;./MarkdownEditor.module.scss&apos;;
import clsx from &apos;clsx&apos;;

// TODO special plugin which force CodeMirror using capture for paste event
const stopEventPropagationPlugin = ViewPlugin.fromClass(
  class {
    constructor(view: EditorView) {
      // @ts-ignore
      this.view = view;

      // @ts-ignore
      this.pasteHandler = (event: Event) =&gt; {
        event.stopPropagation();
      };

      // @ts-ignore
      view.dom.addEventListener(&apos;paste&apos;, this.pasteHandler);
    }

    destroy() {
      // @ts-ignore
      this.view.dom.removeEventListener(&apos;paste&apos;, this.pasteHandler);
    }
  },
);

const CODE_MIRROR_EXTENSIONS = [
  markdown(),
  EditorView.lineWrapping,
  EditorView.theme({
    &apos;&amp;&apos;: { backgroundColor: &apos;transparent !important&apos; },
    &apos;&amp; .cm-gutterElement&apos;: { display: &apos;none&apos; },
  }),
  stopEventPropagationPlugin,
];

export interface MarkdownEditorProps {
  overlayContent?: ReactNode;
  value: string;
  onChange: (value: string) =&gt; void;
}

export const MarkdownEditor = ({ value, onChange, overlayContent }: MarkdownEditorProps) =&gt; {
  const [hasShift, setHasShift] = useState(false);

  const refData = useRef({ onChange });
  refData.current = { onChange };

  const handleOnChange = useCallback((value: string, viewUpdate: ViewUpdate) =&gt; {
    // Rerender happens after change
    setTimeout(() =&gt; {
      const scrollDOM = viewUpdate.view.scrollDOM;
      setHasShift(scrollDOM.scrollHeight &gt; scrollDOM.clientHeight);
    }, 0);

    refData.current.onChange(value);
  }, []);

  return (
    &lt;div className={clsx(classes.MarkdownEditor, &apos;relative&apos;)}&gt;
      &lt;CodeMirror
        value={value}
        height=&quot;70px&quot;
        extensions={CODE_MIRROR_EXTENSIONS}
        className={classes.CERoot}
        theme={oneDark}
        onChange={handleOnChange}
        placeholder=&quot;Start typing...&quot;
      /&gt;
      &lt;div
        className={clsx(&apos;absolute top-0 left-0 h-full pointer-events-none&apos;, {
          &apos;w-full&apos;: !hasShift,
          &apos;w-[calc(100%-10px)]&apos;: hasShift,
        })}
      &gt;
        {overlayContent}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/SystemCustomLabelDialog/index.ts">export * from &apos;./SystemCustomLabelDialog&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/SystemCustomLabelDialog/SystemCustomLabelDialog.tsx">import { InputText } from &apos;primereact/inputtext&apos;;
import { Dialog } from &apos;primereact/dialog&apos;;
import { getSystemById } from &apos;@/hooks/Mapper/helpers&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback, useEffect, useRef, useState } from &apos;react&apos;;
import { Button } from &apos;primereact/button&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types&apos;;
import { IconField } from &apos;primereact/iconfield&apos;;
import { LabelsManager } from &apos;@/hooks/Mapper/utils/labelsManager.ts&apos;;
import { WdImageSize, WdImgButton, TooltipPosition } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

interface SystemCustomLabelDialog {
  systemId: string;
  visible: boolean;
  setVisible: (visible: boolean) =&gt; void;
}

export const SystemCustomLabelDialog = ({ systemId, visible, setVisible }: SystemCustomLabelDialog) =&gt; {
  const {
    data: { systems },
    outCommand,
  } = useMapRootState();

  const system = getSystemById(systems, systemId);

  const [label, setLabel] = useState(&apos;&apos;);

  useEffect(() =&gt; {
    if (!system) {
      return;
    }

    const leb = new LabelsManager(system.labels || &apos;&apos;);

    setLabel(leb.customLabel);
  }, [system]);

  const ref = useRef({ label, outCommand, systemId, system });
  ref.current = { label, outCommand, systemId, system };

  const handleSave = useCallback(() =&gt; {
    const { label, outCommand, system } = ref.current;

    if (!system) {
      return;
    }

    const outLabel = new LabelsManager(system.labels ?? &apos;&apos;);
    outLabel.updateCustomLabel(label);

    outCommand({
      type: OutCommand.updateSystemLabels,
      data: {
        system_id: system.id,
        value: outLabel.toString(),
      },
    });

    setVisible(false);
  }, [setVisible]);

  const inputRef = useRef&lt;HTMLInputElement&gt;();

  const handleReset = useCallback(() =&gt; {
    setLabel(&apos;&apos;);
  }, []);

  const onShow = useCallback(() =&gt; {
    inputRef.current?.focus();
  }, []);

  const onHide = useCallback(() =&gt; {
    if (!visible) {
      return;
    }

    setVisible(false);
  }, [setVisible, visible]);

  // @ts-ignore
  const handleInput = useCallback(e =&gt; {
    e.target.value = e.target.value.toUpperCase().replace(/[^A-Z0-9\-[\](){}]/g, &apos;&apos;);
  }, []);

  return (
    &lt;Dialog
      header=&quot;Edit label&quot;
      visible={visible}
      draggable={true}
      style={{ width: &apos;250px&apos; }}
      onHide={onHide}
      onShow={onShow}
    &gt;
      &lt;form onSubmit={handleSave}&gt;
        &lt;div className=&quot;flex flex-col gap-3&quot;&gt;
          &lt;div className=&quot;flex flex-col gap-2&quot;&gt;
            &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
              &lt;label htmlFor=&quot;username&quot;&gt;Custom label&lt;/label&gt;

              &lt;IconField&gt;
                {label !== &apos;&apos; &amp;&amp; (
                  &lt;WdImgButton
                    className=&quot;pi pi-trash text-red-400&quot;
                    textSize={WdImageSize.large}
                    tooltip={{
                      content: &apos;Remove custom label&apos;,
                      className: &apos;pi p-input-icon&apos;,
                      position: TooltipPosition.top,
                    }}
                    onClick={handleReset}
                  /&gt;
                )}
                &lt;InputText
                  id=&quot;username&quot;
                  aria-describedby=&quot;username-help&quot;
                  autoComplete=&quot;off&quot;
                  value={label}
                  maxLength={5}
                  onChange={e =&gt; setLabel(e.target.value)}
                  // @ts-expect-error
                  ref={inputRef}
                  onInput={handleInput}
                /&gt;
              &lt;/IconField&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div className=&quot;flex gap-2 justify-end&quot;&gt;
            &lt;Button onClick={handleSave} outlined size=&quot;small&quot; label=&quot;Save&quot;&gt;&lt;/Button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/Dialog&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/SystemLinkSignatureDialog/index.ts">export * from &apos;./SystemLinkSignatureDialog&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/SystemLinkSignatureDialog/SystemLinkSignatureDialog.tsx">import { Dialog } from &apos;primereact/dialog&apos;;
import { useCallback, useEffect, useMemo, useRef } from &apos;react&apos;;

import { useSystemInfo } from &apos;@/hooks/Mapper/components/hooks&apos;;
import {
  SOLAR_SYSTEM_CLASS_IDS,
  SOLAR_SYSTEM_CLASSES_TO_CLASS_GROUPS,
  WORMHOLES_ADDITIONAL_INFO_BY_SHORT_NAME,
} from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import {
  SETTINGS_KEYS,
  SignatureSettingsType,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts&apos;;
import { SystemSignaturesContent } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SystemSignaturesContent&apos;;
import { K162_TYPES_MAP } from &apos;@/hooks/Mapper/constants.ts&apos;;
import { getWhSize } from &apos;@/hooks/Mapper/helpers/getWhSize&apos;;
import { parseSignatureCustomInfo } from &apos;@/hooks/Mapper/helpers/parseSignatureCustomInfo&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { CommandLinkSignatureToSystem, SignatureGroup, SystemSignature, TimeStatus } from &apos;@/hooks/Mapper/types&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;

const K162_SIGNATURE_TYPE = WORMHOLES_ADDITIONAL_INFO_BY_SHORT_NAME[&apos;K162&apos;].shortName;

interface SystemLinkSignatureDialogProps {
  data: CommandLinkSignatureToSystem;
  setVisible: (visible: boolean) =&gt; void;
}

export const LINK_SIGNTATURE_SETTINGS: SignatureSettingsType = {
  [SETTINGS_KEYS.COSMIC_SIGNATURE]: true,
  [SETTINGS_KEYS.WORMHOLE]: true,
  [SETTINGS_KEYS.SHOW_DESCRIPTION_COLUMN]: true,
};

// Extend the SignatureCustomInfo type to include k162Type
interface ExtendedSignatureCustomInfo {
  k162Type?: string;
  isEOL?: boolean;
  [key: string]: unknown;
}

export const SystemLinkSignatureDialog = ({ data, setVisible }: SystemLinkSignatureDialogProps) =&gt; {
  const {
    outCommand,
    data: { wormholes },
  } = useMapRootState();

  const ref = useRef({ outCommand });
  ref.current = { outCommand };

  // Get system info for the target system
  const { staticInfo: targetSystemInfo, dynamicInfo: targetSystemDynamicInfo } = useSystemInfo({
    systemId: `${data.solar_system_target}`,
  });

  // Get the system class group for the target system
  const targetSystemClassGroup = useMemo(() =&gt; {
    if (!targetSystemInfo) return null;
    const systemClassId = targetSystemInfo.system_class;

    const systemClassKey = Object.keys(SOLAR_SYSTEM_CLASS_IDS).find(
      key =&gt; SOLAR_SYSTEM_CLASS_IDS[key as keyof typeof SOLAR_SYSTEM_CLASS_IDS] === systemClassId,
    );

    if (!systemClassKey) return null;

    return (
      SOLAR_SYSTEM_CLASSES_TO_CLASS_GROUPS[systemClassKey as keyof typeof SOLAR_SYSTEM_CLASSES_TO_CLASS_GROUPS] || null
    );
  }, [targetSystemInfo]);

  const handleHide = useCallback(() =&gt; {
    setVisible(false);
  }, [setVisible]);

  const filterSignature = useCallback(
    (signature: SystemSignature) =&gt; {
      if (signature.group !== SignatureGroup.Wormhole || !targetSystemClassGroup) {
        return true;
      }

      if (!signature.type) {
        return true;
      }

      if (signature.type === K162_SIGNATURE_TYPE) {
        // Parse the custom info to see if the user has specified what class this K162 leads to
        const customInfo = parseSignatureCustomInfo(signature.custom_info) as ExtendedSignatureCustomInfo;

        // If the user has specified a k162Type for this K162
        if (customInfo.k162Type) {
          // Get the K162 type information
          const k162TypeInfo = K162_TYPES_MAP[customInfo.k162Type];

          if (k162TypeInfo) {
            // Check if the k162Type matches our target system class
            return customInfo.k162Type === targetSystemClassGroup;
          }
        }

        // If no k162Type is specified or we couldn&apos;t find type info, allow it
        return true;
      }

      // Find the wormhole data for this signature type
      const wormholeData = wormholes.find(wh =&gt; wh.name === signature.type);
      if (!wormholeData) {
        return true; // If we don&apos;t know the destination, don&apos;t filter it out
      }

      // Get the destination system class from the wormhole data
      const destinationClass = wormholeData.dest;

      // Check if the destination class matches the target system class
      const isMatch = destinationClass === targetSystemClassGroup;
      return isMatch;
    },
    [targetSystemClassGroup, wormholes],
  );

  const handleSelect = useCallback(
    async (signature: SystemSignature) =&gt; {
      if (!signature) {
        return;
      }

      const { outCommand } = ref.current;

      await outCommand({
        type: OutCommand.linkSignatureToSystem,
        data: {
          ...data,
          signature_eve_id: signature.eve_id,
        },
      });

      if (parseSignatureCustomInfo(signature.custom_info).isEOL === true) {
        await outCommand({
          type: OutCommand.updateConnectionTimeStatus,
          data: {
            source: data.solar_system_source,
            target: data.solar_system_target,
            value: TimeStatus.eol,
          },
        });
      }

      const whShipSize = getWhSize(wormholes, signature.type);
      if (whShipSize) {
        await outCommand({
          type: OutCommand.updateConnectionShipSizeType,
          data: {
            source: data.solar_system_source,
            target: data.solar_system_target,
            value: whShipSize,
          },
        });
      }

      setVisible(false);
    },
    [data, setVisible, wormholes],
  );

  useEffect(() =&gt; {
    if (!targetSystemDynamicInfo) {
      handleHide();
    }
  }, [targetSystemDynamicInfo]);

  return (
    &lt;Dialog
      header=&quot;Select signature to link&quot;
      visible
      draggable={true}
      style={{ width: &apos;500px&apos; }}
      onHide={handleHide}
      contentClassName=&quot;!p-0&quot;
    &gt;
      &lt;SystemSignaturesContent
        systemId={`${data.solar_system_source}`}
        hideLinkedSignatures
        settings={LINK_SIGNTATURE_SETTINGS}
        onSelect={handleSelect}
        selectable={true}
        filterSignature={filterSignature}
      /&gt;
    &lt;/Dialog&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/SystemSettingsDialog/index.ts">export * from &apos;./SystemSettingsDialog&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/SystemSettingsDialog/SystemSettingsDialog.tsx">import { InputText } from &apos;primereact/inputtext&apos;;
import { InputTextarea } from &apos;primereact/inputtextarea&apos;;
import { Dialog } from &apos;primereact/dialog&apos;;
import { getSystemById } from &apos;@/hooks/Mapper/helpers&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useMapGetOption } from &apos;@/hooks/Mapper/mapRootProvider/hooks/api&apos;;
import { useCallback, useEffect, useRef, useState } from &apos;react&apos;;
import { Button } from &apos;primereact/button&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types&apos;;
import { IconField } from &apos;primereact/iconfield&apos;;
import { TooltipPosition, WdImageSize, WdImgButton } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { LabelsManager } from &apos;@/hooks/Mapper/utils/labelsManager.ts&apos;;
import { getSystemStaticInfo } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic&apos;;

interface SystemSettingsDialog {
  systemId: string;
  visible: boolean;
  setVisible: (visible: boolean) =&gt; void;
}

export const SystemSettingsDialog = ({ systemId, visible, setVisible }: SystemSettingsDialog) =&gt; {
  const {
    data: { systems },
    outCommand,
  } = useMapRootState();

  const isTempSystemNameEnabled = useMapGetOption(&apos;show_temp_system_name&apos;) === &apos;true&apos;;

  const system = getSystemById(systems, systemId);
  const systemStaticInfo = getSystemStaticInfo(systemId);

  const [name, setName] = useState(&apos;&apos;);
  const [label, setLabel] = useState(&apos;&apos;);
  const [temporaryName, setTemporaryName] = useState(&apos;&apos;);
  const [description, setDescription] = useState(&apos;&apos;);
  const inputRef = useRef&lt;HTMLInputElement&gt;();

  const ref = useRef({ name, description, temporaryName, label, outCommand, systemId, system, systemStaticInfo });
  ref.current = { name, description, label, temporaryName, outCommand, systemId, system, systemStaticInfo };

  const handleSave = useCallback(() =&gt; {
    const { name, description, label, temporaryName, outCommand, systemId, system, systemStaticInfo } = ref.current;

    const outLabel = new LabelsManager(system?.labels ?? &apos;&apos;);
    outLabel.updateCustomLabel(label);

    outCommand({
      type: OutCommand.updateSystemLabels,
      data: {
        system_id: systemId,
        value: outLabel.toString(),
      },
    });

    outCommand({
      type: OutCommand.updateSystemTemporaryName,
      data: {
        system_id: systemId,
        value: temporaryName,
      },
    });

    outCommand({
      type: OutCommand.updateSystemName,
      data: {
        system_id: systemId,
        value: name.trim() || systemStaticInfo?.solar_system_name,
      },
    });

    outCommand({
      type: OutCommand.updateSystemDescription,
      data: {
        system_id: systemId,
        value: description,
      },
    });

    setVisible(false);
  }, [setVisible]);

  const handleResetSystemName = useCallback(() =&gt; {
    const { systemStaticInfo } = ref.current;
    if (!systemStaticInfo) {
      return;
    }
    setName(systemStaticInfo.solar_system_name);
  }, []);

  const onShow = useCallback(() =&gt; {
    inputRef.current?.focus();
  }, []);

  const handleInput = useCallback((e: any) =&gt; {
    e.target.value = e.target.value.toUpperCase().replace(/[^A-Z0-9\-[\](){}]/g, &apos;&apos;);
  }, []);

  // Attention: this effect should be call only on mount.
  useEffect(() =&gt; {
    const { system } = ref.current;
    if (!system) {
      return;
    }

    const labels = new LabelsManager(system.labels || &apos;&apos;);

    setName(system.name || &apos;&apos;);
    setLabel(labels.customLabel);
    setTemporaryName(system.temporary_name || &apos;&apos;);
    setDescription(system.description || &apos;&apos;);
  }, []);

  return (
    &lt;Dialog
      header=&quot;System settings&quot;
      visible={visible}
      draggable={false}
      style={{ width: &apos;450px&apos; }}
      onShow={onShow}
      onHide={() =&gt; {
        if (!visible) {
          return;
        }

        setVisible(false);
      }}
    &gt;
      &lt;form onSubmit={handleSave}&gt;
        &lt;div className=&quot;flex flex-col gap-3&quot;&gt;
          &lt;div className=&quot;flex flex-col gap-2&quot;&gt;
            &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
              &lt;label htmlFor=&quot;username&quot;&gt;Custom name&lt;/label&gt;

              &lt;IconField&gt;
                {name !== systemStaticInfo?.solar_system_name &amp;&amp; (
                  &lt;WdImgButton
                    className=&quot;pi pi-undo&quot;
                    textSize={WdImageSize.large}
                    tooltip={{
                      content: &apos;Reset system name&apos;,
                      className: &apos;pi p-input-icon&apos;,
                      position: TooltipPosition.top,
                    }}
                    onClick={handleResetSystemName}
                  /&gt;
                )}
                &lt;InputText
                  id=&quot;name&quot;
                  aria-describedby=&quot;name&quot;
                  autoComplete=&quot;off&quot;
                  value={name}
                  // @ts-expect-error
                  ref={inputRef}
                  onChange={e =&gt; setName(e.target.value)}
                /&gt;
              &lt;/IconField&gt;
            &lt;/div&gt;

            &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
              &lt;label htmlFor=&quot;label&quot;&gt;Custom label&lt;/label&gt;

              &lt;IconField&gt;
                {label !== &apos;&apos; &amp;&amp; (
                  &lt;WdImgButton
                    className=&quot;pi pi-trash text-red-400&quot;
                    textSize={WdImageSize.large}
                    tooltip={{
                      content: &apos;Remove custom label&apos;,
                      className: &apos;pi p-input-icon&apos;,
                      position: TooltipPosition.top,
                    }}
                    onClick={() =&gt; setLabel(&apos;&apos;)}
                  /&gt;
                )}
                &lt;InputText
                  id=&quot;label&quot;
                  aria-describedby=&quot;label&quot;
                  autoComplete=&quot;off&quot;
                  value={label}
                  maxLength={5}
                  onChange={e =&gt; setLabel(e.target.value)}
                  onInput={handleInput}
                /&gt;
              &lt;/IconField&gt;
            &lt;/div&gt;

            {isTempSystemNameEnabled &amp;&amp; (
              &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
                &lt;label htmlFor=&quot;username&quot;&gt;Temporary Name&lt;/label&gt;

                &lt;IconField&gt;
                  {temporaryName !== &apos;&apos; &amp;&amp; (
                    &lt;WdImgButton
                      className=&quot;pi pi-trash text-red-400&quot;
                      textSize={WdImageSize.large}
                      tooltip={{
                        content: &apos;Remove temporary name&apos;,
                        className: &apos;pi p-input-icon&apos;,
                        position: TooltipPosition.top,
                      }}
                      onClick={() =&gt; setTemporaryName(&apos;&apos;)}
                    /&gt;
                  )}
                  &lt;InputText
                    id=&quot;temporaryName&quot;
                    aria-describedby=&quot;temporaryName&quot;
                    autoComplete=&quot;off&quot;
                    value={temporaryName}
                    maxLength={10}
                    onChange={e =&gt; setTemporaryName(e.target.value)}
                  /&gt;
                &lt;/IconField&gt;
              &lt;/div&gt;
            )}

            &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
              &lt;label htmlFor=&quot;username&quot;&gt;Description&lt;/label&gt;
              &lt;InputTextarea
                autoResize
                rows={5}
                cols={30}
                value={description}
                onChange={e =&gt; setDescription(e.target.value)}
              /&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div className=&quot;flex gap-2 justify-end&quot;&gt;
            &lt;Button onClick={handleSave} outlined size=&quot;small&quot; label=&quot;Save&quot;&gt;&lt;/Button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/Dialog&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/Widget/index.ts">export * from &apos;./Widget&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/Widget/Widget.module.scss">.root {

}

.Header {
  height: 28px;
  min-height: 28px;
  max-height: 28px;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/Widget/Widget.tsx">import React from &apos;react&apos;;

import classes from &apos;./Widget.module.scss&apos;;
import clsx from &apos;clsx&apos;;
import { WithChildren } from &apos;@/hooks/Mapper/types/common.ts&apos;;

export type WidgetProps = {
  label: React.ReactNode | string;
  windowId?: string;
  contentClassName?: string;
} &amp; WithChildren;

export const Widget = ({ label, children, windowId, contentClassName }: WidgetProps) =&gt; {
  return (
    &lt;div
      data-window-id={windowId}
      className={clsx(
        classes.root,
        &apos;flex flex-col w-full h-full rounded&apos;,
        &apos;text-gray-200 shadow-lg&apos;,
        &apos;border border-gray-500 border-opacity-30&apos;,
        &apos;bg-opacity-80 bg-neutral-900 &apos;,
      )}
    &gt;
      &lt;div
        className={clsx(
          classes.Header,
          &apos;react-grid-dragHandleExample h-7 text-sm flex w-full&apos;,
          &apos;bg-gray-400 bg-opacity-5 &apos;,
          &apos;px-2 py-1&apos;,
          &apos;border-b border-gray-500 border-opacity-30&apos;,
          &apos;cursor-move select-none &apos;,
        )}
      &gt;
        {label}
      &lt;/div&gt;
      &lt;div
        className={clsx(classes.Content, &apos;overflow-auto&apos;, &apos;bg-opacity-5 custom-scrollbar&apos;, contentClassName)}
        style={{ flexGrow: 1 }}
        onContextMenu={e =&gt; {
          e.preventDefault();
          e.stopPropagation();
        }}
      &gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/components/index.ts">export * from &apos;./Widget&apos;;
export * from &apos;./SystemSettingsDialog&apos;;
export * from &apos;./SystemCustomLabelDialog&apos;;
export * from &apos;./SystemLinkSignatureDialog&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/helpers/sortCharacters.ts">import { CharacterTypeRaw, WithIsOwnCharacter } from &apos;@/hooks/Mapper/types&apos;;

export const sortCharacters = (a: CharacterTypeRaw &amp; WithIsOwnCharacter, b: CharacterTypeRaw &amp; WithIsOwnCharacter) =&gt; {
  if (a.online !== b.online) {
    return a.online &amp;&amp; !b.online ? -1 : 1;
  }

  if (!a.online &amp;&amp; !b.online) {
    return a.name.localeCompare(b.name);
  }

  if (!a.isOwn &amp;&amp; !b.isOwn) {
    return 0;
  }
  if (a.isOwn &amp;&amp; !b.isOwn) {
    return -1;
  }
  if (!a.isOwn &amp;&amp; b.isOwn) {
    return 1;
  }

  return a.name.localeCompare(b.name);
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/CommentsWidget/CommentsWidget.tsx">import { Widget } from &apos;@/hooks/Mapper/components/mapInterface/components&apos;;
import { Comments } from &apos;@/hooks/Mapper/components/mapInterface/components/Comments&apos;;
import { InfoDrawer, SystemView, TooltipPosition, WdImgButton } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { useRef } from &apos;react&apos;;
import useMaxWidth from &apos;@/hooks/Mapper/hooks/useMaxWidth.ts&apos;;
import { COMPACT_MAX_WIDTH } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import clsx from &apos;clsx&apos;;
import { CommentsEditor } from &apos;@/hooks/Mapper/components/mapInterface/components/CommentsEditor&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;

export const CommentsWidgetContent = () =&gt; {
  const {
    data: { selectedSystems },
  } = useMapRootState();

  const isNotSelectedSystem = selectedSystems.length !== 1;

  if (isNotSelectedSystem) {
    return (
      &lt;div className=&quot;w-full h-full flex justify-center items-center select-none text-stone-400/80 text-sm&quot;&gt;
        System is not selected
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className={clsx(&apos;h-full grid grid-rows-[1fr_auto] gap-1 px-[4px]&apos;)}&gt;
      &lt;Comments /&gt;
      &lt;CommentsEditor /&gt;
    &lt;/div&gt;
  );
};

export const CommentsWidget = () =&gt; {
  const containerRef = useRef&lt;HTMLDivElement&gt;(null);
  const isCompact = useMaxWidth(containerRef, COMPACT_MAX_WIDTH);

  const {
    data: { selectedSystems, isSubscriptionActive },
  } = useMapRootState();
  const [systemId] = selectedSystems;
  const isNotSelectedSystem = selectedSystems.length !== 1;

  return (
    &lt;Widget
      contentClassName=&quot;my-1&quot;
      label={
        &lt;div ref={containerRef} className=&quot;flex justify-between items-center gap-1 text-xs w-full&quot;&gt;
          &lt;div className=&quot;flex items-center gap-1&quot;&gt;
            {!isCompact &amp;&amp; (
              &lt;div className=&quot;flex whitespace-nowrap text-ellipsis overflow-hidden text-stone-400&quot;&gt;
                Comments {isNotSelectedSystem ? &apos;&apos; : &apos;in&apos;}
              &lt;/div&gt;
            )}
            {!isNotSelectedSystem &amp;&amp; &lt;SystemView systemId={systemId} className=&quot;select-none text-center&quot; hideRegion /&gt;}
          &lt;/div&gt;
          &lt;WdImgButton
            className={PrimeIcons.QUESTION_CIRCLE}
            tooltip={{
              position: TooltipPosition.left,
              content: (
                &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
                  &lt;InfoDrawer title={&lt;b className=&quot;text-slate-50&quot;&gt;How to add/delete comment?&lt;/b&gt;}&gt;
                    It is possible to use markdown formating. &lt;br /&gt;
                    Only users with tracking permission can add/delete comments. &lt;br /&gt;
                  &lt;/InfoDrawer&gt;
                  &lt;InfoDrawer title={&lt;b className=&quot;text-slate-50&quot;&gt;Limitations&lt;/b&gt;}&gt;
                    Each comment length is limited to &lt;b&gt;500&lt;/b&gt; characters. &lt;br /&gt;
                    No more than &lt;b&gt;{isSubscriptionActive ? &apos;500&apos; : &apos;30&apos;}&lt;/b&gt; comments are allowed per system*. &lt;br /&gt;
                    &lt;small&gt;* based on active map subscription.&lt;/small&gt;
                  &lt;/InfoDrawer&gt;
                &lt;/div&gt;
              ),
            }}
          /&gt;
        &lt;/div&gt;
      }
    &gt;
      &lt;CommentsWidgetContent /&gt;
    &lt;/Widget&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/CommentsWidget/index.ts">export * from &apos;./CommentsWidget&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/components/LocalCharactersItemTemplate/index.ts">export * from &apos;./LocalCharactersItemTemplate.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/components/LocalCharactersItemTemplate/LocalCharactersItemTemplate.module.scss">.CharacterRow {
  &amp;.CardBorderLeftIsOwn {
    border-left-color: rgb(251 146 60 / 1)
  }
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/components/LocalCharactersItemTemplate/LocalCharactersItemTemplate.tsx">import classes from &apos;./LocalCharactersItemTemplate.module.scss&apos;;
import clsx from &apos;clsx&apos;;
import { CharacterCard } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { CharItemProps } from &apos;@/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/components&apos;;
import { VirtualScrollerTemplateOptions } from &apos;primereact/virtualscroller&apos;;

export type LocalCharactersItemTemplateProps = { showShipName: boolean } &amp; CharItemProps &amp;
  VirtualScrollerTemplateOptions;

export const LocalCharactersItemTemplate = ({ showShipName, ...options }: LocalCharactersItemTemplateProps) =&gt; {
  return (
    &lt;div
      className={clsx(
        classes.CharacterRow,
        &apos;box-border flex items-center w-full whitespace-nowrap overflow-hidden text-ellipsis min-w-[0px]&apos;,
        &apos;px-1&apos;,
        {
          &apos;surface-hover&apos;: options.odd,
          &apos;border-b border-gray-600 border-opacity-20&apos;: !options.last,
          &apos;bg-green-500 hover:bg-green-700 transition duration-300 bg-opacity-10 hover:bg-opacity-10&apos;: options.online,
        },
      )}
      style={{ height: `${options.props.itemSize}px` }}
    &gt;
      &lt;CharacterCard showShipName={showShipName} showTicker {...options} /&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/components/index.ts">export * from &apos;./LocalCharactersItemTemplate&apos;;
export * from &apos;./LocalCharactersList&apos;;
export * from &apos;./types&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/components/LocalCharactersHeader.tsx">import React, { useRef } from &apos;react&apos;;
import clsx from &apos;clsx&apos;;
import useMaxWidth from &apos;@/hooks/Mapper/hooks/useMaxWidth&apos;;
import { LayoutEventBlocker, TooltipPosition, WdCheckbox, WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

interface LocalCharactersHeaderProps {
  sortedCount: number;
  showList: boolean;
  showOffline: boolean;
  settings: {
    compact: boolean;
    showOffline: boolean;
    showShipName: boolean;
  };
  setSettings: (fn: (prev: any) =&gt; any) =&gt; void;
}

export const LocalCharactersHeader: React.FC&lt;LocalCharactersHeaderProps&gt; = ({
  sortedCount,
  showList,
  showOffline,
  settings,
  setSettings,
}) =&gt; {
  const headerRef = useRef&lt;HTMLDivElement&gt;(null);
  const compactOffline = useMaxWidth(headerRef, 145);
  const compactShipName = useMaxWidth(headerRef, 195);

  return (
    &lt;div className=&quot;flex w-full items-center text-xs justify-between&quot; ref={headerRef}&gt;
      &lt;div className=&quot;flex-shrink-0 select-none mr-2&quot;&gt;Local{showList ? ` [${sortedCount}]` : &apos;&apos;}&lt;/div&gt;
      &lt;LayoutEventBlocker className=&quot;flex items-center gap-2 justify-end&quot;&gt;
        &lt;div className=&quot;flex items-center gap-2&quot;&gt;
          {showOffline &amp;&amp; (
            &lt;WdTooltipWrapper content=&quot;Show offline characters in system&quot; position={TooltipPosition.top}&gt;
              &lt;WdCheckbox
                size=&quot;xs&quot;
                labelSide=&quot;left&quot;
                label={compactOffline ? &apos;&apos; : &apos;Offline&apos;}
                value={settings.showOffline}
                onChange={() =&gt; setSettings((prev: any) =&gt; ({ ...prev, showOffline: !prev.showOffline }))}
                classNameLabel={clsx(&apos;whitespace-nowrap text-stone-400 hover:text-stone-200 transition duration-300&apos;, {
                  truncate: compactOffline,
                })}
              /&gt;
            &lt;/WdTooltipWrapper&gt;
          )}

          {settings.compact &amp;&amp; (
            &lt;WdTooltipWrapper content=&quot;Show ship name in compact rows&quot; position={TooltipPosition.top}&gt;
              &lt;WdCheckbox
                size=&quot;xs&quot;
                labelSide=&quot;left&quot;
                label={compactShipName ? &apos;&apos; : &apos;Ship name&apos;}
                value={settings.showShipName}
                onChange={() =&gt; setSettings((prev: any) =&gt; ({ ...prev, showShipName: !prev.showShipName }))}
                classNameLabel={clsx(&apos;whitespace-nowrap text-stone-400 hover:text-stone-200 transition duration-300&apos;, {
                  truncate: compactShipName,
                })}
              /&gt;
            &lt;/WdTooltipWrapper&gt;
          )}
        &lt;/div&gt;
        &lt;WdTooltipWrapper content=&quot;Enable compact mode&quot; position={TooltipPosition.top}&gt;
          &lt;span
            className={clsx(&apos;w-4 h-4 min-w-[1rem] cursor-pointer&apos;, {
              &apos;hero-bars-2&apos;: settings.compact,
              &apos;hero-bars-3&apos;: !settings.compact,
            })}
            onClick={() =&gt; setSettings((prev: any) =&gt; ({ ...prev, compact: !prev.compact }))}
          /&gt;
        &lt;/WdTooltipWrapper&gt;
      &lt;/LayoutEventBlocker&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/components/LocalCharactersList.tsx">import React from &apos;react&apos;;
import { VirtualScroller, VirtualScrollerTemplateOptions } from &apos;primereact/virtualscroller&apos;;
import clsx from &apos;clsx&apos;;
import { CharItemProps } from &apos;./types&apos;;

export type LocalCharactersListProps = {
  items: Array&lt;CharItemProps&gt;;
  itemSize: number;
  itemTemplate: (char: CharItemProps, options: VirtualScrollerTemplateOptions) =&gt; React.ReactNode;
  containerClassName?: string;
  style?: React.CSSProperties;
  autoSize?: boolean;
};

export const LocalCharactersList = ({
  items,
  itemSize,
  itemTemplate,
  containerClassName,
  style = {},
  autoSize = false,
}: LocalCharactersListProps) =&gt; {
  const computedHeight = autoSize ? `${Math.max(items.length, 1) * itemSize}px` : style.height || &apos;100%&apos;;

  const localStyle: React.CSSProperties = {
    ...style,
    height: computedHeight,
    width: &apos;100%&apos;,
    boxSizing: &apos;border-box&apos;,
    overflowX: &apos;hidden&apos;,
  };

  return (
    &lt;VirtualScroller
      items={items}
      itemSize={itemSize}
      orientation=&quot;vertical&quot;
      className={clsx(&apos;w-full h-full&apos;, containerClassName)}
      itemTemplate={itemTemplate}
      autoSize={autoSize}
      style={localStyle}
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/components/types.ts">import { CharacterTypeRaw, WithIsOwnCharacter } from &apos;@/hooks/Mapper/types&apos;;

export type CharItemProps = {
  compact: boolean;
} &amp; CharacterTypeRaw &amp;
  WithIsOwnCharacter;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/hooks/useLocalCharacters.tsx">import { useCallback } from &apos;react&apos;;
import { VirtualScrollerTemplateOptions } from &apos;primereact/virtualscroller&apos;;
import { CharItemProps, LocalCharactersItemTemplate } from &apos;../components&apos;;

export function useLocalCharactersItemTemplate(showShipName: boolean) {
  return useCallback(
    (char: CharItemProps, options: VirtualScrollerTemplateOptions) =&gt; (
      &lt;LocalCharactersItemTemplate {...char} {...options} showShipName={showShipName} /&gt;
    ),
    [showShipName],
  );
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/hooks/useLocalWidgetSettings.ts">import useLocalStorageState from &apos;use-local-storage-state&apos;;

export interface LocalCharacterWidgetSettings {
  compact: boolean;
  showOffline: boolean;
  version: number;
  showShipName: boolean;
}

export const LOCAL_CHARACTER_WIDGET_DEFAULT: LocalCharacterWidgetSettings = {
  compact: true,
  showOffline: false,
  version: 0,
  showShipName: false,
};

export function useLocalCharacterWidgetSettings() {
  return useLocalStorageState&lt;LocalCharacterWidgetSettings&gt;(&apos;kills:widget:settings&apos;, {
    defaultValue: LOCAL_CHARACTER_WIDGET_DEFAULT,
  });
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/index.ts">export * from &apos;./LocalCharacters.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/LocalCharacters.module.scss">.VirtualScroller {
  height: 100% !important;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/LocalCharacters/LocalCharacters.tsx">import { useMemo } from &apos;react&apos;;
import { Widget } from &apos;@/hooks/Mapper/components/mapInterface/components&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { sortCharacters } from &apos;@/hooks/Mapper/components/mapInterface/helpers/sortCharacters&apos;;
import { useMapCheckPermissions, useMapGetOption } from &apos;@/hooks/Mapper/mapRootProvider/hooks/api&apos;;
import { UserPermission } from &apos;@/hooks/Mapper/types/permissions&apos;;
import { LocalCharactersList } from &apos;./components/LocalCharactersList&apos;;
import { useLocalCharactersItemTemplate } from &apos;./hooks/useLocalCharacters&apos;;
import { useLocalCharacterWidgetSettings } from &apos;./hooks/useLocalWidgetSettings&apos;;
import { LocalCharactersHeader } from &apos;./components/LocalCharactersHeader&apos;;
import classes from &apos;./LocalCharacters.module.scss&apos;;
import clsx from &apos;clsx&apos;;

export const LocalCharacters = () =&gt; {
  const {
    data: { characters, userCharacters, selectedSystems },
  } = useMapRootState();

  const [settings, setSettings] = useLocalCharacterWidgetSettings();
  const [systemId] = selectedSystems;
  const restrictOfflineShowing = useMapGetOption(&apos;restrict_offline_showing&apos;);
  const isAdminOrManager = useMapCheckPermissions([UserPermission.MANAGE_MAP]);
  const showOffline = useMemo(
    () =&gt; !restrictOfflineShowing || isAdminOrManager,
    [isAdminOrManager, restrictOfflineShowing],
  );

  const sorted = useMemo(() =&gt; {
    const filtered = characters
      .filter(x =&gt; x.location?.solar_system_id?.toString() === systemId)
      .map(x =&gt; ({
        ...x,
        isOwn: userCharacters.includes(x.eve_id),
        compact: settings.compact,
        showShipName: settings.showShipName,
      }))
      .sort(sortCharacters);

    if (!showOffline || !settings.showOffline) {
      return filtered.filter(c =&gt; c.online);
    }
    return filtered;
  }, [
    characters,
    systemId,
    userCharacters,
    settings.compact,
    settings.showOffline,
    settings.showShipName,
    showOffline,
  ]);

  const isNobodyHere = sorted.length === 0;
  const isNotSelectedSystem = selectedSystems.length !== 1;
  const showList = sorted.length &gt; 0 &amp;&amp; selectedSystems.length === 1;

  const itemTemplate = useLocalCharactersItemTemplate(settings.showShipName);

  return (
    &lt;Widget
      label={
        &lt;LocalCharactersHeader
          sortedCount={sorted.length}
          showList={showList}
          showOffline={showOffline}
          settings={settings}
          setSettings={setSettings}
        /&gt;
      }
    &gt;
      {isNotSelectedSystem &amp;&amp; (
        &lt;div className=&quot;w-full h-full flex justify-center items-center select-none text-center text-stone-400/80 text-sm&quot;&gt;
          System is not selected
        &lt;/div&gt;
      )}
      {isNobodyHere &amp;&amp; !isNotSelectedSystem &amp;&amp; (
        &lt;div className=&quot;w-full h-full flex justify-center items-center select-none text-stone-400/80 text-sm&quot;&gt;
          Nobody here
        &lt;/div&gt;
      )}
      {showList &amp;&amp; (
        &lt;LocalCharactersList
          items={sorted}
          itemSize={settings.compact ? 26 : 41}
          itemTemplate={itemTemplate}
          containerClassName={clsx(
            &apos;w-full h-full overflow-x-hidden overflow-y-auto custom-scrollbar select-none&apos;,
            classes.VirtualScroller,
          )}
        /&gt;
      )}
    &lt;/Widget&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/hooks/index.ts">export * from &apos;./useLoadRoutes&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/hooks/useLoadRoutes.ts">import { useCallback, useEffect, useRef } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useRouteProvider } from &apos;@/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesProvider.tsx&apos;;
import { RoutesType } from &apos;@/hooks/Mapper/mapRootProvider/types.ts&apos;;

function usePrevious&lt;T&gt;(value: T): T | undefined {
  const ref = useRef&lt;T&gt;();

  useEffect(() =&gt; {
    ref.current = value;
  }, [value]);

  return ref.current;
}

export const useLoadRoutes = () =&gt; {
  const { data: routesSettings, loadRoutesCommand, hubs, routesList, loading, setLoading } = useRouteProvider();

  const {
    data: { selectedSystems, systems, connections },
  } = useMapRootState();

  const prevSys = usePrevious(systems);
  const ref = useRef({ prevSys, selectedSystems });
  ref.current = { prevSys, selectedSystems };

  const loadRoutes = useCallback(
    (systemId: string, routesSettings: RoutesType) =&gt; {
      loadRoutesCommand(systemId, routesSettings);
      setLoading(true);
    },
    [loadRoutesCommand],
  );

  useEffect(() =&gt; {
    setLoading(false);
  }, [routesList]);

  useEffect(() =&gt; {
    if (selectedSystems.length !== 1) {
      return;
    }

    const [systemId] = selectedSystems;
    loadRoutes(systemId, routesSettings);
  }, [
    loadRoutes,
    selectedSystems,
    systems?.length,
    connections,
    hubs,
    routesSettings,
    ...Object.keys(routesSettings)
      .sort()
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error
      .map(x =&gt; routesSettings[x]),
  ]);

  return { loading, loadRoutes };
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesList/index.ts">export * from &apos;./RoutesList&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesList/RoutesList.module.scss">.RoutesListRoot {
  display: flex;
  gap: 2px;
  align-items: center;
  flex-wrap: wrap;
}

.RouteSystem {
  width: 8px;
  height: 8px;

  cursor: pointer;
  transition: opacity 200ms;
  opacity: 1;
}

.Faded {
  opacity: 0.3;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesList/RoutesList.tsx">import classes from &apos;./RoutesList.module.scss&apos;;
import { Route, SystemStaticInfoShort } from &apos;@/hooks/Mapper/types/routes.ts&apos;;
import clsx from &apos;clsx&apos;;
import { SystemViewStandalone, TooltipPosition, WdTooltip, WdTooltipHandlers } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { getBackgroundClass, getShapeClass } from &apos;@/hooks/Mapper/components/map/helpers&apos;;
import { MouseEvent, useCallback, useRef, useState } from &apos;react&apos;;
import { Commands } from &apos;@/hooks/Mapper/types&apos;;
import { emitMapEvent } from &apos;@/hooks/Mapper/events&apos;;

export type RouteSystemProps = {
  destination: number;
  onClick?(systemId: number): void;
  onMouseEnter?(systemId: number): void;
  onMouseLeave?(): void;
  onContextMenu?(e: MouseEvent, systemId: string): void;
  faded?: boolean;
} &amp; SystemStaticInfoShort;

export const RouteSystem = ({
  system_class,
  security,
  solar_system_id,
  class_title,
  triglavian_invasion_status,
  solar_system_name,
  // destination,
  region_name,
  faded,
  onClick,
  onMouseEnter,
  onMouseLeave,
  onContextMenu,
}: RouteSystemProps) =&gt; {
  const tooltipRef = useRef&lt;WdTooltipHandlers&gt;(null);

  const handleContext = useCallback(
    (e: MouseEvent) =&gt; {
      e.preventDefault();
      e.stopPropagation();
      onContextMenu?.(e, solar_system_id.toString());
    },
    [onContextMenu, solar_system_id],
  );

  return (
    &lt;&gt;
      &lt;WdTooltip
        ref={tooltipRef}
        position={TooltipPosition.top}
        // targetSelector={`.tooltip-route-sys_${destination}_${solar_system_id}`}
        content={() =&gt; (
          &lt;SystemViewStandalone
            className=&quot;mx-[4px]&quot;
            security={security}
            system_class={system_class}
            class_title={class_title}
            solar_system_name={solar_system_name}
            region_name={region_name}
            solar_system_id={solar_system_id}
          /&gt;
        )}
      /&gt;
      &lt;div
        onMouseEnter={e =&gt; {
          tooltipRef.current?.show(e);
          onMouseEnter?.(solar_system_id);
        }}
        onMouseLeave={() =&gt; {
          tooltipRef.current?.hide();
          onMouseLeave?.();
        }}
        onContextMenu={handleContext}
        onClick={() =&gt; onClick?.(solar_system_id)}
        className={clsx(
          classes.RouteSystem,
          // `tooltip-route-sys_${destination}_${solar_system_id}`,
          getBackgroundClass(system_class, security),
          getShapeClass(system_class, triglavian_invasion_status),
          { [classes.Faded]: faded },
        )}
      &gt;&lt;/div&gt;
    &lt;/&gt;
  );
};

export interface RoutesListProps {
  onContextMenu?(e: MouseEvent, systemId: string): void;
  data: Route;
}

export const RoutesList = ({ data, onContextMenu }: RoutesListProps) =&gt; {
  const [selected, setSelected] = useState&lt;number | null&gt;(null);

  const handleClick = useCallback(
    (systemId: number) =&gt; emitMapEvent({ name: Commands.centerSystem, data: systemId?.toString() }),
    [],
  );

  if (!data.has_connection) {
    return &lt;div className=&quot;text-stone-400&quot;&gt;No connection&lt;/div&gt;;
  }

  return (
    &lt;&gt;
      &lt;div className={classes.RoutesListRoot}&gt;
        {data.mapped_systems?.filter(Boolean).map(x =&gt; {
          if (!x) {
            return null;
          }
          return (
            &lt;RouteSystem
              key={x.solar_system_id}
              faded={selected !== null &amp;&amp; selected !== x?.solar_system_id}
              destination={data.destination}
              {...x}
              onMouseEnter={systemId =&gt; {
                setSelected(systemId);
              }}
              onMouseLeave={() =&gt; {
                setSelected(null);
              }}
              onContextMenu={onContextMenu}
              onClick={handleClick}
            /&gt;
          );
        })}
      &lt;/div&gt;
    &lt;/&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesSettingsDialog/index.ts">export * from &apos;./RoutesSettingsDialog&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesSettingsDialog/RoutesSettingsDialog.tsx">import { Dialog } from &apos;primereact/dialog&apos;;
import { useCallback, useEffect, useRef, useState } from &apos;react&apos;;
import { Button } from &apos;primereact/button&apos;;
import {
  RoutesType,
  useRouteProvider,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesProvider.tsx&apos;;
import { PrettySwitchbox } from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings/components&apos;;

interface RoutesSettingsDialog {
  visible: boolean;
  setVisible: (visible: boolean) =&gt; void;
}

type RoutesFlagsType = Omit&lt;RoutesType, &apos;path_type&apos; | &apos;avoid&apos;&gt;;

const checkboxes: { label: string; propName: keyof RoutesFlagsType }[] = [
  { label: &apos;Include Mass Crit&apos;, propName: &apos;include_mass_crit&apos; },
  { label: &apos;Include EOL&apos;, propName: &apos;include_eol&apos; },
  { label: &apos;Include Frigate&apos;, propName: &apos;include_frig&apos; },
  { label: &apos;Include Cruise&apos;, propName: &apos;include_cruise&apos; },
  { label: &apos;Include Thera connections&apos;, propName: &apos;include_thera&apos; },
  { label: &apos;Avoid Wormholes&apos;, propName: &apos;avoid_wormholes&apos; },
  { label: &apos;Avoid Pochven&apos;, propName: &apos;avoid_pochven&apos; },
  { label: &apos;Avoid Edencom systems&apos;, propName: &apos;avoid_edencom&apos; },
  { label: &apos;Avoid Triglavian systems&apos;, propName: &apos;avoid_triglavian&apos; },
];

export const RoutesSettingsDialog = ({ visible, setVisible }: RoutesSettingsDialog) =&gt; {
  const { data, update } = useRouteProvider();

  const [, updateKey] = useState(0);

  const optionsRef = useRef(data);

  const currentData = useRef(data);
  currentData.current = data;

  const handleChangeEvent = useCallback(
    (propName: keyof RoutesType) =&gt; (event: boolean) =&gt; {
      optionsRef.current = { ...optionsRef.current, [propName]: event };
      updateKey(x =&gt; x + 1);
    },
    [],
  );

  const handleSave = useCallback(() =&gt; {
    update({ ...optionsRef.current });
    setVisible(false);
  }, [setVisible, update]);

  useEffect(() =&gt; {
    if (visible) {
      optionsRef.current = currentData.current;
      updateKey(x =&gt; x + 1);
    }
  }, [visible]);

  return (
    &lt;Dialog
      header=&quot;Routes settings&quot;
      visible={visible}
      draggable={false}
      style={{ width: &apos;350px&apos; }}
      onHide={() =&gt; {
        if (!visible) {
          return;
        }

        setVisible(false);
      }}
    &gt;
      &lt;div className=&quot;flex flex-col gap-3 p-2.5&quot;&gt;
        &lt;div className=&quot;flex flex-col gap-2 mb-2&quot;&gt;
          {checkboxes.map(({ label, propName }) =&gt; (
            &lt;PrettySwitchbox
              key={propName}
              label={label}
              checked={optionsRef.current[propName]}
              setChecked={handleChangeEvent(propName)}
            /&gt;
          ))}
        &lt;/div&gt;

        &lt;div className=&quot;flex gap-2 justify-end&quot;&gt;
          &lt;Button onClick={handleSave} outlined size=&quot;small&quot; label=&quot;Apply&quot;&gt;&lt;/Button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/Dialog&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/index.ts">export * from &apos;./RoutesWidget.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesProvider.tsx">import React, { createContext, forwardRef, useContext, useImperativeHandle, useState } from &apos;react&apos;;
import {
  RoutesImperativeHandle,
  RoutesProviderInnerProps,
  RoutesWidgetProps,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/types.ts&apos;;

type MapProviderProps = {
  children: React.ReactNode;
} &amp; RoutesWidgetProps;

const RoutesContext = createContext&lt;RoutesProviderInnerProps&gt;({
  update: () =&gt; {},
  // @ts-ignore
  data: {},
});

export const RoutesProvider = forwardRef&lt;RoutesImperativeHandle, MapProviderProps&gt;(({ children, ...props }, ref) =&gt; {
  const [loading, setLoading] = useState(false);

  useImperativeHandle(ref, () =&gt; ({
    stopLoading() {
      setLoading(false);
    },
  }));

  return &lt;RoutesContext.Provider value={{ ...props, loading, setLoading }}&gt;{children}&lt;/RoutesContext.Provider&gt;;
});
RoutesProvider.displayName = &apos;RoutesProvider&apos;;

export const useRouteProvider = () =&gt; {
  const context = useContext&lt;RoutesProviderInnerProps&gt;(RoutesContext);
  return context;
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesWidget.module.scss">.RoutesGrid {
  display: grid;
  grid-template-columns: auto auto 1fr;
  align-items: center;

  column-gap: 3px;
  row-gap: 2px;

  font-size: 12px;
}

.RemoveBtn {
  font-size: 9px;
  opacity: 0.3;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/RoutesWidget.tsx">import { Widget } from &apos;@/hooks/Mapper/components/mapInterface/components&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import {
  LayoutEventBlocker,
  LoadingWrapper,
  SystemViewStandalone,
  TooltipPosition,
  WdCheckbox,
  WdImgButton,
} from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { useLoadSystemStatic } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic.ts&apos;;
import { forwardRef, MouseEvent, ReactNode, useCallback, useEffect, useMemo, useRef, useState } from &apos;react&apos;;
import { getSystemById } from &apos;@/hooks/Mapper/helpers/getSystemById.ts&apos;;
import classes from &apos;./RoutesWidget.module.scss&apos;;
import { useLoadRoutes } from &apos;./hooks&apos;;
import { RoutesList } from &apos;./RoutesList&apos;;
import clsx from &apos;clsx&apos;;
import { Route } from &apos;@/hooks/Mapper/types/routes.ts&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { RoutesSettingsDialog } from &apos;./RoutesSettingsDialog&apos;;
import { RoutesProvider, useRouteProvider } from &apos;./RoutesProvider.tsx&apos;;
import { ContextMenuSystemInfo, useContextMenuSystemInfoHandlers } from &apos;@/hooks/Mapper/components/contexts&apos;;
import useMaxWidth from &apos;@/hooks/Mapper/hooks/useMaxWidth.ts&apos;;
import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;
import {
  AddSystemDialog,
  SearchOnSubmitCallback,
} from &apos;@/hooks/Mapper/components/mapInterface/components/AddSystemDialog&apos;;
import {
  RoutesImperativeHandle,
  RoutesWidgetProps,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/types.ts&apos;;

const sortByDist = (a: Route, b: Route) =&gt; {
  const distA = a.has_connection ? a.systems?.length || 0 : Infinity;
  const distB = b.has_connection ? b.systems?.length || 0 : Infinity;

  return distA - distB;
};

export const RoutesWidgetContent = () =&gt; {
  const {
    data: { selectedSystems, systems, isSubscriptionActive },
  } = useMapRootState();
  const { hubs = [], routesList, isRestricted } = useRouteProvider();

  const [systemId] = selectedSystems;

  const { loading } = useLoadRoutes();

  const { systems: systemStatics, loadSystems, lastUpdateKey } = useLoadSystemStatic({ systems: hubs ?? [] });
  const { open, ...systemCtxProps } = useContextMenuSystemInfoHandlers();

  const preparedHubs = useMemo(() =&gt; {
    return hubs.map(x =&gt; {
      const sys = getSystemById(systems, x.toString());

      return { ...systemStatics.get(parseInt(x))!, ...(sys &amp;&amp; { customName: sys.name ?? &apos;&apos; }) };
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [hubs, systems, systemStatics, lastUpdateKey]);

  const preparedRoutes: Route[] = useMemo(() =&gt; {
    return (
      routesList?.routes
        .sort(sortByDist)
        // .filter(x =&gt; x.destination.toString() !== systemId)
        .map(route =&gt; ({
          ...route,
          mapped_systems:
            route.systems?.map(solar_system_id =&gt;
              routesList?.systems_static_data.find(
                system_static_data =&gt; system_static_data.solar_system_id === solar_system_id,
              ),
            ) ?? [],
        })) ?? []
    );
  }, [routesList?.routes, routesList?.systems_static_data, systemId]);

  const refData = useRef({ open, loadSystems, preparedRoutes });
  refData.current = { open, loadSystems, preparedRoutes };

  useEffect(() =&gt; {
    (async () =&gt; await refData.current.loadSystems(hubs))();
  }, [hubs]);

  const handleClick = useCallback((e: MouseEvent, systemId: string) =&gt; {
    const route = refData.current.preparedRoutes.find(x =&gt; x.destination.toString() === systemId);

    refData.current.open(e, systemId, route?.mapped_systems ?? []);
  }, []);

  const handleContextMenu = useCallback(
    async (e: MouseEvent, systemId: string) =&gt; {
      await refData.current.loadSystems([systemId]);
      handleClick(e, systemId);
    },
    [handleClick],
  );

  if (isRestricted &amp;&amp; !isSubscriptionActive) {
    return (
      &lt;div className=&quot;w-full h-full flex items-center justify-center&quot;&gt;
        &lt;span className=&quot;select-none text-center text-stone-400/80 text-sm&quot;&gt;
          User Routes available with &amp;#39;Active&amp;#39; map subscription only (contact map administrators)
        &lt;/span&gt;
      &lt;/div&gt;
    );
  }

  if (!systemId) {
    return (
      &lt;div className=&quot;w-full h-full flex justify-center items-center select-none text-center text-stone-400/80 text-sm&quot;&gt;
        System is not selected
      &lt;/div&gt;
    );
  }

  if (hubs.length === 0) {
    return &lt;div className=&quot;w-full h-full flex justify-center items-center select-none&quot;&gt;Routes not set&lt;/div&gt;;
  }

  return (
    &lt;&gt;
      &lt;LoadingWrapper loading={loading}&gt;
        &lt;div className={clsx(classes.RoutesGrid, &apos;px-2 py-2&apos;)}&gt;
          {preparedRoutes.map(route =&gt; {
            const sys = preparedHubs.find(x =&gt; x.solar_system_id === route.destination)!;

            // TODO do not delte this console log
            // eslint-disable-next-line no-console
            // console.log(&apos;JOipP&apos;, `Check sys [${route.destination}]:`, sys);

            return (
              &lt;&gt;
                &lt;div className=&quot;flex gap-2 items-center&quot;&gt;
                  &lt;WdImgButton
                    className={clsx(PrimeIcons.BARS, classes.RemoveBtn)}
                    onClick={e =&gt; handleClick(e, route.destination.toString())}
                    tooltip={{
                      content: &apos;Click here to open system menu&apos;,
                      position: TooltipPosition.top,
                      offset: 10,
                    }}
                  /&gt;

                  &lt;SystemViewStandalone
                    key={route.destination}
                    className={clsx(&apos;select-none text-center cursor-context-menu&apos;)}
                    hideRegion
                    compact
                    {...sys}
                  /&gt;
                &lt;/div&gt;
                &lt;div className=&quot;text-right pl-1&quot;&gt;{route.has_connection ? route.systems?.length ?? 2 : &apos;&apos;}&lt;/div&gt;
                &lt;div className=&quot;pl-2 pb-0.5&quot;&gt;
                  &lt;RoutesList data={route} onContextMenu={handleContextMenu} /&gt;
                &lt;/div&gt;
              &lt;/&gt;
            );
          })}
        &lt;/div&gt;
      &lt;/LoadingWrapper&gt;

      &lt;ContextMenuSystemInfo
        hubs={hubs}
        routes={preparedRoutes}
        systems={systems}
        systemStatics={systemStatics}
        systemIdFrom={systemId}
        {...systemCtxProps}
      /&gt;
    &lt;/&gt;
  );
};

type RoutesWidgetCompProps = {
  title: ReactNode | string;
};

export const RoutesWidgetComp = ({ title }: RoutesWidgetCompProps) =&gt; {
  const [routeSettingsVisible, setRouteSettingsVisible] = useState(false);
  const { data, update, addHubCommand } = useRouteProvider();

  const isSecure = data.path_type === &apos;secure&apos;;
  const handleSecureChange = useCallback(() =&gt; {
    update({
      ...data,
      path_type: data.path_type === &apos;secure&apos; ? &apos;shortest&apos; : &apos;secure&apos;,
    });
  }, [data, update]);

  const ref = useRef&lt;HTMLDivElement&gt;(null);
  const compact = useMaxWidth(ref, 170);
  const [openAddSystem, setOpenAddSystem] = useState&lt;boolean&gt;(false);

  const onAddSystem = useCallback(() =&gt; setOpenAddSystem(true), []);

  const handleSubmitAddSystem: SearchOnSubmitCallback = useCallback(
    async item =&gt; addHubCommand(item.value.toString()),
    [addHubCommand],
  );

  return (
    &lt;Widget
      label={
        &lt;div className=&quot;flex justify-between items-center text-xs w-full&quot; ref={ref}&gt;
          &lt;span className=&quot;select-none&quot;&gt;{title}&lt;/span&gt;
          &lt;LayoutEventBlocker className=&quot;flex items-center gap-2&quot;&gt;
            &lt;WdImgButton
              className={PrimeIcons.PLUS_CIRCLE}
              onClick={onAddSystem}
              tooltip={{
                content: &apos;Click here to add new system to routes&apos;,
              }}
            /&gt;

            &lt;WdTooltipWrapper content=&quot;Show shortest route&quot; position={TooltipPosition.top}&gt;
              &lt;WdCheckbox
                size=&quot;xs&quot;
                labelSide=&quot;left&quot;
                label={compact ? &apos;&apos; : &apos;Show shortest&apos;}
                value={!isSecure}
                onChange={handleSecureChange}
                classNameLabel=&quot;text-red-400 whitespace-nowrap&quot;
              /&gt;
            &lt;/WdTooltipWrapper&gt;
            &lt;WdImgButton
              className={PrimeIcons.SLIDERS_H}
              onClick={() =&gt; setRouteSettingsVisible(true)}
              tooltip={{
                position: TooltipPosition.top,
                content: &apos;Click here to open Routes settings&apos;,
              }}
            /&gt;
          &lt;/LayoutEventBlocker&gt;
        &lt;/div&gt;
      }
    &gt;
      &lt;RoutesWidgetContent /&gt;
      &lt;RoutesSettingsDialog visible={routeSettingsVisible} setVisible={setRouteSettingsVisible} /&gt;

      &lt;AddSystemDialog
        title=&quot;Add system to routes&quot;
        visible={openAddSystem}
        setVisible={() =&gt; setOpenAddSystem(false)}
        onSubmit={handleSubmitAddSystem}
      /&gt;
    &lt;/Widget&gt;
  );
};

export const RoutesWidget = forwardRef&lt;RoutesImperativeHandle, RoutesWidgetProps &amp; RoutesWidgetCompProps&gt;(
  ({ title, ...props }, ref) =&gt; {
    return (
      &lt;RoutesProvider {...props} ref={ref}&gt;
        &lt;RoutesWidgetComp title={title} /&gt;
      &lt;/RoutesProvider&gt;
    );
  },
);
RoutesWidget.displayName = &apos;RoutesWidget&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/types.ts">import { RoutesType } from &apos;@/hooks/Mapper/mapRootProvider/types.ts&apos;;
import { RoutesList } from &apos;@/hooks/Mapper/types/routes.ts&apos;;

export type LoadRoutesCommand = (systemId: string, routesSettings: RoutesType) =&gt; Promise&lt;void&gt;;
export type AddHubCommand = (systemId: string) =&gt; Promise&lt;void&gt;;
export type ToggleHubCommand = (systemId: string) =&gt; Promise&lt;void&gt;;

export type RoutesWidgetProps = {
  data: RoutesType;
  update: (d: RoutesType) =&gt; void;
  hubs: string[];
  routesList: RoutesList | undefined;

  loadRoutesCommand: LoadRoutesCommand;
  addHubCommand: AddHubCommand;
  toggleHubCommand: ToggleHubCommand;
  isRestricted?: boolean;
};

export type RoutesProviderInnerProps = RoutesWidgetProps &amp; {
  loading: boolean;
  setLoading(loading: boolean): void;
};

export type RoutesImperativeHandle = {
  stopLoading: () =&gt; void;
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemInfo/SystemInfoContent/index.ts">export * from &apos;./SystemInfoContent&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemInfo/SystemInfoContent/SystemInfoContent.module.scss">.SmallText {
  font-size: 10px;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemInfo/SystemInfoContent/SystemInfoContent.tsx">import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { isWormholeSpace } from &apos;@/hooks/Mapper/components/map/helpers/isWormholeSpace.ts&apos;;
import { useMemo } from &apos;react&apos;;
import { getSystemById, sortWHClasses } from &apos;@/hooks/Mapper/helpers&apos;;
import { InfoDrawer, WHClassView, WHEffectView } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { getSystemStaticInfo } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic&apos;;

interface SystemInfoContentProps {
  systemId: string;
  onEditClick?(): void;
}
export const SystemInfoContent = ({ systemId }: SystemInfoContentProps) =&gt; {
  const {
    data: { systems, wormholesData },
  } = useMapRootState();

  const sys = getSystemById(systems, systemId)! || {};
  const systemStaticInfo = getSystemStaticInfo(systemId)!;
  const { description } = sys;
  const { system_class, region_name, constellation_name, statics, effect_name, effect_power } = systemStaticInfo || {};
  const isWH = isWormholeSpace(system_class);
  const sortedStatics = useMemo(() =&gt; sortWHClasses(wormholesData, statics), [wormholesData, statics]);

  return (
    &lt;div className=&quot;flex flex-col gap-1 p-2&quot;&gt;
      &lt;InfoDrawer title=&quot;Constellation &amp; Region&quot;&gt;
        {constellation_name} / {region_name}
      &lt;/InfoDrawer&gt;

      {isWH &amp;&amp; (
        &lt;InfoDrawer title=&quot;Statics&quot;&gt;
          &lt;div className=&quot;flex gap-1&quot;&gt;
            {sortedStatics.map(x =&gt; (
              &lt;WHClassView key={x} whClassName={x} /&gt;
            ))}
          &lt;/div&gt;
        &lt;/InfoDrawer&gt;
      )}

      {isWH &amp;&amp; effect_name &amp;&amp; (
        &lt;InfoDrawer title=&quot;Effect&quot;&gt;
          &lt;WHEffectView effectName={effect_name} effectPower={effect_power} /&gt;
        &lt;/InfoDrawer&gt;
      )}

      {description &amp;&amp; (
        &lt;InfoDrawer
          title={
            &lt;div className=&quot;flex gap-1 items-center&quot;&gt;
              &lt;div&gt;Description&lt;/div&gt;
            &lt;/div&gt;
          }
        &gt;
          &lt;div className=&quot;break-words&quot;&gt;{description}&lt;/div&gt;
        &lt;/InfoDrawer&gt;
      )}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemInfo/index.ts">export * from &apos;./SystemInfo.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemInfo/SystemInfo.module.scss">.VirtualScroller {
  height: 100% !important;
}

.CharacterRow {
  //border-left-width: 1px;

  &amp;.CardBorderLeftIsOwn {
    border-left-color: rgb(251 146 60 / 1)
  }
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemInfo/SystemInfo.tsx">import { Widget } from &apos;@/hooks/Mapper/components/mapInterface/components&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { LayoutEventBlocker, SystemView, TooltipPosition, WdImgButton } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { SystemInfoContent } from &apos;./SystemInfoContent&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { useCallback, useState } from &apos;react&apos;;
import { SystemSettingsDialog } from &apos;@/hooks/Mapper/components/mapInterface/components/SystemSettingsDialog/SystemSettingsDialog.tsx&apos;;
import { ANOIK_ICON, DOTLAN_ICON, ZKB_ICON } from &apos;@/hooks/Mapper/icons&apos;;
import { getSystemStaticInfo } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic&apos;;

export const SystemInfo = () =&gt; {
  const [visible, setVisible] = useState(false);

  const {
    data: { selectedSystems },
  } = useMapRootState();

  const [systemId] = selectedSystems;

  const systemStaticInfo = getSystemStaticInfo(systemId)!;
  const { solar_system_name: solarSystemName } = systemStaticInfo || {};

  const isNotSelectedSystem = selectedSystems.length !== 1;

  const copySystemNameToClipboard = useCallback(async () =&gt; {
    try {
      await navigator.clipboard.writeText(solarSystemName);
    } catch (err) {
      console.error(err);
    }
  }, [solarSystemName]);

  return (
    &lt;Widget
      label={
        !isNotSelectedSystem &amp;&amp; (
          &lt;div className=&quot;flex justify-between items-center text-xs h-full w-full&quot;&gt;
            &lt;div className=&quot;flex gap-1&quot;&gt;
              &lt;SystemView systemId={systemId} className=&quot;select-none text-center&quot; hideRegion /&gt;
              &lt;LayoutEventBlocker className=&quot;flex gap-1 items-center&quot;&gt;
                &lt;WdImgButton className={PrimeIcons.COPY} onClick={copySystemNameToClipboard} /&gt;
                &lt;WdImgButton
                  className=&quot;pi pi-pen-to-square&quot;
                  onClick={() =&gt; setVisible(true)}
                  tooltip={{ position: TooltipPosition.top, content: &apos;Edit system name and description&apos; }}
                /&gt;
              &lt;/LayoutEventBlocker&gt;
            &lt;/div&gt;

            &lt;LayoutEventBlocker className=&quot;flex gap-1 items-center&quot;&gt;
              &lt;a href={`https://zkillboard.com/system/${systemId}`} rel=&quot;noreferrer&quot; target=&quot;_blank&quot;&gt;
                &lt;img src={ZKB_ICON} width=&quot;14&quot; height=&quot;14&quot; className=&quot;external-icon&quot; /&gt;
              &lt;/a&gt;
              &lt;a href={`http://anoik.is/systems/${solarSystemName}`} rel=&quot;noreferrer&quot; target=&quot;_blank&quot;&gt;
                &lt;img src={ANOIK_ICON} width=&quot;14&quot; height=&quot;14&quot; className=&quot;external-icon&quot; /&gt;
              &lt;/a&gt;
              &lt;a href={`https://evemaps.dotlan.net/system/${solarSystemName}`} rel=&quot;noreferrer&quot; target=&quot;_blank&quot;&gt;
                &lt;img src={DOTLAN_ICON} alt=&quot;&quot; width=&quot;14&quot; height=&quot;14&quot; className=&quot;external-icon&quot; /&gt;
              &lt;/a&gt;
            &lt;/LayoutEventBlocker&gt;
          &lt;/div&gt;
        )
      }
    &gt;
      {isNotSelectedSystem ? (
        &lt;div className=&quot;w-full h-full flex justify-center items-center select-none text-center text-stone-400/80 text-sm&quot;&gt;
          System is not selected
        &lt;/div&gt;
      ) : (
        &lt;SystemInfoContent systemId={systemId} onEditClick={() =&gt; setVisible(true)} /&gt;
      )}

      {visible &amp;&amp; &lt;SystemSettingsDialog systemId={systemId} visible setVisible={setVisible} /&gt;}
    &lt;/Widget&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/helpers/contentHelpers.ts">import { ExtendedSystemSignature, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { FINAL_DURATION_MS } from &apos;../constants&apos;;

export function prepareUpdatePayload(
  systemId: string,
  added: ExtendedSystemSignature[],
  updated: ExtendedSystemSignature[],
  removed: ExtendedSystemSignature[],
) {
  return {
    system_id: systemId,
    added: added.map(s =&gt; ({ ...s })),
    updated: updated.map(s =&gt; ({ ...s })),
    removed: removed.map(s =&gt; ({ ...s })),
  };
}

export function schedulePendingAdditionForSig(
  sig: ExtendedSystemSignature,
  finalDuration: number,
  setSignatures: React.Dispatch&lt;React.SetStateAction&lt;ExtendedSystemSignature[]&gt;&gt;,
  pendingAdditionMapRef: React.MutableRefObject&lt;Record&lt;string, { finalUntil: number; finalTimeoutId: number }&gt;&gt;,
  setPendingUndoAdditions: React.Dispatch&lt;React.SetStateAction&lt;ExtendedSystemSignature[]&gt;&gt;,
) {
  setPendingUndoAdditions(prev =&gt; [...prev, sig]);

  const now = Date.now();
  const finalTimeoutId = window.setTimeout(() =&gt; {
    setSignatures(prev =&gt;
      prev.map(x =&gt; (x.eve_id === sig.eve_id ? { ...x, pendingAddition: false, pendingUntil: undefined } : x)),
    );
    const clone = { ...pendingAdditionMapRef.current };
    delete clone[sig.eve_id];
    pendingAdditionMapRef.current = clone;

    setPendingUndoAdditions(prev =&gt; prev.filter(x =&gt; x.eve_id !== sig.eve_id));
  }, finalDuration);

  pendingAdditionMapRef.current = {
    ...pendingAdditionMapRef.current,
    [sig.eve_id]: {
      finalUntil: now + finalDuration,
      finalTimeoutId,
    },
  };

  setSignatures(prev =&gt;
    prev.map(x =&gt; (x.eve_id === sig.eve_id ? { ...x, pendingAddition: true, pendingUntil: now + finalDuration } : x)),
  );
}

export function mergeLocalPending(
  pendingMapRef: React.MutableRefObject&lt;Record&lt;string, ExtendedSystemSignature&gt;&gt;,
  serverSigs: ExtendedSystemSignature[],
): ExtendedSystemSignature[] {
  const now = Date.now();
  const pendingDeletions = Object.values(pendingMapRef.current).filter(
    sig =&gt; sig.pendingDeletion &amp;&amp; sig.pendingUntil &amp;&amp; sig.pendingUntil &gt; now,
  );
  const mergedMap = new Map&lt;string, ExtendedSystemSignature&gt;();
  serverSigs.forEach(sig =&gt; mergedMap.set(sig.eve_id, sig));

  pendingDeletions.forEach(sig =&gt; {
    if (mergedMap.has(sig.eve_id)) {
      mergedMap.set(sig.eve_id, sig);
    }
  });
  return Array.from(mergedMap.values());
}

export function scheduleLazyTimers(
  signatures: ExtendedSystemSignature[],
  pendingMapRef: React.MutableRefObject&lt;Record&lt;string, ExtendedSystemSignature&gt;&gt;,
  finalizeFn: (sig: ExtendedSystemSignature) =&gt; Promise&lt;void&gt;,
  finalDuration = FINAL_DURATION_MS,
) {
  signatures.forEach(sig =&gt; {
    const finalTimeoutId = window.setTimeout(async () =&gt; {
      await finalizeFn(sig);
    }, finalDuration);

    pendingMapRef.current = {
      ...pendingMapRef.current,
      [sig.eve_id]: {
        ...sig,
        finalTimeoutId,
      },
    };
  });
}

export const calculateTimeRemaining = (pendingSigs: SystemSignature[]) =&gt; {
  const now = Date.now();
  let minTime: number | undefined = undefined;

  pendingSigs.forEach(sig =&gt; {
    const extendedSig = sig as unknown as { pendingUntil?: number };
    if (extendedSig.pendingUntil &amp;&amp; (minTime === undefined || extendedSig.pendingUntil - now &lt; minTime)) {
      minTime = extendedSig.pendingUntil - now;
    }
  });

  return minTime &amp;&amp; minTime &gt; 0 ? minTime : undefined;
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/helpers/getActualSigs.ts">import { GROUPS_LIST } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants&apos;;
import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { getState } from &apos;./getState&apos;;

/**
 * Compare two lists of signatures and return which are added, updated, or removed.
 *
 * @param oldSignatures existing signatures (in memory or from server)
 * @param newSignatures newly parsed or incoming signatures from user input
 * @param updateOnly    if true, do NOT remove old signatures not found in newSignatures
 * @param skipUpdateUntouched if true, do NOT push unmodified signatures into the `updated` array
 */
export const getActualSigs = (
  oldSignatures: SystemSignature[],
  newSignatures: SystemSignature[],
  updateOnly?: boolean,
  skipUpdateUntouched?: boolean,
): { added: SystemSignature[]; updated: SystemSignature[]; removed: SystemSignature[] } =&gt; {
  const updated: SystemSignature[] = [];
  const removed: SystemSignature[] = [];
  const added: SystemSignature[] = [];

  oldSignatures.forEach(oldSig =&gt; {
    const newSig = newSignatures.find(s =&gt; s.eve_id === oldSig.eve_id);

    if (newSig) {
      const needUpgrade = getState(GROUPS_LIST, newSig) &gt; getState(GROUPS_LIST, oldSig);
      const mergedSig = { ...oldSig };
      let changed = false;

      if (needUpgrade) {
        mergedSig.group = newSig.group;
        mergedSig.name = newSig.name;
        changed = true;
      }
      if (newSig.description &amp;&amp; newSig.description !== oldSig.description) {
        mergedSig.description = newSig.description;
        changed = true;
      }

      try {
        const oldInfo = JSON.parse(oldSig.custom_info || &apos;{}&apos;);
        const newInfo = JSON.parse(newSig.custom_info || &apos;{}&apos;);
        let infoChanged = false;
        for (const key in newInfo) {
          if (oldInfo[key] !== newInfo[key]) {
            oldInfo[key] = newInfo[key];
            infoChanged = true;
          }
        }
        if (infoChanged) {
          mergedSig.custom_info = JSON.stringify(oldInfo);
          changed = true;
        }
      } catch (e) {
        console.error(`getActualSigs: Error merging custom_info for ${oldSig.eve_id}`, e);
      }

      if (newSig.updated_at !== oldSig.updated_at) {
        mergedSig.updated_at = newSig.updated_at;
        changed = true;
      }

      if (changed) {
        updated.push(mergedSig);
      } else if (!skipUpdateUntouched) {
        updated.push({ ...oldSig });
      }
    } else {
      if (!updateOnly) {
        removed.push(oldSig);
      }
    }
  });

  const oldIds = new Set(oldSignatures.map(x =&gt; x.eve_id));
  newSignatures.forEach(s =&gt; {
    if (!oldIds.has(s.eve_id)) {
      added.push(s);
    }
  });

  return { added, updated, removed };
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/helpers/getRowBackgroundColor.ts">import {
  TIME_ONE_MINUTE,
  TIME_TEN_MINUTES,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts&apos;;

export const getRowBackgroundColor = (date: Date | undefined): string =&gt; {
  if (!date) {
    return &apos;&apos;;
  }

  const currentDate = new Date();
  const diff = currentDate.getTime() + currentDate.getTimezoneOffset() * TIME_ONE_MINUTE - date.getTime();

  if (diff &lt; TIME_ONE_MINUTE) {
    return &apos;[&amp;_.ssc-header]:text-amber-300 [&amp;_.ssc-header]:hover:text-amber-200 [&amp;_.ssc-header]:font-bold&apos;;
  }

  if (diff &lt; TIME_TEN_MINUTES) {
    return &apos;[&amp;_.ssc-header]:text-amber-500 [&amp;_.ssc-header]:hover:text-amber-500 [&amp;_.ssc-header]:font-bold&apos;;
  }

  return &apos;&apos;;
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/helpers/getState.ts">import { UNKNOWN_SIGNATURE_NAME } from &apos;@/hooks/Mapper/helpers&apos;;
import { SignatureGroup, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;

export const getState = (_: string[], newSig: SystemSignature) =&gt; {
  let state = -1;
  if (!newSig.group || newSig.group === SignatureGroup.CosmicSignature) {
    state = 0;
  } else if (!newSig.name || newSig.name === &apos;&apos; || newSig.name === UNKNOWN_SIGNATURE_NAME) {
    state = 1;
  } else if (newSig.name !== &apos;&apos;) {
    state = 2;
  }

  return state;
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/helpers/index.ts">export * from &apos;./getState&apos;;
export * from &apos;./getRowBackgroundColor&apos;;
export * from &apos;./getActualSigs&apos;;
export * from &apos;./contentHelpers&apos;;
export * from &apos;./rowStyles&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/helpers/rowStyles.module.scss">.TableRowCompact {
  font-size: 12px !important;
  line-height: 1.333;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/helpers/rowStyles.ts">import clsx from &apos;clsx&apos;;
import { ExtendedSystemSignature, SignatureGroup } from &apos;@/hooks/Mapper/types&apos;;
import { getRowBackgroundColor } from &apos;./getRowBackgroundColor&apos;;
import classes from &apos;./rowStyles.module.scss&apos;;

export function getSignatureRowClass(
  row: ExtendedSystemSignature,
  selectedSignatures: ExtendedSystemSignature[],
  colorByType?: boolean,
): string {
  const isSelected = selectedSignatures.some(s =&gt; s.eve_id === row.eve_id);

  const baseCls = [
    classes.TableRowCompact,
    getRowBackgroundColor(row.inserted_at ? new Date(row.inserted_at) : undefined),
    &apos;transition duration-200 my-2 hover:bg-purple-400/20&apos;,
  ];

  if (isSelected) {
    return clsx([...baseCls, &apos;bg-violet-400/40 hover:bg-violet-300/40&apos;]);
  }

  if (row.pendingDeletion) {
    return clsx([...baseCls, &apos;bg-red-400/40 hover:bg-red-400/50&apos;]);
  }

  // Apply color by type styling if enabled
  if (colorByType) {
    switch (row.group) {
      case SignatureGroup.CosmicSignature:
        return clsx([...baseCls, &apos;[&amp;_td:nth-child(-n+3)]:text-rose-400 [&amp;_td:nth-child(-n+3)]:hover:text-rose-300&apos;]);
      case SignatureGroup.Wormhole:
        return clsx([...baseCls, &apos;[&amp;_td:nth-child(-n+3)]:text-sky-300 [&amp;_td:nth-child(-n+3)]:hover:text-sky-200&apos;]);
      case SignatureGroup.CombatSite:
      case SignatureGroup.RelicSite:
      case SignatureGroup.DataSite:
      case SignatureGroup.GasSite:
      case SignatureGroup.OreSite:
        return clsx([...baseCls, &apos;[&amp;_td:nth-child(-n+4)]:text-lime-400 [&amp;_td:nth-child(-n+4)]:hover:text-lime-300&apos;]);
    }

    // Default for color by type - apply same color as CosmicSignature (red) and small text size
    return clsx([...baseCls, &apos;[&amp;_td:nth-child(-n+3)]:text-rose-400/100&apos;]);
  }

  // Original styling when color by type is disabled
  return clsx(...baseCls);
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/hooks/types.ts">import { SignatureSettingsType } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts&apos;;
import { ExtendedSystemSignature } from &apos;@/hooks/Mapper/types&apos;;

export interface UseSystemSignaturesDataProps {
  systemId: string;
  settings: SignatureSettingsType;
  hideLinkedSignatures?: boolean;
  onCountChange?: (count: number) =&gt; void;
  onPendingChange?: (
    pending: React.MutableRefObject&lt;Record&lt;string, ExtendedSystemSignature&gt;&gt;,
    undo: () =&gt; void,
  ) =&gt; void;
  onLazyDeleteChange?: (value: boolean) =&gt; void;
  deletionTiming?: number;
}

export interface UseFetchingParams {
  systemId: string;
  signaturesRef: React.MutableRefObject&lt;ExtendedSystemSignature[]&gt;;
  setSignatures: React.Dispatch&lt;React.SetStateAction&lt;ExtendedSystemSignature[]&gt;&gt;;
  pendingDeletionMapRef: React.MutableRefObject&lt;Record&lt;string, ExtendedSystemSignature&gt;&gt;;
}

export interface UsePendingDeletionParams {
  systemId: string;
  deletionTiming?: number;
  setSignatures: React.Dispatch&lt;React.SetStateAction&lt;ExtendedSystemSignature[]&gt;&gt;;
  onPendingChange?: (
    pending: React.MutableRefObject&lt;Record&lt;string, ExtendedSystemSignature&gt;&gt;,
    undo: () =&gt; void,
  ) =&gt; void;
}

export interface UsePendingAdditionParams {
  systemId: string;
  setSignatures: React.Dispatch&lt;React.SetStateAction&lt;ExtendedSystemSignature[]&gt;&gt;;
  deletionTiming?: number;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/hooks/usePendingDeletions.ts">import { useCallback, useRef } from &apos;react&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers&apos;;
import { prepareUpdatePayload } from &apos;../helpers&apos;;
import { UsePendingDeletionParams } from &apos;./types&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { ExtendedSystemSignature } from &apos;@/hooks/Mapper/types&apos;;

export function usePendingDeletions({
  systemId,
  setSignatures,
  onPendingChange,
}: Omit&lt;UsePendingDeletionParams, &apos;deletionTiming&apos;&gt;) {
  const { outCommand } = useMapRootState();
  const pendingDeletionMapRef = useRef&lt;Record&lt;string, ExtendedSystemSignature&gt;&gt;({});

  const processRemovedSignatures = useCallback(
    async (
      removed: ExtendedSystemSignature[],
      added: ExtendedSystemSignature[],
      updated: ExtendedSystemSignature[],
    ) =&gt; {
      if (!removed.length) return;
      await outCommand({
        type: OutCommand.updateSignatures,
        data: prepareUpdatePayload(systemId, added, updated, removed),
      });
    },
    [systemId, outCommand],
  );

  const clearPendingDeletions = useCallback(() =&gt; {
    pendingDeletionMapRef.current = {};
    setSignatures(prev =&gt; prev.map(x =&gt; (x.pendingDeletion ? { ...x, pendingDeletion: false } : x)));
    onPendingChange?.(pendingDeletionMapRef, clearPendingDeletions);
  }, []);

  return {
    pendingDeletionMapRef,
    processRemovedSignatures,
    clearPendingDeletions,
  };
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/hooks/useSignatureFetching.ts">import { useCallback } from &apos;react&apos;;
import { ExtendedSystemSignature, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers&apos;;
import { prepareUpdatePayload, getActualSigs, mergeLocalPending } from &apos;../helpers&apos;;
import { UseFetchingParams } from &apos;./types&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

export const useSignatureFetching = ({
  systemId,
  signaturesRef,
  setSignatures,
  pendingDeletionMapRef,
}: UseFetchingParams) =&gt; {
  const {
    data: { characters },
    outCommand,
  } = useMapRootState();

  const handleGetSignatures = useCallback(async () =&gt; {
    if (!systemId) {
      setSignatures([]);
      return;
    }
    const resp = await outCommand({
      type: OutCommand.getSignatures,
      data: { system_id: systemId },
    });
    const serverSigs = (resp.signatures ?? []) as SystemSignature[];

    const extended = serverSigs.map(s =&gt; ({
      ...s,
      character_name: characters.find(c =&gt; c.eve_id === s.character_eve_id)?.name,
    })) as ExtendedSystemSignature[];

    setSignatures(() =&gt; mergeLocalPending(pendingDeletionMapRef, extended));
  }, [characters, systemId, outCommand]);

  const handleUpdateSignatures = useCallback(
    async (newList: ExtendedSystemSignature[], updateOnly: boolean, skipUpdateUntouched?: boolean) =&gt; {
      const { added, updated, removed } = getActualSigs(
        signaturesRef.current,
        newList,
        updateOnly,
        skipUpdateUntouched,
      );

      await outCommand({
        type: OutCommand.updateSignatures,
        data: prepareUpdatePayload(systemId, added, updated, removed),
      });
    },
    [systemId, outCommand, signaturesRef],
  );

  return {
    handleGetSignatures,
    handleUpdateSignatures,
  };
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/hooks/useSystemSignaturesData.ts">import { useMapEventListener } from &apos;@/hooks/Mapper/events&apos;;
import { parseSignatures } from &apos;@/hooks/Mapper/helpers&apos;;
import { Commands, ExtendedSystemSignature, SignatureKind } from &apos;@/hooks/Mapper/types&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers&apos;;
import { useCallback, useEffect, useState } from &apos;react&apos;;
import useRefState from &apos;react-usestateref&apos;;

import { SETTINGS_KEYS } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { getActualSigs } from &apos;../helpers&apos;;
import { UseSystemSignaturesDataProps } from &apos;./types&apos;;
import { usePendingDeletions } from &apos;./usePendingDeletions&apos;;
import { useSignatureFetching } from &apos;./useSignatureFetching&apos;;

export const useSystemSignaturesData = ({
  systemId,
  settings,
  onCountChange,
  onPendingChange,
  onLazyDeleteChange,
  onSignatureDeleted,
}: Omit&lt;UseSystemSignaturesDataProps, &apos;deletionTiming&apos;&gt; &amp; {
  onSignatureDeleted?: (deletedIds: string[]) =&gt; void;
}) =&gt; {
  const { outCommand } = useMapRootState();
  const [signatures, setSignatures, signaturesRef] = useRefState&lt;ExtendedSystemSignature[]&gt;([]);
  const [selectedSignatures, setSelectedSignatures] = useState&lt;ExtendedSystemSignature[]&gt;([]);
  const [hasUnsupportedLanguage, setHasUnsupportedLanguage] = useState&lt;boolean&gt;(false);

  const { pendingDeletionMapRef, processRemovedSignatures, clearPendingDeletions } = usePendingDeletions({
    systemId,
    setSignatures,
    onPendingChange,
  });

  const { handleGetSignatures, handleUpdateSignatures } = useSignatureFetching({
    systemId,
    signaturesRef,
    setSignatures,
    pendingDeletionMapRef,
  });

  const handlePaste = useCallback(
    async (clipboardString: string) =&gt; {
      const lazyDeleteValue = settings[SETTINGS_KEYS.LAZY_DELETE_SIGNATURES] as boolean;

      // Parse the incoming signatures
      const incomingSignatures = parseSignatures(
        clipboardString,
        Object.keys(settings).filter(skey =&gt; skey in SignatureKind),
      ) as ExtendedSystemSignature[];

      if (incomingSignatures.length === 0) {
        return;
      }

      // Check if any signatures might be using unsupported languages
      // This is a basic heuristic: if we have signatures where the original group wasn&apos;t mapped
      const clipboardRows = clipboardString.split(&apos;\n&apos;).filter(row =&gt; row.trim() !== &apos;&apos;);
      const detectedSignatureCount = clipboardRows.filter(row =&gt; row.match(/^[A-Z]{3}-\d{3}/)).length;

      // If we detected valid IDs but got fewer parsed signatures, we might have language issues
      if (detectedSignatureCount &gt; 0 &amp;&amp; incomingSignatures.length &lt; detectedSignatureCount) {
        setHasUnsupportedLanguage(true);
      } else {
        setHasUnsupportedLanguage(false);
      }

      const currentNonPending = lazyDeleteValue
        ? signaturesRef.current.filter(sig =&gt; !sig.pendingDeletion)
        : signaturesRef.current.filter(sig =&gt; !sig.pendingDeletion || !sig.pendingAddition);

      const { added, updated, removed } = getActualSigs(currentNonPending, incomingSignatures, !lazyDeleteValue, false);

      if (removed.length &gt; 0) {
        await processRemovedSignatures(removed, added, updated);
        if (onSignatureDeleted) {
          const deletedIds = removed.map(sig =&gt; sig.eve_id);
          onSignatureDeleted(deletedIds);
        }
      }

      if (updated.length !== 0 || added.length !== 0) {
        await outCommand({
          type: OutCommand.updateSignatures,
          data: {
            system_id: systemId,
            added,
            updated,
            removed: [],
          },
        });
      }

      const keepLazy = settings[SETTINGS_KEYS.KEEP_LAZY_DELETE] as boolean;
      if (lazyDeleteValue &amp;&amp; !keepLazy) {
        onLazyDeleteChange?.(false);
      }
    },
    [settings, signaturesRef, processRemovedSignatures, outCommand, systemId, onLazyDeleteChange, onSignatureDeleted],
  );

  const handleDeleteSelected = useCallback(async () =&gt; {
    if (!selectedSignatures.length) return;
    const selectedIds = selectedSignatures.map(s =&gt; s.eve_id);
    const finalList = signatures.filter(s =&gt; !selectedIds.includes(s.eve_id));
    await handleUpdateSignatures(finalList, false, true);
    setSelectedSignatures([]);
  }, [handleUpdateSignatures, selectedSignatures, signatures]);

  const handleSelectAll = useCallback(() =&gt; {
    setSelectedSignatures(signatures);
  }, [signatures]);

  const undoPending = useCallback(() =&gt; {
    clearPendingDeletions();
  }, [clearPendingDeletions]);

  useMapEventListener(event =&gt; {
    if (event.name === Commands.signaturesUpdated &amp;&amp; String(event.data) === String(systemId)) {
      handleGetSignatures();
      return true;
    }
  });

  useEffect(() =&gt; {
    if (!systemId) {
      setSignatures([]);
      undoPending();
      return;
    }
    handleGetSignatures();
  }, [systemId]);

  useEffect(() =&gt; {
    onCountChange?.(signatures.length);
  }, [signatures]);

  return {
    signatures: signatures.filter(sig =&gt; !sig.deleted),
    selectedSignatures,
    setSelectedSignatures,
    handleDeleteSelected,
    handleSelectAll,
    handlePaste,
    hasUnsupportedLanguage,
  };
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders/index.ts">export * from &apos;./renderIcon&apos;;
export * from &apos;./renderDescription&apos;;
export * from &apos;./renderName&apos;;
export * from &apos;./renderAddedTimeLeft&apos;;
export * from &apos;./renderUpdatedTimeLeft&apos;;
export * from &apos;./renderLinkedSystem&apos;;
export * from &apos;./renderInfoColumn&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders/renderAddedTimeLeft.tsx">import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { TimeLeft } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

export const renderAddedTimeLeft = (row: SystemSignature) =&gt; {
  return (
    &lt;div className=&quot;flex w-full items-center&quot;&gt;
      &lt;TimeLeft cDate={row.inserted_at ? new Date(row.inserted_at) : undefined} /&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders/renderDescription.tsx">import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;

export const renderDescription = (row: SystemSignature) =&gt; {
  return &lt;span title={row?.description}&gt;{row?.description}&lt;/span&gt;;
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders/renderIcon.tsx">import { GroupType, SignatureGroup, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { GROUPS } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts&apos;;

export const renderIcon = (row: SystemSignature, customSize?: Omit&lt;GroupType, &apos;icon&apos; | &apos;id&apos;&gt;) =&gt; {
  if (row.group == null) {
    return null;
  }

  const group = GROUPS[row.group as SignatureGroup];
  if (!group) {
    return null;
  }

  return (
    &lt;div className=&quot;flex justify-center items-center&quot;&gt;
      &lt;img src={group.icon} style={{ width: customSize?.w ?? group.w, height: customSize?.h ?? group.h }} /&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders/renderInfoColumn.tsx">import { PrimeIcons } from &apos;primereact/api&apos;;
import { SignatureGroup, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { SystemViewStandalone, TooltipPosition, WHClassView } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

import { renderK162Type } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureK162TypeSelect&apos;;
import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;

import clsx from &apos;clsx&apos;;
import { renderName } from &apos;./renderName.tsx&apos;;
import { K162_TYPES_MAP } from &apos;@/hooks/Mapper/constants.ts&apos;;
import { parseSignatureCustomInfo } from &apos;@/hooks/Mapper/helpers/parseSignatureCustomInfo.ts&apos;;

export const renderInfoColumn = (row: SystemSignature) =&gt; {
  if (!row.group || row.group === SignatureGroup.Wormhole) {
    const customInfo = parseSignatureCustomInfo(row.custom_info);

    const k162TypeOption = customInfo.k162Type ? K162_TYPES_MAP[customInfo.k162Type] : null;

    return (
      &lt;div className=&quot;flex justify-start items-center gap-[4px]&quot;&gt;
        {customInfo.isEOL &amp;&amp; (
          &lt;WdTooltipWrapper offset={5} position={TooltipPosition.top} content=&quot;Signature marked as EOL&quot;&gt;
            &lt;div className=&quot;pi pi-clock text-fuchsia-400 text-[11px] mr-[2px]&quot;&gt;&lt;/div&gt;
          &lt;/WdTooltipWrapper&gt;
        )}

        {customInfo.isCrit &amp;&amp; (
          &lt;WdTooltipWrapper offset={5} position={TooltipPosition.top} content=&quot;Signature marked as Crit&quot;&gt;
            &lt;div className=&quot;pi pi-clock text-fuchsia-400 text-[11px] mr-[2px]&quot;&gt;&lt;/div&gt;
          &lt;/WdTooltipWrapper&gt;
        )}

        {row.type &amp;&amp; (
          &lt;WHClassView
            className=&quot;text-[11px]&quot;
            classNameWh=&quot;!text-[11px] !font-bold&quot;
            hideWhClass={!!row.linked_system}
            whClassName={row.type}
            noOffset
            useShortTitle
          /&gt;
        )}

        {!row.linked_system &amp;&amp; row.type === &apos;K162&apos; &amp;&amp; k162TypeOption &amp;&amp; renderK162Type(k162TypeOption)}

        {row.linked_system &amp;&amp; (
          &lt;&gt;
            &lt;span title={row.linked_system?.solar_system_name}&gt;
              &lt;SystemViewStandalone
                className={clsx(&apos;select-none text-center cursor-context-menu&apos;)}
                hideRegion
                {...row.linked_system}
              /&gt;
            &lt;/span&gt;
          &lt;/&gt;
        )}
        {row.description &amp;&amp; (
          &lt;WdTooltipWrapper content={row.description}&gt;
            &lt;span className={clsx(PrimeIcons.EXCLAMATION_CIRCLE, &apos;text-[12px]&apos;)}&gt;&lt;/span&gt;
          &lt;/WdTooltipWrapper&gt;
        )}
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className=&quot;flex gap-1 items-center&quot;&gt;
      {renderName(row)}{&apos; &apos;}
      {row.description &amp;&amp; (
        &lt;WdTooltipWrapper content={row.description}&gt;
          &lt;span className={clsx(PrimeIcons.EXCLAMATION_CIRCLE, &apos;text-[12px]&apos;)}&gt;&lt;/span&gt;
        &lt;/WdTooltipWrapper&gt;
      )}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders/renderLinkedSystem.tsx">import clsx from &apos;clsx&apos;;

import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { SystemViewStandalone } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

export const renderLinkedSystem = (row: SystemSignature) =&gt; {
  if (!row.linked_system) {
    return null;
  }

  return (
    &lt;span title={row.linked_system?.solar_system_name}&gt;
      &lt;SystemViewStandalone
        className={clsx(&apos;select-none text-center cursor-context-menu&apos;)}
        hideRegion
        {...row.linked_system}
      /&gt;
    &lt;/span&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders/renderName.tsx">import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;

export const renderName = (row: SystemSignature) =&gt; {
  return &lt;span title={row.name}&gt;{row.name}&lt;/span&gt;;
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders/renderUpdatedTimeLeft.tsx">import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { TimeLeft } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

export const renderUpdatedTimeLeft = (row: SystemSignature) =&gt; {
  return (
    &lt;div className=&quot;flex w-full items-center&quot;&gt;
      &lt;TimeLeft cDate={row.updated_at ? new Date(row.updated_at) : undefined} /&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SignatureView/index.ts">export * from &apos;./SignatureView&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SignatureView/SignatureView.tsx">import { SignatureGroup, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { renderIcon } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders&apos;;
import { getCharacterPortraitUrl } from &apos;@/hooks/Mapper/helpers&apos;;

export interface SignatureViewProps {
  signature: SystemSignature;
  showCharacterPortrait?: boolean;
}

export const SignatureView = ({ signature, showCharacterPortrait = false }: SignatureViewProps) =&gt; {
  const isWormhole = signature?.group === SignatureGroup.Wormhole;
  const hasCharacterInfo = showCharacterPortrait &amp;&amp; signature.character_eve_id;
  const groupDisplay = isWormhole ? SignatureGroup.Wormhole : signature?.group ?? SignatureGroup.CosmicSignature;
  const characterName = signature.character_name || &apos;Unknown character&apos;;

  return (
    &lt;div className=&quot;flex flex-col gap-2&quot;&gt;
      &lt;div className=&quot;flex gap-2 items-center px-2&quot;&gt;
        {renderIcon(signature)}
        &lt;div&gt;{signature?.eve_id}&lt;/div&gt;
        &lt;div&gt;{groupDisplay}&lt;/div&gt;
        {!isWormhole &amp;&amp; &lt;div&gt;{signature?.name}&lt;/div&gt;}
        {hasCharacterInfo &amp;&amp; (
          &lt;div className=&quot;flex items-center gap-1 ml-2 pl-2 border-l border-stone-700&quot;&gt;
            &lt;img
              src={getCharacterPortraitUrl(signature.character_eve_id)}
              alt={characterName}
              className=&quot;w-5 h-5 rounded-sm border border-stone-700&quot;
            /&gt;
            &lt;div className=&quot;text-xs text-stone-300&quot;&gt;{characterName}&lt;/div&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SystemSignatureHeader/index.ts">export * from &apos;./SystemSignatureHeader&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SystemSignatureHeader/SystemSignatureHeader.tsx">import { useRef } from &apos;react&apos;;
import {
  InfoDrawer,
  LayoutEventBlocker,
  SystemView,
  TooltipPosition,
  WdCheckbox,
  WdImgButton,
} from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { CheckboxChangeEvent } from &apos;primereact/checkbox&apos;;
import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;
import useMaxWidth from &apos;@/hooks/Mapper/hooks/useMaxWidth.ts&apos;;
import { COMPACT_MAX_WIDTH } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

export type HeaderProps = {
  sigCount: number;
  lazyDeleteValue: boolean;
  onLazyDeleteChange: (checked: boolean) =&gt; void;
  pendingCount: number;
  undoCountdown?: number;
  onUndoClick: () =&gt; void;
  onSettingsClick: () =&gt; void;
};

export const SystemSignaturesHeader = ({
  sigCount,
  lazyDeleteValue,
  onLazyDeleteChange,
  pendingCount,
  undoCountdown,
  onUndoClick,
  onSettingsClick,
}: HeaderProps) =&gt; {
  const {
    data: { selectedSystems },
  } = useMapRootState();

  const [systemId] = selectedSystems;
  const isNotSelectedSystem = selectedSystems.length !== 1;

  const containerRef = useRef&lt;HTMLDivElement&gt;(null);
  const isCompact = useMaxWidth(containerRef, COMPACT_MAX_WIDTH);

  return (
    &lt;div ref={containerRef} className=&quot;w-full&quot;&gt;
      &lt;div className=&quot;flex justify-between items-center text-xs w-full h-full&quot;&gt;
        &lt;div className=&quot;flex justify-between items-center gap-1&quot;&gt;
          {!isCompact &amp;&amp; (
            &lt;div className=&quot;flex whitespace-nowrap text-ellipsis overflow-hidden text-stone-400&quot;&gt;
              {sigCount ? `[${sigCount}] ` : &apos;&apos;}Signatures {isNotSelectedSystem ? &apos;&apos; : &apos;in&apos;}
            &lt;/div&gt;
          )}
          {!isNotSelectedSystem &amp;&amp; &lt;SystemView systemId={systemId} className=&quot;select-none text-center&quot; hideRegion /&gt;}
        &lt;/div&gt;

        &lt;LayoutEventBlocker className=&quot;flex gap-2.5&quot;&gt;
          &lt;WdTooltipWrapper content=&quot;Enable Lazy delete&quot;&gt;
            &lt;WdCheckbox
              size=&quot;xs&quot;
              labelSide=&quot;left&quot;
              label={isCompact ? &apos;&apos; : &apos;Lazy delete&apos;}
              value={lazyDeleteValue}
              classNameLabel=&quot;text-stone-400 hover:text-stone-200 transition duration-300 whitespace-nowrap text-ellipsis overflow-hidden&quot;
              onChange={(event: CheckboxChangeEvent) =&gt; onLazyDeleteChange(!!event.checked)}
            /&gt;
          &lt;/WdTooltipWrapper&gt;

          {pendingCount &gt; 0 &amp;&amp; (
            &lt;WdImgButton
              className={PrimeIcons.UNDO}
              style={{ color: &apos;red&apos; }}
              tooltip={{
                content: `Undo pending deletions (${pendingCount})${undoCountdown &amp;&amp; undoCountdown &gt; 0 ? ` ‚Äî ${undoCountdown}s left` : &apos;&apos;}`,
              }}
              onClick={onUndoClick}
            /&gt;
          )}

          &lt;WdImgButton
            className={PrimeIcons.QUESTION_CIRCLE}
            tooltip={{
              position: TooltipPosition.left,
              content: (
                &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
                  &lt;InfoDrawer title={&lt;b className=&quot;text-slate-50&quot;&gt;How to add/update signature?&lt;/b&gt;}&gt;
                    In game you need to select one or more signatures &lt;br /&gt; in the list in{&apos; &apos;}
                    &lt;b className=&quot;text-sky-500&quot;&gt;Probe scanner&lt;/b&gt;. &lt;br /&gt; Use next hotkeys:
                    &lt;br /&gt;
                    &lt;b className=&quot;text-sky-500&quot;&gt;Shift + LMB&lt;/b&gt; or &lt;b className=&quot;text-sky-500&quot;&gt;Ctrl + LMB&lt;/b&gt;
                    &lt;br /&gt; or &lt;b className=&quot;text-sky-500&quot;&gt;Ctrl + A&lt;/b&gt; for select all
                    &lt;br /&gt; and then use &lt;b className=&quot;text-sky-500&quot;&gt;Ctrl + C&lt;/b&gt;, after you need to go &lt;br /&gt;
                    here, select Solar system and paste it with &lt;b className=&quot;text-sky-500&quot;&gt;Ctrl + V&lt;/b&gt;
                  &lt;/InfoDrawer&gt;
                  &lt;InfoDrawer title={&lt;b className=&quot;text-slate-50&quot;&gt;How to select?&lt;/b&gt;}&gt;
                    For selecting any signature, click on it &lt;br /&gt; with hotkeys{&apos; &apos;}
                    &lt;b className=&quot;text-sky-500&quot;&gt;Shift + LMB&lt;/b&gt; or &lt;b className=&quot;text-sky-500&quot;&gt;Ctrl + LMB&lt;/b&gt;
                  &lt;/InfoDrawer&gt;
                  &lt;InfoDrawer title={&lt;b className=&quot;text-slate-50&quot;&gt;How to delete?&lt;/b&gt;}&gt;
                    To delete any signature, first select it &lt;br /&gt; and then press &lt;b className=&quot;text-sky-500&quot;&gt;Del&lt;/b&gt;
                  &lt;/InfoDrawer&gt;
                &lt;/div&gt;
              ),
            }}
          /&gt;

          &lt;WdImgButton className={PrimeIcons.SLIDERS_H} onClick={onSettingsClick} /&gt;
        &lt;/LayoutEventBlocker&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SystemSignaturesContent/index.ts">export * from &apos;./SystemSignaturesContent&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SystemSignaturesContent/SystemSignaturesContent.tsx">import { PrimeIcons } from &apos;primereact/api&apos;;
import { Column } from &apos;primereact/column&apos;;
import {
  DataTable,
  DataTableRowClickEvent,
  DataTableRowMouseEvent,
  DataTableStateEvent,
  SortOrder,
} from &apos;primereact/datatable&apos;;
import { useCallback, useEffect, useMemo, useRef, useState } from &apos;react&apos;;
import useLocalStorageState from &apos;use-local-storage-state&apos;;

import { SignatureView } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SignatureView&apos;;
import {
  COMPACT_MAX_WIDTH,
  getGroupIdByRawGroup,
  GROUPS_LIST,
  MEDIUM_MAX_WIDTH,
  OTHER_COLUMNS_WIDTH,
  SETTINGS_KEYS,
  SIGNATURE_WINDOW_ID,
  SignatureSettingsType,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants&apos;;
import { SignatureSettings } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings&apos;;
import { TooltipPosition, WdTooltip, WdTooltipHandlers, WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { ExtendedSystemSignature, SignatureGroup, SignatureKind, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;

import {
  renderAddedTimeLeft,
  renderDescription,
  renderIcon,
  renderInfoColumn,
  renderUpdatedTimeLeft,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders&apos;;
import { useClipboard, useHotkey } from &apos;@/hooks/Mapper/hooks&apos;;
import useMaxWidth from &apos;@/hooks/Mapper/hooks/useMaxWidth&apos;;
import { getSignatureRowClass } from &apos;../helpers/rowStyles&apos;;
import { useSystemSignaturesData } from &apos;../hooks/useSystemSignaturesData&apos;;

const renderColIcon = (sig: SystemSignature) =&gt; renderIcon(sig);

type SystemSignaturesSortSettings = {
  sortField: string;
  sortOrder: SortOrder;
};

const SORT_DEFAULT_VALUES: SystemSignaturesSortSettings = {
  sortField: &apos;inserted_at&apos;,
  sortOrder: -1,
};

interface SystemSignaturesContentProps {
  systemId: string;
  settings: SignatureSettingsType;
  hideLinkedSignatures?: boolean;
  selectable?: boolean;
  onSelect?: (signature: SystemSignature) =&gt; void;
  onLazyDeleteChange?: (value: boolean) =&gt; void;
  onCountChange?: (count: number) =&gt; void;
  filterSignature?: (signature: SystemSignature) =&gt; boolean;
  onSignatureDeleted?: (deletedIds: string[]) =&gt; void;
}

export const SystemSignaturesContent = ({
  systemId,
  settings,
  hideLinkedSignatures,
  selectable,
  onSelect,
  onLazyDeleteChange,
  onCountChange,
  filterSignature,
  onSignatureDeleted,
}: SystemSignaturesContentProps) =&gt; {
  const [selectedSignatureForDialog, setSelectedSignatureForDialog] = useState&lt;SystemSignature | null&gt;(null);
  const [showSignatureSettings, setShowSignatureSettings] = useState(false);
  const [nameColumnWidth, setNameColumnWidth] = useState(&apos;auto&apos;);
  const [hoveredSignature, setHoveredSignature] = useState&lt;SystemSignature | null&gt;(null);

  const tableRef = useRef&lt;HTMLDivElement&gt;(null);
  const tooltipRef = useRef&lt;WdTooltipHandlers&gt;(null);

  const isCompact = useMaxWidth(tableRef, COMPACT_MAX_WIDTH);
  const isMedium = useMaxWidth(tableRef, MEDIUM_MAX_WIDTH);

  const { clipboardContent, setClipboardContent } = useClipboard();

  const [sortSettings, setSortSettings] = useLocalStorageState&lt;{ sortField: string; sortOrder: SortOrder }&gt;(
    &apos;window:signatures:sort&apos;,
    { defaultValue: SORT_DEFAULT_VALUES },
  );

  const {
    signatures,
    selectedSignatures,
    setSelectedSignatures,
    handleDeleteSelected,
    handleSelectAll,
    handlePaste,
    hasUnsupportedLanguage,
  } = useSystemSignaturesData({
    systemId,
    settings,
    onCountChange,
    onLazyDeleteChange,
    onSignatureDeleted,
  });

  useEffect(() =&gt; {
    if (selectable) return;
    if (!clipboardContent?.text) return;

    handlePaste(clipboardContent.text);

    setClipboardContent(null);
  }, [selectable, clipboardContent, handlePaste, setClipboardContent]);

  useHotkey(true, [&apos;a&apos;], handleSelectAll);

  useHotkey(false, [&apos;Backspace&apos;, &apos;Delete&apos;], (event: KeyboardEvent) =&gt; {
    const targetWindow = (event.target as HTMLHtmlElement)?.closest(`[data-window-id=&quot;${SIGNATURE_WINDOW_ID}&quot;]`);

    if (!targetWindow) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();
    if (onSignatureDeleted &amp;&amp; selectedSignatures.length &gt; 0) {
      const deletedIds = selectedSignatures.map(s =&gt; s.eve_id);
      onSignatureDeleted(deletedIds);
    }
    handleDeleteSelected();
  });

  const handleResize = useCallback(() =&gt; {
    if (!tableRef.current) return;

    setNameColumnWidth(`${tableRef.current.offsetWidth - OTHER_COLUMNS_WIDTH}px`);
  }, []);

  useEffect(() =&gt; {
    if (!tableRef.current) return;

    const observer = new ResizeObserver(handleResize);
    observer.observe(tableRef.current);
    handleResize();

    return () =&gt; {
      observer.disconnect();
    };
  }, [handleResize]);

  const handleRowClick = useCallback((e: DataTableRowClickEvent) =&gt; {
    setSelectedSignatureForDialog(e.data as SystemSignature);
    setShowSignatureSettings(true);
  }, []);

  const handleSelectSignatures = useCallback(
    (e: { value: SystemSignature[] }) =&gt; {
      selectable ? onSelect?.(e.value[0]) : setSelectedSignatures(e.value as ExtendedSystemSignature[]);
    },
    [onSelect, selectable, setSelectedSignatures],
  );

  const { showDescriptionColumn, showUpdatedColumn, showCharacterColumn, showCharacterPortrait } = useMemo(
    () =&gt; ({
      showDescriptionColumn: settings[SETTINGS_KEYS.SHOW_DESCRIPTION_COLUMN] as boolean,
      showUpdatedColumn: settings[SETTINGS_KEYS.SHOW_UPDATED_COLUMN] as boolean,
      showCharacterColumn: settings[SETTINGS_KEYS.SHOW_CHARACTER_COLUMN] as boolean,
      showCharacterPortrait: settings[SETTINGS_KEYS.SHOW_CHARACTER_PORTRAIT] as boolean,
    }),
    [settings],
  );

  const filteredSignatures = useMemo&lt;ExtendedSystemSignature[]&gt;(() =&gt; {
    return signatures.filter(sig =&gt; {
      if (filterSignature &amp;&amp; !filterSignature(sig)) {
        return false;
      }

      if (hideLinkedSignatures &amp;&amp; sig.linked_system) {
        return false;
      }

      if (sig.kind === SignatureKind.CosmicSignature) {
        if (!settings[SETTINGS_KEYS.COSMIC_SIGNATURE]) {
          return false;
        }

        if (sig.group) {
          const enabledGroups = Object.keys(settings).filter(
            x =&gt; GROUPS_LIST.includes(x as SignatureGroup) &amp;&amp; settings[x as SETTINGS_KEYS],
          );

          const mappedGroup = getGroupIdByRawGroup(sig.group);
          if (!mappedGroup) {
            return true; // If we can&apos;t determine the group, still show it
          }
          return enabledGroups.includes(mappedGroup);
        }

        return true;
      }

      return settings[sig.kind];
    });
  }, [signatures, hideLinkedSignatures, settings, filterSignature]);

  const onRowMouseEnter = useCallback((e: DataTableRowMouseEvent) =&gt; {
    setHoveredSignature(e.data as SystemSignature);
    tooltipRef.current?.show(e.originalEvent);
  }, []);

  const onRowMouseLeave = useCallback(() =&gt; {
    setHoveredSignature(null);
    tooltipRef.current?.hide();
  }, []);

  const refVars = useRef({ settings, selectedSignatures, setSortSettings });
  refVars.current = { settings, selectedSignatures, setSortSettings };

  // @ts-ignore
  const getRowClassName = useCallback(rowData =&gt; {
    if (!rowData) {
      return null;
    }

    return getSignatureRowClass(
      rowData as ExtendedSystemSignature,
      refVars.current.selectedSignatures,
      refVars.current.settings[SETTINGS_KEYS.COLOR_BY_TYPE] as boolean,
    );
  }, []);

  const handleSortSettings = useCallback(
    (e: DataTableStateEvent) =&gt; refVars.current.setSortSettings({ sortField: e.sortField, sortOrder: e.sortOrder }),
    [],
  );

  return (
    &lt;div ref={tableRef} className=&quot;h-full&quot;&gt;
      {filteredSignatures.length === 0 ? (
        &lt;div className=&quot;w-full h-full flex justify-center items-center select-none text-stone-400/80 text-sm&quot;&gt;
          No signatures
        &lt;/div&gt;
      ) : (
        &lt;&gt;
          {hasUnsupportedLanguage &amp;&amp; (
            &lt;div className=&quot;w-full flex justify-center items-center text-amber-500 text-xs p-1 bg-amber-950/20 border-b border-amber-800/30&quot;&gt;
              &lt;i className={PrimeIcons.EXCLAMATION_TRIANGLE + &apos; mr-1&apos;} /&gt;
              Non-English signatures detected. Some signatures may not display correctly. Double-click to edit signature details.
            &lt;/div&gt;
          )}
          &lt;DataTable
            value={filteredSignatures}
            size=&quot;small&quot;
            selectionMode=&quot;multiple&quot;
            selection={selectedSignatures}
            metaKeySelection
            onSelectionChange={handleSelectSignatures}
            dataKey=&quot;eve_id&quot;
            className=&quot;w-full select-none&quot;
            resizableColumns={false}
            rowHover
            selectAll
            onRowDoubleClick={handleRowClick}
            sortField={sortSettings.sortField}
            sortOrder={sortSettings.sortOrder}
            onSort={handleSortSettings}
            onRowMouseEnter={onRowMouseEnter}
            onRowMouseLeave={onRowMouseLeave}
            // @ts-ignore
            rowClassName={getRowClassName}
          &gt;
            &lt;Column
              field=&quot;icon&quot;
              header=&quot;&quot;
              body={renderColIcon}
              bodyClassName=&quot;p-0 px-1&quot;
              style={{ maxWidth: 26, minWidth: 26, width: 26 }}
            /&gt;
            &lt;Column
              field=&quot;eve_id&quot;
              header=&quot;Id&quot;
              bodyClassName=&quot;text-ellipsis overflow-hidden whitespace-nowrap&quot;
              style={{ maxWidth: 72, minWidth: 72, width: 72 }}
              sortable
            /&gt;
            &lt;Column
              field=&quot;group&quot;
              header=&quot;Group&quot;
              bodyClassName=&quot;text-ellipsis overflow-hidden whitespace-nowrap&quot;
              style={{ maxWidth: 110, minWidth: 110, width: 110 }}
              body={sig =&gt; sig.group ?? &apos;&apos;}
              hidden={isCompact}
              sortable
            /&gt;
            &lt;Column
              field=&quot;info&quot;
              header=&quot;Info&quot;
              bodyClassName=&quot;text-ellipsis overflow-hidden whitespace-nowrap&quot;
              style={{ maxWidth: nameColumnWidth }}
              hidden={isCompact || isMedium}
              body={renderInfoColumn}
            /&gt;
            {showDescriptionColumn &amp;&amp; (
              &lt;Column
                field=&quot;description&quot;
                header=&quot;Description&quot;
                bodyClassName=&quot;text-ellipsis overflow-hidden whitespace-nowrap&quot;
                hidden={isCompact}
                body={renderDescription}
                sortable
              /&gt;
            )}
            &lt;Column
              field=&quot;inserted_at&quot;
              header=&quot;Added&quot;
              dataType=&quot;date&quot;
              body={renderAddedTimeLeft}
              style={{ minWidth: 70, maxWidth: 80 }}
              bodyClassName=&quot;ssc-header text-ellipsis overflow-hidden whitespace-nowrap&quot;
              sortable
            /&gt;
            {showUpdatedColumn &amp;&amp; (
              &lt;Column
                field=&quot;updated_at&quot;
                header=&quot;Updated&quot;
                dataType=&quot;date&quot;
                body={renderUpdatedTimeLeft}
                style={{ minWidth: 70, maxWidth: 80 }}
                bodyClassName=&quot;text-ellipsis overflow-hidden whitespace-nowrap&quot;
                sortable
              /&gt;
            )}

            {showCharacterColumn &amp;&amp; (
              &lt;Column
                field=&quot;character_name&quot;
                header=&quot;Character&quot;
                bodyClassName=&quot;w-[70px] text-ellipsis overflow-hidden whitespace-nowrap&quot;
                sortable
              &gt;&lt;/Column&gt;
            )}

            {!selectable &amp;&amp; (
              &lt;Column
                header=&quot;&quot;
                body={() =&gt; (
                  &lt;div className=&quot;flex justify-end items-center gap-2 mr-[4px]&quot;&gt;
                    &lt;WdTooltipWrapper content=&quot;Double-click a row to edit signature&quot;&gt;
                      &lt;span className={PrimeIcons.PENCIL + &apos; text-[10px]&apos;} /&gt;
                    &lt;/WdTooltipWrapper&gt;
                  &lt;/div&gt;
                )}
                style={{ maxWidth: 26, minWidth: 26, width: 26 }}
                bodyClassName=&quot;p-0 pl-1 pr-2&quot;
              /&gt;
            )}
          &lt;/DataTable&gt;
        &lt;/&gt;
      )}

      &lt;WdTooltip
        className=&quot;bg-stone-900/95 text-slate-50&quot;
        ref={tooltipRef}
        position={TooltipPosition.top}
        content={
          hoveredSignature ? (
            &lt;SignatureView signature={hoveredSignature} showCharacterPortrait={showCharacterPortrait} /&gt;
          ) : null
        }
      /&gt;

      {showSignatureSettings &amp;&amp; (
        &lt;SignatureSettings
          systemId={systemId}
          show
          onHide={() =&gt; setShowSignatureSettings(false)}
          signatureData={selectedSignatureForDialog || undefined}
        /&gt;
      )}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SystemSignatureSettingsDialog/index.ts">export * from &apos;./SystemSignatureSettingsDialog&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SystemSignatureSettingsDialog/SystemSignatureSettingsDialog.tsx">import { Dialog } from &apos;primereact/dialog&apos;;
import { useCallback, useState } from &apos;react&apos;;
import { Button } from &apos;primereact/button&apos;;
import { TabPanel, TabView } from &apos;primereact/tabview&apos;;
import { PrettySwitchbox } from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings/components&apos;;
import { Dropdown } from &apos;primereact/dropdown&apos;;
import {
  Setting,
  SettingsTypes,
  SIGNATURE_SETTINGS,
  SignatureSettingsType,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts&apos;;

interface SystemSignatureSettingsDialogProps {
  settings: SignatureSettingsType;
  onSave: (settings: SignatureSettingsType) =&gt; void;
  onCancel: () =&gt; void;
}

export const SystemSignatureSettingsDialog = ({
  settings: defaultSettings,
  onSave,
  onCancel,
}: SystemSignatureSettingsDialogProps) =&gt; {
  const [activeIndex, setActiveIndex] = useState(0);
  const [settings, setSettings] = useState&lt;SignatureSettingsType&gt;(defaultSettings);

  const handleSettingsChange = ({ key, type }: Setting, value?: unknown) =&gt; {
    setSettings(prev =&gt; {
      switch (type) {
        case SettingsTypes.dropdown:
          return { ...prev, [key]: value };
        case SettingsTypes.flag:
          return { ...prev, [key]: !prev[key] };
      }
      return prev;
    });
  };

  const handleSave = useCallback(() =&gt; {
    onSave(settings);
  }, [onSave, settings]);

  const renderSetting = (setting: Setting) =&gt; {
    const val = settings[setting.key];
    if (setting.options) {
      return (
        &lt;div key={setting.key} className=&quot;flex items-center justify-between gap-2 mb-2&quot;&gt;
          &lt;label className=&quot;text-[#b8b8b8] text-[13px] select-none&quot;&gt;{setting.name}&lt;/label&gt;
          &lt;Dropdown
            value={val}
            options={setting.options}
            onChange={e =&gt; handleSettingsChange(setting, e.value)}
            className=&quot;w-40&quot;
          /&gt;
        &lt;/div&gt;
      );
    }

    return (
      &lt;PrettySwitchbox
        key={setting.key}
        label={setting.name}
        checked={!!val}
        setChecked={() =&gt; handleSettingsChange(setting)}
      /&gt;
    );
  };

  return (
    &lt;Dialog header=&quot;System Signatures Settings&quot; visible={true} onHide={onCancel} className=&quot;w-full max-w-lg h-[500px]&quot;&gt;
      &lt;div className=&quot;flex flex-col gap-3 justify-between h-full&quot;&gt;
        &lt;div className=&quot;flex flex-col gap-2&quot;&gt;
          &lt;TabView
            activeIndex={activeIndex}
            onTabChange={e =&gt; setActiveIndex(e.index)}
            className=&quot;vertical-tabs-container&quot;
          &gt;
            &lt;TabPanel header=&quot;Filters&quot;&gt;
              &lt;div className=&quot;w-full h-full flex flex-col gap-1&quot;&gt;
                {SIGNATURE_SETTINGS.filterFlags.map(renderSetting)}
              &lt;/div&gt;
            &lt;/TabPanel&gt;
            &lt;TabPanel header=&quot;User Interface&quot;&gt;
              &lt;div className=&quot;w-full h-full flex flex-col gap-1&quot;&gt;
                {SIGNATURE_SETTINGS.uiFlags.map(renderSetting)}
                &lt;div className=&quot;my-2 border-t border-stone-700/50&quot;&gt;&lt;/div&gt;
                {SIGNATURE_SETTINGS.uiOther.map(renderSetting)}
              &lt;/div&gt;
            &lt;/TabPanel&gt;
          &lt;/TabView&gt;
        &lt;/div&gt;

        &lt;div className=&quot;flex gap-2 justify-end&quot;&gt;
          &lt;Button onClick={handleSave} outlined size=&quot;small&quot; label=&quot;Save&quot;&gt;&lt;/Button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/Dialog&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts">import {
  GroupType,
  SignatureGroup,
  SignatureGroupDE,
  SignatureGroupENG,
  SignatureGroupFR,
  SignatureGroupRU,
  SignatureKind,
  SignatureKindDE,
  SignatureKindENG,
  SignatureKindFR,
  SignatureKindRU,
} from &apos;@/hooks/Mapper/types&apos;;

export const TIME_ONE_MINUTE = 1000 * 60;
export const TIME_TEN_MINUTES = TIME_ONE_MINUTE * 10;
export const TIME_ONE_DAY = 24 * 60 * TIME_ONE_MINUTE;
export const TIME_ONE_WEEK = 7 * TIME_ONE_DAY;
export const FINAL_DURATION_MS = 10000;

export const COMPACT_MAX_WIDTH = 260;
export const MEDIUM_MAX_WIDTH = 380;
export const OTHER_COLUMNS_WIDTH = 276;

export const GROUPS_LIST = [
  SignatureGroup.GasSite,
  SignatureGroup.RelicSite,
  SignatureGroup.DataSite,
  SignatureGroup.OreSite,
  SignatureGroup.CombatSite,
  SignatureGroup.Wormhole,
  SignatureGroup.CosmicSignature,
];

const wh = { w: 14, h: 14 };

export const GROUPS: Record&lt;SignatureGroup, GroupType&gt; = {
  [SignatureGroup.GasSite]: { id: SignatureGroup.GasSite, icon: &apos;/icons/brackets/harvestableCloud.png&apos;, ...wh },
  [SignatureGroup.RelicSite]: { id: SignatureGroup.RelicSite, icon: &apos;/icons/brackets/relic_Site_16.png&apos;, ...wh },
  [SignatureGroup.DataSite]: { id: SignatureGroup.DataSite, icon: &apos;/icons/brackets/data_Site_16.png&apos;, ...wh },
  [SignatureGroup.OreSite]: { id: SignatureGroup.OreSite, icon: &apos;/icons/brackets/ore_Site_16.png&apos;, ...wh },
  [SignatureGroup.CombatSite]: { id: SignatureGroup.CombatSite, icon: &apos;/icons/brackets/combatSite_16.png&apos;, ...wh },
  [SignatureGroup.Wormhole]: { id: SignatureGroup.Wormhole, icon: &apos;/icons/brackets/wormhole.png&apos;, ...wh },
  [SignatureGroup.CosmicSignature]: { id: SignatureGroup.CosmicSignature, icon: &apos;/icons/x_close14.png&apos;, w: 9, h: 9 },
};

export const LANGUAGE_GROUP_MAPPINGS = {
  EN: {
    [SignatureGroupENG.GasSite]: SignatureGroup.GasSite,
    [SignatureGroupENG.RelicSite]: SignatureGroup.RelicSite,
    [SignatureGroupENG.DataSite]: SignatureGroup.DataSite,
    [SignatureGroupENG.OreSite]: SignatureGroup.OreSite,
    [SignatureGroupENG.CombatSite]: SignatureGroup.CombatSite,
    [SignatureGroupENG.Wormhole]: SignatureGroup.Wormhole,
    [SignatureGroupENG.CosmicSignature]: SignatureGroup.CosmicSignature,
  },
  RU: {
    [SignatureGroupRU.GasSite]: SignatureGroup.GasSite,
    [SignatureGroupRU.RelicSite]: SignatureGroup.RelicSite,
    [SignatureGroupRU.DataSite]: SignatureGroup.DataSite,
    [SignatureGroupRU.OreSite]: SignatureGroup.OreSite,
    [SignatureGroupRU.CombatSite]: SignatureGroup.CombatSite,
    [SignatureGroupRU.Wormhole]: SignatureGroup.Wormhole,
    [SignatureGroupRU.CosmicSignature]: SignatureGroup.CosmicSignature,
  },
  FR: {
    [SignatureGroupFR.GasSite]: SignatureGroup.GasSite,
    [SignatureGroupFR.RelicSite]: SignatureGroup.RelicSite,
    [SignatureGroupFR.DataSite]: SignatureGroup.DataSite,
    [SignatureGroupFR.OreSite]: SignatureGroup.OreSite,
    [SignatureGroupFR.CombatSite]: SignatureGroup.CombatSite,
    [SignatureGroupFR.Wormhole]: SignatureGroup.Wormhole,
    [SignatureGroupFR.CosmicSignature]: SignatureGroup.CosmicSignature,
  },
  DE: {
    [SignatureGroupDE.GasSite]: SignatureGroup.GasSite,
    [SignatureGroupDE.RelicSite]: SignatureGroup.RelicSite,
    [SignatureGroupDE.DataSite]: SignatureGroup.DataSite,
    [SignatureGroupDE.OreSite]: SignatureGroup.OreSite,
    [SignatureGroupDE.CombatSite]: SignatureGroup.CombatSite,
    [SignatureGroupDE.Wormhole]: SignatureGroup.Wormhole,
    [SignatureGroupDE.CosmicSignature]: SignatureGroup.CosmicSignature,
  },
};

// Flatten the structure for backward compatibility
export const MAPPING_GROUP_TO_ENG: Record&lt;string, SignatureGroup&gt; = (() =&gt; {
  const flattened: Record&lt;string, SignatureGroup&gt; = {};
  for (const [, mappings] of Object.entries(LANGUAGE_GROUP_MAPPINGS)) {
    Object.assign(flattened, mappings);
  }
  return flattened;
})();

export const getGroupIdByRawGroup = (val: string): SignatureGroup | undefined =&gt; {
  return MAPPING_GROUP_TO_ENG[val] || undefined;
};

export const SIGNATURE_WINDOW_ID = &apos;system_signatures_window&apos;;
export const SIGNATURE_SETTING_STORE_KEY = &apos;wanderer_system_signature_settings_v6_5&apos;;

export enum SETTINGS_KEYS {
  SHOW_DESCRIPTION_COLUMN = &apos;show_description_column&apos;,
  SHOW_UPDATED_COLUMN = &apos;show_updated_column&apos;,
  SHOW_CHARACTER_COLUMN = &apos;show_character_column&apos;,
  LAZY_DELETE_SIGNATURES = &apos;lazy_delete_signatures&apos;,
  KEEP_LAZY_DELETE = &apos;keep_lazy_delete_enabled&apos;,
  DELETION_TIMING = &apos;deletion_timing&apos;,
  COLOR_BY_TYPE = &apos;color_by_type&apos;,
  SHOW_CHARACTER_PORTRAIT = &apos;show_character_portrait&apos;,

  // From SignatureKind
  COSMIC_ANOMALY = SignatureKind.CosmicAnomaly,
  COSMIC_SIGNATURE = SignatureKind.CosmicSignature,
  DEPLOYABLE = SignatureKind.Deployable,
  STRUCTURE = SignatureKind.Structure,
  STARBASE = SignatureKind.Starbase,
  SHIP = SignatureKind.Ship,
  DRONE = SignatureKind.Drone,

  // From SignatureGroup
  WORMHOLE = SignatureGroup.Wormhole,
  RELIC_SITE = SignatureGroup.RelicSite,
  DATA_SITE = SignatureGroup.DataSite,
  ORE_SITE = SignatureGroup.OreSite,
  GAS_SITE = SignatureGroup.GasSite,
  COMBAT_SITE = SignatureGroup.CombatSite,
}

export enum SettingsTypes {
  flag,
  dropdown,
}

export type SignatureSettingsType = { [key in SETTINGS_KEYS]?: unknown };

export type Setting = {
  key: SETTINGS_KEYS;
  name: string;
  type: SettingsTypes;
  isSeparator?: boolean;
  options?: { label: string; value: number | string | boolean }[];
};

export enum SIGNATURES_DELETION_TIMING {
  IMMEDIATE,
  DEFAULT,
  EXTENDED,
}

export type SignatureDeletionTimingType = { [key in SIGNATURES_DELETION_TIMING]?: unknown };

export const SIGNATURE_SETTINGS = {
  filterFlags: [
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.COSMIC_ANOMALY, name: &apos;Show Anomalies&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.COSMIC_SIGNATURE, name: &apos;Show Cosmic Signatures&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.DEPLOYABLE, name: &apos;Show Deployables&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.STRUCTURE, name: &apos;Show Structures&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.STARBASE, name: &apos;Show Starbase&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.SHIP, name: &apos;Show Ships&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.DRONE, name: &apos;Show Drones And Charges&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.WORMHOLE, name: &apos;Show Wormholes&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.RELIC_SITE, name: &apos;Show Relic Sites&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.DATA_SITE, name: &apos;Show Data Sites&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.ORE_SITE, name: &apos;Show Ore Sites&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.GAS_SITE, name: &apos;Show Gas Sites&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.COMBAT_SITE, name: &apos;Show Combat Sites&apos; },
  ],
  uiFlags: [
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.SHOW_UPDATED_COLUMN, name: &apos;Show Updated Column&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.SHOW_DESCRIPTION_COLUMN, name: &apos;Show Description Column&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.SHOW_CHARACTER_COLUMN, name: &apos;Show Character Column&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.LAZY_DELETE_SIGNATURES, name: &apos;Lazy Delete Signatures&apos; },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.KEEP_LAZY_DELETE, name: &apos;Keep &quot;Lazy Delete&quot; Enabled&apos; },
    {
      type: SettingsTypes.flag,
      key: SETTINGS_KEYS.SHOW_CHARACTER_PORTRAIT,
      name: &apos;Show Character Portrait in Tooltip&apos;,
    },
    { type: SettingsTypes.flag, key: SETTINGS_KEYS.COLOR_BY_TYPE, name: &apos;Color Signatures by Type&apos; },
  ],
  uiOther: [
    {
      type: SettingsTypes.dropdown,
      key: SETTINGS_KEYS.DELETION_TIMING,
      name: &apos;Deletion Timing&apos;,
      options: [
        { value: SIGNATURES_DELETION_TIMING.IMMEDIATE, label: &apos;0s&apos; },
        { value: SIGNATURES_DELETION_TIMING.DEFAULT, label: &apos;10s&apos; },
        { value: SIGNATURES_DELETION_TIMING.EXTENDED, label: &apos;30s&apos; },
      ],
    },
  ],
};

export const SETTINGS_VALUES: SignatureSettingsType = {
  [SETTINGS_KEYS.SHOW_UPDATED_COLUMN]: true,
  [SETTINGS_KEYS.SHOW_DESCRIPTION_COLUMN]: true,
  [SETTINGS_KEYS.SHOW_CHARACTER_COLUMN]: true,
  [SETTINGS_KEYS.LAZY_DELETE_SIGNATURES]: true,
  [SETTINGS_KEYS.KEEP_LAZY_DELETE]: false,
  [SETTINGS_KEYS.DELETION_TIMING]: SIGNATURES_DELETION_TIMING.DEFAULT,
  [SETTINGS_KEYS.COLOR_BY_TYPE]: true,
  [SETTINGS_KEYS.SHOW_CHARACTER_PORTRAIT]: true,

  [SETTINGS_KEYS.COSMIC_ANOMALY]: true,
  [SETTINGS_KEYS.COSMIC_SIGNATURE]: true,
  [SETTINGS_KEYS.DEPLOYABLE]: true,
  [SETTINGS_KEYS.STRUCTURE]: true,
  [SETTINGS_KEYS.STARBASE]: true,
  [SETTINGS_KEYS.SHIP]: true,
  [SETTINGS_KEYS.DRONE]: true,

  [SETTINGS_KEYS.WORMHOLE]: true,
  [SETTINGS_KEYS.RELIC_SITE]: true,
  [SETTINGS_KEYS.DATA_SITE]: true,
  [SETTINGS_KEYS.ORE_SITE]: true,
  [SETTINGS_KEYS.GAS_SITE]: true,
  [SETTINGS_KEYS.COMBAT_SITE]: true,
};

export const SIGNATURE_DELETION_TIMEOUTS: SignatureDeletionTimingType = {
  [SIGNATURES_DELETION_TIMING.DEFAULT]: 10_000,
  [SIGNATURES_DELETION_TIMING.IMMEDIATE]: 0,
  [SIGNATURES_DELETION_TIMING.EXTENDED]: 30_000,
};

// Replace the flat structure with a nested structure by language
export const LANGUAGE_TYPE_MAPPINGS = {
  EN: {
    [SignatureKindENG.CosmicSignature]: SignatureKind.CosmicSignature,
    [SignatureKindENG.CosmicAnomaly]: SignatureKind.CosmicAnomaly,
    [SignatureKindENG.Structure]: SignatureKind.Structure,
    [SignatureKindENG.Ship]: SignatureKind.Ship,
    [SignatureKindENG.Deployable]: SignatureKind.Deployable,
    [SignatureKindENG.Drone]: SignatureKind.Drone,
    [SignatureKindENG.Starbase]: SignatureKind.Starbase,
  },
  RU: {
    [SignatureKindRU.CosmicSignature]: SignatureKind.CosmicSignature,
    [SignatureKindRU.CosmicAnomaly]: SignatureKind.CosmicAnomaly,
    [SignatureKindRU.Structure]: SignatureKind.Structure,
    [SignatureKindRU.Ship]: SignatureKind.Ship,
    [SignatureKindRU.Deployable]: SignatureKind.Deployable,
    [SignatureKindRU.Drone]: SignatureKind.Drone,
    [SignatureKindRU.Starbase]: SignatureKind.Starbase,
  },
  FR: {
    [SignatureKindFR.CosmicSignature]: SignatureKind.CosmicSignature,
    [SignatureKindFR.CosmicAnomaly]: SignatureKind.CosmicAnomaly,
    [SignatureKindFR.Structure]: SignatureKind.Structure,
    [SignatureKindFR.Ship]: SignatureKind.Ship,
    [SignatureKindFR.Deployable]: SignatureKind.Deployable,
    [SignatureKindFR.Drone]: SignatureKind.Drone,
    [SignatureKindFR.Starbase]: SignatureKind.Starbase,
  },
  DE: {
    [SignatureKindDE.CosmicSignature]: SignatureKind.CosmicSignature,
    [SignatureKindDE.CosmicAnomaly]: SignatureKind.CosmicAnomaly,
    [SignatureKindDE.Structure]: SignatureKind.Structure,
    [SignatureKindDE.Ship]: SignatureKind.Ship,
    [SignatureKindDE.Deployable]: SignatureKind.Deployable,
    [SignatureKindDE.Drone]: SignatureKind.Drone,
    [SignatureKindDE.Starbase]: SignatureKind.Starbase,
  },
};

// Flatten the structure for backward compatibility
export const MAPPING_TYPE_TO_ENG: Record&lt;string, SignatureKind&gt; = (() =&gt; {
  const flattened: Record&lt;string, SignatureKind&gt; = {};
  for (const [, mappings] of Object.entries(LANGUAGE_TYPE_MAPPINGS)) {
    Object.assign(flattened, mappings);
  }
  return flattened;
})();</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/index.ts">export * from &apos;./SystemSignatures&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/SystemSignatures.tsx">import { useCallback, useState, useEffect, useRef, useMemo } from &apos;react&apos;;
import { Widget } from &apos;@/hooks/Mapper/components/mapInterface/components&apos;;
import { SystemSignaturesContent } from &apos;./SystemSignaturesContent&apos;;
import { SystemSignatureSettingsDialog } from &apos;./SystemSignatureSettingsDialog&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { SystemSignaturesHeader } from &apos;./SystemSignatureHeader&apos;;
import useLocalStorageState from &apos;use-local-storage-state&apos;;
import { useHotkey } from &apos;@/hooks/Mapper/hooks/useHotkey&apos;;
import {
  SETTINGS_KEYS,
  SETTINGS_VALUES,
  SIGNATURE_SETTING_STORE_KEY,
  SIGNATURE_WINDOW_ID,
  SignatureSettingsType,
  SIGNATURES_DELETION_TIMING,
  SIGNATURE_DELETION_TIMEOUTS,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts&apos;;
import { OutCommand, OutCommandHandler } from &apos;@/hooks/Mapper/types/mapHandlers&apos;;

/**
 * Custom hook for managing pending signature deletions and undo countdown.
 */
function useSignatureUndo(
  systemId: string | undefined,
  settings: SignatureSettingsType,
  outCommand: OutCommandHandler,
) {
  const [countdown, setCountdown] = useState&lt;number&gt;(0);
  const [pendingIds, setPendingIds] = useState&lt;Set&lt;string&gt;&gt;(new Set());
  const intervalRef = useRef&lt;number | null&gt;(null);

  const addDeleted = useCallback((ids: string[]) =&gt; {
    setPendingIds(prev =&gt; {
      const next = new Set(prev);
      ids.forEach(id =&gt; next.add(id));
      return next;
    });
  }, []);

  // kick off or clear countdown whenever pendingIds changes
  useEffect(() =&gt; {
    // clear any existing timer
    if (intervalRef.current != null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }

    if (pendingIds.size === 0) {
      setCountdown(0);
      return;
    }

    // determine timeout from settings
    const timingKey = Number(settings[SETTINGS_KEYS.DELETION_TIMING] ?? SIGNATURES_DELETION_TIMING.DEFAULT);
    const timeoutMs =
      Number(SIGNATURE_DELETION_TIMEOUTS[timingKey as keyof typeof SIGNATURE_DELETION_TIMEOUTS]) || 10000;
    setCountdown(Math.ceil(timeoutMs / 1000));

    // start new interval
    intervalRef.current = window.setInterval(() =&gt; {
      setCountdown(prev =&gt; {
        if (prev &lt;= 1) {
          clearInterval(intervalRef.current!);
          intervalRef.current = null;
          setPendingIds(new Set());
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () =&gt; {
      if (intervalRef.current != null) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, [pendingIds, settings[SETTINGS_KEYS.DELETION_TIMING]]);

  // undo handler
  const handleUndo = useCallback(async () =&gt; {
    if (!systemId || pendingIds.size === 0) return;
    await outCommand({
      type: OutCommand.undoDeleteSignatures,
      data: { system_id: systemId, eve_ids: Array.from(pendingIds) },
    });
    setPendingIds(new Set());
    setCountdown(0);
    if (intervalRef.current != null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, [systemId, pendingIds, outCommand]);

  return {
    pendingIds,
    countdown,
    addDeleted,
    handleUndo,
  };
}

export const SystemSignatures = () =&gt; {
  const [visible, setVisible] = useState(false);
  const [sigCount, setSigCount] = useState(0);

  const {
    data: { selectedSystems },
    outCommand,
  } = useMapRootState();

  const [currentSettings, setCurrentSettings] = useLocalStorageState&lt;SignatureSettingsType&gt;(
    SIGNATURE_SETTING_STORE_KEY,
    {
      defaultValue: SETTINGS_VALUES,
    },
  );

  const [systemId] = selectedSystems;
  const isSystemSelected = useMemo(() =&gt; selectedSystems.length === 1, [selectedSystems.length]);
  const { pendingIds, countdown, addDeleted, handleUndo } = useSignatureUndo(systemId, currentSettings, outCommand);

  useHotkey(true, [&apos;z&apos;, &apos;Z&apos;], (event: KeyboardEvent) =&gt; {
    if (pendingIds.size &gt; 0 &amp;&amp; countdown &gt; 0) {
      event.preventDefault();
      event.stopPropagation();
      handleUndo();
    }
  });

  const handleCountChange = useCallback((count: number) =&gt; {
    setSigCount(count);
  }, []);

  const handleSettingsSave = useCallback(
    (newSettings: SignatureSettingsType) =&gt; {
      setCurrentSettings(newSettings);
      setVisible(false);
    },
    [setCurrentSettings],
  );

  const handleLazyDeleteToggle = useCallback(
    (value: boolean) =&gt; {
      setCurrentSettings(prev =&gt; ({
        ...prev,
        [SETTINGS_KEYS.LAZY_DELETE_SIGNATURES]: value,
      }));
    },
    [setCurrentSettings],
  );

  const openSettings = useCallback(() =&gt; setVisible(true), []);

  return (
    &lt;Widget
      label={
        &lt;SystemSignaturesHeader
          sigCount={sigCount}
          lazyDeleteValue={currentSettings[SETTINGS_KEYS.LAZY_DELETE_SIGNATURES] as boolean}
          pendingCount={pendingIds.size}
          undoCountdown={countdown}
          onLazyDeleteChange={handleLazyDeleteToggle}
          onUndoClick={handleUndo}
          onSettingsClick={openSettings}
        /&gt;
      }
      windowId={SIGNATURE_WINDOW_ID}
    &gt;
      {!isSystemSelected ? (
        &lt;div className=&quot;w-full h-full flex justify-center items-center select-none text-center text-stone-400/80 text-sm&quot;&gt;
          System is not selected
        &lt;/div&gt;
      ) : (
        &lt;SystemSignaturesContent
          systemId={systemId}
          settings={currentSettings}
          onLazyDeleteChange={handleLazyDeleteToggle}
          onCountChange={handleCountChange}
          onSignatureDeleted={addDeleted}
        /&gt;
      )}

      {visible &amp;&amp; (
        &lt;SystemSignatureSettingsDialog
          settings={currentSettings}
          onCancel={() =&gt; setVisible(false)}
          onSave={handleSettingsSave}
        /&gt;
      )}
    &lt;/Widget&gt;
  );
};

export default SystemSignatures;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/helpers/index.ts">export * from &apos;./parserHelper&apos;;
export * from &apos;./pasteParser&apos;;
export * from &apos;./structureTypes&apos;;
export * from &apos;./structureUtils&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/helpers/parserHelper.ts">import { StructureStatus, StructureItem, STRUCTURE_TYPE_MAP } from &apos;./structureTypes&apos;;
import { formatToISO } from &apos;./structureUtils&apos;;

// Up to you if you&apos;d like to keep a separate constant here or not
export const statusesRequiringTimer: StructureStatus[] = [&apos;Anchoring&apos;, &apos;Reinforced&apos;];

/**
 * parseFormatOneLine(line):
 *  - Splits by tabs
 *  - First col =&gt; structureTypeId
 *  - Second col =&gt; rawName
 *  - Third col =&gt; structureTypeName
 */
export function parseFormatOneLine(line: string): StructureItem | null {
  const columns = line
    .split(&apos;\t&apos;)
    .map(c =&gt; c.trim())
    .filter(Boolean);

  // Expecting e.g. &quot;35832   J214811 - SomeName    Astrahus&quot;
  if (columns.length &lt; 3) {
    return null;
  }

  const [rawTypeId, rawName, rawTypeName] = columns;

  if (columns.length != 4) {
    return null;
  }

  if (!STRUCTURE_TYPE_MAP[rawTypeId]) {
    return null;
  }

  // in some localizations (like russian) there is an option called &quot;mark names with *&quot;
  // The example output will be &quot;35826	Itamo - Research &amp; Production	Azbel*	609 –º&quot;
  // so, let&apos;s fix this
  const localizationFixedName = rawTypeName.replace(&quot;*&quot;, &quot;&quot;);

  if (localizationFixedName != STRUCTURE_TYPE_MAP[rawTypeId]) {
    return null;
  }

  const name = rawName.replace(/^J\d{6}\s*-\s*/, &apos;&apos;).trim();

  return {
    id: crypto.randomUUID(),
    structureTypeId: rawTypeId,
    structureType: rawTypeName,
    name,
    ownerName: &apos;&apos;,
    notes: &apos;&apos;,
    status: &apos;Powered&apos;, // Default
    endTime: &apos;&apos;, // No timer by default
  };
}

export function matchesThreeLineSnippet(lines: string[]): boolean {
  if (lines.length &lt; 3) return false;
  return /until\s+\d{4}\.\d{2}\.\d{2}/i.test(lines[2]);
}

/**
 * parseThreeLineSnippet:
 *  - Example lines:
 *    line1: &quot;J214811 - Folgers&quot;
 *    line2: &quot;1,475 km&quot;
 *    line3: &quot;Reinforced until 2025.01.13 23:51&quot;
 */
export function parseThreeLineSnippet(lines: string[]): StructureItem {
  const [line1, , line3] = lines;

  let status: StructureStatus = &apos;Reinforced&apos;;
  let endTime: string | undefined;

  // e.g. &quot;Reinforced until 2025.01.13 23:27&quot;
  const match = line3.match(/^(?&lt;stat&gt;\w+)\s+until\s+(?&lt;dateTime&gt;[\d.]+\s+[\d:]+)/i);

  if (match?.groups?.stat) {
    const candidateStatus = match.groups.stat as StructureStatus;
    if (statusesRequiringTimer.includes(candidateStatus)) {
      status = candidateStatus;
    }
  }
  if (match?.groups?.dateTime) {
    let dt = match.groups.dateTime.trim().replace(/\./g, &apos;-&apos;); // &quot;2025-01-13 23:27&quot;
    dt = dt.replace(&apos; &apos;, &apos;T&apos;); // &quot;2025-01-13T23:27&quot;
    endTime = formatToISO(dt); // =&gt; &quot;2025-01-13T23:27:00Z&quot;
  }

  return {
    id: crypto.randomUUID(),
    name: line1.replace(/^J\d{6}\s*-\s*/, &apos;&apos;).trim(),
    status,
    endTime,
  };
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/helpers/pasteParser.ts">import { StructureItem } from &apos;./structureTypes&apos;;
import { parseThreeLineSnippet, parseFormatOneLine, matchesThreeLineSnippet } from &apos;./parserHelper&apos;;

export function processSnippetText(rawText: string, existingStructures: StructureItem[]): StructureItem[] {
  if (!rawText) {
    return existingStructures.slice();
  }

  const lines = rawText
    .split(/\r?\n/)
    .map(line =&gt; line.trim())
    .filter(Boolean);

  if (lines.length === 3 &amp;&amp; matchesThreeLineSnippet(lines)) {
    return applyThreeLineSnippet(lines, existingStructures);
  } else {
    return applySingleLineParse(lines, existingStructures);
  }
}

function applyThreeLineSnippet(snippetLines: string[], existingStructures: StructureItem[]): StructureItem[] {
  const updatedList = [...existingStructures];
  const snippetItem = parseThreeLineSnippet(snippetLines);

  const existingIndex = updatedList.findIndex(s =&gt; s.name.trim() === snippetItem.name.trim());

  if (existingIndex !== -1) {
    const existing = updatedList[existingIndex];
    updatedList[existingIndex] = {
      ...existing,
      status: snippetItem.status,
      endTime: snippetItem.endTime,
    };
  }

  return updatedList;
}

function applySingleLineParse(lines: string[], existingStructures: StructureItem[]): StructureItem[] {
  const updatedList = [...existingStructures];
  const newItems: StructureItem[] = [];

  for (const line of lines) {
    const item = parseFormatOneLine(line);
    if (!item) continue;

    const isDuplicate = updatedList.some(
      s =&gt; s.structureTypeId === item.structureTypeId &amp;&amp; s.name.trim() === item.name.trim(),
    );
    if (!isDuplicate) {
      newItems.push(item);
    }
  }

  return [...updatedList, ...newItems];
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/helpers/structureTypes.ts">export type StructureStatus = &apos;Powered&apos; | &apos;Anchoring&apos; | &apos;Unanchoring&apos; | &apos;Low Power&apos; | &apos;Abandoned&apos; | &apos;Reinforced&apos;;

export interface StructureItem {
  id: string;
  systemId?: string;
  structureTypeId?: string;
  structureType?: string;
  name: string;
  ownerName?: string;
  ownerId?: string;
  ownerTicker?: string;
  notes?: string;
  status: StructureStatus;
  endTime?: string;
}

export const STRUCTURE_TYPE_MAP: Record&lt;string, string&gt; = {
  &apos;35825&apos;: &apos;Raitaru&apos;,
  &apos;35826&apos;: &apos;Azbel&apos;,
  &apos;35827&apos;: &apos;Sotiyo&apos;,
  &apos;35832&apos;: &apos;Astrahus&apos;,
  &apos;35833&apos;: &apos;Fortizar&apos;,
  &apos;35834&apos;: &apos;Keepstar&apos;,
  &apos;35835&apos;: &apos;Athanor&apos;,
  &apos;35836&apos;: &apos;Tatara&apos;,
  &apos;40340&apos;: &apos;Upwell Palatine Keepstar&apos;,
  &apos;47512&apos;: &quot;&apos;Moreau&apos; Fortizar&quot;,
  &apos;47513&apos;: &quot;&apos;Draccous&apos; Fortizar&quot;,
  &apos;47514&apos;: &quot;&apos;Horizon&apos; Fortizar&quot;,
  &apos;47515&apos;: &quot;&apos;Marginis&apos; Fortizar&quot;,
  &apos;47516&apos;: &quot;&apos;Prometheus&apos; Fortizar&quot;,
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/helpers/structureUtils.ts">import { StructureItem } from &apos;./structureTypes&apos;;

export function getActualStructures(oldList: StructureItem[], newList: StructureItem[]) {
  const oldMap = new Map(oldList.map(s =&gt; [s.id, s]));
  const newMap = new Map(newList.map(s =&gt; [s.id, s]));

  const added: StructureItem[] = [];
  const updated: StructureItem[] = [];
  const removed: StructureItem[] = [];

  for (const newItem of newList) {
    const oldItem = oldMap.get(newItem.id);
    if (!oldItem) {
      added.push(newItem);
    } else if (JSON.stringify(oldItem) !== JSON.stringify(newItem)) {
      updated.push(newItem);
    }
  }

  for (const oldItem of oldList) {
    if (!newMap.has(oldItem.id)) {
      removed.push(oldItem);
    }
  }

  return { added, updated, removed };
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function mapServerStructure(serverData: any): StructureItem {
  const { owner_id, owner_ticker, structure_type_id, structure_type, owner_name, end_time, system_id, ...rest } =
    serverData;

  return {
    ...rest,
    ownerId: owner_id,
    ownerTicker: owner_ticker,
    ownerName: owner_name,
    structureType: structure_type,
    structureTypeId: structure_type_id,
    endTime: end_time ?? &apos;&apos;,
    systemId: system_id,
  };
}

export function formatToISO(datetimeLocal: string): string {
  if (!datetimeLocal) return &apos;&apos;;

  // If missing seconds, add :00
  let iso = datetimeLocal;
  if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(iso)) {
    iso += &apos;:00&apos;;
  }
  // Ensure trailing &apos;Z&apos;
  if (!iso.endsWith(&apos;Z&apos;)) {
    iso += &apos;Z&apos;;
  }
  return iso;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/hooks/useSystemStructures.ts">import { useEffect, useState, useCallback } from &apos;react&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers&apos;;
import { mapServerStructure, getActualStructures, StructureItem, statusesRequiringTimer } from &apos;../helpers&apos;;

interface UseSystemStructuresProps {
  systemId: string | undefined;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  outCommand: (payload: any) =&gt; Promise&lt;any&gt;;
}

export function useSystemStructures({ systemId, outCommand }: UseSystemStructuresProps) {
  const [structures, setStructures] = useState&lt;StructureItem[]&gt;([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);

  const fetchStructures = useCallback(async () =&gt; {
    if (!systemId) {
      setStructures([]);
      return;
    }
    setIsLoading(true);
    setError(null);

    try {
      const { structures: fetched = [] } = await outCommand({
        type: OutCommand.getStructures,
        data: { system_id: systemId },
      });

      const mappedStructures = fetched.map(mapServerStructure);
      setStructures(mappedStructures);
    } catch (err) {
      console.error(&apos;Failed to get structures:&apos;, err);
      setError(&apos;Error fetching structures&apos;);
    } finally {
      setIsLoading(false);
    }
  }, [systemId, outCommand]);

  useEffect(() =&gt; {
    fetchStructures();
  }, [fetchStructures]);

  const sanitizeEndTimers = useCallback((item: StructureItem) =&gt; {
    if (!statusesRequiringTimer.includes(item.status)) {
      item.endTime = &apos;&apos;;
    }
    return item;
  }, []);

  const sanitizeIds = useCallback((item: StructureItem) =&gt; {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { id, ...rest } = item;
    return rest;
  }, []);

  const handleUpdateStructures = useCallback(
    async (newList: StructureItem[]) =&gt; {
      const { added, updated, removed } = getActualStructures(structures, newList);

      const sanitizedAdded = added.map(sanitizeIds);
      const sanitizedUpdated = updated.map(sanitizeEndTimers);

      try {
        const { structures: updatedStructures = [] } = await outCommand({
          type: OutCommand.updateStructures,
          data: {
            system_id: systemId,
            added: sanitizedAdded,
            updated: sanitizedUpdated,
            removed,
          },
        });

        const finalStructures = updatedStructures.map(mapServerStructure);
        setStructures(finalStructures);
      } catch (err) {
        console.error(&apos;Failed to update structures:&apos;, err);
      }
    },
    [structures, systemId, outCommand, sanitizeIds, sanitizeEndTimers],
  );

  return { structures, handleUpdateStructures, isLoading, error };
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/renders/cellRenders.tsx">import { StructureItem } from &apos;../helpers&apos;;
import { TimerCell } from &apos;./TimerCell&apos;;

export function renderTimerCell(row: StructureItem) {
  return &lt;TimerCell endTime={row.endTime} status={row.status} /&gt;;
}

export function renderOwnerCell(row: StructureItem) {
  return (
    &lt;div className=&quot;flex items-center gap-2&quot;&gt;
      {row.ownerId &amp;&amp; (
        &lt;img
          src={`https://images.evetech.net/corporations/${row.ownerId}/logo?size=32`}
          alt=&quot;corp icon&quot;
          className=&quot;w-5 h-5 object-contain&quot;
        /&gt;
      )}
      &lt;span&gt;{row.ownerTicker || row.ownerName}&lt;/span&gt;
    &lt;/div&gt;
  );
}

export function renderTypeCell(row: StructureItem) {
  return (
    &lt;div className=&quot;flex items-center gap-1&quot;&gt;
      {row.structureTypeId &amp;&amp; (
        &lt;img
          src={`https://images.evetech.net/types/${row.structureTypeId}/icon`}
          alt=&quot;icon&quot;
          className=&quot;w-5 h-5 object-contain&quot;
        /&gt;
      )}
      &lt;span&gt;{row.structureType ?? &apos;&apos;}&lt;/span&gt;
    &lt;/div&gt;
  );
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/renders/TimerCell.tsx">// File: TimerCell.tsx
import React, { useEffect, useState } from &apos;react&apos;;
import { StructureStatus } from &apos;../helpers/structureTypes&apos;;
import { statusesRequiringTimer } from &apos;../helpers&apos;;

interface TimerCellProps {
  endTime?: string;
  status: StructureStatus;
}

function TimerCellImpl({ endTime, status }: TimerCellProps) {
  const [now, setNow] = useState(() =&gt; Date.now());

  useEffect(() =&gt; {
    if (!endTime || !statusesRequiringTimer.includes(status)) {
      return;
    }

    const intervalId = setInterval(() =&gt; {
      setNow(Date.now());
    }, 1000);

    return () =&gt; clearInterval(intervalId);
  }, [endTime, status]);

  if (!statusesRequiringTimer.includes(status)) {
    return &lt;span className=&quot;text-stone-400&quot;&gt;&lt;/span&gt;;
  }
  if (!endTime) {
    return &lt;span className=&quot;text-sky-400&quot;&gt;Set Timer&lt;/span&gt;;
  }

  const msLeft = new Date(endTime).getTime() - now;
  if (msLeft &lt;= 0) {
    return &lt;span className=&quot;text-red-500&quot;&gt;00:00:00&lt;/span&gt;;
  }

  const sec = Math.floor(msLeft / 1000) % 60;
  const min = Math.floor(msLeft / (1000 * 60)) % 60;
  const hr = Math.floor(msLeft / (1000 * 3600));

  const pad = (n: number) =&gt; n.toString().padStart(2, &apos;0&apos;);
  return (
    &lt;span className=&quot;text-sky-400&quot;&gt;
      {pad(hr)}:{pad(min)}:{pad(sec)}
    &lt;/span&gt;
  );
}

export const TimerCell = React.memo(TimerCellImpl);</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/SystemStructuresContent/SystemStructuresContent.module.scss">.TableRowCompact {
  height: 8px;
  max-height: 8px;
  font-size: 12px !important;
  line-height: 8px;
}

.Table {
  font-size: 12px;
  border-collapse: collapse;
  table-layout: fixed;
  width: 100%;
}

.Table .p-datatable-tbody &gt; tr &gt; td {
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}

.Tooltip {
  white-space: pre-line;
  line-height: 1.2rem;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/SystemStructuresContent/SystemStructuresContent.tsx">import React, { useState, useCallback, useMemo } from &apos;react&apos;;
import { DataTable, DataTableRowClickEvent } from &apos;primereact/datatable&apos;;
import { Column } from &apos;primereact/column&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import clsx from &apos;clsx&apos;;

import { SystemStructuresDialog } from &apos;../SystemStructuresDialog/SystemStructuresDialog&apos;;
import { StructureItem } from &apos;../helpers/structureTypes&apos;;
import { useHotkey } from &apos;@/hooks/Mapper/hooks&apos;;
import classes from &apos;./SystemStructuresContent.module.scss&apos;;
import { renderOwnerCell, renderTypeCell, renderTimerCell } from &apos;../renders/cellRenders&apos;;

interface SystemStructuresContentProps {
  structures: StructureItem[];
  onUpdateStructures: (newList: StructureItem[]) =&gt; void;
}

export const SystemStructuresContent: React.FC&lt;SystemStructuresContentProps&gt; = ({ structures, onUpdateStructures }) =&gt; {
  const [selectedRow, setSelectedRow] = useState&lt;StructureItem | null&gt;(null);
  const [editingItem, setEditingItem] = useState&lt;StructureItem | null&gt;(null);
  const [showEditDialog, setShowEditDialog] = useState(false);

  const handleRowClick = (e: DataTableRowClickEvent) =&gt; {
    const row = e.data as StructureItem;
    setSelectedRow(prev =&gt; (prev?.id === row.id ? null : row));
  };

  const handleRowDoubleClick = (e: DataTableRowClickEvent) =&gt; {
    setEditingItem(e.data as StructureItem);
    setShowEditDialog(true);
  };

  // Press Delete =&gt; remove selected row
  const handleDeleteSelected = useCallback(
    (e: KeyboardEvent) =&gt; {
      if (!selectedRow) return;
      e.preventDefault();
      e.stopPropagation();

      const newList = structures.filter(s =&gt; s.id !== selectedRow.id);
      onUpdateStructures(newList);
      setSelectedRow(null);
    },
    [selectedRow, structures, onUpdateStructures],
  );

  useHotkey(false, [&apos;Delete&apos;, &apos;Backspace&apos;], handleDeleteSelected);

  const visibleStructures = useMemo(() =&gt; {
    return structures;
  }, [structures]);

  return (
    &lt;div className=&quot;flex flex-col gap-2 p-2 text-xs text-stone-200 h-full&quot;&gt;
      {visibleStructures.length === 0 ? (
        &lt;div className=&quot;flex-1 flex justify-center items-center text-stone-400/80 text-sm&quot;&gt;No structures&lt;/div&gt;
      ) : (
        &lt;div className=&quot;flex-1&quot;&gt;
          &lt;DataTable
            value={visibleStructures}
            dataKey=&quot;id&quot;
            className={clsx(classes.Table, &apos;w-full select-none h-full&apos;)}
            size=&quot;small&quot;
            sortMode=&quot;single&quot;
            rowHover
            style={{ tableLayout: &apos;fixed&apos;, width: &apos;100%&apos; }}
            onRowClick={handleRowClick}
            onRowDoubleClick={handleRowDoubleClick}
            rowClassName={rowData =&gt; {
              const isSelected = selectedRow?.id === rowData.id;
              return clsx(
                classes.TableRowCompact,
                &apos;transition-colors duration-200 cursor-pointer&apos;,
                isSelected ? &apos;bg-amber-500/50 hover:bg-amber-500/70&apos; : &apos;hover:bg-purple-400/20&apos;,
              );
            }}
          &gt;
            &lt;Column
              header=&quot;Type&quot;
              body={renderTypeCell}
              style={{
                width: &apos;160px&apos;,
                whiteSpace: &apos;nowrap&apos;,
                overflow: &apos;hidden&apos;,
                textOverflow: &apos;ellipsis&apos;,
              }}
            /&gt;
            &lt;Column
              field=&quot;name&quot;
              header=&quot;Name&quot;
              style={{
                width: &apos;120px&apos;,
                whiteSpace: &apos;nowrap&apos;,
                overflow: &apos;hidden&apos;,
                textOverflow: &apos;ellipsis&apos;,
              }}
            /&gt;
            &lt;Column
              header=&quot;Owner&quot;
              body={renderOwnerCell}
              style={{
                width: &apos;120px&apos;,
                whiteSpace: &apos;nowrap&apos;,
                overflow: &apos;hidden&apos;,
                textOverflow: &apos;ellipsis&apos;,
              }}
            /&gt;
            &lt;Column
              field=&quot;status&quot;
              header=&quot;Status&quot;
              style={{
                width: &apos;100px&apos;,
                whiteSpace: &apos;nowrap&apos;,
                overflow: &apos;hidden&apos;,
                textOverflow: &apos;ellipsis&apos;,
              }}
            /&gt;
            &lt;Column
              header=&quot;Timer&quot;
              body={renderTimerCell}
              style={{
                width: &apos;110px&apos;,
                whiteSpace: &apos;nowrap&apos;,
                overflow: &apos;hidden&apos;,
                textOverflow: &apos;ellipsis&apos;,
              }}
            /&gt;
            &lt;Column
              body={(rowData: StructureItem) =&gt; (
                &lt;i
                  className={clsx(PrimeIcons.PENCIL, &apos;text-[14px] cursor-pointer&apos;)}
                  title=&quot;Edit&quot;
                  onClick={() =&gt; {
                    setEditingItem(rowData);
                    setShowEditDialog(true);
                  }}
                /&gt;
              )}
              style={{
                width: &apos;40px&apos;,
                textAlign: &apos;center&apos;,
                whiteSpace: &apos;nowrap&apos;,
                overflow: &apos;hidden&apos;,
                textOverflow: &apos;ellipsis&apos;,
              }}
            /&gt;
          &lt;/DataTable&gt;
        &lt;/div&gt;
      )}

      {showEditDialog &amp;&amp; editingItem &amp;&amp; (
        &lt;SystemStructuresDialog
          visible={showEditDialog}
          structure={editingItem}
          onClose={() =&gt; setShowEditDialog(false)}
          onSave={(updatedItem: StructureItem) =&gt; {
            const newList = structures.map(s =&gt; (s.id === updatedItem.id ? updatedItem : s));
            onUpdateStructures(newList);
            setShowEditDialog(false);
          }}
          onDelete={(deleteId: string) =&gt; {
            const newList = structures.filter(s =&gt; s.id !== deleteId);
            onUpdateStructures(newList);
            setShowEditDialog(false);
          }}
        /&gt;
      )}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/SystemStructuresDialog/SystemStructureDialog.module.scss">.systemStructureDialog {
  
    .p-dialog-content {
      background-color: var(--surface-800) !important;
    }
  
    .p-dialog-header {
      background-color: var(--surface-700);
      color: var(--text-color);
    }
  
    .p-dialog-header-icon,
    .p-dialog-header-title {
      color: var(--gray-200);
    }
  
    .p-inputtext {
      background-color: #2a2a2a !important;
      color: #ddd !important;
      font-size: 12px !important;
      padding: 0.25rem 0.5rem !important;
    }
  
    .p-dialog-footer {
      .p-button {
        font-size: 12px !important;
        padding: 0.3rem 0.75rem !important;
      }
    }
  }</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/SystemStructuresDialog/SystemStructuresDialog.tsx">import React, { useEffect, useState, useCallback } from &apos;react&apos;;
import { Dialog } from &apos;primereact/dialog&apos;;
import { Button } from &apos;primereact/button&apos;;
import { AutoComplete } from &apos;primereact/autocomplete&apos;;
import { Calendar } from &apos;primereact/calendar&apos;;
import clsx from &apos;clsx&apos;;

import { StructureItem, StructureStatus, statusesRequiringTimer, formatToISO } from &apos;../helpers&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types&apos;;

interface StructuresEditDialogProps {
  visible: boolean;
  structure?: StructureItem;
  onClose: () =&gt; void;
  onSave: (updatedItem: StructureItem) =&gt; void;
  onDelete: (id: string) =&gt; void;
}

export const SystemStructuresDialog: React.FC&lt;StructuresEditDialogProps&gt; = ({
  visible,
  structure,
  onClose,
  onSave,
  onDelete,
}) =&gt; {
  const [editData, setEditData] = useState&lt;StructureItem | null&gt;(null);
  const [ownerInput, setOwnerInput] = useState(&apos;&apos;);
  const [ownerSuggestions, setOwnerSuggestions] = useState&lt;{ label: string; value: string }[]&gt;([]);

  const { outCommand } = useMapRootState();

  const [prevQuery, setPrevQuery] = useState(&apos;&apos;);
  const [prevResults, setPrevResults] = useState&lt;{ label: string; value: string }[]&gt;([]);

  useEffect(() =&gt; {
    if (structure) {
      setEditData(structure);
      setOwnerInput(structure.ownerName ?? &apos;&apos;);
    } else {
      setEditData(null);
      setOwnerInput(&apos;&apos;);
    }
  }, [structure]);

  // Searching corporation owners via auto-complete
  const searchOwners = useCallback(
    async (e: { query: string }) =&gt; {
      const newQuery = e.query.trim();
      if (!newQuery) {
        setOwnerSuggestions([]);
        return;
      }

      // If user typed more text but we have partial match in prevResults
      if (newQuery.startsWith(prevQuery) &amp;&amp; prevResults.length &gt; 0) {
        const filtered = prevResults.filter(item =&gt;
          item.label.toLowerCase().includes(newQuery.toLowerCase()),
        );
        setOwnerSuggestions(filtered);
        return;
      }

      try {
        const { results = [] } = await outCommand({
          type: OutCommand.getCorporationNames,
          data: { search: newQuery },
        });
        setOwnerSuggestions(results);
        setPrevQuery(newQuery);
        setPrevResults(results);
      } catch (err) {
        console.error(&apos;Failed to fetch owners:&apos;, err);
        setOwnerSuggestions([]);
      }
    },
    [prevQuery, prevResults, outCommand],
  );

  const handleChange = (field: keyof StructureItem, val: string | Date) =&gt; {
    // If we want to forbid changing structureTypeId or structureType from the dialog, do so here:
    if (field === &apos;structureTypeId&apos; || field === &apos;structureType&apos;) return;

    setEditData(prev =&gt; {
      if (!prev) return null;

      // If this is the endTime (Date from Calendar), we store as ISO or string:
      if (field === &apos;endTime&apos; &amp;&amp; val instanceof Date) {
        return { ...prev, endTime: val.toISOString() };
      }

      return { ...prev, [field]: val };
    });
  };

  // when user picks a corp from auto-complete
  const handleSelectOwner = (selected: { label: string; value: string }) =&gt; {
    setOwnerInput(selected.label);
    setEditData(prev =&gt;
      prev ? { ...prev, ownerName: selected.label, ownerId: selected.value } : null,
    );
  };

  const handleStatusChange = (val: string) =&gt; {
    setEditData(prev =&gt; {
      if (!prev) return null;
      const newStatus = val as StructureStatus;
      // If new status doesn&apos;t require a timer, we clear out endTime
      const newEndTime = statusesRequiringTimer.includes(newStatus) ? prev.endTime : &apos;&apos;;
      return { ...prev, status: newStatus, endTime: newEndTime };
    });
  };

  const handleSaveClick = async () =&gt; {
    if (!editData) return;

    // If status doesn&apos;t require a timer, clear endTime
    if (!statusesRequiringTimer.includes(editData.status)) {
      editData.endTime = &apos;&apos;;
    } else if (editData.endTime) {
      // convert to full ISO if not already
      editData.endTime = formatToISO(editData.endTime);
    }

    // fetch corporation ticker if we have an ownerId
    if (editData.ownerId) {
      try {
        const { ticker } = await outCommand({
          type: OutCommand.getCorporationTicker,
          data: { corp_id: editData.ownerId },
        });
        editData.ownerTicker = ticker ?? &apos;&apos;;
      } catch (err) {
        console.error(&apos;Failed to fetch ticker:&apos;, err);
        editData.ownerTicker = &apos;&apos;;
      }
    }

    onSave(editData);
  };

  const handleDeleteClick = () =&gt; {
    if (!editData) return;
    onDelete(editData.id);
    onClose();
  };

  if (!editData) return null;

  return (
    &lt;Dialog
      visible={visible}
      onHide={onClose}
      header={`Edit Structure - ${editData.name ?? &apos;&apos;}`}
      className={clsx(&apos;myStructuresDialog&apos;, &apos;text-stone-200 w-full max-w-md&apos;)}
    &gt;
      &lt;div className=&quot;flex flex-col gap-2 text-[14px]&quot;&gt;
        &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center&quot;&gt;
          &lt;span&gt;Type:&lt;/span&gt;
          &lt;input
            readOnly
            className=&quot;p-inputtext p-component cursor-not-allowed&quot;
            value={editData.structureType ?? &apos;&apos;}
          /&gt;
        &lt;/label&gt;
        &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center&quot;&gt;
          &lt;span&gt;Name:&lt;/span&gt;
          &lt;input
            className=&quot;p-inputtext p-component&quot;
            value={editData.name ?? &apos;&apos;}
            onChange={e =&gt; handleChange(&apos;name&apos;, e.target.value)}
          /&gt;
        &lt;/label&gt;
        &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center&quot;&gt;
          &lt;span&gt;Owner:&lt;/span&gt;
          &lt;AutoComplete
            id=&quot;owner&quot;
            value={ownerInput}
            suggestions={ownerSuggestions}
            completeMethod={searchOwners}
            minLength={3}
            delay={400}
            field=&quot;label&quot;
            placeholder=&quot;Corporation name...&quot;
            onChange={e =&gt; setOwnerInput(e.value)}
            onSelect={e =&gt; handleSelectOwner(e.value)}
          /&gt;
        &lt;/label&gt;
        &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center&quot;&gt;
          &lt;span&gt;Status:&lt;/span&gt;
          &lt;select
            className=&quot;p-inputtext p-component&quot;
            value={editData.status}
            onChange={e =&gt; handleStatusChange(e.target.value)}
          &gt;
            &lt;option value=&quot;Powered&quot;&gt;Powered&lt;/option&gt;
            &lt;option value=&quot;Anchoring&quot;&gt;Anchoring&lt;/option&gt;
            &lt;option value=&quot;Unanchoring&quot;&gt;Unanchoring&lt;/option&gt;
            &lt;option value=&quot;Low Power&quot;&gt;Low Power&lt;/option&gt;
            &lt;option value=&quot;Abandoned&quot;&gt;Abandoned&lt;/option&gt;
            &lt;option value=&quot;Reinforced&quot;&gt;Reinforced&lt;/option&gt;
          &lt;/select&gt;
        &lt;/label&gt;

        {statusesRequiringTimer.includes(editData.status) &amp;&amp; (
          &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center&quot;&gt;
            &lt;span&gt;Timer &lt;br /&gt; (Eve Time):&lt;/span&gt;
            &lt;Calendar
              value={editData.endTime ? new Date(editData.endTime) : undefined}
              onChange={(e) =&gt; handleChange(&apos;endTime&apos;, e.value ?? &apos;&apos;)}
              showTime
              hourFormat=&quot;24&quot;
              dateFormat=&quot;yy-mm-dd&quot;
              showIcon
            /&gt;
          &lt;/label&gt;
        )}

        &lt;label className=&quot;grid grid-cols-[100px_1fr] gap-2 items-start mt-2&quot;&gt;
          &lt;span className=&quot;mt-1&quot;&gt;Notes:&lt;/span&gt;
          &lt;textarea
            className=&quot;p-inputtext p-component resize-none h-24&quot;
            value={editData.notes ?? &apos;&apos;}
            onChange={e =&gt; handleChange(&apos;notes&apos;, e.target.value)}
          /&gt;
        &lt;/label&gt;
      &lt;/div&gt;

      &lt;div className=&quot;flex justify-end items-center gap-2 mt-4&quot;&gt;
        &lt;Button label=&quot;Delete&quot; severity=&quot;danger&quot; className=&quot;p-button-sm&quot; onClick={handleDeleteClick} /&gt;
        &lt;Button label=&quot;Save&quot; className=&quot;p-button-sm&quot; onClick={handleSaveClick} /&gt;
      &lt;/div&gt;
    &lt;/Dialog&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/index.ts">export * from &apos;./SystemStructures&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/SystemStructures/SystemStructures.tsx">import React, { useCallback, ClipboardEvent, useRef } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import useMaxWidth from &apos;@/hooks/Mapper/hooks/useMaxWidth&apos;;
import {
  LayoutEventBlocker,
  WdImgButton,
  TooltipPosition,
  InfoDrawer,
  SystemView,
} from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { Widget } from &apos;@/hooks/Mapper/components/mapInterface/components&apos;;

import { SystemStructuresContent } from &apos;./SystemStructuresContent/SystemStructuresContent&apos;;
import { useSystemStructures } from &apos;./hooks/useSystemStructures&apos;;
import { processSnippetText } from &apos;./helpers&apos;;

export const SystemStructures: React.FC = () =&gt; {
  const {
    data: { selectedSystems },
    outCommand,
  } = useMapRootState();
  const [systemId] = selectedSystems;
  const isNotSelectedSystem = selectedSystems.length !== 1;

  const { structures, handleUpdateStructures } = useSystemStructures({ systemId, outCommand });

  const labelRef = useRef&lt;HTMLDivElement&gt;(null);
  const isCompact = useMaxWidth(labelRef, 260);

  const processClipboard = useCallback(
    (text: string) =&gt; {
      const updated = processSnippetText(text, structures);
      handleUpdateStructures(updated);
    },
    [structures, handleUpdateStructures],
  );

  const handlePaste = useCallback(
    (e: ClipboardEvent&lt;HTMLDivElement&gt;) =&gt; {
      e.preventDefault();
      processClipboard(e.clipboardData.getData(&apos;text&apos;));
    },
    [processClipboard],
  );

  const handlePasteTimer = useCallback(async () =&gt; {
    try {
      const text = await navigator.clipboard.readText();
      processClipboard(text);
    } catch (err) {
      console.error(&apos;Clipboard read error:&apos;, err);
    }
  }, [processClipboard]);

  function renderWidgetLabel() {
    return (
      &lt;div className=&quot;flex justify-between items-center text-xs w-full h-full&quot; ref={labelRef}&gt;
        &lt;div className=&quot;flex justify-between items-center gap-1&quot;&gt;
          {!isCompact &amp;&amp; (
            &lt;div className=&quot;flex whitespace-nowrap text-ellipsis overflow-hidden text-stone-400&quot;&gt;
              Structures
              {!isNotSelectedSystem &amp;&amp; &apos; in&apos;}
            &lt;/div&gt;
          )}
          {!isNotSelectedSystem &amp;&amp; &lt;SystemView systemId={systemId} className=&quot;select-none text-center&quot; hideRegion /&gt;}
        &lt;/div&gt;

        &lt;LayoutEventBlocker className=&quot;flex gap-2.5&quot;&gt;
          &lt;WdImgButton
            className={`${PrimeIcons.CLOCK} text-sky-400 hover:text-sky-200 transition duration-300`}
            onClick={handlePasteTimer}
            tooltip={{
              position: TooltipPosition.left,
              // @ts-ignore
              content: &apos;Add Structures/Timer&apos;,
            }}
          /&gt;
          &lt;WdImgButton
            className={PrimeIcons.QUESTION_CIRCLE}
            tooltip={{
              position: TooltipPosition.left,
              // @ts-ignore
              content: (
                &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
                  &lt;InfoDrawer title={&lt;b className=&quot;text-slate-50&quot;&gt;How to add/update structures?&lt;/b&gt;}&gt;
                    In game, select one or more structures in D-Scan and then
                    &lt;br /&gt;
                    use the blue add structure data button
                  &lt;/InfoDrawer&gt;
                  &lt;InfoDrawer title={&lt;b className=&quot;text-slate-50&quot;&gt;How to add a timer?&lt;/b&gt;}&gt;
                    In game, select a structure with an active timer, right click to copy, and then
                    &lt;span className=&quot;text-blue-500&quot;&gt; blue &lt;/span&gt;
                    use the blue add structure data button
                  &lt;/InfoDrawer&gt;
                &lt;/div&gt;
              ),
            }}
          /&gt;
        &lt;/LayoutEventBlocker&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div tabIndex={0} onPaste={handlePaste} className=&quot;h-full flex flex-col&quot; style={{ outline: &apos;none&apos; }}&gt;
      &lt;Widget label={renderWidgetLabel()}&gt;
        {isNotSelectedSystem ? (
          &lt;div className=&quot;w-full h-full flex justify-center items-center select-none text-center text-stone-400/80 text-sm&quot;&gt;
            System is not selected
          &lt;/div&gt;
        ) : (
          &lt;SystemStructuresContent structures={structures} onUpdateStructures={handleUpdateStructures} /&gt;
        )}
      &lt;/Widget&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WRoutesPublic/index.ts">export * from &apos;./WRoutesPublic&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WRoutesPublic/WRoutesPublic.tsx">import { Commands, OutCommand } from &apos;@/hooks/Mapper/types&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import {
  AddHubCommand,
  LoadRoutesCommand,
  RoutesImperativeHandle,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/types.ts&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { RoutesWidget } from &apos;@/hooks/Mapper/components/mapInterface/widgets&apos;;
import { useMapEventListener } from &apos;@/hooks/Mapper/events&apos;;

export const WRoutesPublic = () =&gt; {
  const {
    outCommand,
    storedSettings: { settingsRoutes, settingsRoutesUpdate },
    data: { hubs, routes },
  } = useMapRootState();

  const ref = useRef&lt;RoutesImperativeHandle&gt;(null);

  const loadRoutesCommand: LoadRoutesCommand = useCallback(
    async (systemId, routesSettings) =&gt; {
      outCommand({
        type: OutCommand.getRoutes,
        data: {
          system_id: systemId,
          routes_settings: routesSettings,
        },
      });
    },
    [outCommand],
  );

  const addHubCommand: AddHubCommand = useCallback(
    async systemId =&gt; {
      if (hubs.includes(systemId)) {
        return;
      }

      await outCommand({
        type: OutCommand.addHub,
        data: { system_id: systemId },
      });
    },
    [hubs, outCommand],
  );

  const toggleHubCommand: AddHubCommand = useCallback(
    async (systemId: string | undefined) =&gt; {
      if (!systemId) {
        return;
      }

      outCommand({
        type: !hubs.includes(systemId) ? OutCommand.addHub : OutCommand.deleteHub,
        data: {
          system_id: systemId,
        },
      });
    },
    [hubs, outCommand],
  );

  useMapEventListener(event =&gt; {
    if (event.name === Commands.routes) {
      ref.current?.stopLoading();
    }
  });

  return (
    &lt;RoutesWidget
      ref={ref}
      title=&quot;Routes&quot;
      data={settingsRoutes}
      update={settingsRoutesUpdate}
      hubs={hubs}
      routesList={routes}
      loadRoutesCommand={loadRoutesCommand}
      addHubCommand={addHubCommand}
      toggleHubCommand={toggleHubCommand}
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WRoutesUser/index.ts">export * from &apos;./WRoutesUser&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WRoutesUser/WRoutesUser.tsx">import { Commands, OutCommand } from &apos;@/hooks/Mapper/types&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import {
  AddHubCommand,
  LoadRoutesCommand,
  RoutesImperativeHandle,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/RoutesWidget/types.ts&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { RoutesWidget } from &apos;@/hooks/Mapper/components/mapInterface/widgets&apos;;
import { useMapEventListener } from &apos;@/hooks/Mapper/events&apos;;

export const WRoutesUser = () =&gt; {
  const {
    outCommand,
    storedSettings: { settingsRoutes, settingsRoutesUpdate },
    data: { userHubs, userRoutes },
  } = useMapRootState();

  const ref = useRef&lt;RoutesImperativeHandle&gt;(null);

  const loadRoutesCommand: LoadRoutesCommand = useCallback(
    async (systemId, routesSettings) =&gt; {
      outCommand({
        type: OutCommand.getUserRoutes,
        data: {
          system_id: systemId,
          routes_settings: routesSettings,
        },
      });
    },
    [outCommand],
  );

  const addHubCommand: AddHubCommand = useCallback(
    async systemId =&gt; {
      if (userHubs.includes(systemId)) {
        return;
      }

      await outCommand({
        type: OutCommand.addUserHub,
        data: { system_id: systemId },
      });
    },
    [userHubs, outCommand],
  );

  const toggleHubCommand: AddHubCommand = useCallback(
    async (systemId: string | undefined) =&gt; {
      if (!systemId) {
        return;
      }

      outCommand({
        type: !userHubs.includes(systemId) ? OutCommand.addUserHub : OutCommand.deleteUserHub,
        data: {
          system_id: systemId,
        },
      });
    },
    [userHubs, outCommand],
  );

  useMapEventListener(event =&gt; {
    if (event.name === Commands.userRoutes) {
      ref.current?.stopLoading();
    }
    return true;
  });

  return (
    &lt;RoutesWidget
      ref={ref}
      title=&quot;User Routes&quot;
      data={settingsRoutes}
      update={settingsRoutesUpdate}
      hubs={userHubs}
      routesList={userRoutes}
      loadRoutesCommand={loadRoutesCommand}
      addHubCommand={addHubCommand}
      toggleHubCommand={toggleHubCommand}
      isRestricted
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/components/KillItemTemplate.tsx">import { DetailedKill } from &apos;@/hooks/Mapper/types/kills&apos;;
import { VirtualScrollerTemplateOptions } from &apos;primereact/virtualscroller&apos;;
import { KillRowDetail } from &apos;@/hooks/Mapper/components/mapInterface/widgets/WSystemKills/components/KillRowDetail.tsx&apos;;
import clsx from &apos;clsx&apos;;
import { getSystemStaticInfo } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic&apos;;

export const KillItemTemplate = (
  onlyOneSystem: boolean,
  kill: DetailedKill,
  options: VirtualScrollerTemplateOptions,
) =&gt; {
  const systemName = getSystemStaticInfo(kill.solar_system_id)?.solar_system_name || `System ${kill.solar_system_id}`;

  return (
    &lt;div style={{ height: `${options.props.itemSize}px` }}&gt;
      &lt;KillRowDetail
        killDetails={kill}
        systemName={systemName}
        onlyOneSystem={onlyOneSystem}
        className={clsx(options.odd &amp;&amp; &apos;bg-stone-800/50&apos;)}
      /&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/components/KillRowDetail.module.scss">.killRowContainer {
  @apply flex items-center whitespace-nowrap overflow-hidden;
  &amp;:not(:last-child) {
    @apply border-b border-stone-800;
  }
  @apply bg-transparent transition-all hover:bg-stone-900 hover:border-stone-700;
}

.killRowImage {
  @apply border border-stone-800 rounded-[4px] object-contain;
}

.attackerCountLabel {
  position: absolute;
  bottom: 0;
  right: 0;
  font-size: 10px;
  padding: 0 2px;
}

.attackerCountLabelCompact {
  position: absolute;
  left: 0;
  bottom: 0;
  font-size: 0.6rem;
  line-height: 1;
  background-color: rgba(0, 0, 0, 0.7);
  padding: 1px 2px;
  pointer-events: none;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/components/KillRowDetail.tsx">import { useMemo } from &apos;react&apos;;
import clsx from &apos;clsx&apos;;
import { DetailedKill } from &apos;@/hooks/Mapper/types/kills&apos;;
import {
  formatISK,
  formatTimeMixed,
  zkillLink,
  getAttackerSubscript,
  buildVictimImageUrls,
  buildAttackerImageUrls,
  getPrimaryLogoAndTooltip,
  getAttackerPrimaryImageAndTooltip,
} from &apos;../helpers&apos;;
import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import classes from &apos;./KillRowDetail.module.scss&apos;;
import { TooltipPosition } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { WithClassName } from &apos;@/hooks/Mapper/types/common.ts&apos;;

export type CompactKillRowProps = {
  killDetails: DetailedKill;
  systemName: string;
  onlyOneSystem: boolean;
} &amp; WithClassName;

export const KillRowDetail = ({ killDetails, systemName, onlyOneSystem, className }: CompactKillRowProps) =&gt; {
  const {
    killmail_id = 0,
    // Victim data
    victim_char_name = &apos;Unknown Pilot&apos;,
    victim_alliance_ticker = &apos;&apos;,
    victim_corp_ticker = &apos;&apos;,
    victim_ship_name = &apos;Unknown Ship&apos;,
    victim_corp_name = &apos;&apos;,
    victim_alliance_name = &apos;&apos;,
    victim_char_id = 0,
    victim_corp_id = 0,
    victim_alliance_id = 0,
    victim_ship_type_id = 0,
    // Attacker data
    final_blow_char_id = 0,
    final_blow_char_name = &apos;&apos;,
    final_blow_alliance_ticker = &apos;&apos;,
    final_blow_alliance_name = &apos;&apos;,
    final_blow_alliance_id = 0,
    final_blow_corp_ticker = &apos;&apos;,
    final_blow_corp_id = 0,
    final_blow_corp_name = &apos;&apos;,
    final_blow_ship_type_id = 0,
    kill_time = &apos;&apos;,
    total_value = 0,
  } = killDetails || {};

  const attackerIsNpc = final_blow_char_id === 0;

  // Define victim affiliation ticker.
  const victimAffiliationTicker = victim_alliance_ticker || victim_corp_ticker || &apos;No Ticker&apos;;

  const killValueFormatted = total_value != null &amp;&amp; total_value &gt; 0 ? `${formatISK(total_value)} ISK` : null;
  const killTimeAgo = kill_time ? formatTimeMixed(kill_time) : &apos;0h ago&apos;;

  const attackerSubscript = getAttackerSubscript(killDetails);

  const { victimCorpLogoUrl, victimAllianceLogoUrl, victimShipUrl } = buildVictimImageUrls({
    victim_char_id,
    victim_ship_type_id,
    victim_corp_id,
    victim_alliance_id,
  });

  const { attackerCorpLogoUrl, attackerAllianceLogoUrl } = buildAttackerImageUrls({
    final_blow_char_id,
    final_blow_corp_id,
    final_blow_alliance_id,
  });

  const { url: victimPrimaryLogoUrl, tooltip: victimPrimaryTooltip } = getPrimaryLogoAndTooltip(
    victimAllianceLogoUrl,
    victimCorpLogoUrl,
    victim_alliance_name,
    victim_corp_name,
    &apos;Victim&apos;,
  );

  const { url: attackerPrimaryImageUrl, tooltip: attackerPrimaryTooltip } = useMemo(
    () =&gt;
      getAttackerPrimaryImageAndTooltip(
        attackerIsNpc,
        attackerAllianceLogoUrl,
        attackerCorpLogoUrl,
        final_blow_alliance_name,
        final_blow_corp_name,
        final_blow_ship_type_id,
      ),
    [
      attackerAllianceLogoUrl,
      attackerCorpLogoUrl,
      attackerIsNpc,
      final_blow_alliance_name,
      final_blow_corp_name,
      final_blow_ship_type_id,
    ],
  );

  // Define attackerTicker to use the alliance ticker if available, otherwise the corp ticker.
  const attackerTicker = attackerIsNpc ? &apos;&apos; : final_blow_alliance_ticker || final_blow_corp_ticker || &apos;&apos;;

  // For the attacker image link: if the attacker is not an NPC, link to the character page; otherwise, link to the kill page.
  const attackerLink = attackerIsNpc ? zkillLink(&apos;kill&apos;, killmail_id) : zkillLink(&apos;character&apos;, final_blow_char_id);

  return (
    &lt;div
      className={clsx(
        &apos;h-10 flex items-center border-b border-stone-800&apos;,
        &apos;text-xs whitespace-nowrap overflow-hidden leading-none&apos;,
        &apos;px-1&apos;,
        className,
      )}
    &gt;
      {/* Victim Section */}
      &lt;div className=&quot;flex items-center gap-1&quot;&gt;
        {victimShipUrl &amp;&amp; (
          &lt;div className=&quot;relative shrink-0 w-8 h-8 overflow-hidden&quot;&gt;
            &lt;a
              href={zkillLink(&apos;kill&apos;, killmail_id)}
              target=&quot;_blank&quot;
              rel=&quot;noopener noreferrer&quot;
              className=&quot;block w-full h-full&quot;
            &gt;
              &lt;img
                src={victimShipUrl}
                alt=&quot;Victim Ship&quot;
                className={clsx(classes.killRowImage, &apos;w-full h-full object-contain&apos;)}
              /&gt;
            &lt;/a&gt;
          &lt;/div&gt;
        )}
        {victimPrimaryLogoUrl &amp;&amp; (
          &lt;WdTooltipWrapper content={victimPrimaryTooltip} position={TooltipPosition.top}&gt;
            &lt;a
              href={zkillLink(&apos;kill&apos;, killmail_id)}
              target=&quot;_blank&quot;
              rel=&quot;noopener noreferrer&quot;
              className=&quot;relative block shrink-0 w-8 h-8 overflow-hidden&quot;
            &gt;
              &lt;img
                src={victimPrimaryLogoUrl}
                alt=&quot;Victim Primary Logo&quot;
                className={clsx(classes.killRowImage, &apos;w-full h-full object-contain&apos;)}
              /&gt;
            &lt;/a&gt;
          &lt;/WdTooltipWrapper&gt;
        )}
      &lt;/div&gt;
      &lt;div className=&quot;flex flex-col ml-2 flex-1 min-w-0 overflow-hidden leading-[1rem]&quot;&gt;
        &lt;div className=&quot;truncate text-stone-200&quot;&gt;
          {victim_char_name}
          &lt;span className=&quot;text-stone-400&quot;&gt; / {victimAffiliationTicker}&lt;/span&gt;
        &lt;/div&gt;
        &lt;div className=&quot;truncate text-stone-300 flex items-center gap-1&quot;&gt;
          &lt;span className=&quot;text-stone-400 overflow-hidden text-ellipsis whitespace-nowrap max-w-[140px]&quot;&gt;
            {victim_ship_name}
          &lt;/span&gt;
          {killValueFormatted &amp;&amp; (
            &lt;&gt;
              &lt;span className=&quot;text-stone-400&quot;&gt;/&lt;/span&gt;
              &lt;span className=&quot;text-green-400&quot;&gt;{killValueFormatted}&lt;/span&gt;
            &lt;/&gt;
          )}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;flex items-center ml-auto gap-2&quot;&gt;
        &lt;div className=&quot;flex flex-col items-end flex-1 min-w-0 overflow-hidden text-right leading-[1rem]&quot;&gt;
          {!attackerIsNpc &amp;&amp; (final_blow_char_name || attackerTicker) &amp;&amp; (
            &lt;div className=&quot;truncate text-stone-200&quot;&gt;
              {final_blow_char_name}
              {!attackerIsNpc &amp;&amp; attackerTicker &amp;&amp; &lt;span className=&quot;ml-1 text-stone-400&quot;&gt;/ {attackerTicker}&lt;/span&gt;}
            &lt;/div&gt;
          )}
          &lt;div className=&quot;truncate text-stone-400&quot;&gt;
            {!onlyOneSystem &amp;&amp; systemName ? (
              &lt;&gt;
                {systemName} / &lt;span className=&quot;ml-1 text-red-400&quot;&gt;{killTimeAgo}&lt;/span&gt;
              &lt;/&gt;
            ) : (
              &lt;span className=&quot;text-red-400&quot;&gt;{killTimeAgo}&lt;/span&gt;
            )}
          &lt;/div&gt;
        &lt;/div&gt;
        {attackerPrimaryImageUrl &amp;&amp; (
          &lt;WdTooltipWrapper content={attackerPrimaryTooltip} position={TooltipPosition.top}&gt;
            &lt;a
              href={attackerLink}
              target=&quot;_blank&quot;
              rel=&quot;noopener noreferrer&quot;
              className=&quot;relative block shrink-0 w-8 h-8 overflow-hidden&quot;
            &gt;
              &lt;img
                src={attackerPrimaryImageUrl}
                alt={attackerIsNpc ? &apos;NPC Ship&apos; : &apos;Attacker Primary Logo&apos;}
                className={clsx(classes.killRowImage, &apos;w-full h-full object-contain&apos;)}
              /&gt;
              {attackerSubscript &amp;&amp; (
                &lt;span
                  className={clsx(
                    classes.attackerCountLabel,
                    attackerSubscript.cssClass,
                    &apos;text-[0.6rem] leading-none px-[2px]&apos;,
                  )}
                &gt;
                  {attackerSubscript.label}
                &lt;/span&gt;
              )}
            &lt;/a&gt;
          &lt;/WdTooltipWrapper&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/components/SystemKillsHeader.tsx">import React, { useRef } from &apos;react&apos;;
import {
  LayoutEventBlocker,
  SystemView,
  TooltipPosition,
  WdCheckbox,
  WdImgButton,
  WdTooltipWrapper,
} from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { useKillsWidgetSettings } from &apos;../hooks/useKillsWidgetSettings&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import useMaxWidth from &apos;@/hooks/Mapper/hooks/useMaxWidth.ts&apos;;

interface KillsHeaderProps {
  systemId?: string;
  onOpenSettings: () =&gt; void;
}

export const KillsHeader: React.FC&lt;KillsHeaderProps&gt; = ({ systemId, onOpenSettings }) =&gt; {
  const [settings, setSettings] = useKillsWidgetSettings();
  const { showAll } = settings;

  const onToggleShowAllVisible = () =&gt; {
    setSettings(prev =&gt; ({ ...prev, showAll: !prev.showAll }));
  };

  const headerRef = useRef&lt;HTMLDivElement&gt;(null);
  const compact = useMaxWidth(headerRef, 150);

  return (
    &lt;div className=&quot;flex w-full items-center justify-between text-xs&quot; ref={headerRef}&gt;
      &lt;div className=&quot;flex items-center gap-1&quot;&gt;
        &lt;div className=&quot;text-stone-400&quot;&gt;
          Kills
          {systemId &amp;&amp; !showAll &amp;&amp; &apos; in &apos;}
        &lt;/div&gt;
        {systemId &amp;&amp; !showAll &amp;&amp; &lt;SystemView systemId={systemId} className=&quot;select-none text-center&quot; hideRegion /&gt;}
      &lt;/div&gt;

      &lt;LayoutEventBlocker className=&quot;flex items-center gap-2 justify-end&quot;&gt;
        &lt;div className=&quot;flex items-center gap-2&quot;&gt;
          &lt;WdTooltipWrapper content=&quot;Show all systems&quot; position={TooltipPosition.top}&gt;
            &lt;WdCheckbox
              size=&quot;xs&quot;
              labelSide=&quot;left&quot;
              label={compact ? &apos;All&apos; : &apos;Show all systems&apos;}
              value={showAll}
              onChange={onToggleShowAllVisible}
              classNameLabel=&quot;whitespace-nowrap text-stone-400 hover:text-stone-200 transition duration-300&quot;
            /&gt;
          &lt;/WdTooltipWrapper&gt;

          &lt;WdImgButton
            className={PrimeIcons.SLIDERS_H}
            onClick={onOpenSettings}
            tooltip={{
              content: &apos;Open Kills Settings&apos;,
              position: TooltipPosition.top,
            }}
          /&gt;
        &lt;/div&gt;
      &lt;/LayoutEventBlocker&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/components/SystemKillsSettingsDialog.tsx">import React, { useCallback, useEffect, useRef, useState } from &apos;react&apos;;
import { Dialog } from &apos;primereact/dialog&apos;;
import { Button } from &apos;primereact/button&apos;;
import { WdImgButton } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { PrimeIcons } from &apos;primereact/api&apos;;
import { useKillsWidgetSettings } from &apos;../hooks/useKillsWidgetSettings&apos;;
import {
  AddSystemDialog,
  SearchOnSubmitCallback,
} from &apos;@/hooks/Mapper/components/mapInterface/components/AddSystemDialog&apos;;
import { SystemView, TooltipPosition } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

interface KillsSettingsDialogProps {
  visible: boolean;
  setVisible: (visible: boolean) =&gt; void;
}

export const KillsSettingsDialog: React.FC&lt;KillsSettingsDialogProps&gt; = ({ visible, setVisible }) =&gt; {
  const [globalSettings, setGlobalSettings] = useKillsWidgetSettings();
  const localRef = useRef({
    showAll: globalSettings.showAll,
    whOnly: globalSettings.whOnly,
    excludedSystems: globalSettings.excludedSystems || [],
    timeRange: globalSettings.timeRange,
  });

  const [, forceRender] = useState(0);
  const [addSystemDialogVisible, setAddSystemDialogVisible] = useState(false);

  useEffect(() =&gt; {
    if (visible) {
      localRef.current = {
        showAll: globalSettings.showAll,
        whOnly: globalSettings.whOnly,
        excludedSystems: globalSettings.excludedSystems || [],
        timeRange: globalSettings.timeRange,
      };
      forceRender(n =&gt; n + 1);
    }
  }, [visible, globalSettings]);

  const handleWHChange = useCallback((checked: boolean) =&gt; {
    localRef.current = {
      ...localRef.current,
      whOnly: checked,
    };
    forceRender(n =&gt; n + 1);
  }, []);

  const handleTimeRangeChange = useCallback((newTimeRange: number) =&gt; {
    localRef.current = {
      ...localRef.current,
      timeRange: newTimeRange,
    };
    forceRender(n =&gt; n + 1);
  }, []);

  const handleRemoveSystem = useCallback((sysId: number) =&gt; {
    localRef.current = {
      ...localRef.current,
      excludedSystems: localRef.current.excludedSystems.filter(id =&gt; id !== sysId),
    };
    forceRender(n =&gt; n + 1);
  }, []);

  const handleAddSystemSubmit: SearchOnSubmitCallback = useCallback(item =&gt; {
    if (localRef.current.excludedSystems.includes(item.value)) {
      return;
    }
    localRef.current = {
      ...localRef.current,
      excludedSystems: [...localRef.current.excludedSystems, item.value],
    };
    forceRender(n =&gt; n + 1);
  }, []);

  const handleApply = useCallback(() =&gt; {
    setGlobalSettings(prev =&gt; ({
      ...prev,
      ...localRef.current,
    }));
    setVisible(false);
  }, [setGlobalSettings, setVisible]);

  const handleHide = useCallback(() =&gt; {
    setVisible(false);
  }, [setVisible]);

  const localData = localRef.current;
  const excluded = localData.excludedSystems || [];
  const timeRangeOptions = [4, 12, 24];

  // Ensure timeRange is one of the valid options
  useEffect(() =&gt; {
    if (visible &amp;&amp; !timeRangeOptions.includes(localData.timeRange)) {
      // If current timeRange is not in options, set it to the default (4 hours)
      handleTimeRangeChange(4);
    }
  }, [visible, localData.timeRange, handleTimeRangeChange]);

  return (
    &lt;Dialog header=&quot;Kills Settings&quot; visible={visible} style={{ width: &apos;440px&apos; }} draggable={false} onHide={handleHide}&gt;
      &lt;div className=&quot;flex flex-col gap-3 p-2.5&quot;&gt;
        &lt;div className=&quot;flex items-center gap-2&quot;&gt;
          &lt;input
            type=&quot;checkbox&quot;
            id=&quot;kills-wormhole-only-mode&quot;
            checked={localData.whOnly}
            onChange={e =&gt; handleWHChange(e.target.checked)}
          /&gt;
          &lt;label htmlFor=&quot;kills-wormhole-only-mode&quot; className=&quot;cursor-pointer&quot;&gt;
            Only show wormhole kills
          &lt;/label&gt;
        &lt;/div&gt;

        &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
          &lt;span className=&quot;text-sm&quot;&gt;Time Range:&lt;/span&gt;
          &lt;div className=&quot;flex flex-wrap gap-2&quot;&gt;
            {timeRangeOptions.map(option =&gt; (
              &lt;label key={option} className=&quot;cursor-pointer flex items-center gap-1&quot;&gt;
                &lt;input
                  type=&quot;radio&quot;
                  name=&quot;timeRange&quot;
                  value={option}
                  checked={localData.timeRange === option}
                  onChange={() =&gt; handleTimeRangeChange(option)}
                /&gt;
                &lt;span className=&quot;text-sm&quot;&gt;{option} Hours&lt;/span&gt;
              &lt;/label&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Excluded Systems */}
        &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
          &lt;div className=&quot;flex items-center justify-between&quot;&gt;
            &lt;label className=&quot;text-sm text-stone-400&quot;&gt;Excluded Systems&lt;/label&gt;
            &lt;WdImgButton
              className={PrimeIcons.PLUS_CIRCLE}
              onClick={() =&gt; setAddSystemDialogVisible(true)}
              tooltip={{ content: &apos;Add system to excluded list&apos; }}
            /&gt;
          &lt;/div&gt;
          {excluded.length === 0 &amp;&amp; &lt;div className=&quot;text-stone-500 text-xs italic&quot;&gt;No systems excluded.&lt;/div&gt;}
          {excluded.map(sysId =&gt; (
            &lt;div key={sysId} className=&quot;flex items-center justify-between border-b border-stone-600 py-1 px-1 text-xs&quot;&gt;
              &lt;SystemView systemId={sysId.toString()} hideRegion /&gt;
              &lt;WdImgButton
                className={PrimeIcons.TRASH}
                onClick={() =&gt; handleRemoveSystem(sysId)}
                tooltip={{ content: &apos;Remove from excluded&apos;, position: TooltipPosition.top }}
              /&gt;
            &lt;/div&gt;
          ))}
        &lt;/div&gt;

        &lt;div className=&quot;flex gap-2 justify-end mt-4&quot;&gt;
          &lt;Button onClick={handleApply} label=&quot;Apply&quot; outlined size=&quot;small&quot; /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;AddSystemDialog
        title=&quot;Add system to kills exclude list&quot;
        visible={addSystemDialogVisible}
        setVisible={() =&gt; setAddSystemDialogVisible(false)}
        onSubmit={handleAddSystemSubmit}
        excludedSystems={excluded}
      /&gt;
    &lt;/Dialog&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/helpers/index.ts">export * from &apos;./linkHelpers&apos;;
export * from &apos;./killRowUtils&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/helpers/killRowUtils.ts">import { DetailedKill } from &apos;@/hooks/Mapper/types/kills&apos;;

/** Returns &quot;5m ago&quot;, &quot;3h ago&quot;, &quot;2.5d ago&quot;, etc. */
export function formatTimeMixed(killTime: string): string {
  const killDate = new Date(killTime);
  const diffMs = Date.now() - killDate.getTime();
  const diffHours = diffMs / (1000 * 60 * 60);

  if (diffHours &lt; 1) {
    const mins = Math.round(diffHours * 60);
    return `${mins}m ago`;
  } else if (diffHours &lt; 24) {
    const hours = Math.round(diffHours);
    return `${hours}h ago`;
  } else {
    const days = diffHours / 24;
    const roundedDays = days.toFixed(1);
    return `${roundedDays}d ago`;
  }
}

/** Formats integer ISK values into k/M/B/T. */
export function formatISK(value: number): string {
  if (value &gt;= 1_000_000_000_000) {
    return `${(value / 1_000_000_000_000).toFixed(2)}T`;
  } else if (value &gt;= 1_000_000_000) {
    return `${(value / 1_000_000_000).toFixed(2)}B`;
  } else if (value &gt;= 1_000_000) {
    return `${(value / 1_000_000).toFixed(2)}M`;
  } else if (value &gt;= 1_000) {
    return `${(value / 1_000).toFixed(2)}k`;
  }
  return Math.round(value).toString();
}

export function getAttackerSubscript(kill: DetailedKill) {
  if (kill.npc) {
    return { label: &apos;npc&apos;, cssClass: &apos;text-purple-400&apos; };
  }
  const count = kill.attacker_count ?? 0;
  if (count === 1) {
    return { label: &apos;solo&apos;, cssClass: &apos;text-green-400&apos; };
  } else if (count &gt; 1) {
    return { label: String(count), cssClass: &apos;text-white&apos; };
  }
  return null;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/helpers/linkHelpers.ts">const ZKILL_URL = &apos;https://zkillboard.com&apos;;
import { getEveImageUrl } from &apos;@/hooks/Mapper/helpers&apos;;

export function zkillLink(type: &apos;kill&apos; | &apos;character&apos; | &apos;corporation&apos; | &apos;alliance&apos;, id?: number | null): string {
  if (!id) return `${ZKILL_URL}`;
  if (type === &apos;kill&apos;) return `${ZKILL_URL}/kill/${id}/`;
  if (type === &apos;character&apos;) return `${ZKILL_URL}/character/${id}/`;
  if (type === &apos;corporation&apos;) return `${ZKILL_URL}/corporation/${id}/`;
  if (type === &apos;alliance&apos;) return `${ZKILL_URL}/alliance/${id}/`;
  return `${ZKILL_URL}`;
}

export const eveImageUrl = getEveImageUrl;

export function buildVictimImageUrls(args: {
  victim_char_id?: number | null;
  victim_ship_type_id?: number | null;
  victim_corp_id?: number | null;
  victim_alliance_id?: number | null;
}) {
  const { victim_char_id, victim_ship_type_id, victim_corp_id, victim_alliance_id } = args;

  const victimPortraitUrl = eveImageUrl(&apos;characters&apos;, victim_char_id, &apos;portrait&apos;, 64);
  const victimShipUrl = eveImageUrl(&apos;types&apos;, victim_ship_type_id, &apos;render&apos;, 64);
  const victimCorpLogoUrl = eveImageUrl(&apos;corporations&apos;, victim_corp_id, &apos;logo&apos;, 32);
  const victimAllianceLogoUrl = eveImageUrl(&apos;alliances&apos;, victim_alliance_id, &apos;logo&apos;, 32);

  return {
    victimPortraitUrl,
    victimShipUrl,
    victimCorpLogoUrl,
    victimAllianceLogoUrl,
  };
}

export function buildAttackerShipUrl(final_blow_ship_type_id?: number | null): string | null {
  return eveImageUrl(&apos;types&apos;, final_blow_ship_type_id, &apos;render&apos;, 64);
}

export function buildAttackerImageUrls(args: {
  final_blow_char_id?: number | null;
  final_blow_corp_id?: number | null;
  final_blow_alliance_id?: number | null;
}) {
  const { final_blow_char_id, final_blow_corp_id, final_blow_alliance_id } = args;

  const attackerPortraitUrl = eveImageUrl(&apos;characters&apos;, final_blow_char_id, &apos;portrait&apos;, 64);
  const attackerCorpLogoUrl = eveImageUrl(&apos;corporations&apos;, final_blow_corp_id, &apos;logo&apos;, 32);
  const attackerAllianceLogoUrl = eveImageUrl(&apos;alliances&apos;, final_blow_alliance_id, &apos;logo&apos;, 32);

  return {
    attackerPortraitUrl,
    attackerCorpLogoUrl,
    attackerAllianceLogoUrl,
  };
}

export function getPrimaryLogoAndTooltip(
  allianceUrl: string | null,
  corpUrl: string | null,
  allianceName: string,
  corpName: string,
  fallback: string,
) {
  let url: string | null = null;
  let tooltip = &apos;&apos;;

  if (allianceUrl) {
    url = allianceUrl;
    tooltip = allianceName || fallback;
  } else if (corpUrl) {
    url = corpUrl;
    tooltip = corpName || fallback;
  }

  return { url, tooltip };
}

export function getAttackerPrimaryImageAndTooltip(
  isNpc: boolean,
  allianceUrl: string | null,
  corpUrl: string | null,
  allianceName: string,
  corpName: string,
  finalBlowShipTypeId: number | null,
  npcFallback: string = &apos;NPC Attacker&apos;,
) {
  if (isNpc) {
    const shipUrl = buildAttackerShipUrl(finalBlowShipTypeId);
    return {
      url: shipUrl,
      tooltip: npcFallback,
    };
  }

  return getPrimaryLogoAndTooltip(allianceUrl, corpUrl, allianceName, corpName, &apos;Attacker&apos;);
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/hooks/useKillsWidgetSettings.ts">import { useMemo, useCallback } from &apos;react&apos;;
import useLocalStorageState from &apos;use-local-storage-state&apos;;

export interface KillsWidgetSettings {
  showAll: boolean;
  whOnly: boolean;
  excludedSystems: number[];
  version: number;
  timeRange: number;
}

export const DEFAULT_KILLS_WIDGET_SETTINGS: KillsWidgetSettings = {
  showAll: false,
  whOnly: true,
  excludedSystems: [],
  version: 2,
  timeRange: 4,
};

function mergeWithDefaults(settings?: Partial&lt;KillsWidgetSettings&gt;): KillsWidgetSettings {
  if (!settings) {
    return DEFAULT_KILLS_WIDGET_SETTINGS;
  }

  return {
    ...DEFAULT_KILLS_WIDGET_SETTINGS,
    ...settings,
    excludedSystems: Array.isArray(settings.excludedSystems) ? settings.excludedSystems : [],
  };
}

export function useKillsWidgetSettings() {
  const [rawValue, setRawValue] = useLocalStorageState&lt;KillsWidgetSettings | undefined&gt;(&apos;kills:widget:settings&apos;);

  const value = useMemo&lt;KillsWidgetSettings&gt;(() =&gt; {
    return mergeWithDefaults(rawValue);
  }, [rawValue]);

  const setValue = useCallback(
    (newVal: KillsWidgetSettings | ((prev: KillsWidgetSettings) =&gt; KillsWidgetSettings)) =&gt; {
      setRawValue(prev =&gt; {
        const mergedPrev = mergeWithDefaults(prev);

        const nextUnmerged = typeof newVal === &apos;function&apos; ? newVal(mergedPrev) : newVal;

        return mergeWithDefaults(nextUnmerged);
      });
    },
    [setRawValue],
  );

  return [value, setValue] as const;
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/hooks/useSystemKills.ts">import { useCallback, useMemo, useState, useEffect, useRef } from &apos;react&apos;;
import debounce from &apos;lodash.debounce&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers&apos;;
import { DetailedKill } from &apos;@/hooks/Mapper/types/kills&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useKillsWidgetSettings } from &apos;./useKillsWidgetSettings&apos;;

interface UseSystemKillsProps {
  systemId?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  outCommand: (payload: any) =&gt; Promise&lt;any&gt;;
  showAllVisible?: boolean;
  sinceHours?: number;
}

function combineKills(existing: DetailedKill[], incoming: DetailedKill[], sinceHours: number): DetailedKill[] {
  const cutoff = Date.now() - sinceHours * 60 * 60 * 1000;
  const byId: Record&lt;string, DetailedKill&gt; = {};

  for (const kill of [...existing, ...incoming]) {
    if (!kill.kill_time) continue;
    const killTimeMs = new Date(kill.kill_time).valueOf();
    if (killTimeMs &gt;= cutoff) {
      byId[kill.killmail_id] = kill;
    }
  }

  return Object.values(byId);
}

export function useSystemKills({ systemId, outCommand, showAllVisible = false, sinceHours = 24 }: UseSystemKillsProps) {
  const { data, update } = useMapRootState();
  const { detailedKills = {}, systems = [] } = data;
  const [settings] = useKillsWidgetSettings();
  const excludedSystems = settings.excludedSystems;

  const effectiveSinceHours = sinceHours;

  const effectiveSystemIds = useMemo(() =&gt; {
    if (showAllVisible) {
      return systems.map(s =&gt; s.id).filter(id =&gt; !excludedSystems.includes(Number(id)));
    }
    return systems.map(s =&gt; s.id);
  }, [systems, excludedSystems, showAllVisible]);

  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const didFallbackFetch = useRef(Object.keys(detailedKills).length !== 0);

  const mergeKillsIntoGlobal = useCallback(
    (killsMap: Record&lt;string, DetailedKill[]&gt;) =&gt; {
      update(prev =&gt; {
        const oldMap = prev.detailedKills ?? {};
        const updated: Record&lt;string, DetailedKill[]&gt; = { ...oldMap };

        for (const [sid, newKills] of Object.entries(killsMap)) {
          const existing = updated[sid] ?? [];
          const combined = combineKills(existing, newKills, effectiveSinceHours);
          updated[sid] = combined;
        }

        return { ...prev, detailedKills: updated };
      });
    },
    [update, effectiveSinceHours],
  );

  const fetchKills = useCallback(
    async (forceFallback = false) =&gt; {
      setIsLoading(true);
      setError(null);

      try {
        let eventType: OutCommand;
        let requestData: Record&lt;string, unknown&gt;;

        if (showAllVisible || forceFallback) {
          eventType = OutCommand.getSystemsKills;
          requestData = {
            system_ids: effectiveSystemIds,
            since_hours: effectiveSinceHours,
          };
        } else if (systemId) {
          eventType = OutCommand.getSystemKills;
          requestData = {
            system_id: systemId,
            since_hours: effectiveSinceHours,
          };
        } else {
          setIsLoading(false);
          return;
        }

        const resp = await outCommand({
          type: eventType,
          data: requestData,
        });

        if (resp?.kills) {
          const arr = resp.kills as DetailedKill[];
          const sid = systemId ?? &apos;unknown&apos;;
          mergeKillsIntoGlobal({ [sid]: arr });
        } else if (resp?.systems_kills) {
          mergeKillsIntoGlobal(resp.systems_kills as Record&lt;string, DetailedKill[]&gt;);
        } else {
          console.warn(&apos;[useSystemKills] Unexpected kills response =&gt;&apos;, resp);
        }
      } catch (err) {
        console.error(&apos;[useSystemKills] Failed to fetch kills:&apos;, err);
        setError(err instanceof Error ? err.message : &apos;Error fetching kills&apos;);
      } finally {
        setIsLoading(false);
      }
    },
    [showAllVisible, systemId, outCommand, effectiveSystemIds, effectiveSinceHours, mergeKillsIntoGlobal],
  );

  const debouncedFetchKills = useMemo(
    () =&gt;
      debounce(fetchKills, 500, {
        leading: true,
        trailing: false,
      }),
    [fetchKills],
  );

  const finalKills = useMemo(() =&gt; {
    let result: DetailedKill[] = [];

    if (showAllVisible) {
      result = effectiveSystemIds.flatMap(sid =&gt; detailedKills[sid] ?? []);
    } else if (systemId) {
      result = detailedKills[systemId] ?? [];
    } else if (didFallbackFetch.current) {
      result = effectiveSystemIds.flatMap(sid =&gt; detailedKills[sid] ?? []);
    }

    return result;
  }, [showAllVisible, systemId, effectiveSystemIds, detailedKills, didFallbackFetch]);

  const effectiveIsLoading = isLoading &amp;&amp; finalKills.length === 0;

  useEffect(() =&gt; {
    if (!systemId &amp;&amp; !showAllVisible &amp;&amp; !didFallbackFetch.current) {
      didFallbackFetch.current = true;
      debouncedFetchKills.cancel();
      fetchKills(true);
    }
  }, [systemId, showAllVisible, debouncedFetchKills, fetchKills]);

  useEffect(() =&gt; {
    if (effectiveSystemIds.length === 0) return;

    if (showAllVisible || systemId) {
      // Cancel any pending debounced fetch
      debouncedFetchKills.cancel();
      // Fetch kills immediately
      fetchKills();
      return () =&gt; debouncedFetchKills.cancel();
    }
  }, [showAllVisible, systemId, effectiveSystemIds, debouncedFetchKills, fetchKills]);

  const refetch = useCallback(() =&gt; {
    debouncedFetchKills.cancel();
    fetchKills();
  }, [debouncedFetchKills, fetchKills]);

  return {
    kills: finalKills,
    isLoading: effectiveIsLoading,
    error,
    refetch,
  };
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/hooks/useSystemKillsItemTemplate.ts">// useSystemKillsItemTemplate.tsx
import { useCallback } from &apos;react&apos;;
import { VirtualScrollerTemplateOptions } from &apos;primereact/virtualscroller&apos;;
import { DetailedKill } from &apos;@/hooks/Mapper/types/kills&apos;;
import { KillItemTemplate } from &apos;../components/KillItemTemplate&apos;;

export function useSystemKillsItemTemplate(onlyOneSystem: boolean) {
  return useCallback(
    (kill: DetailedKill, options: VirtualScrollerTemplateOptions) =&gt; KillItemTemplate(onlyOneSystem, kill, options),
    [onlyOneSystem],
  );
}</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/SystemKillsList/index.ts">export * from &apos;./SystemKillsList&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/SystemKillsList/SystemKillsList.tsx">import { useMemo } from &apos;react&apos;;
import { DetailedKill } from &apos;@/hooks/Mapper/types/kills&apos;;
import { VirtualScroller } from &apos;primereact/virtualscroller&apos;;
import { useSystemKillsItemTemplate } from &apos;../hooks/useSystemKillsItemTemplate&apos;;
import clsx from &apos;clsx&apos;;
import { WithClassName } from &apos;@/hooks/Mapper/types/common.ts&apos;;

export const KILLS_ROW_HEIGHT = 40;

export type SystemKillsContentProps = {
  kills: DetailedKill[];
  onlyOneSystem?: boolean;
  timeRange?: number;
  limit?: number;
} &amp; WithClassName;

export const SystemKillsList = ({
  kills,
  onlyOneSystem = false,
  timeRange = 4,
  limit,
  className,
}: SystemKillsContentProps) =&gt; {
  const processedKills = useMemo(() =&gt; {
    if (!kills || kills.length === 0) return [];

    // sort by newest first
    const sortedKills = kills
      .filter(k =&gt; k.kill_time)
      .sort((a, b) =&gt; new Date(b.kill_time!).getTime() - new Date(a.kill_time!).getTime());

    // filter by timeRange
    let filteredKills = sortedKills;
    if (timeRange !== undefined) {
      const cutoffTime = new Date();
      cutoffTime.setHours(cutoffTime.getHours() - timeRange);
      filteredKills = sortedKills.filter(kill =&gt; {
        const killTime = new Date(kill.kill_time!).getTime();
        return killTime &gt;= cutoffTime.getTime();
      });
    }

    // apply limit if present
    if (limit !== undefined) {
      return filteredKills.slice(0, limit);
    }
    return filteredKills;
  }, [kills, timeRange, limit]);

  const itemTemplate = useSystemKillsItemTemplate(onlyOneSystem);

  return (
    &lt;VirtualScroller
      items={processedKills}
      itemSize={KILLS_ROW_HEIGHT}
      itemTemplate={itemTemplate}
      className={clsx(
        &apos;w-full flex-1 select-none !h-full overflow-x-hidden overflow-y-auto custom-scrollbar&apos;,
        className,
      )}
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/index.ts">export * from &apos;./WSystemKills&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/WSystemKills/WSystemKills.tsx">import { useCallback, useMemo, useState } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { Widget } from &apos;@/hooks/Mapper/components/mapInterface/components&apos;;
import { SystemKillsList } from &apos;./SystemKillsList&apos;;
import { KillsHeader } from &apos;./components/SystemKillsHeader&apos;;
import { useKillsWidgetSettings } from &apos;./hooks/useKillsWidgetSettings&apos;;
import { useSystemKills } from &apos;./hooks/useSystemKills&apos;;
import { KillsSettingsDialog } from &apos;./components/SystemKillsSettingsDialog&apos;;
import { isWormholeSpace } from &apos;@/hooks/Mapper/components/map/helpers/isWormholeSpace&apos;;
import { getSystemStaticInfo } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic&apos;;

const SystemKillsContent = () =&gt; {
  const {
    data: { selectedSystems, isSubscriptionActive },
    outCommand,
  } = useMapRootState();

  const [systemId] = selectedSystems || [];

  const systemStaticInfo = getSystemStaticInfo(systemId)!;

  const [settings] = useKillsWidgetSettings();
  const visible = settings.showAll;

  const { kills, isLoading, error } = useSystemKills({
    systemId,
    outCommand,
    showAllVisible: visible,
    sinceHours: settings.timeRange,
  });

  const isNothingSelected = !systemId &amp;&amp; !visible;
  const showLoading = isLoading &amp;&amp; kills.length === 0;

  const filteredKills = useMemo(() =&gt; {
    if (!settings.whOnly || !visible) return kills;
    return kills.filter(kill =&gt; {
      if (!systemStaticInfo) {
        console.warn(`System with id ${kill.solar_system_id} not found.`);
        return false;
      }
      return isWormholeSpace(systemStaticInfo.system_class);
    });
  }, [kills, settings.whOnly, systemStaticInfo, visible]);

  if (!isSubscriptionActive) {
    return (
      &lt;div className=&quot;w-full h-full flex items-center justify-center&quot;&gt;
        &lt;span className=&quot;select-none text-center text-stone-400/80 text-sm&quot;&gt;
          Kills available with &amp;#39;Active&amp;#39; map subscription only (contact map administrators)
        &lt;/span&gt;
      &lt;/div&gt;
    );
  }

  if (isNothingSelected) {
    return (
      &lt;div className=&quot;w-full h-full flex items-center justify-center&quot;&gt;
        &lt;span className=&quot;select-none text-center text-stone-400/80 text-sm&quot;&gt;
          No system selected (or toggle &amp;quot;Show all systems&amp;quot;)
        &lt;/span&gt;
      &lt;/div&gt;
    );
  }

  if (showLoading) {
    return (
      &lt;div className=&quot;w-full h-full flex items-center justify-center&quot;&gt;
        &lt;span className=&quot;select-none text-center text-stone-400/80 text-sm&quot;&gt;Loading Kills...&lt;/span&gt;
      &lt;/div&gt;
    );
  }

  if (error) {
    return (
      &lt;div className=&quot;w-full h-full flex items-center justify-center&quot;&gt;
        &lt;span className=&quot;select-none text-center text-red-400 text-sm&quot;&gt;{error}&lt;/span&gt;
      &lt;/div&gt;
    );
  }

  if (!filteredKills || filteredKills.length === 0) {
    return (
      &lt;div className=&quot;w-full h-full flex items-center justify-center&quot;&gt;
        &lt;span className=&quot;select-none text-center text-stone-400/80 text-sm&quot;&gt;No kills found&lt;/span&gt;
      &lt;/div&gt;
    );
  }

  return &lt;SystemKillsList kills={filteredKills} onlyOneSystem={!visible} timeRange={settings.timeRange} /&gt;;
};

export const WSystemKills = () =&gt; {
  const [settingsDialogVisible, setSettingsDialogVisible] = useState(false);
  const {
    data: { selectedSystems },
  } = useMapRootState();

  const [systemId] = selectedSystems || [];

  const handleOpenSettings = useCallback(() =&gt; setSettingsDialogVisible(true), []);

  return (
    &lt;Widget label={&lt;KillsHeader systemId={systemId} onOpenSettings={handleOpenSettings} /&gt;}&gt;
      &lt;SystemKillsContent /&gt;
      {settingsDialogVisible &amp;&amp; &lt;KillsSettingsDialog visible setVisible={setSettingsDialogVisible} /&gt;}
    &lt;/Widget&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapInterface/widgets/index.ts">export * from &apos;./LocalCharacters&apos;;
export * from &apos;./SystemInfo&apos;;
export * from &apos;./RoutesWidget&apos;;
export * from &apos;./SystemSignatures&apos;;
export * from &apos;./SystemStructures&apos;;
export * from &apos;./WSystemKills&apos;;
export * from &apos;./WRoutesUser&apos;;
export * from &apos;./WRoutesPublic&apos;;
export * from &apos;./CommentsWidget&apos;;</file><file path="assets/js/hooks/Mapper/components/mapInterface/constants.tsx">import { WindowProps } from &apos;@/hooks/Mapper/components/ui-kit/WindowManager/types.ts&apos;;
import {
  CommentsWidget,
  LocalCharacters,
  SystemInfo,
  SystemSignatures,
  SystemStructures,
  WRoutesPublic,
  WRoutesUser,
  WSystemKills,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets&apos;;

export const CURRENT_WINDOWS_VERSION = 9;
export const WINDOWS_LOCAL_STORE_KEY = &apos;windows:settings:v2&apos;;

export enum WidgetsIds {
  info = &apos;info&apos;,
  signatures = &apos;signatures&apos;,
  local = &apos;local&apos;,
  routes = &apos;routes&apos;,
  structures = &apos;structures&apos;,
  kills = &apos;kills&apos;,
  comments = &apos;comments&apos;,
  userRoutes = &apos;userRoutes&apos;,
}

export const STORED_VISIBLE_WIDGETS_DEFAULT = [
  WidgetsIds.info,
  WidgetsIds.local,
  WidgetsIds.routes,
  WidgetsIds.signatures,
];

export const DEFAULT_WIDGETS: WindowProps[] = [
  {
    id: WidgetsIds.info,
    position: { x: 10, y: 10 },
    size: { width: 250, height: 200 },
    zIndex: 0,
    content: () =&gt; &lt;SystemInfo /&gt;,
  },
  {
    id: WidgetsIds.signatures,
    position: { x: 10, y: 220 },
    size: { width: 250, height: 300 },
    zIndex: 0,
    content: () =&gt; &lt;SystemSignatures /&gt;,
  },
  {
    id: WidgetsIds.local,
    position: { x: 270, y: 10 },
    size: { width: 250, height: 510 },
    zIndex: 0,
    content: () =&gt; &lt;LocalCharacters /&gt;,
  },
  {
    id: WidgetsIds.routes,
    position: { x: 10, y: 530 },
    size: { width: 510, height: 200 },
    zIndex: 0,
    content: () =&gt; &lt;WRoutesPublic /&gt;,
  },
  {
    id: WidgetsIds.userRoutes,
    position: { x: 10, y: 530 },
    size: { width: 510, height: 200 },
    zIndex: 0,
    content: () =&gt; &lt;WRoutesUser /&gt;,
  },
  {
    id: WidgetsIds.structures,
    position: { x: 10, y: 730 },
    size: { width: 510, height: 200 },
    zIndex: 0,
    content: () =&gt; &lt;SystemStructures /&gt;,
  },
  {
    id: WidgetsIds.kills,
    position: { x: 270, y: 730 },
    size: { width: 510, height: 200 },
    zIndex: 0,
    content: () =&gt; &lt;WSystemKills /&gt;,
  },
  {
    id: WidgetsIds.comments,
    position: { x: 10, y: 10 },
    size: { width: 250, height: 300 },
    zIndex: 0,
    content: () =&gt; &lt;CommentsWidget /&gt;,
  },
];

type WidgetsCheckboxesType = {
  id: WidgetsIds;
  label: string;
}[];

export const WIDGETS_CHECKBOXES_PROPS: WidgetsCheckboxesType = [
  {
    id: WidgetsIds.info,
    label: &apos;System Info&apos;,
  },
  {
    id: WidgetsIds.signatures,
    label: &apos;Signatures&apos;,
  },
  {
    id: WidgetsIds.local,
    label: &apos;Local&apos;,
  },
  {
    id: WidgetsIds.routes,
    label: &apos;Routes&apos;,
  },
  {
    id: WidgetsIds.userRoutes,
    label: &apos;User Routes&apos;,
  },
  {
    id: WidgetsIds.structures,
    label: &apos;Structures&apos;,
  },
  {
    id: WidgetsIds.kills,
    label: &apos;Kills&apos;,
  },
  {
    id: WidgetsIds.comments,
    label: &apos;Comments&apos;,
  },
];</file><file path="assets/js/hooks/Mapper/components/mapInterface/MapInterface.tsx">import { useMemo } from &apos;react&apos;;
import { WindowManager } from &apos;@/hooks/Mapper/components/ui-kit/WindowManager&apos;;
import { DEFAULT_WIDGETS } from &apos;@/hooks/Mapper/components/mapInterface/constants.tsx&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

export const MapInterface = () =&gt; {
  // const [items, setItems] = useState&lt;WindowProps[]&gt;(restoreWindowsFromLS);
  const { windowsSettings, updateWidgetSettings } = useMapRootState();

  const items = useMemo(() =&gt; {
    return windowsSettings.windows
      .map(x =&gt; {
        const content = DEFAULT_WIDGETS.find(y =&gt; y.id === x.id)?.content;
        return {
          ...x,
          content: content!,
        };
      })
      .filter(x =&gt; windowsSettings.visible.some(j =&gt; x.id === j));
  }, [windowsSettings]);

  return (
    &lt;WindowManager
      windows={items}
      viewPort={windowsSettings.viewPort}
      dragSelector=&quot;.react-grid-dragHandleExample&quot;
      onChange={updateWidgetSettings}
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/CharacterActivity/CharacterActivity.tsx">import { Dialog } from &apos;primereact/dialog&apos;;
import { CharacterActivityContent } from &apos;@/hooks/Mapper/components/mapRootContent/components/CharacterActivity/CharacterActivityContent.tsx&apos;;

interface CharacterActivityProps {
  visible: boolean;
  onHide: () =&gt; void;
}

export const CharacterActivity = ({ visible, onHide }: CharacterActivityProps) =&gt; {
  return (
    &lt;Dialog
      header=&quot;Character Activity&quot;
      visible={visible}
      className=&quot;w-[550px] max-h-[90vh]&quot;
      onHide={onHide}
      dismissableMask
      contentClassName=&quot;p-0 h-full flex flex-col&quot;
    &gt;
      &lt;CharacterActivityContent /&gt;
    &lt;/Dialog&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/CharacterActivity/CharacterActivityContent.tsx">import { ProgressSpinner } from &apos;primereact/progressspinner&apos;;
import { DataTable } from &apos;primereact/datatable&apos;;
import {
  getRowClassName,
  renderCharacterTemplate,
  renderValueTemplate,
} from &apos;@/hooks/Mapper/components/mapRootContent/components/CharacterActivity/helpers.tsx&apos;;
import { Column } from &apos;primereact/column&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useMemo } from &apos;react&apos;;

export const CharacterActivityContent = () =&gt; {
  const {
    data: { characterActivityData },
  } = useMapRootState();

  const activity = useMemo(() =&gt; characterActivityData?.activity || [], [characterActivityData]);
  const loading = useMemo(() =&gt; characterActivityData?.loading !== false, [characterActivityData]);

  if (loading) {
    return (
      &lt;div className=&quot;flex flex-col items-center justify-center h-full w-full&quot;&gt;
        &lt;ProgressSpinner className=&quot;w-[50px] h-[50px]&quot; strokeWidth=&quot;4&quot; /&gt;
        &lt;div className=&quot;mt-4 text-text-color-secondary text-sm&quot;&gt;Loading character activity data...&lt;/div&gt;
      &lt;/div&gt;
    );
  }

  if (activity.length === 0) {
    return &lt;div className=&quot;p-8 text-center text-text-color-secondary italic&quot;&gt;No character activity data available&lt;/div&gt;;
  }

  return (
    &lt;div className=&quot;w-full h-full overflow-auto custom-scrollbar&quot;&gt;
      &lt;DataTable
        value={activity}
        scrollable
        className=&quot;w-full&quot;
        tableClassName=&quot;w-full border-0&quot;
        emptyMessage=&quot;No character activity data available&quot;
        sortField=&quot;passages&quot;
        sortOrder={-1}
        size=&quot;small&quot;
        rowClassName={getRowClassName}
        rowHover
      &gt;
        &lt;Column
          field=&quot;character_name&quot;
          header=&quot;Character&quot;
          body={renderCharacterTemplate}
          sortable
          className=&quot;!py-[6px]&quot;
        /&gt;

        &lt;Column
          field=&quot;passages&quot;
          header=&quot;Passages&quot;
          headerClassName=&quot;[&amp;_.p-column-header-content]:justify-center&quot;
          body={rowData =&gt; renderValueTemplate(rowData, &apos;passages&apos;)}
          sortable
        /&gt;
        &lt;Column
          field=&quot;connections&quot;
          header=&quot;Connections&quot;
          headerClassName=&quot;[&amp;_.p-column-header-content]:justify-center&quot;
          body={rowData =&gt; renderValueTemplate(rowData, &apos;connections&apos;)}
          sortable
        /&gt;
        &lt;Column
          field=&quot;signatures&quot;
          header=&quot;Signatures&quot;
          headerClassName=&quot;[&amp;_.p-column-header-content]:justify-center&quot;
          body={rowData =&gt; renderValueTemplate(rowData, &apos;signatures&apos;)}
          sortable
        /&gt;
      &lt;/DataTable&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/CharacterActivity/helpers.tsx">import { CharacterCard } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { ActivitySummary } from &apos;@/hooks/Mapper/types&apos;;

export const getRowClassName = () =&gt; [&apos;text-xs&apos;, &apos;leading-tight&apos;];

export const renderCharacterTemplate = (rowData: ActivitySummary) =&gt; {
  return &lt;CharacterCard compact isOwn {...rowData.character} /&gt;;
};

export const renderValueTemplate = (rowData: ActivitySummary, field: keyof ActivitySummary) =&gt; {
  return &lt;div className=&quot;tabular-nums w-full flex justify-center&quot;&gt;{rowData[field] as number}&lt;/div&gt;;
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/CharacterActivity/index.ts">export * from &apos;./CharacterActivity&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/Connections/PassageCard/index.ts">export * from &apos;./PassageCard.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/Connections/PassageCard/PassageCard.module.scss">.CharacterCard {

}

.EveIcon {
  display: flex;
  transition:
    border-color 250ms,
    opacity 250ms;
  min-width: 34px;
  min-height: 34px;
  width: 34px;
  height: 34px;
  border-width: 1px;
  border-style: solid;
  border-color: #272727;
  background-color: rgba(0, 0, 0, 0);
  border-radius: 3px;
}

.MaxWidth {
  max-width: 7rem;
}

.CharIcon {}

.CharRow {
  display: grid;
  gap: 4px;

  &amp;.TwoColumns {
    grid-template-columns: auto 1fr;
  }

  &amp;.ThreeColumns {
    grid-template-columns: auto 1fr auto;
  }
}

.CardBorderLeftIsOwn {

}</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/Connections/PassageCard/PassageCard.tsx">import clsx from &apos;clsx&apos;;
import classes from &apos;./PassageCard.module.scss&apos;;
import { Passage } from &apos;@/hooks/Mapper/types&apos;;
import { TimeAgo } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;
import { kgToTons } from &apos;@/hooks/Mapper/utils/kgToTons.ts&apos;;
import { useMemo } from &apos;react&apos;;

type PassageCardType = {
  // compact?: boolean;
  showShipName?: boolean;
  // showSystem?: boolean;
  // useSystemsCache?: boolean;
} &amp; Passage;

const SHIP_NAME_RX = /u&apos;|&apos;/g;
export const getShipName = (name: string) =&gt; {
  return name
    .replace(SHIP_NAME_RX, &apos;&apos;)
    .replace(/\\u([\dA-Fa-f]{4})/g, (_, grp) =&gt; {
      return String.fromCharCode(parseInt(grp, 16));
    })
    .replace(/\\x([\dA-Fa-f]{2})/g, (_, grp) =&gt; {
      return String.fromCharCode(parseInt(grp, 16));
    });
};

export const PassageCard = ({ inserted_at, character: char, ship }: PassageCardType) =&gt; {
  const isOwn = false;

  const insertedAt = useMemo(() =&gt; {
    const date = new Date(inserted_at);
    return date.toLocaleString();
  }, [inserted_at]);

  return (
    &lt;div className={clsx(classes.CharacterCard, &apos;w-full text-xs&apos;, &apos;flex flex-col box-border&apos;)}&gt;
      &lt;div className=&quot;flex flex-col justify-between px-2 py-1 gap-1&quot;&gt;
        {/*here icon and other*/}
        &lt;div className={clsx(classes.CharRow, classes.ThreeColumns)}&gt;
          {/*portrait*/}
          &lt;span
            className={clsx(classes.EveIcon, classes.CharIcon, &apos;wd-bg-default&apos;)}
            style={{ backgroundImage: `url(https://images.evetech.net/characters/${char.eve_id}/portrait)` }}
          /&gt;

          {/*info*/}
          &lt;div className=&quot;flex flex-col&quot;&gt;
            {/*here name and ship name*/}
            &lt;div className=&quot;grid gap-1 justify-between grid-cols-[max-content_1fr]&quot;&gt;
              {/*char name*/}
              &lt;div className=&quot;grid gap-1 grid-cols-[auto_1px_1fr]&quot;&gt;
                &lt;span
                  className={clsx(classes.MaxWidth, &apos;text-ellipsis overflow-hidden whitespace-nowrap&apos;, {
                    [classes.CardBorderLeftIsOwn]: isOwn,
                  })}
                  title={char.name}
                &gt;
                  {char.name}
                &lt;/span&gt;

                &lt;div className=&quot;h-3 border-r border-neutral-500 my-0.5&quot;&gt;&lt;/div&gt;
                {char.alliance_ticker &amp;&amp; &lt;span className=&quot;text-neutral-400&quot;&gt;{char.alliance_ticker}&lt;/span&gt;}
                {!char.alliance_ticker &amp;&amp; &lt;span className=&quot;text-neutral-400&quot;&gt;{char.corporation_ticker}&lt;/span&gt;}
              &lt;/div&gt;

              {/*ship name*/}
              &lt;div className=&quot;grid gap-1 grid-cols-[1fr_1px_auto]&quot;&gt;
                {ship.ship_name &amp;&amp; (
                  &lt;&gt;
                    &lt;span className=&quot;text-ellipsis overflow-hidden whitespace-nowrap flex justify-end text-neutral-400&quot;&gt;
                      {getShipName(ship.ship_name)}
                    &lt;/span&gt;
                    &lt;div className=&quot;h-3 border-r border-neutral-500 my-0.5&quot;&gt;&lt;/div&gt;
                    &lt;span className={clsx(classes.MaxWidth, &apos;text-ellipsis overflow-hidden whitespace-nowrap&apos;)}&gt;
                      {ship.ship_type_info.name}
                    &lt;/span&gt;
                  &lt;/&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;

            {/*time and class*/}
            &lt;div className=&quot;flex justify-between&quot;&gt;
              &lt;span className=&quot;text-stone-400&quot;&gt;
                &lt;WdTooltipWrapper content={insertedAt}&gt;
                  &lt;TimeAgo timestamp={inserted_at} /&gt;
                &lt;/WdTooltipWrapper&gt;
              &lt;/span&gt;

              &lt;div className=&quot;text-stone-400&quot;&gt;{kgToTons(parseInt(ship.ship_type_info.mass))}&lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          {/*ship icon*/}
          &lt;span
            className={clsx(classes.EveIcon, classes.CharIcon, &apos;wd-bg-default&apos;)}
            style={{ backgroundImage: `url(https://images.evetech.net/types/${ship.ship_type_id}/icon)` }}
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/Connections/Connections.module.scss">.OnTheMapRoot {

}

.SidebarOnTheMap {
  width: 400px;
  padding: 0 !important;

  :global {
    .p-sidebar-content {
      padding-left: 0px;
      padding-right: 0px;
    }
  }
}

.SidebarContent {
  display: grid;
  grid-template-rows: auto auto 1fr;
  row-gap: 4px;
  height: 100%;
}

.InfoTextSize {
  font-size: 12px !important;
}</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/Connections/Connections.tsx">import classes from &apos;./Connections.module.scss&apos;;
import { Sidebar } from &apos;primereact/sidebar&apos;;
import { useEffect, useMemo, useState, useCallback } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { VirtualScroller, VirtualScrollerTemplateOptions } from &apos;primereact/virtualscroller&apos;;
import clsx from &apos;clsx&apos;;
import {
  ConnectionType,
  ConnectionOutput,
  ConnectionInfoOutput,
  OutCommand,
  Passage,
  SolarSystemConnection,
} from &apos;@/hooks/Mapper/types&apos;;

import { PassageCard } from &apos;./PassageCard&apos;;
import { InfoDrawer, SystemView } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { kgToTons } from &apos;@/hooks/Mapper/utils/kgToTons.ts&apos;;
import { TimeAgo } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

const sortByDate = (a: string, b: string) =&gt; new Date(a).getTime() - new Date(b).getTime();

const itemTemplate = (item: Passage, options: VirtualScrollerTemplateOptions) =&gt; {
  return (
    &lt;div
      className={clsx(classes.CharacterRow, &apos;w-full box-border&apos;, {
        &apos;surface-hover&apos;: options.odd,
        [&apos;border-b border-gray-600 border-opacity-20&apos;]: !options.last,
        [&apos;bg-green-500 hover:bg-green-700 transition duration-300 bg-opacity-10 hover:bg-opacity-10&apos;]: false,
      })}
      style={{ height: options.props.itemSize + &apos;px&apos; }}
    &gt;
      &lt;PassageCard {...item} /&gt;
    &lt;/div&gt;
  );
};

export interface ConnectionPassagesContentProps {
  passages: Passage[];
}

export const ConnectionPassages = ({ passages = [] }: ConnectionPassagesContentProps) =&gt; {
  if (passages.length === 0) {
    return &lt;div className=&quot;flex justify-center items-center text-stone-400 select-none&quot;&gt;Nobody passed here&lt;/div&gt;;
  }

  return (
    &lt;VirtualScroller
      items={passages}
      itemSize={43}
      itemTemplate={itemTemplate}
      className={clsx(
        classes.VirtualScroller,
        &apos;w-full h-full overflow-x-hidden overflow-y-auto custom-scrollbar select-none&apos;,
      )}
      autoSize={false}
    /&gt;
  );
};

export interface OnTheMapProps {
  selectedConnection: SolarSystemConnection | null;
  onHide: () =&gt; void;
}

export const Connections = ({ selectedConnection, onHide }: OnTheMapProps) =&gt; {
  const {
    data: { connections },
    outCommand,
  } = useMapRootState();

  const cnInfo = useMemo(() =&gt; {
    if (!selectedConnection) {
      return null;
    }

    return connections.find(x =&gt; x.source === selectedConnection.source &amp;&amp; x.target === selectedConnection.target);
  }, [connections, selectedConnection]);

  const isWormhole = useMemo(() =&gt; {
    return cnInfo?.type !== ConnectionType.gate;
  }, [cnInfo]);

  const [passages, setPassages] = useState&lt;Passage[]&gt;([]);
  const [info, setInfo] = useState&lt;ConnectionInfoOutput | null&gt;(null);

  const loadInfo = useCallback(
    async (connection: SolarSystemConnection) =&gt; {
      const result = await outCommand&lt;ConnectionInfoOutput&gt;({
        type: OutCommand.getConnectionInfo,
        data: {
          from: connection.source,
          to: connection.target,
        },
      });

      setInfo(result);
    },
    [outCommand],
  );

  const loadPassages = useCallback(
    async (connection: SolarSystemConnection) =&gt; {
      const result = await outCommand&lt;ConnectionOutput&gt;({
        type: OutCommand.getPassages,
        data: {
          from: connection.source,
          to: connection.target,
        },
      });

      setPassages(result.passages.sort((a, b) =&gt; sortByDate(b.inserted_at, a.inserted_at)));
    },
    [outCommand],
  );

  useEffect(() =&gt; {
    if (!selectedConnection) {
      return;
    }
    loadInfo(selectedConnection);
    loadPassages(selectedConnection);
  }, [selectedConnection]);

  const approximateMass = useMemo(() =&gt; {
    return passages.reduce((acc, x) =&gt; acc + parseInt(x.ship.ship_type_info.mass), 0);
  }, [passages]);

  if (!cnInfo) {
    return null;
  }

  return (
    &lt;Sidebar
      className={clsx(classes.SidebarOnTheMap, &apos;bg-neutral-900&apos;)}
      visible={!!selectedConnection}
      position=&quot;right&quot;
      onHide={onHide}
      header=&quot;Connection Info&quot;
      icons={&lt;&gt;&lt;/&gt;}
    &gt;
      &lt;div className={clsx(classes.SidebarContent, &apos;&apos;)}&gt;
        {/* Connection Info */}
        &lt;div className=&quot;px-2 flex flex-col gap-2&quot;&gt;
          {/* Connection Info Row */}
          &lt;InfoDrawer title=&quot;Connection&quot; rightSide&gt;
            &lt;div className=&quot;flex justify-end gap-2 items-center&quot;&gt;
              &lt;SystemView
                systemId={cnInfo.source}
                className={clsx(classes.InfoTextSize, &apos;select-none text-center&apos;)}
                hideRegion
              /&gt;
              &lt;span className=&quot;pi pi-angle-double-right text-stone-500 text-[15px]&quot;&gt;&lt;/span&gt;
              &lt;SystemView
                systemId={cnInfo.target}
                className={clsx(classes.InfoTextSize, &apos;select-none text-center&apos;)}
                hideRegion
              /&gt;
            &lt;/div&gt;
          &lt;/InfoDrawer&gt;

          &lt;div className=&quot;flex justify-between gap-2&quot;&gt;
            {/*Left column*/}
            &lt;div&gt;
              {isWormhole &amp;&amp; info?.marl_eol_time &amp;&amp; (
                &lt;InfoDrawer title=&quot;Mark EOL Time&quot;&gt;
                  &lt;TimeAgo timestamp={info.marl_eol_time} /&gt;
                &lt;/InfoDrawer&gt;
              )}
            &lt;/div&gt;

            {/*Right column*/}
            &lt;div&gt;
              {isWormhole &amp;&amp; (
                &lt;InfoDrawer title=&quot;Approximate mass of passages&quot; rightSide&gt;
                  {kgToTons(approximateMass)}
                &lt;/InfoDrawer&gt;
              )}
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div className=&quot;flex gap-2&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;

        {/* separator */}
        &lt;div className=&quot;w-full h-px bg-neutral-800 px-0.5&quot;&gt;&lt;/div&gt;

        &lt;ConnectionPassages passages={passages} /&gt;
      &lt;/div&gt;
    &lt;/Sidebar&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/Connections/index.ts">export * from &apos;./Connections.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapContextMenu/MapContextMenu.tsx">import { Menu } from &apos;primereact/menu&apos;;
import { useCallback, useMemo, useRef } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;
import { TooltipPosition } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types&apos;;
import { MenuItem } from &apos;primereact/menuitem&apos;;
import { useMapCheckPermissions } from &apos;@/hooks/Mapper/mapRootProvider/hooks/api&apos;;
import { UserPermission } from &apos;@/hooks/Mapper/types/permissions.ts&apos;;

export interface MapContextMenuProps {
  onShowOnTheMap?: () =&gt; void;
  onShowMapSettings?: () =&gt; void;
  onShowTrackingDialog?: () =&gt; void;
}

export const MapContextMenu = ({ onShowOnTheMap, onShowMapSettings, onShowTrackingDialog }: MapContextMenuProps) =&gt; {
  const { outCommand, setInterfaceSettings } = useMapRootState();

  const canTrackCharacters = useMapCheckPermissions([UserPermission.TRACK_CHARACTER]);

  const menuRight = useRef&lt;Menu&gt;(null);

  const handleShowActivity = useCallback(() =&gt; {
    outCommand({
      type: OutCommand.showActivity,
      data: {},
    });
  }, [outCommand]);

  const items = useMemo(() =&gt; {
    return (
      [
        {
          label: &apos;Tracking&apos;,
          icon: &apos;pi pi-user-plus&apos;,
          command: onShowTrackingDialog,
          visible: canTrackCharacters,
        },
        {
          label: &apos;Character Activity&apos;,
          icon: &apos;pi pi-chart-bar&apos;,
          command: handleShowActivity,
          visible: canTrackCharacters,
        },
        {
          label: &apos;On the map&apos;,
          icon: &apos;pi pi-hashtag&apos;,
          command: onShowOnTheMap,
          visible: canTrackCharacters,
        },
        { separator: true, visible: true },
        {
          label: &apos;Settings&apos;,
          icon: `pi pi-cog`,
          command: onShowMapSettings,
          visible: true,
        },
        {
          label: &apos;Dock menu&apos;,
          icon: &apos;pi pi-window-maximize&apos;,
          command: () =&gt;
            setInterfaceSettings(x =&gt; ({
              ...x,
              isShowMenu: !x.isShowMenu,
            })),
          visible: true,
        },
      ] as MenuItem[]
    ).filter(item =&gt; item.visible);
  }, [
    canTrackCharacters,
    onShowTrackingDialog,
    handleShowActivity,
    onShowMapSettings,
    onShowOnTheMap,
    setInterfaceSettings,
  ]);

  return (
    &lt;div className=&quot;ml-1&quot;&gt;
      &lt;WdTooltipWrapper content=&quot;Map Menu&quot; position={TooltipPosition.left}&gt;
        &lt;button
          className=&quot;btn bg-transparent text-gray-400 hover:text-white border-transparent hover:bg-transparent px-2&quot;
          type=&quot;button&quot;
          onClick={event =&gt; menuRight.current?.toggle(event)}
        &gt;
          &lt;i className=&quot;pi pi-sliders-h text-lg&quot;&gt;&lt;/i&gt;
        &lt;/button&gt;
      &lt;/WdTooltipWrapper&gt;
      &lt;Menu model={items} popup ref={menuRight} id=&quot;popup_menu_right&quot; popupAlignment=&quot;right&quot; /&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/components/PrettySwitchbox/index.ts">export * from &apos;./PrettySwitchbox&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/components/PrettySwitchbox/MapSettings.module.scss">.CheckboxContainer {
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;

  &amp; &gt; span:nth-child(1) {
    color: var(--gray-200);
    font-size: 13px;
    user-select: none;
  }

  &amp; &gt; :nth-child(2){
    border-bottom: 2px dotted #3f3f3f;
    height: 1px;
    margin: 0 12px;
  }
}

/* –£–º–µ–Ω—å—à–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ InputSwitch —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö —Å—Ç–∏–ª–µ–π */
.smallInputSwitch {
  height: 100%;
  display: flex;
  align-items: center;

  :global {
    .p-inputswitch {
      height: 1rem;
      width: 2rem;
      &amp;.p-inputswitch-checked {
        .p-inputswitch-slider::before {
          transform: translateX(1rem);
        }
      }

      &amp;.p-highlight .p-inputswitch-slider:before {
        transform: translateX(1rem);
      }

      .p-inputswitch-slider::before {
        width: 0.8rem;
        height: 0.8rem;
        margin-top: -0.4rem;
        margin-left: -3px;
      }
    }
  }

}</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/components/PrettySwitchbox/PrettySwitchbox.tsx">import styles from &apos;./MapSettings.module.scss&apos;;

import { WdCheckbox } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

interface PrettySwitchboxProps {
  checked: boolean;
  setChecked: (checked: boolean) =&gt; void;
  label: string;
}

export const PrettySwitchbox = ({ checked, setChecked, label }: PrettySwitchboxProps) =&gt; {
  return (
    &lt;label className={styles.CheckboxContainer}&gt;
      &lt;span&gt;{label}&lt;/span&gt;
      &lt;div /&gt;
      &lt;div className={styles.smallInputSwitch}&gt;
        &lt;WdCheckbox size=&quot;m&quot; label={&apos;&apos;} value={checked} onChange={e =&gt; setChecked(e.checked ?? false)} /&gt;
      &lt;/div&gt;
    &lt;/label&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/components/CommonSettings.tsx">import { COMMON_CHECKBOXES_PROPS } from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings/constants.ts&apos;;
import { useMapSettings } from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings/MapSettingsProvider.tsx&apos;;
import { SettingsListItem } from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings/types.ts&apos;;

export const CommonSettings = () =&gt; {
  const { renderSettingItem } = useMapSettings();

  const renderSettingsList = (list: SettingsListItem[]) =&gt; {
    return list.map(renderSettingItem);
  };

  return &lt;div className=&quot;w-full h-full flex flex-col gap-1&quot;&gt;{renderSettingsList(COMMON_CHECKBOXES_PROPS)}&lt;/div&gt;;
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/components/index.ts">export * from &apos;./PrettySwitchbox&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/components/WidgetsSettings.tsx">import { PrettySwitchbox } from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings/components/index.ts&apos;;
import { WIDGETS_CHECKBOXES_PROPS, WidgetsIds } from &apos;@/hooks/Mapper/components/mapInterface/constants.tsx&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback } from &apos;react&apos;;

import { Button } from &apos;primereact/button&apos;;

export interface WidgetsSettingsProps {}

// eslint-disable-next-line no-empty-pattern
export const WidgetsSettings = ({}: WidgetsSettingsProps) =&gt; {
  const { windowsSettings, toggleWidgetVisibility, resetWidgets } = useMapRootState();

  const handleWidgetSettingsChange = useCallback(
    (widget: WidgetsIds) =&gt; toggleWidgetVisibility(widget),
    [toggleWidgetVisibility],
  );

  return (
    &lt;div className=&quot;flex flex-col h-full gap-2&quot;&gt;
      &lt;div&gt;
        {WIDGETS_CHECKBOXES_PROPS.map(widget =&gt; (
          &lt;PrettySwitchbox
            key={widget.id}
            label={widget.label}
            checked={windowsSettings.visible.some(x =&gt; x === widget.id)}
            setChecked={() =&gt; handleWidgetSettingsChange(widget.id)}
          /&gt;
        ))}
      &lt;/div&gt;
      &lt;div className=&quot;grid grid-cols-[1fr_auto]&quot;&gt;
        &lt;div /&gt;
        &lt;Button className=&quot;py-[4px]&quot; onClick={resetWidgets} outlined size=&quot;small&quot; label=&quot;Reset Widgets&quot;&gt;&lt;/Button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/constants.ts">import { SettingsListItem, UserSettingsRemoteProps } from &apos;./types.ts&apos;;
import { InterfaceStoredSettingsProps } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { AvailableThemes } from &apos;@/hooks/Mapper/mapRootProvider/types.ts&apos;;

export const DEFAULT_REMOTE_SETTINGS = {
  [UserSettingsRemoteProps.link_signature_on_splash]: false,
  [UserSettingsRemoteProps.select_on_spash]: false,
  [UserSettingsRemoteProps.delete_connection_with_sigs]: false,
};

export const UserSettingsRemoteList = [
  UserSettingsRemoteProps.link_signature_on_splash,
  UserSettingsRemoteProps.select_on_spash,
  UserSettingsRemoteProps.delete_connection_with_sigs,
];

export const COMMON_CHECKBOXES_PROPS: SettingsListItem[] = [
  {
    prop: InterfaceStoredSettingsProps.isShowMinimap,
    label: &apos;Show Minimap&apos;,
    type: &apos;checkbox&apos;,
  },
];

export const SYSTEMS_CHECKBOXES_PROPS: SettingsListItem[] = [
  {
    prop: InterfaceStoredSettingsProps.isShowKSpace,
    label: &apos;Highlight Low/High-security systems&apos;,
    type: &apos;checkbox&apos;,
  },
  {
    prop: UserSettingsRemoteProps.select_on_spash,
    label: &apos;Auto-select splashed&apos;,
    type: &apos;checkbox&apos;,
  },
];

export const SIGNATURES_CHECKBOXES_PROPS: SettingsListItem[] = [
  {
    prop: UserSettingsRemoteProps.link_signature_on_splash,
    label: &apos;Link signature on splash&apos;,
    type: &apos;checkbox&apos;,
  },
  {
    prop: InterfaceStoredSettingsProps.isShowUnsplashedSignatures,
    label: &apos;Show unsplashed signatures&apos;,
    type: &apos;checkbox&apos;,
  },
];

export const CONNECTIONS_CHECKBOXES_PROPS: SettingsListItem[] = [
  {
    prop: UserSettingsRemoteProps.delete_connection_with_sigs,
    label: &apos;Delete connections to linked signatures&apos;,
    type: &apos;checkbox&apos;,
  },
  {
    prop: InterfaceStoredSettingsProps.isThickConnections,
    label: &apos;Thicker connections&apos;,
    type: &apos;checkbox&apos;,
  },
];

export const UI_CHECKBOXES_PROPS: SettingsListItem[] = [
  {
    prop: InterfaceStoredSettingsProps.isShowMenu,
    label: &apos;Enable compact map menu bar&apos;,
    type: &apos;checkbox&apos;,
  },
  {
    prop: InterfaceStoredSettingsProps.isShowBackgroundPattern,
    label: &apos;Show background pattern&apos;,
    type: &apos;checkbox&apos;,
  },
  {
    prop: InterfaceStoredSettingsProps.isSoftBackground,
    label: &apos;Enable soft background&apos;,
    type: &apos;checkbox&apos;,
  },
];

export const THEME_OPTIONS = [
  { label: &apos;Default&apos;, value: AvailableThemes.default },
  { label: &apos;Pathfinder&apos;, value: AvailableThemes.pathfinder },
];

export const THEME_SETTING: SettingsListItem = {
  prop: &apos;theme&apos;,
  label: &apos;Theme&apos;,
  type: &apos;dropdown&apos;,
  options: THEME_OPTIONS,
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/index.ts">export * from &apos;./MapSettings&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/MapSettings.module.scss">.CheckboxContainer {
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;

  &amp; &gt; span:nth-child(1) {
    color: var(--gray-200);
    font-size: 13px;
  }

  &amp; &gt; :nth-child(2){
    border-bottom: 2px dotted #3f3f3f;
    height: 2px;
    margin: 0 12px;
  }
}

/* –£–º–µ–Ω—å—à–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ InputSwitch —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö —Å—Ç–∏–ª–µ–π */
.smallInputSwitch {
  height: 100%;
  display: flex;
  align-items: center;

  :global {
    .p-inputswitch {
      height: 1rem;
      width: 2rem;
      &amp;.p-inputswitch-checked {
        .p-inputswitch-slider::before {
          transform: translateX(1rem);
        }
      }

      &amp;.p-highlight .p-inputswitch-slider:before {
        transform: translateX(1rem);
      }

      .p-inputswitch-slider::before {
        width: 0.8rem;
        height: 0.8rem;
        margin-top: -0.4rem;
        margin-left: -3px;
      }
    }
  }

}</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/MapSettings.tsx">import styles from &apos;./MapSettings.module.scss&apos;;
import { Dialog } from &apos;primereact/dialog&apos;;
import { useCallback, useRef, useState } from &apos;react&apos;;
import { TabPanel, TabView } from &apos;primereact/tabview&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types&apos;;
import {
  CONNECTIONS_CHECKBOXES_PROPS,
  SIGNATURES_CHECKBOXES_PROPS,
  SYSTEMS_CHECKBOXES_PROPS,
  THEME_SETTING,
  UI_CHECKBOXES_PROPS,
} from &apos;./constants.ts&apos;;
import {
  MapSettingsProvider,
  useMapSettings,
} from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings/MapSettingsProvider.tsx&apos;;
import { WidgetsSettings } from &apos;./components/WidgetsSettings&apos;;
import { CommonSettings } from &apos;./components/CommonSettings&apos;;
import { SettingsListItem } from &apos;./types.ts&apos;;

export interface MapSettingsProps {
  visible: boolean;
  onHide: () =&gt; void;
}

export const MapSettingsComp = ({ visible, onHide }: MapSettingsProps) =&gt; {
  const [activeIndex, setActiveIndex] = useState(0);
  const { outCommand } = useMapRootState();

  const { renderSettingItem, setUserRemoteSettings } = useMapSettings();

  const refVars = useRef({ outCommand, onHide, visible });
  refVars.current = { outCommand, onHide, visible };

  const handleShow = useCallback(async () =&gt; {
    const { user_settings } = await refVars.current.outCommand({
      type: OutCommand.getUserSettings,
      data: null,
    });
    setUserRemoteSettings({
      ...user_settings,
    });
  }, [setUserRemoteSettings]);

  const handleHide = useCallback(() =&gt; {
    if (!refVars.current.visible) {
      return;
    }

    setActiveIndex(0);
    refVars.current.onHide();
  }, []);

  const renderSettingsList = (list: SettingsListItem[]) =&gt; {
    return list.map(renderSettingItem);
  };

  return (
    &lt;Dialog
      header=&quot;Map user settings&quot;
      visible
      draggable={false}
      style={{ width: &apos;550px&apos; }}
      onShow={handleShow}
      onHide={handleHide}
    &gt;
      &lt;div className=&quot;flex flex-col gap-3&quot;&gt;
        &lt;div className=&quot;flex flex-col gap-2&quot;&gt;
          &lt;TabView
            activeIndex={activeIndex}
            className=&quot;vertical-tabs-container&quot;
            onTabChange={e =&gt; setActiveIndex(e.index)}
          &gt;
            &lt;TabPanel header=&quot;Common&quot; headerClassName={styles.verticalTabHeader}&gt;
              &lt;CommonSettings /&gt;
            &lt;/TabPanel&gt;

            &lt;TabPanel header=&quot;Systems&quot; headerClassName={styles.verticalTabHeader}&gt;
              &lt;div className=&quot;w-full h-full flex flex-col gap-1&quot;&gt;{renderSettingsList(SYSTEMS_CHECKBOXES_PROPS)}&lt;/div&gt;
            &lt;/TabPanel&gt;

            &lt;TabPanel header=&quot;Connections&quot; headerClassName={styles.verticalTabHeader}&gt;
              {renderSettingsList(CONNECTIONS_CHECKBOXES_PROPS)}
            &lt;/TabPanel&gt;

            &lt;TabPanel header=&quot;Signatures&quot; headerClassName={styles.verticalTabHeader}&gt;
              {renderSettingsList(SIGNATURES_CHECKBOXES_PROPS)}
            &lt;/TabPanel&gt;

            &lt;TabPanel header=&quot;User Interface&quot; headerClassName={styles.verticalTabHeader}&gt;
              {renderSettingsList(UI_CHECKBOXES_PROPS)}
            &lt;/TabPanel&gt;

            &lt;TabPanel header=&quot;Widgets&quot; className=&quot;h-full&quot; headerClassName={styles.verticalTabHeader}&gt;
              &lt;WidgetsSettings /&gt;
            &lt;/TabPanel&gt;

            &lt;TabPanel header=&quot;Theme&quot; headerClassName={styles.verticalTabHeader}&gt;
              {renderSettingItem(THEME_SETTING)}
            &lt;/TabPanel&gt;
          &lt;/TabView&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/Dialog&gt;
  );
};

export const MapSettings = (props: MapSettingsProps) =&gt; {
  return (
    &lt;MapSettingsProvider&gt;
      &lt;MapSettingsComp {...props} /&gt;
    &lt;/MapSettingsProvider&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/MapSettingsProvider.tsx">import {
  createContext,
  Dispatch,
  ReactNode,
  SetStateAction,
  useCallback,
  useContext,
  useMemo,
  useRef,
  useState,
} from &apos;react&apos;;
import {
  SettingsListItem,
  UserSettings,
  UserSettingsRemote,
} from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings/types.ts&apos;;
import {
  DEFAULT_REMOTE_SETTINGS,
  UserSettingsRemoteList,
} from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings/constants.ts&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types&apos;;
import { PrettySwitchbox } from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings/components&apos;;
import { Dropdown } from &apos;primereact/dropdown&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

type MapSettingsContextType = {
  renderSettingItem: (item: SettingsListItem) =&gt; ReactNode;
  setUserRemoteSettings: Dispatch&lt;SetStateAction&lt;UserSettingsRemote&gt;&gt;;
};

const MapSettingsContext = createContext&lt;MapSettingsContextType | undefined&gt;(undefined);

export const MapSettingsProvider = ({ children }: { children: ReactNode }) =&gt; {
  const {
    outCommand,
    storedSettings: { interfaceSettings, setInterfaceSettings },
  } = useMapRootState();

  const [userRemoteSettings, setUserRemoteSettings] = useState&lt;UserSettingsRemote&gt;({
    ...DEFAULT_REMOTE_SETTINGS,
  });

  const mergedSettings: UserSettings = useMemo(() =&gt; {
    return {
      ...userRemoteSettings,
      ...interfaceSettings,
    };
  }, [userRemoteSettings, interfaceSettings]);

  const refVars = useRef({ mergedSettings, userRemoteSettings, interfaceSettings, outCommand, setInterfaceSettings });
  refVars.current = { mergedSettings, userRemoteSettings, interfaceSettings, outCommand, setInterfaceSettings };

  const handleSettingChange = useCallback(async (prop: keyof UserSettings, value: boolean | string) =&gt; {
    const { userRemoteSettings, interfaceSettings, outCommand, setInterfaceSettings } = refVars.current;

    if (UserSettingsRemoteList.includes(prop as any)) {
      const newRemoteSettings = {
        ...userRemoteSettings,
        [prop]: value,
      };
      await outCommand({
        type: OutCommand.updateUserSettings,
        data: newRemoteSettings,
      });
      setUserRemoteSettings(newRemoteSettings);
    } else {
      setInterfaceSettings({
        ...interfaceSettings,
        [prop]: value,
      });
    }
  }, []);

  const renderSettingItem = useCallback(
    (item: SettingsListItem) =&gt; {
      const currentValue = refVars.current.mergedSettings[item.prop];

      if (item.type === &apos;checkbox&apos;) {
        return (
          &lt;PrettySwitchbox
            key={item.prop.toString()}
            label={item.label}
            checked={!!currentValue}
            setChecked={checked =&gt; handleSettingChange(item.prop, checked)}
          /&gt;
        );
      }

      if (item.type === &apos;dropdown&apos; &amp;&amp; item.options) {
        return (
          &lt;div key={item.prop.toString()} className=&quot;flex items-center gap-2 mt-2&quot;&gt;
            &lt;label className=&quot;text-sm&quot;&gt;{item.label}:&lt;/label&gt;
            &lt;Dropdown
              className=&quot;text-sm&quot;
              value={currentValue}
              options={item.options}
              onChange={e =&gt; handleSettingChange(item.prop, e.value)}
              placeholder=&quot;Select a theme&quot;
            /&gt;
          &lt;/div&gt;
        );
      }

      return null;
    },
    [handleSettingChange],
  );

  return (
    &lt;MapSettingsContext.Provider value={{ renderSettingItem, setUserRemoteSettings }}&gt;
      {children}
    &lt;/MapSettingsContext.Provider&gt;
  );
};

export const useMapSettings = () =&gt; {
  const context = useContext(MapSettingsContext);
  if (!context) {
    throw new Error(&apos;useMapSettings must be used within a MapSettingsProvider&apos;);
  }
  return context;
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/MapSettings/types.ts">import { InterfaceStoredSettings } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

export enum UserSettingsRemoteProps {
  link_signature_on_splash = &apos;link_signature_on_splash&apos;,
  select_on_spash = &apos;select_on_spash&apos;,
  delete_connection_with_sigs = &apos;delete_connection_with_sigs&apos;,
}

export type UserSettingsRemote = {
  link_signature_on_splash: boolean;
  select_on_spash: boolean;
  delete_connection_with_sigs: boolean;
};

export type UserSettings = UserSettingsRemote &amp; InterfaceStoredSettings;

export type SettingsListItem = {
  prop: keyof UserSettings;
  label: string;
  type: &apos;checkbox&apos; | &apos;dropdown&apos;;
  options?: { label: string; value: string }[];
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/OnTheMap/index.ts">export * from &apos;./OnTheMap&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/OnTheMap/OnTheMap.module.scss">.OnTheMapRoot {

}

.SidebarOnTheMap {
  width: 500px;
  padding: 0 !important;

  :global {
    .p-sidebar-content {
      padding-left: 0px;
      padding-right: 0px;
    }
  }
}

.SidebarContent {
  display: grid;
  grid-template-rows: auto 1fr;
  row-gap: 4px;
  height: 100%;
}</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/OnTheMap/OnTheMap.tsx">import classes from &apos;./OnTheMap.module.scss&apos;;
import { Sidebar } from &apos;primereact/sidebar&apos;;
import { useMemo, useState } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { sortCharacters } from &apos;@/hooks/Mapper/components/mapInterface/helpers/sortCharacters.ts&apos;;
import { VirtualScroller, VirtualScrollerTemplateOptions } from &apos;primereact/virtualscroller&apos;;
import clsx from &apos;clsx&apos;;
import { CharacterTypeRaw, WithIsOwnCharacter } from &apos;@/hooks/Mapper/types&apos;;
import { CharacterCard, TooltipPosition, WdCheckbox, WdImageSize, WdImgButton } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import useLocalStorageState from &apos;use-local-storage-state&apos;;
import { useMapCheckPermissions, useMapGetOption } from &apos;@/hooks/Mapper/mapRootProvider/hooks/api&apos;;
import { UserPermission } from &apos;@/hooks/Mapper/types/permissions.ts&apos;;
import { InputText } from &apos;primereact/inputtext&apos;;
import { IconField } from &apos;primereact/iconfield&apos;;

type WindowLocalSettingsType = {
  compact: boolean;
  hideOffline: boolean;
  version: number;
};

const STORED_DEFAULT_VALUES: WindowLocalSettingsType = {
  compact: true,
  hideOffline: false,
  version: 0,
};

const itemTemplate = (item: CharacterTypeRaw &amp; WithIsOwnCharacter, options: VirtualScrollerTemplateOptions) =&gt; {
  return (
    &lt;div
      className={clsx(classes.CharacterRow, &apos;w-full box-border px-2 py-1&apos;, {
        &apos;surface-hover&apos;: options.odd,
        [&apos;border-b border-gray-600 border-opacity-20&apos;]: !options.last,
        [&apos;bg-green-500 hover:bg-green-700 transition duration-300 bg-opacity-10 hover:bg-opacity-10&apos;]: item.online,
      })}
      style={{ height: options.props.itemSize + &apos;px&apos; }}
    &gt;
      &lt;CharacterCard showCorporationLogo showAllyLogo showSystem showTicker {...item} /&gt;
    &lt;/div&gt;
  );
};

export interface OnTheMapProps {
  show: boolean;
  onHide: () =&gt; void;
}

export const OnTheMap = ({ show, onHide }: OnTheMapProps) =&gt; {
  const {
    data: { characters, userCharacters },
  } = useMapRootState();

  const [searchVal, setSearchVal] = useState(&apos;&apos;);

  const [settings, setSettings] = useLocalStorageState&lt;WindowLocalSettingsType&gt;(&apos;window:onTheMap:settings&apos;, {
    defaultValue: STORED_DEFAULT_VALUES,
  });

  const restrictOfflineShowing = useMapGetOption(&apos;restrict_offline_showing&apos;);
  const isAdminOrManager = useMapCheckPermissions([UserPermission.MANAGE_MAP]);

  const showOffline = useMemo(
    () =&gt; !restrictOfflineShowing || isAdminOrManager,
    [isAdminOrManager, restrictOfflineShowing],
  );

  const sorted = useMemo(() =&gt; {
    let out = characters.map(x =&gt; ({ ...x, isOwn: userCharacters.includes(x.eve_id) })).sort(sortCharacters);

    if (searchVal !== &apos;&apos;) {
      out = out.filter(x =&gt; {
        const normalized = searchVal.toLowerCase();

        if (x.name.toLowerCase().includes(normalized)) {
          return true;
        }

        if (x.corporation_name.toLowerCase().includes(normalized)) {
          return true;
        }

        if (x.alliance_name?.toLowerCase().includes(normalized)) {
          return true;
        }

        if (x.corporation_ticker.toLowerCase().includes(normalized)) {
          return true;
        }

        if (x.alliance_ticker?.toLowerCase().includes(normalized)) {
          return true;
        }

        if (x.ship?.ship_name?.toLowerCase().includes(normalized)) {
          return true;
        }

        if (x.ship?.ship_type_info.name?.toLowerCase().includes(normalized)) {
          return true;
        }

        if (x.ship?.ship_type_info.group_name?.toLowerCase().includes(normalized)) {
          return true;
        }

        return false;
      });
    }

    if (showOffline &amp;&amp; !settings.hideOffline) {
      return out;
    }

    return out.filter(x =&gt; x.online);
  }, [showOffline, searchVal, characters, settings.hideOffline, userCharacters]);

  return (
    &lt;Sidebar
      className={clsx(classes.SidebarOnTheMap, &apos;bg-neutral-900&apos;)}
      visible={show}
      position=&quot;right&quot;
      onHide={onHide}
      header={`On the map [${sorted.length}]`}
      icons={&lt;&gt;&lt;/&gt;}
    &gt;
      &lt;div className={clsx(classes.SidebarContent, &apos;&apos;)}&gt;
        &lt;div className={&apos;flex justify-between items-center gap-2 px-2 pt-1&apos;}&gt;
          &lt;IconField&gt;
            {searchVal.length &gt; 0 &amp;&amp; (
              &lt;WdImgButton
                className=&quot;pi pi-trash&quot;
                textSize={WdImageSize.large}
                tooltip={{
                  content: &apos;Clear&apos;,
                  className: &apos;pi p-input-icon&apos;,
                  position: TooltipPosition.top,
                }}
                onClick={() =&gt; setSearchVal(&apos;&apos;)}
              /&gt;
            )}
            &lt;InputText
              id=&quot;label&quot;
              aria-describedby=&quot;label&quot;
              autoComplete=&quot;off&quot;
              value={searchVal}
              placeholder=&quot;Type to search&quot;
              onChange={e =&gt; setSearchVal(e.target.value)}
            /&gt;
          &lt;/IconField&gt;

          {showOffline &amp;&amp; (
            &lt;WdCheckbox
              size=&quot;m&quot;
              labelSide=&quot;left&quot;
              label={&apos;Hide offline&apos;}
              value={settings.hideOffline}
              classNameLabel=&quot;text-stone-400 hover:text-stone-200 transition duration-300&quot;
              onChange={() =&gt; setSettings(() =&gt; ({ ...settings, hideOffline: !settings.hideOffline }))}
            /&gt;
          )}
        &lt;/div&gt;

        &lt;VirtualScroller
          items={sorted}
          itemSize={41}
          itemTemplate={itemTemplate}
          className={clsx(
            classes.VirtualScroller,
            &apos;w-full h-full overflow-x-hidden overflow-y-auto custom-scrollbar select-none&apos;,
          )}
          autoSize={false}
        /&gt;
      &lt;/div&gt;
    &lt;/Sidebar&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/RightBar/index.ts">export * from &apos;./RightBar&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/RightBar/RightBar.module.scss">.RightBarRoot {
  
}</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/RightBar/RightBar.tsx">import classes from &apos;./RightBar.module.scss&apos;;
import clsx from &apos;clsx&apos;;
import { useCallback } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;
import { TooltipPosition } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

import { useMapCheckPermissions } from &apos;@/hooks/Mapper/mapRootProvider/hooks/api&apos;;
import { UserPermission } from &apos;@/hooks/Mapper/types/permissions.ts&apos;;

interface RightBarProps {
  onShowOnTheMap?: () =&gt; void;
  onShowMapSettings?: () =&gt; void;
  onShowTrackingDialog?: () =&gt; void;
}

export const RightBar = ({ onShowOnTheMap, onShowMapSettings, onShowTrackingDialog }: RightBarProps) =&gt; {
  const {
    storedSettings: { interfaceSettings, setInterfaceSettings },
  } = useMapRootState();

  const canTrackCharacters = useMapCheckPermissions([UserPermission.TRACK_CHARACTER]);

  const isShowMinimap = interfaceSettings.isShowMinimap === undefined ? true : interfaceSettings.isShowMinimap;

  const toggleMinimap = useCallback(() =&gt; {
    setInterfaceSettings(x =&gt; ({
      ...x,
      isShowMinimap: !x.isShowMinimap,
    }));
  }, [setInterfaceSettings]);

  const toggleKSpace = useCallback(() =&gt; {
    setInterfaceSettings(x =&gt; ({
      ...x,
      isShowKSpace: !x.isShowKSpace,
    }));
  }, [setInterfaceSettings]);

  const toggleMenu = useCallback(() =&gt; {
    setInterfaceSettings(x =&gt; ({
      ...x,
      isShowMenu: !x.isShowMenu,
    }));
  }, [setInterfaceSettings]);

  return (
    &lt;div
      className={clsx(
        classes.RightBarRoot,
        &apos;w-full h-full&apos;,
        &apos;text-gray-200 shadow-lg border-l border-zinc-800 border-opacity-70 bg-opacity-70 bg-neutral-900&apos;,
        &apos;flex flex-col items-center justify-between&apos;,
      )}
    &gt;
      &lt;div className=&quot;flex flex-col gap-2 items-center mt-1&quot;&gt;
        {canTrackCharacters &amp;&amp; (
          &lt;&gt;
            &lt;WdTooltipWrapper content=&quot;Tracking status&quot; position={TooltipPosition.left}&gt;
              &lt;button
                className=&quot;btn bg-transparent text-gray-400 hover:text-white border-transparent hover:bg-transparent py-2 h-auto min-h-auto&quot;
                type=&quot;button&quot;
                onClick={onShowTrackingDialog}
                id=&quot;show-tracking-button&quot;
              &gt;
                &lt;i className=&quot;pi pi-user-plus&quot;&gt;&lt;/i&gt;
              &lt;/button&gt;
            &lt;/WdTooltipWrapper&gt;

            &lt;WdTooltipWrapper content=&quot;Show on the map&quot; position={TooltipPosition.left}&gt;
              &lt;button
                className=&quot;btn bg-transparent text-gray-400 hover:text-white border-transparent hover:bg-transparent py-2 h-auto min-h-auto&quot;
                type=&quot;button&quot;
                onClick={onShowOnTheMap}
              &gt;
                &lt;i className=&quot;pi pi-hashtag&quot;&gt;&lt;/i&gt;
              &lt;/button&gt;
            &lt;/WdTooltipWrapper&gt;
          &lt;/&gt;
        )}
      &lt;/div&gt;

      &lt;div className=&quot;flex flex-col items-center mb-2 gap-1&quot;&gt;
        &lt;WdTooltipWrapper content=&quot;Map user settings&quot; position={TooltipPosition.left}&gt;
          &lt;button
            className=&quot;btn bg-transparent text-gray-400 hover:text-white border-transparent hover:bg-transparent py-2 h-auto min-h-auto&quot;
            type=&quot;button&quot;
            onClick={onShowMapSettings}
          &gt;
            &lt;i className=&quot;pi pi-cog&quot;&gt;&lt;/i&gt;
          &lt;/button&gt;
        &lt;/WdTooltipWrapper&gt;

        &lt;WdTooltipWrapper
          content={
            interfaceSettings.isShowKSpace ? &apos;Hide highlighting Imperial Space&apos; : &apos;Show highlighting Imperial Space&apos;
          }
          position={TooltipPosition.left}
        &gt;
          &lt;button
            className=&quot;btn bg-transparent text-gray-400 hover:text-white border-transparent hover:bg-transparent py-2 h-auto min-h-auto&quot;
            type=&quot;button&quot;
            onClick={toggleKSpace}
          &gt;
            &lt;i className={interfaceSettings.isShowKSpace ? &apos;hero-cloud-solid&apos; : &apos;hero-cloud&apos;}&gt;&lt;/i&gt;
          &lt;/button&gt;
        &lt;/WdTooltipWrapper&gt;

        &lt;WdTooltipWrapper content={isShowMinimap ? &apos;Hide minimap&apos; : &apos;Show minimap&apos;} position={TooltipPosition.left}&gt;
          &lt;button
            className=&quot;btn bg-transparent text-gray-400 hover:text-white border-transparent hover:bg-transparent py-2 h-auto min-h-auto&quot;
            type=&quot;button&quot;
            onClick={toggleMinimap}
          &gt;
            &lt;i className={isShowMinimap ? &apos;pi pi-eye&apos; : &apos;pi pi-eye-slash&apos;}&gt;&lt;/i&gt;
          &lt;/button&gt;
        &lt;/WdTooltipWrapper&gt;

        &lt;WdTooltipWrapper content=&quot;Switch to menu&quot; position={TooltipPosition.left}&gt;
          &lt;button
            className=&quot;btn bg-transparent text-gray-400 hover:text-white border-transparent hover:bg-transparent py-2 h-auto min-h-auto&quot;
            type=&quot;button&quot;
            onClick={toggleMenu}
          &gt;
            &lt;i className=&quot;pi pi-window-minimize&quot;&gt;&lt;/i&gt;
          &lt;/button&gt;
        &lt;/WdTooltipWrapper&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureEOLCheckbox/index.ts">export * from &apos;./SignatureEOLCheckbox.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureEOLCheckbox/SignatureEOLCheckbox.tsx">import { InputSwitch } from &apos;primereact/inputswitch&apos;;
import { Controller, useFormContext } from &apos;react-hook-form&apos;;
import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;

export interface SignatureEOLCheckboxProps {
  name: string;
  defaultValue?: boolean;
}

export const SignatureEOLCheckbox = ({ name, defaultValue = false }: SignatureEOLCheckboxProps) =&gt; {
  const { control } = useFormContext&lt;SystemSignature&gt;();

  return (
    &lt;Controller
      // @ts-ignore
      name={name}
      control={control}
      defaultValue={defaultValue}
      render={({ field }) =&gt; {
        return &lt;InputSwitch className=&quot;my-1&quot; checked={!!field.value} onChange={e =&gt; field.onChange(e.value)} /&gt;;
      }}
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureGroupContent/index.ts">export * from &apos;./SignatureGroupContent&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureGroupContent/SignatureGroupContent.tsx">import { Controller, useFormContext } from &apos;react-hook-form&apos;;
import { SignatureGroup, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { useSystemsSettingsProvider } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/Provider.tsx&apos;;
import { SignatureGroupContentWormholes } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureGroupContentWormholes.tsx&apos;;
import { InputText } from &apos;primereact/inputtext&apos;;

export interface SignatureGroupContentProps {}

export const SignatureGroupContent = ({}: SignatureGroupContentProps) =&gt; {
  const { watch, control } = useFormContext&lt;SystemSignature&gt;();
  const group = watch(&apos;group&apos;);

  const {
    value: { systemId },
  } = useSystemsSettingsProvider();

  if (!systemId) {
    return null;
  }

  if (group === SignatureGroup.Wormhole) {
    return (
      &lt;&gt;
        &lt;SignatureGroupContentWormholes /&gt;
      &lt;/&gt;
    );
  }

  if (group === SignatureGroup.CosmicSignature) {
    return &lt;div&gt;&lt;/div&gt;;
  }

  return (
    &lt;div&gt;
      &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center text-[14px]&quot;&gt;
        &lt;span&gt;Name:&lt;/span&gt;
        &lt;Controller
          name=&quot;name&quot;
          control={control}
          render={({ field }) =&gt; &lt;InputText placeholder=&quot;Name&quot; value={field.value} onChange={field.onChange} /&gt;}
        /&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureGroupSelect/index.ts">export * from &apos;./SignatureGroupSelect&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureGroupSelect/SignatureGroupSelect.tsx">import { Dropdown } from &apos;primereact/dropdown&apos;;
import clsx from &apos;clsx&apos;;
import { SignatureGroup, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { renderIcon } from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/renders&apos;;
import { Controller, useFormContext } from &apos;react-hook-form&apos;;

const signatureGroupOptions = Object.keys(SignatureGroup).map(x =&gt; ({
  value: SignatureGroup[x as keyof typeof SignatureGroup],
  label: SignatureGroup[x as keyof typeof SignatureGroup],
}));

// @ts-ignore
const renderSignatureTemplate = option =&gt; {
  if (!option) {
    return &apos;No group selected&apos;;
  }

  return (
    &lt;div className=&quot;flex gap-2 items-center&quot;&gt;
      &lt;span className=&quot;w-[20px] mt-[1px] flex justify-center items-center&quot;&gt;
        {renderIcon(
          { group: option.label } as SystemSignature,
          option.label === SignatureGroup.CosmicSignature ? { w: 10, h: 10 } : { w: 16, h: 16 },
        )}
      &lt;/span&gt;
      &lt;span&gt;{option.label}&lt;/span&gt;
    &lt;/div&gt;
  );
};

export interface SignatureGroupSelectProps {
  name: string;
  defaultValue?: string;
}

export const SignatureGroupSelect = ({ name, defaultValue = &apos;&apos; }: SignatureGroupSelectProps) =&gt; {
  const { control } = useFormContext();
  return (
    &lt;Controller
      name={name}
      control={control}
      defaultValue={defaultValue}
      render={({ field }) =&gt; (
        &lt;Dropdown
          value={field.value}
          onChange={field.onChange}
          options={signatureGroupOptions}
          optionLabel=&quot;label&quot;
          optionValue=&quot;value&quot;
          placeholder=&quot;Select group&quot;
          className={clsx(&apos;w-full&apos;)}
          scrollHeight=&quot;240px&quot;
          itemTemplate={renderSignatureTemplate}
          valueTemplate={renderSignatureTemplate}
        /&gt;
      )}
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureK162TypeSelect/index.ts">export * from &apos;./SignatureK162TypeSelect.tsx&apos;;
export * from &apos;./renderK162Type.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureK162TypeSelect/renderK162Type.tsx">import { WHClassView } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { K162Type } from &apos;@/hooks/Mapper/constants.ts&apos;;

const renderNoValue = () =&gt; &lt;div className=&quot;flex gap-2 items-center&quot;&gt;-Unknown-&lt;/div&gt;;

export const renderK162Type = (option: K162Type) =&gt; {
  if (!option) {
    return renderNoValue();
  }

  const { value, whClassName = &apos;&apos; } = option;
  if (value == null) {
    return renderNoValue();
  }

  return (
    &lt;WHClassView
      classNameWh=&quot;!text-[11px] !font-bold&quot;
      hideWhClassName
      hideTooltip
      whClassName={whClassName}
      noOffset
      useShortTitle
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureK162TypeSelect/SignatureK162TypeSelect.tsx">import { Dropdown } from &apos;primereact/dropdown&apos;;
import clsx from &apos;clsx&apos;;
import { Controller, useFormContext } from &apos;react-hook-form&apos;;
import { useMemo } from &apos;react&apos;;
import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { K162_TYPES } from &apos;@/hooks/Mapper/constants.ts&apos;;
import { renderK162Type } from &apos;.&apos;;

export interface SignatureK162TypeSelectProps {
  name: string;
  defaultValue?: string;
}

export const SignatureK162TypeSelect = ({ name, defaultValue = &apos;&apos; }: SignatureK162TypeSelectProps) =&gt; {
  const { control } = useFormContext&lt;SystemSignature&gt;();

  const options = useMemo(() =&gt; {
    return [{ value: null }, ...K162_TYPES];
  }, []);

  return (
    &lt;Controller
      // @ts-ignore
      name={name}
      control={control}
      defaultValue={defaultValue}
      render={({ field }) =&gt; {
        return (
          &lt;Dropdown
            value={field.value}
            onChange={field.onChange}
            options={options}
            optionValue=&quot;value&quot;
            placeholder=&quot;Select K162 type&quot;
            className={clsx(&apos;w-full&apos;)}
            scrollHeight=&quot;240px&quot;
            itemTemplate={renderK162Type}
            valueTemplate={renderK162Type}
          /&gt;
        );
      }}
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureLeadsToSelect/index.ts">export * from &apos;./SignatureLeadsToSelect.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureLeadsToSelect/SignatureLeadsToSelect.module.scss">.SystemView {
  font-size: 14px !important;
}</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureLeadsToSelect/SignatureLeadsToSelect.tsx">import { Dropdown } from &apos;primereact/dropdown&apos;;
import clsx from &apos;clsx&apos;;
import { Controller, useFormContext } from &apos;react-hook-form&apos;;
import { useSystemsSettingsProvider } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/Provider.tsx&apos;;
import { useSystemInfo } from &apos;@/hooks/Mapper/components/hooks&apos;;
import { useMemo } from &apos;react&apos;;
import { SystemView } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import classes from &apos;./SignatureLeadsToSelect.module.scss&apos;;
import { useLoadSystemStatic } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic.ts&apos;;
import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { WORMHOLES_ADDITIONAL_INFO_BY_CLASS_ID } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

// @ts-ignore
const renderLinkedSystemItem = (option: { value: string }) =&gt; {
  const { value } = option;
  if (value == null) {
    return &lt;div className=&quot;flex gap-2 items-center&quot;&gt;- Unknown -&lt;/div&gt;;
  }

  return (
    &lt;div className=&quot;flex gap-2 items-center&quot;&gt;
      &lt;SystemView systemId={value} className={classes.SystemView} /&gt;
    &lt;/div&gt;
  );
};

// @ts-ignore
const renderLinkedSystemValue = (option: { value: string }) =&gt; {
  if (!option) {
    return &apos;Select Leads To system&apos;;
  }

  if (option.value == null) {
    return &apos;Select Leads To system&apos;;
  }

  return (
    &lt;div className=&quot;flex gap-2 items-center&quot;&gt;
      &lt;SystemView systemId={option.value} className={classes.SystemView} /&gt;
    &lt;/div&gt;
  );
};

const renderLeadsToEmpty = () =&gt; &lt;div className=&quot;flex items-center text-[14px]&quot;&gt;No wormhole to select&lt;/div&gt;;

export interface SignatureLeadsToSelectProps {
  name: string;
  defaultValue?: string;
}

export const SignatureLeadsToSelect = ({ name, defaultValue = &apos;&apos; }: SignatureLeadsToSelectProps) =&gt; {
  const { control, watch } = useFormContext&lt;SystemSignature&gt;();
  const group = watch(&apos;type&apos;);

  const {
    value: { systemId },
  } = useSystemsSettingsProvider();

  const { leadsTo } = useSystemInfo({ systemId });
  const { systems: systemStatics } = useLoadSystemStatic({ systems: leadsTo });
  const {
    data: { wormholes },
  } = useMapRootState();

  const leadsToOptions = useMemo(() =&gt; {
    return [
      { value: null },

      ...leadsTo
        .filter(systemId =&gt; {
          const systemStatic = systemStatics.get(parseInt(systemId));
          const whInfo = wormholes.find(x =&gt; x.name === group);

          if (!systemStatic || !whInfo || group === &apos;K162&apos;) {
            return true;
          }

          const { id: whType } = WORMHOLES_ADDITIONAL_INFO_BY_CLASS_ID[systemStatic.system_class];
          return whInfo.dest === whType;
        })
        .map(x =&gt; ({ value: x })),
    ];
  }, [group, leadsTo, systemStatics, wormholes]);

  return (
    &lt;Controller
      // @ts-ignore
      name={name}
      control={control}
      defaultValue={defaultValue}
      render={({ field }) =&gt; {
        return (
          &lt;Dropdown
            value={field.value}
            onChange={field.onChange}
            options={leadsToOptions}
            optionValue=&quot;value&quot;
            placeholder=&quot;Select Leads To wormhole&quot;
            className={clsx(&apos;w-full&apos;)}
            scrollHeight=&quot;240px&quot;
            itemTemplate={renderLinkedSystemItem}
            valueTemplate={renderLinkedSystemValue}
            emptyMessage={renderLeadsToEmpty}
          /&gt;
        );
      }}
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureWormholeTypeSelect/index.ts">export * from &apos;./SignatureWormholeTypeSelect&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureWormholeTypeSelect/SignatureWormholeTypeSelect.tsx">import { Dropdown } from &apos;primereact/dropdown&apos;;
import clsx from &apos;clsx&apos;;
import { Respawn, SolarSystemStaticInfoRaw, WormholeDataRaw } from &apos;@/hooks/Mapper/types&apos;;
import { Controller, useFormContext } from &apos;react-hook-form&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useSystemsSettingsProvider } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/Provider.tsx&apos;;
import { useSystemInfo } from &apos;@/hooks/Mapper/components/hooks&apos;;
import {
  SOLAR_SYSTEM_CLASSES_TO_CLASS_GROUPS,
  WORMHOLES_ADDITIONAL_INFO_BY_CLASS_ID,
} from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { useMemo } from &apos;react&apos;;
import { WHClassView } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

const getPossibleWormholes = (systemStatic: SolarSystemStaticInfoRaw, wormholes: WormholeDataRaw[]) =&gt; {
  const { id: whType } = WORMHOLES_ADDITIONAL_INFO_BY_CLASS_ID[systemStatic.system_class];

  // @ts-ignore
  const spawnClassGroup = SOLAR_SYSTEM_CLASSES_TO_CLASS_GROUPS[whType];
  const possibleWHTypes = wormholes.filter(x =&gt; {
    return x.src.some(x =&gt; {
      const [group, type] = x.split(&apos;-&apos;);

      if (type === &apos;shattered&apos;) {
        return systemStatic.is_shattered &amp;&amp; group === spawnClassGroup;
      }

      return group === spawnClassGroup;
    });
  });

  return {
    statics: possibleWHTypes
      .filter(x =&gt; x.respawn.some(y =&gt; y === Respawn.static))
      .filter(x =&gt; systemStatic.statics.includes(x.name)),
    k162: wormholes.find(x =&gt; x.name === &apos;K162&apos;)!,
    wanderings: possibleWHTypes.filter(x =&gt; x.respawn.some(y =&gt; y === Respawn.wandering)),
  };
};

// @ts-ignore
const renderWHTypeGroupTemplate = option =&gt; {
  return (
    &lt;div className=&quot;flex gap-2 items-center&quot;&gt;
      &lt;span&gt;{option.label}&lt;/span&gt;
    &lt;/div&gt;
  );
};

// @ts-ignore
const renderWHTypeTemplateValue = (option: { label: string; data: WormholeDataRaw }) =&gt; {
  if (!option) {
    return &apos;Select wormhole type&apos;;
  }

  return (
    &lt;div className=&quot;flex gap-2 items-center&quot;&gt;
      &lt;WHClassView whClassName={option.data.name} noOffset useShortTitle /&gt;
    &lt;/div&gt;
  );
};

// @ts-ignore
const renderWHTypeTemplate = (option: { label: string; data: WormholeDataRaw }) =&gt; {
  return (
    &lt;div className=&quot;flex gap-2 items-center ml-[1rem]&quot;&gt;
      &lt;WHClassView whClassName={option.data.name} noOffset useShortTitle /&gt;
    &lt;/div&gt;
  );
};

export interface SignatureGroupSelectProps {
  name: string;
  defaultValue?: string;
}

export const SignatureWormholeTypeSelect = ({ name, defaultValue = &apos;&apos; }: SignatureGroupSelectProps) =&gt; {
  const { control } = useFormContext();

  const {
    data: { wormholes },
  } = useMapRootState();

  const {
    value: { systemId },
  } = useSystemsSettingsProvider();

  const system = useSystemInfo({ systemId });

  const possibleWormholesOptions = useMemo(() =&gt; {
    const possibleWormholes = getPossibleWormholes(system.staticInfo, wormholes);

    return [
      {
        label: &apos;Statics&apos;,
        items: [
          ...possibleWormholes.statics.map(x =&gt; ({
            label: x.name,
            value: x.name,
            data: x,
          })),
          {
            value: possibleWormholes.k162.name,
            label: possibleWormholes.k162.name,
            data: possibleWormholes.k162,
          },
        ],
      },
      {
        label: &apos;Wanderings&apos;,
        items: possibleWormholes.wanderings.map(x =&gt; ({
          label: x.name,
          value: x.name,
          data: x,
        })),
      },
    ];
  }, [system, wormholes]);

  return (
    &lt;Controller
      name={name}
      control={control}
      defaultValue={defaultValue}
      render={({ field }) =&gt; (
        &lt;Dropdown
          value={field.value}
          onChange={field.onChange}
          options={possibleWormholesOptions}
          optionLabel=&quot;label&quot;
          optionValue=&quot;value&quot;
          placeholder=&quot;Select wormhole type&quot;
          optionGroupLabel=&quot;label&quot;
          optionGroupChildren=&quot;items&quot;
          className={clsx(&apos;w-full&apos;)}
          scrollHeight=&quot;240px&quot;
          optionGroupTemplate={renderWHTypeGroupTemplate}
          itemTemplate={renderWHTypeTemplate}
          valueTemplate={renderWHTypeTemplateValue}
        /&gt;
      )}
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/index.ts">export * from &apos;./SignatureGroupSelect&apos;;
export * from &apos;./SignatureGroupContent&apos;;
export * from &apos;./SignatureK162TypeSelect&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureGroupContentWormholes.tsx">import { useFormContext } from &apos;react-hook-form&apos;;
import { SystemSignature } from &apos;@/hooks/Mapper/types&apos;;
import { SignatureWormholeTypeSelect } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureWormholeTypeSelect&apos;;
import { SignatureK162TypeSelect } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureK162TypeSelect&apos;;
import { SignatureLeadsToSelect } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureLeadsToSelect&apos;;
import { SignatureEOLCheckbox } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components/SignatureEOLCheckbox&apos;;

export const SignatureGroupContentWormholes = () =&gt; {
  const { watch } = useFormContext&lt;SystemSignature&gt;();
  const type = watch(&apos;type&apos;);

  return (
    &lt;&gt;
      &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center text-[14px]&quot;&gt;
        &lt;span&gt;Type:&lt;/span&gt;
        &lt;SignatureWormholeTypeSelect name=&quot;type&quot; /&gt;
      &lt;/label&gt;

      {type === &apos;K162&apos; &amp;&amp; (
        &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center text-[14px]&quot;&gt;
          &lt;span&gt;K162 Type:&lt;/span&gt;
          &lt;SignatureK162TypeSelect name=&quot;k162Type&quot; /&gt;
        &lt;/label&gt;
      )}

      &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center text-[14px]&quot;&gt;
        &lt;span&gt;Leads To:&lt;/span&gt;
        &lt;SignatureLeadsToSelect name=&quot;linked_system&quot; /&gt;
      &lt;/label&gt;

      &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center text-[14px]&quot;&gt;
        &lt;span&gt;EOL:&lt;/span&gt;
        &lt;SignatureEOLCheckbox name=&quot;isEOL&quot; /&gt;
      &lt;/label&gt;
    &lt;/&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/index.ts">export * from &apos;./SignatureSettings.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/Provider.tsx">import { createGenericContext } from &apos;@/hooks/Mapper/utils/abstractContextProvider.tsx&apos;;

export interface SystemsSettingsProvider {
  systemId: string;
}

const { Provider, useContextValue } = createGenericContext&lt;SystemsSettingsProvider&gt;();

export const SystemsSettingsProvider = Provider;
export const useSystemsSettingsProvider = useContextValue;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/SignatureSettings.module.scss">.verticalTabsContainer {
  width: 100%;
  min-height: 300px;
}

.verticalTabsContainer {
  display: flex;
  width: 100%;
  min-height: 300px;

  :global {
    .p-tabview {
      width: 100%;
      display: flex;
      align-items: flex-start;
    }

    .p-tabview-panels {
      padding: 6px 1rem !important;
      flex-grow: 1;
    }

    .p-tabview-nav-container {
      border-right: none;
      height: 100%;
    }

    .p-tabview-nav {
      flex-direction: column;
      width: 150px;
      min-height: 100%;
      border: none;

      li {
        width: 100%;
        border-right: 4px solid var(--surface-hover);
        background-color: var(--surface-card);

        transition: background-color 200ms, border-right-color 200ms;

        &amp;:hover {
          background-color: var(--surface-hover);
          border-right: 4px solid var(--surface-100);
        }

        .p-tabview-nav-link {
          transition: color 200ms;

          justify-content: flex-end;
          padding: 10px;
          background-color: initial;
          border: none;
          color: var(--gray-400);

          border-radius: initial;
          font-weight: 400;
          margin: 0;
        }

        &amp;.p-tabview-selected {
          background-color: var(--surface-50);
          border-right: 4px solid var(--primary-color);

          .p-tabview-nav-link {
            font-weight: 600;
            color: var(--primary-color);
          }

          &amp;:hover {
            border-right: 4px solid var(--primary-color);
          }

        }
      }
    }

    .p-tabview-panel {
      flex-grow: 1;
    }
  }
}</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/SignatureSettings/SignatureSettings.tsx">import { Dialog } from &apos;primereact/dialog&apos;;
import { useCallback, useEffect } from &apos;react&apos;;
import { OutCommand, SignatureGroup, SystemSignature, TimeStatus } from &apos;@/hooks/Mapper/types&apos;;
import { Controller, FormProvider, useForm } from &apos;react-hook-form&apos;;
import {
  SignatureGroupContent,
  SignatureGroupSelect,
} from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/components&apos;;
import { InputText } from &apos;primereact/inputtext&apos;;
import { SystemsSettingsProvider } from &apos;@/hooks/Mapper/components/mapRootContent/components/SignatureSettings/Provider.tsx&apos;;
import { Button } from &apos;primereact/button&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { getWhSize } from &apos;@/hooks/Mapper/helpers/getWhSize&apos;;

type SystemSignaturePrepared = Omit&lt;SystemSignature, &apos;linked_system&apos;&gt; &amp; { linked_system: string };

export interface MapSettingsProps {
  systemId: string;
  show: boolean;
  onHide: () =&gt; void;
  signatureData: SystemSignature | undefined;
}

export const SignatureSettings = ({ systemId, show, onHide, signatureData }: MapSettingsProps) =&gt; {
  const {
    outCommand,
    data: { wormholes },
  } = useMapRootState();

  const handleShow = async () =&gt; {};
  const signatureForm = useForm&lt;Partial&lt;SystemSignaturePrepared&gt;&gt;({});

  const handleSave = useCallback(
    // TODO: need fix
    async (e: any) =&gt; {
      e?.preventDefault();
      if (!signatureData) {
        return;
      }

      const { group, ...values } = signatureForm.getValues();
      let out = { ...signatureData };

      switch (group) {
        case SignatureGroup.Wormhole:
          if (values.linked_system) {
            await outCommand({
              type: OutCommand.linkSignatureToSystem,
              data: {
                signature_eve_id: signatureData.eve_id,
                solar_system_source: systemId,
                solar_system_target: values.linked_system,
              },
            });

            // TODO: need fix
            if (values.isEOL) {
              await outCommand({
                type: OutCommand.updateConnectionTimeStatus,
                data: {
                  source: systemId,
                  target: values.linked_system,
                  value: TimeStatus.eol,
                },
              });
            }

            if (values.type) {
              const whShipSize = getWhSize(wormholes, values.type);
              if (whShipSize) {
                outCommand({
                  type: OutCommand.updateConnectionShipSizeType,
                  data: {
                    source: systemId,
                    target: values.linked_system,
                    value: whShipSize,
                  },
                });
              }
            }
          }

          out = {
            ...out,
            custom_info: JSON.stringify({
              // TODO: need fix
              k162Type: values.k162Type,
              // TODO: need fix
              isEOL: values.isEOL,
            }),
          };

          if (values.type != null) {
            out = { ...out, type: values.type };
          }

          if (signatureData.group !== SignatureGroup.Wormhole) {
            out = { ...out, name: &apos;&apos; };
          }

          break;
        case SignatureGroup.CosmicSignature:
          out = { ...out, type: &apos;&apos;, name: &apos;&apos; };
          break;
        default:
          if (values.name != null) {
            out = { ...out, name: values.name ?? &apos;&apos; };
          }
      }

      if (values.description != null) {
        out = { ...out, description: values.description };
      }

      // Note: when type of signature changed from WH to other type - we should drop name
      if (
        group !== SignatureGroup.Wormhole &amp;&amp; // new
        signatureData.group === SignatureGroup.Wormhole &amp;&amp; // prev
        signatureData.linked_system
      ) {
        await outCommand({
          type: OutCommand.unlinkSignature,
          data: { signature_eve_id: signatureData.eve_id, solar_system_source: systemId },
        });

        out = { ...out, type: &apos;&apos; };
      }

      if (group === SignatureGroup.Wormhole &amp;&amp; signatureData.linked_system != null &amp;&amp; values.linked_system === null) {
        await outCommand({
          type: OutCommand.unlinkSignature,
          data: { signature_eve_id: signatureData.eve_id, solar_system_source: systemId },
        });
      }

      // Note: despite groups have optional type - this will always set
      out = { ...out, group: group! };

      await outCommand({
        type: OutCommand.updateSignatures,
        data: {
          system_id: systemId,
          added: [],
          updated: [out],
          removed: [],
        },
      });

      signatureForm.reset();
      onHide();
    },
    [signatureData, signatureForm, outCommand, systemId, onHide, wormholes],
  );

  useEffect(() =&gt; {
    if (!signatureData) {
      signatureForm.reset();
      return;
    }

    const { linked_system, custom_info, ...rest } = signatureData;

    let k162Type = null;
    let isEOL = false;
    if (custom_info) {
      const customInfo = JSON.parse(custom_info);
      k162Type = customInfo.k162Type;
      isEOL = customInfo.isEOL;
    }

    signatureForm.reset({
      linked_system: linked_system?.solar_system_id.toString() ?? undefined,
      // TODO: need fix
      k162Type: k162Type,
      isEOL: isEOL,
      ...rest,
    });
  }, [signatureForm, signatureData]);

  return (
    &lt;Dialog
      header={`Signature Edit [${signatureData?.eve_id}]`}
      visible={show}
      draggable={false}
      style={{ width: &apos;390px&apos; }}
      onShow={handleShow}
      onHide={() =&gt; {
        if (!show) {
          return;
        }

        onHide();
      }}
    &gt;
      &lt;SystemsSettingsProvider initialValue={{ systemId }}&gt;
        &lt;FormProvider {...signatureForm}&gt;
          &lt;form onSubmit={handleSave}&gt;
            &lt;div className=&quot;flex flex-col gap-2 justify-between&quot;&gt;
              &lt;div className=&quot;w-full flex flex-col gap-1 p-1 min-h-[150px]&quot;&gt;
                &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center text-[14px]&quot;&gt;
                  &lt;span&gt;Group:&lt;/span&gt;
                  &lt;SignatureGroupSelect name=&quot;group&quot; /&gt;
                &lt;/label&gt;

                &lt;SignatureGroupContent /&gt;

                &lt;label className=&quot;grid grid-cols-[100px_250px_1fr] gap-2 items-center text-[14px]&quot;&gt;
                  &lt;span&gt;Description:&lt;/span&gt;
                  &lt;Controller
                    name=&quot;description&quot;
                    control={signatureForm.control}
                    render={({ field }) =&gt; (
                      &lt;InputText placeholder=&quot;Type description&quot; value={field.value} onChange={field.onChange} /&gt;
                    )}
                  /&gt;
                &lt;/label&gt;
              &lt;/div&gt;

              &lt;div className=&quot;flex gap-2 justify-end&quot;&gt;
                &lt;Button onClick={handleSave} outlined size=&quot;small&quot; label=&quot;Save&quot;&gt;&lt;/Button&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/form&gt;
        &lt;/FormProvider&gt;
      &lt;/SystemsSettingsProvider&gt;
    &lt;/Dialog&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/TrackingDialog/index.ts">export * from &apos;./TrackingDialog.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/TrackingDialog/TrackingCharactersList.tsx">import { Column } from &apos;primereact/column&apos;;
import { CharacterCard } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { DataTable } from &apos;primereact/datatable&apos;;
import { useCallback, useEffect, useRef, useState } from &apos;react&apos;;
import { TrackingCharacter } from &apos;@/hooks/Mapper/types&apos;;
import { useTracking } from &apos;@/hooks/Mapper/components/mapRootContent/components/TrackingDialog/TrackingProvider.tsx&apos;;

export const TrackingCharactersList = () =&gt; {
  const [selected, setSelected] = useState&lt;TrackingCharacter[]&gt;([]);
  const { trackingCharacters, updateTracking } = useTracking();
  const refVars = useRef({ trackingCharacters });
  refVars.current = { trackingCharacters };

  useEffect(() =&gt; {
    setSelected(trackingCharacters.filter(x =&gt; x.tracked));
  }, [trackingCharacters]);

  const handleChangeSelect = useCallback(
    (selected: TrackingCharacter[]) =&gt; updateTracking(selected.map(x =&gt; x.character.eve_id)),
    [updateTracking],
  );

  return (
    &lt;DataTable
      value={trackingCharacters}
      size=&quot;small&quot;
      selectionMode={null}
      selection={selected}
      onSelectionChange={e =&gt; handleChangeSelect(e.value)}
      virtualScrollerOptions={{ itemSize: 40 }}
      className=&quot;relative w-full select-none min-h-0 h-full&quot;
      resizableColumns={false}
      rowHover
      selectAll
    &gt;
      &lt;Column
        selectionMode=&quot;multiple&quot;
        headerClassName=&quot;h-[40px] !pl-4&quot;
        className=&quot;w-12 max-w-12 !pl-4 [&amp;_div]:mt-[-2px] &quot;
      /&gt;
      &lt;Column
        field=&quot;eve_id&quot;
        header=&quot;Character with tracking access&quot;
        bodyClassName=&quot;text-ellipsis overflow-hidden whitespace-nowrap&quot;
        headerClassName=&quot;[&amp;_div]:ml-2&quot;
        body={row =&gt; {
          return &lt;CharacterCard showCorporationLogo showTicker isOwn {...row.character} /&gt;;
        }}
      /&gt;
    &lt;/DataTable&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/TrackingDialog/TrackingDialog.tsx">import { useEffect, useRef, useState } from &apos;react&apos;;
import { Dialog } from &apos;primereact/dialog&apos;;
import { TabPanel, TabView } from &apos;primereact/tabview&apos;;
import { TrackingSettings } from &apos;./TrackingSettings.tsx&apos;;
import { TrackingCharactersList } from &apos;./TrackingCharactersList.tsx&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { TrackingProvider, useTracking } from &apos;./TrackingProvider.tsx&apos;;

interface TrackingDialogProps {
  visible: boolean;
  onHide: () =&gt; void;
}

const TrackingDialogComp = ({ visible, onHide }: TrackingDialogProps) =&gt; {
  const [activeIndex, setActiveIndex] = useState(0);
  const { outCommand } = useMapRootState();
  const { loadTracking } = useTracking();

  const refVars = useRef({ outCommand });
  refVars.current = { outCommand };

  useEffect(() =&gt; {
    if (!visible) {
      return;
    }

    loadTracking();
  }, [loadTracking, visible]);

  return (
    &lt;Dialog
      header={
        &lt;div className=&quot;dialog-header&quot;&gt;
          &lt;span className=&quot;pointer-events-none&quot;&gt;Track &amp; Follow&lt;/span&gt;
        &lt;/div&gt;
      }
      draggable={false}
      resizable={false}
      visible={visible}
      onHide={onHide}
      className=&quot;w-[640px] h-[400px] text-text-color min-h-0&quot;
    &gt;
      &lt;TabView
        className=&quot;vertical-tabs-container h-full [&amp;_.p-tabview-panels]:!pr-0&quot;
        activeIndex={activeIndex}
        onTabChange={e =&gt; setActiveIndex(e.index)}
        renderActiveOnly={false}
      &gt;
        &lt;TabPanel header=&quot;Tracking&quot; contentClassName=&quot;h-full&quot;&gt;
          &lt;TrackingCharactersList /&gt;
        &lt;/TabPanel&gt;
        &lt;TabPanel header=&quot;Follow &amp; Settings&quot;&gt;
          &lt;TrackingSettings /&gt;
        &lt;/TabPanel&gt;
      &lt;/TabView&gt;
    &lt;/Dialog&gt;
  );
};

export const TrackingDialog = (props: TrackingDialogProps) =&gt; {
  return (
    &lt;TrackingProvider&gt;
      &lt;TrackingDialogComp {...props} /&gt;
    &lt;/TrackingProvider&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/TrackingDialog/TrackingProvider.tsx">import { createContext, useCallback, useContext, useRef, useState } from &apos;react&apos;;
import { OutCommand, TrackingCharacter } from &apos;@/hooks/Mapper/types&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { IncomingEvent, WithChildren } from &apos;@/hooks/Mapper/types/common.ts&apos;;
import { CommandInCharactersTrackingInfo } from &apos;@/hooks/Mapper/types/commandsIn.ts&apos;;

type DiffTrackingInfo = { characterId: string; tracked: boolean };

type TrackingContextType = {
  loadTracking: () =&gt; void;
  updateTracking: (selected: string[]) =&gt; void;
  updateFollowing: (characterId: string | null) =&gt; void;
  updateMain: (characterId: string) =&gt; void;
  trackingCharacters: TrackingCharacter[];
  following: string | null;
  main: string | null;
  loading: boolean;
};

const TrackingContext = createContext&lt;TrackingContextType | undefined&gt;(undefined);

export const TrackingProvider = ({ children }: WithChildren) =&gt; {
  const [trackingCharacters, setTrackingCharacters] = useState&lt;TrackingCharacter[]&gt;([]);
  const [following, setFollowing] = useState&lt;string | null&gt;(null);
  const [main, setMain] = useState&lt;string | null&gt;(null);
  const [loading, setLoading] = useState&lt;boolean&gt;(false);

  const { outCommand } = useMapRootState();
  const refVars = useRef({ outCommand, trackingCharacters, following });
  refVars.current = { outCommand, trackingCharacters, following };

  const loadTracking = useCallback(async () =&gt; {
    setLoading(true);

    try {
      const res: IncomingEvent&lt;CommandInCharactersTrackingInfo&gt; = await refVars.current.outCommand({
        type: OutCommand.getCharactersTrackingInfo,
        data: {},
      });

      setTrackingCharacters(res.data.characters);
      setFollowing(res.data.following);
      setMain(res.data.main);
    } catch (err) {
      console.error(&apos;TrackingProviderError&apos;, err);
    }

    setLoading(false);
  }, []);

  const changeTrackingCommand = useCallback(
    async (characterId: string, track: boolean) =&gt; {
      try {
        await outCommand({
          type: OutCommand.updateCharacterTracking,
          data: { character_eve_id: characterId, track },
        });
      } catch (error) {
        console.error(&apos;Error toggling track:&apos;, error);
      }
    },
    [outCommand],
  );

  const updateFollowing = useCallback(
    async (characterId: string | null) =&gt; {
      try {
        await outCommand({
          type: OutCommand.updateFollowingCharacter,
          data: { character_eve_id: characterId },
        });
        setFollowing(characterId);
      } catch (error) {
        console.error(&apos;Error toggling follow:&apos;, error);
      }
    },
    [outCommand],
  );

  const updateTracking = useCallback(
    async (selected: string[]) =&gt; {
      const { following, trackingCharacters } = refVars.current;
      const diffToUpdate: DiffTrackingInfo[] = [];

      const newVal = trackingCharacters.map(x =&gt; {
        const next = selected.includes(x.character.eve_id);

        if (next !== x.tracked) {
          diffToUpdate.push({ characterId: x.character.eve_id, tracked: next });
        }

        return {
          tracked: selected.includes(x.character.eve_id),
          character: x.character,
        };
      });

      await Promise.all(diffToUpdate.map(x =&gt; changeTrackingCommand(x.characterId, x.tracked)));

      if (newVal.some(x =&gt; following != null &amp;&amp; x.character.eve_id === following &amp;&amp; !x.tracked)) {
        await updateFollowing(null);
        setFollowing(null);
      }

      setTrackingCharacters(newVal);
    },
    [changeTrackingCommand, updateFollowing],
  );

  const updateMain = useCallback(
    async (characterId: string) =&gt; {
      try {
        await outCommand({
          type: OutCommand.updateMainCharacter,
          data: { character_eve_id: characterId },
        });
        setMain(characterId);
      } catch (error) {
        console.error(&apos;Error toggling main:&apos;, error);
      }
    },
    [outCommand],
  );

  return (
    &lt;TrackingContext.Provider
      value={{
        loadTracking,
        trackingCharacters,
        following,
        main,
        loading,
        updateTracking,
        updateFollowing,
        updateMain,
      }}
    &gt;
      {children}
    &lt;/TrackingContext.Provider&gt;
  );
};

export const useTracking = () =&gt; {
  const context = useContext(TrackingContext);
  if (!context) {
    throw new Error(&apos;useTracking must be used within a TrackingProvider&apos;);
  }
  return context;
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/TrackingDialog/TrackingSettings.tsx">import { Dropdown } from &apos;primereact/dropdown&apos;;
import { useCallback, useMemo } from &apos;react&apos;;
import { TrackingCharacter } from &apos;@/hooks/Mapper/types&apos;;
import { CharacterCard } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { useTracking } from &apos;@/hooks/Mapper/components/mapRootContent/components/TrackingDialog/TrackingProvider.tsx&apos;;

const renderValCharacterTemplate = (row: TrackingCharacter | undefined) =&gt; {
  if (!row) {
    return &lt;div className=&quot;h-[26px] flex items-center&quot;&gt;Character is not selected&lt;/div&gt;;
  }

  return (
    &lt;div className=&quot;py-1 w-full&quot;&gt;
      &lt;CharacterCard compact isOwn {...row.character} /&gt;
    &lt;/div&gt;
  );
};

const renderCharacterTemplate = (row: TrackingCharacter | undefined) =&gt; {
  if (!row) {
    return &lt;div className=&quot;h-[33px] flex items-center&quot;&gt;Character is not selected&lt;/div&gt;;
  }

  return (
    &lt;div className=&quot;w-full&quot;&gt;
      &lt;CharacterCard isOwn {...row.character} /&gt;
    &lt;/div&gt;
  );
};

export const TrackingSettings = () =&gt; {
  const { trackingCharacters, following, main, updateFollowing, updateMain } = useTracking();

  const followingChar = useMemo(
    () =&gt; trackingCharacters.filter(x =&gt; x.tracked).find(x =&gt; x.character.eve_id === following),
    [following, trackingCharacters],
  );

  const availableForFollowingCharacters = useMemo(
    () =&gt; trackingCharacters.filter(x =&gt; x.tracked),
    [trackingCharacters],
  );

  const mainChar = useMemo(() =&gt; trackingCharacters.find(x =&gt; x.character.eve_id === main), [main, trackingCharacters]);

  const handleSelectFollowing = useCallback(
    (e: TrackingCharacter | null) =&gt; updateFollowing(e == null ? null : e.character.eve_id),
    [updateFollowing],
  );

  const handleSelectMain = useCallback((e: TrackingCharacter) =&gt; updateMain(e.character.eve_id), [updateMain]);

  return (
    &lt;div className=&quot;w-full h-full flex flex-col gap-1&quot;&gt;
      &lt;div className=&quot;flex items-center justify-between gap-2 mx-2&quot;&gt;
        &lt;label className=&quot;text-stone-400 text-[13px] select-none&quot;&gt;Main character&lt;/label&gt;
        &lt;Dropdown
          options={trackingCharacters}
          value={mainChar}
          onChange={e =&gt; handleSelectMain(e.value)}
          className=&quot;w-[230px]&quot;
          itemTemplate={renderCharacterTemplate}
          valueTemplate={renderValCharacterTemplate}
        /&gt;
      &lt;/div&gt;

      &lt;div className=&quot;flex items-center justify-between gap-2 mx-2&quot;&gt;
        &lt;label className=&quot;text-stone-400 text-[13px] select-none&quot;&gt;Following character&lt;/label&gt;
        &lt;Dropdown
          disabled={availableForFollowingCharacters.length === 0}
          options={availableForFollowingCharacters}
          value={followingChar}
          onChange={e =&gt; handleSelectFollowing(e.value)}
          className=&quot;w-[230px]&quot;
          itemTemplate={renderCharacterTemplate}
          valueTemplate={renderValCharacterTemplate}
          showClear
          placeholder=&quot;Character is not selected&quot;
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/components/index.ts">export * from &apos;./RightBar&apos;;
export * from &apos;./OnTheMap&apos;;</file><file path="assets/js/hooks/Mapper/components/mapRootContent/hooks/useCharacterActivityHandlers.ts">import { useCallback } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers&apos;;
import { ActivitySummary } from &apos;@/hooks/Mapper/types&apos;;

/**
 * Hook for character activity related handlers
 */
export const useCharacterActivityHandlers = () =&gt; {
  const { outCommand, update } = useMapRootState();

  /**
   * Handle hiding the character activity dialog
   */
  const handleHideCharacterActivity = useCallback(() =&gt; {
    // Update local state to hide the dialog
    update(state =&gt; ({
      ...state,
      showCharacterActivity: false,
    }));
  }, [update]);

  /**
   * Handle showing the character activity dialog
   */
  const handleShowActivity = useCallback(() =&gt; {
    // Update local state to show the dialog
    update(state =&gt; ({
      ...state,
      showCharacterActivity: true,
    }));

    // Send the command to the server
    outCommand({
      type: OutCommand.showActivity,
      data: {},
    });
  }, [outCommand, update]);

  /**
   * Handle updating character activity data
   */
  const handleUpdateActivity = useCallback(
    (activityData: { activity: ActivitySummary[] }) =&gt; {
      if (!activityData || !activityData.activity) {
        console.error(&apos;Invalid activity data received:&apos;, activityData);
        return;
      }

      // Update local state with the activity data
      update(state =&gt; ({
        ...state,
        characterActivityData: activityData,
        showCharacterActivity: true,
      }));
    },
    [update],
  );

  return {
    handleHideCharacterActivity,
    handleShowActivity,
    handleUpdateActivity,
  };
};</file><file path="assets/js/hooks/Mapper/components/mapRootContent/MapRootContent.tsx">import Topbar from &apos;@/hooks/Mapper/components/topbar/Topbar.tsx&apos;;
import { MapInterface } from &apos;@/hooks/Mapper/components/mapInterface/MapInterface.tsx&apos;;
import Layout from &apos;@/hooks/Mapper/components/layout/Layout.tsx&apos;;
import { MapWrapper } from &apos;@/hooks/Mapper/components/mapWrapper/MapWrapper.tsx&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback, useState } from &apos;react&apos;;
import { OnTheMap, RightBar } from &apos;@/hooks/Mapper/components/mapRootContent/components&apos;;
import { MapContextMenu } from &apos;@/hooks/Mapper/components/mapRootContent/components/MapContextMenu/MapContextMenu.tsx&apos;;
import { useSkipContextMenu } from &apos;@/hooks/Mapper/hooks/useSkipContextMenu&apos;;
import { MapSettings } from &apos;@/hooks/Mapper/components/mapRootContent/components/MapSettings&apos;;
import { CharacterActivity } from &apos;@/hooks/Mapper/components/mapRootContent/components/CharacterActivity&apos;;
import { useCharacterActivityHandlers } from &apos;./hooks/useCharacterActivityHandlers&apos;;
import { TrackingDialog } from &apos;@/hooks/Mapper/components/mapRootContent/components/TrackingDialog&apos;;
import { useMapEventListener } from &apos;@/hooks/Mapper/events&apos;;
import { Commands } from &apos;@/hooks/Mapper/types&apos;;

export interface MapRootContentProps {}

// eslint-disable-next-line no-empty-pattern
export const MapRootContent = ({}: MapRootContentProps) =&gt; {
  const {
    storedSettings: { interfaceSettings },
    data,
  } = useMapRootState();
  const { isShowMenu } = interfaceSettings;
  const { showCharacterActivity } = data;
  const { handleHideCharacterActivity } = useCharacterActivityHandlers();

  const themeClass = `${interfaceSettings.theme ?? &apos;default&apos;}-theme`;

  const [showOnTheMap, setShowOnTheMap] = useState(false);
  const [showMapSettings, setShowMapSettings] = useState(false);
  const [showTrackingDialog, setShowTrackingDialog] = useState(false);

  /* Important Notice - this solution needs for use one instance of MapInterface */
  const mapInterface = &lt;MapInterface /&gt;;

  const handleShowOnTheMap = useCallback(() =&gt; setShowOnTheMap(true), []);
  const handleShowMapSettings = useCallback(() =&gt; setShowMapSettings(true), []);
  const handleShowTrackingDialog = useCallback(() =&gt; setShowTrackingDialog(true), []);

  useMapEventListener(event =&gt; {
    if (event.name === Commands.showTracking) {
      setShowTrackingDialog(true);
      return true;
    }
  });

  useSkipContextMenu();

  return (
    &lt;div className={themeClass}&gt;
      &lt;Layout map={&lt;MapWrapper /&gt;}&gt;
        {!isShowMenu ? (
          &lt;div className=&quot;absolute top-0 left-14 w-[calc(100%-3.5rem)] h-[calc(100%-3.5rem)] pointer-events-none&quot;&gt;
            &lt;div className=&quot;absolute top-0 left-0 w-[calc(100%-3.5rem)] h-full pointer-events-none&quot;&gt;
              &lt;Topbar /&gt;
              {mapInterface}
            &lt;/div&gt;
            &lt;div className=&quot;absolute top-0 right-0 w-14 h-[calc(100%+3.5rem)] pointer-events-auto&quot;&gt;
              &lt;RightBar
                onShowOnTheMap={handleShowOnTheMap}
                onShowMapSettings={handleShowMapSettings}
                onShowTrackingDialog={handleShowTrackingDialog}
              /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        ) : (
          &lt;div className=&quot;absolute top-0 left-14 w-[calc(100%-3.5rem)] h-[calc(100%-3.5rem)] pointer-events-none&quot;&gt;
            &lt;Topbar&gt;
              &lt;MapContextMenu
                onShowOnTheMap={handleShowOnTheMap}
                onShowMapSettings={handleShowMapSettings}
                onShowTrackingDialog={handleShowTrackingDialog}
              /&gt;
            &lt;/Topbar&gt;
            {mapInterface}
          &lt;/div&gt;
        )}
        &lt;OnTheMap show={showOnTheMap} onHide={() =&gt; setShowOnTheMap(false)} /&gt;
        {showMapSettings &amp;&amp; &lt;MapSettings visible={showMapSettings} onHide={() =&gt; setShowMapSettings(false)} /&gt;}
        {showCharacterActivity &amp;&amp; (
          &lt;CharacterActivity visible={showCharacterActivity} onHide={handleHideCharacterActivity} /&gt;
        )}
        {showTrackingDialog &amp;&amp; (
          &lt;TrackingDialog visible={showTrackingDialog} onHide={() =&gt; setShowTrackingDialog(false)} /&gt;
        )}
      &lt;/Layout&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/mapWrapper/hooks/useCommonMapEventProcessor.ts">import { MutableRefObject, useCallback, useEffect, useRef } from &apos;react&apos;;
import { Command, Commands, MapHandlers } from &apos;@/hooks/Mapper/types&apos;;
import { MapEvent } from &apos;@/hooks/Mapper/events&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

export const useCommonMapEventProcessor = () =&gt; {
  const mapRef = useRef&lt;MapHandlers&gt;() as MutableRefObject&lt;MapHandlers&gt;;
  const {
    data: { systems },
  } = useMapRootState();

  const refQueue = useRef&lt;MapEvent&lt;Command&gt;[]&gt;([]);

  // const ref = useRef({})

  const runCommand = useCallback(({ name, data }: MapEvent&lt;Command&gt;) =&gt; {
    switch (name) {
      case Commands.addSystems:
      case Commands.removeSystems:
        // case Commands.addConnections:
        refQueue.current.push({ name, data });
        return;
    }

    // @ts-ignore hz why here type error
    mapRef.current?.command(name, data);
  }, []);

  useEffect(() =&gt; {
    refQueue.current.forEach(x =&gt; mapRef.current?.command(x.name, x.data));
    refQueue.current = [];
  }, [systems]);

  return {
    mapRef,
    runCommand,
  };
};</file><file path="assets/js/hooks/Mapper/components/mapWrapper/MapWrapper.module.scss">.MiniMap {
  right: 3.5rem !important;
}</file><file path="assets/js/hooks/Mapper/components/mapWrapper/MapWrapper.tsx">import { Map, MAP_ROOT_ID } from &apos;@/hooks/Mapper/components/map/Map.tsx&apos;;
import { useCallback, useEffect, useRef, useState } from &apos;react&apos;;
import { OutCommand, OutCommandHandler, SolarSystemConnection } from &apos;@/hooks/Mapper/types&apos;;
import { MapRootData, useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { OnMapAddSystemCallback, OnMapSelectionChange } from &apos;@/hooks/Mapper/components/map/map.types.ts&apos;;
import isEqual from &apos;lodash.isequal&apos;;
import { ContextMenuSystem, useContextMenuSystemHandlers } from &apos;@/hooks/Mapper/components/contexts&apos;;
import {
  SystemCustomLabelDialog,
  SystemLinkSignatureDialog,
  SystemSettingsDialog,
} from &apos;@/hooks/Mapper/components/mapInterface/components&apos;;
import classes from &apos;./MapWrapper.module.scss&apos;;
import { Connections } from &apos;@/hooks/Mapper/components/mapRootContent/components/Connections&apos;;
import { ContextMenuSystemMultiple, useContextMenuSystemMultipleHandlers } from &apos;../contexts/ContextMenuSystemMultiple&apos;;
import { getSystemById } from &apos;@/hooks/Mapper/helpers&apos;;
import { Commands } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { Node, useReactFlow, XYPosition } from &apos;reactflow&apos;;

import { useCommandsSystems } from &apos;@/hooks/Mapper/mapRootProvider/hooks/api&apos;;
import { emitMapEvent, useMapEventListener } from &apos;@/hooks/Mapper/events&apos;;

import { useDeleteSystems } from &apos;@/hooks/Mapper/components/contexts/hooks&apos;;
import { useCommonMapEventProcessor } from &apos;@/hooks/Mapper/components/mapWrapper/hooks/useCommonMapEventProcessor.ts&apos;;
import {
  AddSystemDialog,
  SearchOnSubmitCallback,
} from &apos;@/hooks/Mapper/components/mapInterface/components/AddSystemDialog&apos;;
import { useHotkey } from &apos;../../hooks/useHotkey&apos;;
import { STORED_INTERFACE_DEFAULT_VALUES } from &apos;@/hooks/Mapper/mapRootProvider/constants.ts&apos;;

// TODO: INFO - this component needs for abstract work with Map instance
export const MapWrapper = () =&gt; {
  const {
    update,
    outCommand,
    data: { selectedConnections, selectedSystems, hubs, userHubs, systems, linkSignatureToSystem, systemSignatures },
    storedSettings: { interfaceSettings },
  } = useMapRootState();

  const {
    isShowMenu,
    isShowMinimap = STORED_INTERFACE_DEFAULT_VALUES.isShowMinimap,
    isShowKSpace,
    isThickConnections,
    isShowBackgroundPattern,
    isShowUnsplashedSignatures,
    isSoftBackground,
    theme,
  } = interfaceSettings;

  const { deleteSystems } = useDeleteSystems();
  const { mapRef, runCommand } = useCommonMapEventProcessor();
  const { getNodes } = useReactFlow();

  const { updateLinkSignatureToSystem } = useCommandsSystems();
  const { open, ...systemContextProps } = useContextMenuSystemHandlers({ systems, hubs, userHubs, outCommand });
  const { handleSystemMultipleContext, ...systemMultipleCtxProps } = useContextMenuSystemMultipleHandlers();

  const [openSettings, setOpenSettings] = useState&lt;string | null&gt;(null);
  const [openCustomLabel, setOpenCustomLabel] = useState&lt;string | null&gt;(null);
  const [openAddSystem, setOpenAddSystem] = useState&lt;XYPosition | null&gt;(null);
  const [selectedConnection, setSelectedConnection] = useState&lt;SolarSystemConnection | null&gt;(null);

  const ref = useRef({
    selectedConnections,
    selectedSystems,
    systemContextProps,
    systems,
    systemSignatures,
    deleteSystems,
  });
  ref.current = { selectedConnections, selectedSystems, systemContextProps, systems, systemSignatures, deleteSystems };

  useMapEventListener(event =&gt; {
    runCommand(event);
  });

  const onSelectionChange: OnMapSelectionChange = useCallback(
    ({ systems, connections }) =&gt; {
      const { selectedConnections, selectedSystems } = ref.current;

      const newData: Partial&lt;Pick&lt;MapRootData, &apos;selectedSystems&apos; | &apos;selectedConnections&apos;&gt;&gt; = {};

      if (!isEqual(systems, selectedSystems)) {
        newData.selectedSystems = systems;
      }

      if (!isEqual(connections, selectedConnections)) {
        newData.selectedConnections = connections;
      }

      update(newData);
    },
    [update],
  );

  const handleCommand: OutCommandHandler = useCallback(
    event =&gt; {
      switch (event.type) {
        case OutCommand.openSettings:
          setOpenSettings(event.data.system_id);
          break;
        default:
          return outCommand(event);
      }
      // @ts-ignore
      return new Promise(resolve =&gt; resolve(null));
    },
    [outCommand],
  );

  const handleSystemContextMenu = useCallback(
    (ev: any, systemId: string) =&gt; {
      const { selectedSystems, systems } = ref.current;
      if (selectedSystems.length &gt; 1) {
        const systemsInfo: Node[] = selectedSystems.map(x =&gt; ({ data: getSystemById(systems, x), id: x }) as Node);

        handleSystemMultipleContext(ev, systemsInfo);
        return;
      }

      open(ev, systemId);
    },
    [handleSystemMultipleContext, open],
  );

  const handleConnectionDbClick = useCallback((e: SolarSystemConnection) =&gt; setSelectedConnection(e), []);

  const handleDeleteSelected = useCallback(() =&gt; {
    const restDel = getNodes()
      .filter(x =&gt; x.selected &amp;&amp; !x.data.locked)
      .map(x =&gt; x.data.id);
    if (restDel.length &gt; 0) {
      ref.current.deleteSystems(restDel);
    }
  }, [getNodes]);

  const onAddSystem: OnMapAddSystemCallback = useCallback(({ coordinates }) =&gt; {
    setOpenAddSystem(coordinates);
  }, []);

  const handleSubmitAddSystem: SearchOnSubmitCallback = useCallback(
    async item =&gt; {
      if (ref.current.systems.some(x =&gt; parseInt(x.id) === item.value)) {
        emitMapEvent({
          name: Commands.centerSystem,
          data: item.value.toString(),
        });
        return;
      }

      await outCommand({
        type: OutCommand.manualAddSystem,
        data: { coordinates: openAddSystem, solar_system_id: item.value },
      });
    },
    [openAddSystem, outCommand],
  );

  useHotkey(false, [&apos;Delete&apos;], (event: KeyboardEvent) =&gt; {
    const targetWindow = (event.target as HTMLHtmlElement)?.closest(`[data-window-id=&quot;${MAP_ROOT_ID}&quot;]`);

    if (!targetWindow) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();
    handleDeleteSelected();
  });

  useEffect(() =&gt; {
    const { systemSignatures, systems } = ref.current;
    if (!isShowUnsplashedSignatures || Object.keys(systemSignatures).length !== 0 || systems?.length === 0) {
      return;
    }

    outCommand({ type: OutCommand.loadSignatures, data: {} });
  }, [isShowUnsplashedSignatures, systems]);

  return (
    &lt;&gt;
      &lt;Map
        ref={mapRef}
        onCommand={handleCommand}
        onSelectionChange={onSelectionChange}
        onConnectionInfoClick={handleConnectionDbClick}
        onSystemContextMenu={handleSystemContextMenu}
        onSelectionContextMenu={handleSystemMultipleContext}
        minimapClasses={!isShowMenu ? classes.MiniMap : undefined}
        isShowMinimap={isShowMinimap}
        showKSpaceBG={isShowKSpace}
        isThickConnections={isThickConnections}
        isShowBackgroundPattern={isShowBackgroundPattern}
        isSoftBackground={isSoftBackground}
        theme={theme}
        onAddSystem={onAddSystem}
      /&gt;

      {openSettings != null &amp;&amp; (
        &lt;SystemSettingsDialog systemId={openSettings} visible setVisible={() =&gt; setOpenSettings(null)} /&gt;
      )}

      {openCustomLabel != null &amp;&amp; (
        &lt;SystemCustomLabelDialog systemId={openCustomLabel} visible setVisible={() =&gt; setOpenCustomLabel(null)} /&gt;
      )}

      {linkSignatureToSystem != null &amp;&amp; (
        &lt;SystemLinkSignatureDialog data={linkSignatureToSystem} setVisible={() =&gt; updateLinkSignatureToSystem(null)} /&gt;
      )}

      &lt;AddSystemDialog
        visible={!!openAddSystem}
        setVisible={() =&gt; setOpenAddSystem(null)}
        onSubmit={handleSubmitAddSystem}
      /&gt;

      &lt;Connections selectedConnection={selectedConnection} onHide={() =&gt; setSelectedConnection(null)} /&gt;

      &lt;ContextMenuSystem
        systems={systems}
        hubs={hubs}
        userHubs={userHubs}
        {...systemContextProps}
        onOpenSettings={() =&gt; {
          systemContextProps.systemId &amp;&amp; setOpenSettings(systemContextProps.systemId);
        }}
        onCustomLabelDialog={() =&gt; {
          const { systemContextProps } = ref.current;
          systemContextProps.systemId &amp;&amp; setOpenCustomLabel(systemContextProps.systemId);
        }}
      /&gt;

      &lt;ContextMenuSystemMultiple {...systemMultipleCtxProps} /&gt;
    &lt;/&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/topbar/Topbar.tsx">import { Characters } from &apos;../characters/Characters&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useMemo } from &apos;react&apos;;
import clsx from &apos;clsx&apos;;
import { sortOnlineFunc } from &apos;@/hooks/Mapper/components/hooks/useGetOwnOnlineCharacters.ts&apos;;
import { WithChildren } from &apos;@/hooks/Mapper/types/common.ts&apos;;

const Topbar = ({ children }: WithChildren) =&gt; {
  const {
    data: { characters, userCharacters },
  } = useMapRootState();

  const charsToShow = useMemo(() =&gt; {
    return characters.filter(x =&gt; userCharacters.includes(x.eve_id)).sort(sortOnlineFunc);
  }, [characters, userCharacters]);

  return (
    &lt;nav
      className={clsx(
        &apos;px-2 flex items-center justify-center min-w-0 h-12 pointer-events-auto&apos;,
        &apos;border-b border-stone-800 bg-gray-800 bg-opacity-5&apos;,
        &apos;bg-opacity-70 bg-neutral-900&apos;,
      )}
    &gt;
      &lt;span className=&quot;flex-1&quot;&gt;&lt;/span&gt;
      &lt;span className=&quot;mr-2&quot;&gt;&lt;/span&gt;
      &lt;Characters data={charsToShow} /&gt;
      {children}
    &lt;/nav&gt;
  );
};

// eslint-disable-next-line react/display-name
export default Topbar;</file><file path="assets/js/hooks/Mapper/components/ui-kit/CharacterCard/CharacterCard.module.scss">.Docked {
  content: &quot; &quot;;
  display: inline-block;
  width: 11px;
  height: 11px;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  position: absolute;
  z-index: 1;
  overflow: hidden;
  border-radius: 1px;

  background-image: url(/images/citadelLarge.png);
  left: 10px;
  top: 10px;
  transform: rotateZ(0deg);
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/CharacterCard/CharacterCard.tsx">import { useCallback } from &apos;react&apos;;
import clsx from &apos;clsx&apos;;
import { SystemView } from &apos;@/hooks/Mapper/components/ui-kit/SystemView&apos;;
import { CharacterTypeRaw, WithIsOwnCharacter } from &apos;@/hooks/Mapper/types&apos;;
import { Commands } from &apos;@/hooks/Mapper/types/mapHandlers&apos;;
import { emitMapEvent } from &apos;@/hooks/Mapper/events&apos;;
import {
  TooltipPosition,
  WdEveEntityPortrait,
  WdEveEntityPortraitSize,
  WdEveEntityPortraitType,
  WdTooltipWrapper,
} from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { isDocked } from &apos;@/hooks/Mapper/helpers/isDocked.ts&apos;;
import classes from &apos;./CharacterCard.module.scss&apos;;

type CharacterCardProps = {
  compact?: boolean;
  showSystem?: boolean;
  showTicker?: boolean;
  showShipName?: boolean;
  useSystemsCache?: boolean;
  showCorporationLogo?: boolean;
  showAllyLogo?: boolean;
} &amp; CharacterTypeRaw &amp;
  WithIsOwnCharacter;

const SHIP_NAME_RX = /u&apos;|&apos;/g;
export const getShipName = (name: string) =&gt; {
  return name
    .replace(SHIP_NAME_RX, &apos;&apos;)
    .replace(/\\u([\dA-Fa-f]{4})/g, (_, grp) =&gt; String.fromCharCode(parseInt(grp, 16)))
    .replace(/\\x([\dA-Fa-f]{2})/g, (_, grp) =&gt; String.fromCharCode(parseInt(grp, 16)));
};

export const CharacterCard = ({
  compact = false,
  isOwn,
  showSystem,
  showShipName,
  showCorporationLogo,
  showAllyLogo,
  showTicker,
  useSystemsCache,
  ...char
}: CharacterCardProps) =&gt; {
  const handleSelect = useCallback(() =&gt; {
    emitMapEvent({
      name: Commands.centerSystem,
      data: char?.location?.solar_system_id?.toString(),
    });
  }, [char]);

  const shipNameText = char.ship?.ship_name ? getShipName(char.ship.ship_name) : &apos;&apos;;
  const tickerText = char.alliance_id ? char.alliance_ticker : char.corporation_ticker;
  const shipType = char.ship?.ship_type_info?.name;
  const locationShown = showSystem &amp;&amp; char.location?.solar_system_id;

  if (compact) {
    return (
      &lt;div className=&quot;text-xs box-border w-full&quot; onClick={handleSelect}&gt;
        &lt;div className=&quot;w-full flex items-center gap-1 relative&quot;&gt;
          &lt;WdEveEntityPortrait eveId={char.eve_id} size={WdEveEntityPortraitSize.w18} /&gt;

          {showCorporationLogo &amp;&amp; (
            &lt;WdTooltipWrapper position={TooltipPosition.top} content={char.corporation_name}&gt;
              &lt;WdEveEntityPortrait
                type={WdEveEntityPortraitType.corporation}
                eveId={char.corporation_id.toString()}
                size={WdEveEntityPortraitSize.w18}
              /&gt;
            &lt;/WdTooltipWrapper&gt;
          )}

          {showAllyLogo &amp;&amp; char.alliance_id &amp;&amp; (
            &lt;WdTooltipWrapper position={TooltipPosition.top} content={char.alliance_name}&gt;
              &lt;WdEveEntityPortrait
                type={WdEveEntityPortraitType.alliance}
                eveId={char.alliance_id.toString()}
                size={WdEveEntityPortraitSize.w18}
              /&gt;
            &lt;/WdTooltipWrapper&gt;
          )}

          {isDocked(char.location) &amp;&amp; &lt;span className={classes.Docked} /&gt;}
          &lt;div className=&quot;flex flex-grow-[2] overflow-hidden text-left w-[50px]&quot;&gt;
            &lt;div className=&quot;flex min-w-0&quot;&gt;
              &lt;span
                className={clsx(
                  &apos;overflow-hidden text-ellipsis whitespace-nowrap&apos;,
                  isOwn ? &apos;text-orange-400&apos; : &apos;text-gray-200&apos;,
                )}
                title={char.name}
              &gt;
                {char.name}
              &lt;/span&gt;
              {showTicker &amp;&amp; &lt;span className=&quot;flex-shrink-0 text-gray-400 ml-1&quot;&gt;[{tickerText}]&lt;/span&gt;}
            &lt;/div&gt;
          &lt;/div&gt;

          {shipType &amp;&amp; (
            &lt;&gt;
              {!showShipName &amp;&amp; (
                &lt;div
                  className=&quot;text-gray-300 overflow-hidden text-ellipsis whitespace-nowrap flex-shrink-0&quot;
                  style={{ maxWidth: &apos;120px&apos; }}
                  title={shipType}
                &gt;
                  {shipType}
                &lt;/div&gt;
              )}
              {showShipName &amp;&amp; (
                &lt;div className=&quot;flex flex-grow-[1] justify-end w-[50px]&quot;&gt;
                  &lt;div className=&quot;min-w-0&quot;&gt;
                    &lt;div
                      className=&quot;text-gray-300 overflow-hidden text-ellipsis whitespace-nowrap flex-shrink-0&quot;
                      style={{ maxWidth: &apos;120px&apos; }}
                      title={shipNameText}
                    &gt;
                      {shipNameText}
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              )}
              {char.ship &amp;&amp; (
                &lt;WdTooltipWrapper position={TooltipPosition.top} content={char.ship.ship_type_info.name}&gt;
                  &lt;WdEveEntityPortrait
                    type={WdEveEntityPortraitType.ship}
                    eveId={char.ship.ship_type_id.toString()}
                    size={WdEveEntityPortraitSize.w18}
                  /&gt;
                &lt;/WdTooltipWrapper&gt;
              )}
            &lt;/&gt;
          )}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className={clsx(&apos;w-full text-xs box-border&apos;)} onClick={handleSelect}&gt;
      &lt;div className=&quot;w-full flex items-center gap-2&quot;&gt;
        &lt;div className=&quot;flex items-center gap-1&quot;&gt;
          &lt;WdEveEntityPortrait eveId={char.eve_id} size={WdEveEntityPortraitSize.w33} /&gt;

          {showCorporationLogo &amp;&amp; (
            &lt;WdTooltipWrapper position={TooltipPosition.top} content={char.corporation_name}&gt;
              &lt;WdEveEntityPortrait
                type={WdEveEntityPortraitType.corporation}
                eveId={char.corporation_id.toString()}
                size={WdEveEntityPortraitSize.w33}
              /&gt;
            &lt;/WdTooltipWrapper&gt;
          )}

          {showAllyLogo &amp;&amp; char.alliance_id &amp;&amp; (
            &lt;WdTooltipWrapper position={TooltipPosition.top} content={char.alliance_name}&gt;
              &lt;WdEveEntityPortrait
                type={WdEveEntityPortraitType.alliance}
                eveId={char.alliance_id.toString()}
                size={WdEveEntityPortraitSize.w33}
              /&gt;
            &lt;/WdTooltipWrapper&gt;
          )}
        &lt;/div&gt;

        &lt;div className=&quot;flex flex-col flex-grow overflow-hidden  w-[50px]&quot;&gt;
          &lt;div className=&quot;flex min-w-0&quot;&gt;
            &lt;span
              className={clsx(
                &apos;overflow-hidden text-ellipsis whitespace-nowrap&apos;,
                isOwn ? &apos;text-orange-400&apos; : &apos;text-gray-200&apos;,
              )}
            &gt;
              {char.name}
            &lt;/span&gt;
            {showTicker &amp;&amp; &lt;span className=&quot;flex-shrink-0 text-gray-400 ml-1&quot;&gt;[{tickerText}]&lt;/span&gt;}
          &lt;/div&gt;
          {locationShown ? (
            &lt;div className=&quot;text-gray-300 text-xs overflow-hidden text-ellipsis whitespace-nowrap&quot;&gt;
              &lt;SystemView
                systemId={char?.location?.solar_system_id?.toString() || &apos;&apos;}
                useSystemsCache={useSystemsCache}
              /&gt;
            &lt;/div&gt;
          ) : (
            shipNameText &amp;&amp; (
              &lt;div className=&quot;text-gray-300 text-xs overflow-hidden text-ellipsis whitespace-nowrap&quot;&gt;
                {shipNameText}
              &lt;/div&gt;
            )
          )}
        &lt;/div&gt;
        {shipType &amp;&amp; (
          &lt;&gt;
            &lt;div className=&quot;flex flex-col flex-shrink-0 items-end self-start&quot;&gt;
              &lt;div
                className=&quot;text-gray-300 overflow-hidden text-ellipsis whitespace-nowrap max-w-[200px]&quot;
                title={shipType}
              &gt;
                {shipType}
              &lt;/div&gt;
              &lt;div
                className=&quot;flex justify-end text-stone-500 overflow-hidden text-ellipsis whitespace-nowrap max-w-[200px]&quot;
                title={shipNameText}
              &gt;
                {shipNameText}
              &lt;/div&gt;
            &lt;/div&gt;

            {char.ship &amp;&amp; (
              &lt;WdEveEntityPortrait
                type={WdEveEntityPortraitType.ship}
                eveId={char.ship.ship_type_id.toString()}
                size={WdEveEntityPortraitSize.w33}
              /&gt;
            )}
          &lt;/&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/CharacterCard/index.ts">export * from &apos;./CharacterCard.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/FixedTooltip/FixedTooltip.tsx">import { Tooltip, TooltipProps } from &apos;primereact/tooltip&apos;;
import clsx from &apos;clsx&apos;;

export const FixedTooltip = ({ children, className, ...props }: TooltipProps) =&gt; {
  return (
    &lt;Tooltip
      className={clsx(&apos;border border-green-300 rounded border-opacity-10 bg-stone-900 bg-opacity-70&apos;, className)}
      {...props}
    &gt;
      {children}
    &lt;/Tooltip&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/FixedTooltip/index.ts">export * from &apos;./FixedTooltip&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/InfoDrawer/index.ts">export * from &apos;./InfoDrawer&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/InfoDrawer/InfoDrawer.module.scss">.InfoDrawerRoot {
  border-left: 1px solid rgb(115, 120, 128);

  &amp;.RightSide {
    border-left: initial;
    border-right: 2px solid rgb(115, 120, 128);
  }
}

.InfoDrawerLabel {
  font-size: 11px;
  line-height: 12px;
  margin-bottom: 1px;
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/InfoDrawer/InfoDrawer.tsx">import classes from &apos;./InfoDrawer.module.scss&apos;;
import { WithChildren, WithClassName, WithHTMLProps } from &apos;@/hooks/Mapper/types/common.ts&apos;;
import clsx from &apos;clsx&apos;;
import React from &apos;react&apos;;

export type InfoDrawerProps = { title?: React.ReactNode; labelClassName?: string; rightSide?: boolean } &amp; WithChildren &amp;
  WithClassName &amp;
  Omit&lt;WithHTMLProps, &apos;title&apos;&gt;;

export const InfoDrawer = ({
  title,
  children,
  className,
  labelClassName,
  rightSide,
  ...htmlProps
}: InfoDrawerProps) =&gt; {
  return (
    &lt;div
      className={clsx(classes.InfoDrawerRoot, &apos;text-xs pl-1&apos;, className, {
        [classes.RightSide]: rightSide,
        &apos;flex flex-col items-end pr-1&apos;: rightSide,
        &apos;pl-1&apos;: !rightSide,
      })}
      {...htmlProps}
    &gt;
      {title &amp;&amp; &lt;div className={clsx(classes.InfoDrawerLabel, &apos;text-neutral-400&apos;, labelClassName)}&gt;{title}&lt;/div&gt;}
      &lt;div&gt;{children}&lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/SystemView/index.ts">export * from &apos;./SystemView&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/SystemView/SystemView.tsx">import { WithClassName } from &apos;@/hooks/Mapper/types/common.ts&apos;;
import { SystemViewStandalone } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import { useLoadSystemStatic } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic.ts&apos;;
import { useMemo } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types&apos;;

export type SystemViewProps = {
  systemId: string;
  systemInfo?: SolarSystemStaticInfoRaw;
  hideRegion?: boolean;
  useSystemsCache?: boolean;
  showCustomName?: boolean;
} &amp; WithClassName;

export const SystemView = ({
  systemId,
  systemInfo: customSystemInfo,
  hideRegion,
  className,
  showCustomName,
}: SystemViewProps) =&gt; {
  const memSystems = useMemo(() =&gt; [systemId], [systemId]);
  const { systems, loading } = useLoadSystemStatic({ systems: memSystems });

  const {
    data: { systems: mapSystems },
  } = useMapRootState();

  const systemInfo = useMemo(() =&gt; {
    if (!systemId) {
      return customSystemInfo;
    }
    return systems.get(parseInt(systemId));
    // eslint-disable-next-line
  }, [customSystemInfo, systemId, systems, loading]);

  const mapSystemInfo = useMemo(() =&gt; {
    if (!showCustomName) {
      return null;
    }
    return mapSystems.find(x =&gt; x.id === systemId);
  }, [showCustomName, systemId, mapSystems]);

  if (!systemInfo) {
    return null;
  }

  if (!mapSystemInfo) {
    return &lt;SystemViewStandalone hideRegion={hideRegion} className={className} {...systemInfo} /&gt;;
  }

  return (
    &lt;div&gt;
      &lt;SystemViewStandalone hideRegion={hideRegion} className={className} {...systemInfo} /&gt;
      &lt;span&gt;{systemInfo.solar_system_name}&lt;/span&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/SystemViewStandalone/index.ts">export * from &apos;./SystemViewStandalone&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/SystemViewStandalone/SystemViewStandalone.module.scss">.SystemViewRoot {
  font-size: 11px;
}

.CompactName {
  max-width: 80px;
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/SystemViewStandalone/SystemViewStandalone.tsx">import { getSystemClassStyles } from &apos;@/hooks/Mapper/components/map/helpers&apos;;
import { isWormholeSpace } from &apos;@/hooks/Mapper/components/map/helpers/isWormholeSpace.ts&apos;;
import classes from &apos;./SystemViewStandalone.module.scss&apos;;
import clsx from &apos;clsx&apos;;
import { WithClassName } from &apos;@/hooks/Mapper/types/common.ts&apos;;
import { SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types&apos;;
import { HTMLProps, MouseEvent, useCallback } from &apos;react&apos;;

export type SystemViewStandaloneStatic = Pick&lt;
  SolarSystemStaticInfoRaw,
  &apos;class_title&apos; | &apos;system_class&apos; | &apos;solar_system_name&apos; | &apos;region_name&apos; | &apos;security&apos; | &apos;solar_system_id&apos;
&gt;;

export type SystemViewStandaloneProps = {
  hideRegion?: boolean;
  customName?: string;
  compact?: boolean;
  onContextMenu?(e: MouseEvent, systemId: string): void;
} &amp; WithClassName &amp;
  Omit&lt;SystemViewStandaloneStatic, &apos;region_name&apos;&gt; &amp;
  Partial&lt;Pick&lt;SystemViewStandaloneStatic, &apos;region_name&apos;&gt;&gt; &amp;
  Omit&lt;HTMLProps&lt;HTMLDivElement&gt;, &apos;onContextMenu&apos;&gt;;

export const SystemViewStandalone = ({
  className,
  hideRegion,
  customName,
  class_title,
  system_class,
  solar_system_name,
  region_name,
  security,
  compact,
  solar_system_id,
  onContextMenu,

  ...props
}: SystemViewStandaloneProps) =&gt; {
  const classTitleColor = getSystemClassStyles({ systemClass: system_class, security });
  const isWH = isWormholeSpace(system_class);
  1;

  const handleClick = useCallback(
    (e: MouseEvent) =&gt; {
      e.preventDefault();
      e.stopPropagation();
      onContextMenu?.(e, solar_system_id.toString());
    },
    [onContextMenu, solar_system_id],
  );

  return (
    &lt;div
      {...props}
      onContextMenu={handleClick}
      className={clsx(classes.SystemViewRoot, &apos;flex gap-1 text-gray-400&apos;, className)}
    &gt;
      &lt;span className={clsx(classTitleColor)}&gt;{class_title}&lt;/span&gt;
      &lt;span
        className={clsx(&apos;text-gray-200 whitespace-nowrap&apos;, {
          [&apos;overflow-hidden text-ellipsis&apos;]: compact,
          [classes.CompactName]: compact,
        })}
      &gt;
        {customName ?? solar_system_name}
      &lt;/span&gt;
      {!hideRegion &amp;&amp; !isWH &amp;&amp; &lt;span className=&quot;whitespace-nowrap&quot;&gt;{region_name}&lt;/span&gt;}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/TimeAgo/index.ts">export * from &apos;./TimeAgo.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/TimeAgo/TimeAgo.tsx">import { useEffect, useState, useRef } from &apos;react&apos;;

interface TimeAgoProps {
  timestamp: string; // –¢–µ–ø–µ—Ä—å —Ç–∏–ø string, —Ç–∞–∫ –∫–∞–∫ –ø—Ä–∏—Ö–æ–¥–∏—Ç ISO 8601 —Å—Ç—Ä–æ–∫–∞
}

export const TimeAgo = ({ timestamp }: TimeAgoProps) =&gt; {
  const [timeAgo, setTimeAgo] = useState&lt;string&gt;(&apos;&apos;);
  const timeoutIdRef = useRef&lt;number | null&gt;(null);

  useEffect(() =&gt; {
    const updateTimeAgo = () =&gt; {
      setTimeAgo(calculateTimeAgo(timestamp));
      startTimer();
    };

    const handleVisibilityChange = () =&gt; {
      if (document.hidden) {
        if (timeoutIdRef.current !== null) {
          clearTimeout(timeoutIdRef.current);
        }
      } else {
        updateTimeAgo();
      }
    };

    document.addEventListener(&apos;visibilitychange&apos;, handleVisibilityChange);
    updateTimeAgo(); // Initial calculation

    return () =&gt; {
      if (timeoutIdRef.current !== null) {
        clearTimeout(timeoutIdRef.current);
      }
      document.removeEventListener(&apos;visibilitychange&apos;, handleVisibilityChange);
    };
  }, [timestamp]);

  const startTimer = () =&gt; {
    const now = new Date();
    const diff = now.getTime() - new Date(timestamp).getTime();
    const nextUpdateIn = diff &lt; 60000 ? 1000 : 60000; // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ —Å–µ–∫—É–Ω–¥—ã –∏–ª–∏ –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É

    timeoutIdRef.current = window.setTimeout(() =&gt; {
      setTimeAgo(calculateTimeAgo(timestamp));
      startTimer();
    }, nextUpdateIn);
  };

  const calculateTimeAgo = (utcDateString: string): string =&gt; {
    const now = new Date();
    const date = new Date(utcDateString); // –ü–∞—Ä—Å–∏–º —Å—Ç—Ä–æ–∫—É –≤ –æ–±—ä–µ–∫—Ç Date

    // –ù–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å, —Ç–∞–∫ –∫–∞–∫ `new Date(utcDateString)` —É–∂–µ –¥–µ–ª–∞–µ—Ç —ç—Ç–æ
    const diff = now.getTime() - date.getTime();

    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (seconds &lt; 60) return `${seconds} seconds ago`;
    if (minutes &lt; 60) return `${minutes} min ago`;
    if (hours &lt; 24) return `${hours} hours ago`;
    return `${days} days ago`;
  };

  return &lt;span&gt;{timeAgo}&lt;/span&gt;;
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/TimeLeft/index.ts">export * from &apos;./TimeLeft&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/TimeLeft/TimeLeft.tsx">import { FC, useState, useEffect, useRef } from &apos;react&apos;;

const calibratedDate = new Date(&apos;Mon, 01 Jan 2024 00:00:00 GMT&apos;);

interface TimeLeftProps {
  cDate?: Date;
}

export const TimeLeft: FC&lt;TimeLeftProps&gt; = ({ cDate = new Date() }) =&gt; {
  const [date, setDate] = useState&lt;Date&gt;(cDate);
  const [timeDiff, setTimeDiff] = useState&lt;string&gt;(&apos;&apos;);
  const timerId = useRef&lt;number | undefined&gt;(undefined);

  useEffect(() =&gt; {
    update();
    startTimer();

    return () =&gt; {
      if (timerId.current !== undefined) {
        clearTimeout(timerId.current);
      }
    };
  }, [date]);

  const startTimer = () =&gt; {
    timerId.current = window.setTimeout(() =&gt; {
      update();
      startTimer();
    }, 1000);
  };

  const update = () =&gt; {
    const currentDate = new Date();
    const diff = currentDate.getTime() + currentDate.getTimezoneOffset() * 60000 - date.getTime();
    setTimeDiff(calculateTimeDiff(diff));
  };

  const calculateTimeDiff = (_milliseconds: number) =&gt; {
    const relativeDate = new Date(calibratedDate.getTime() + _milliseconds);
    const seconds = relativeDate.getUTCSeconds().toString().padStart(2, &apos;0&apos;);
    const minutes = relativeDate.getUTCMinutes().toString().padStart(2, &apos;0&apos;);
    const hours = relativeDate.getUTCHours().toString().padStart(2, &apos;0&apos;);
    const days = (relativeDate.getUTCDate() - 1).toString();

    return `${days} ${hours}:${minutes}:${seconds}`;
  };

  useEffect(() =&gt; {
    setDate(cDate);
    update();
  }, [cDate]);

  return &lt;span className=&quot;whitespace-nowrap&quot;&gt;{timeDiff}&lt;/span&gt;;
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdCheckbox/index.ts">export * from &apos;./WdCheckbox.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdCheckbox/WdCheckbox.module.scss">.CheckboxRoot {
  &amp;.SizeXS {
    width: 14px;
    height: 14px;

    :global {
      .p-checkbox-box, .p-checkbox-input {
        width: 14px;
        height: 14px;
      }
    }
  }
  &amp;.SizeM {
    width: 16px;
    height: 16px;

    :global {
      .p-checkbox-box, .p-checkbox-input {
        width: 16px;
        height: 16px;
      }
    }
  }
}

.Label {}</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdCheckbox/WdCheckbox.tsx">import classes from &apos;./WdCheckbox.module.scss&apos;;
import { Checkbox, CheckboxChangeEvent } from &apos;primereact/checkbox&apos;;
import { WithClassName } from &apos;@/hooks/Mapper/types/common&apos;;
import clsx from &apos;clsx&apos;;
import React, { useMemo } from &apos;react&apos;;

let counter = 0;

export interface WdCheckboxProps {
  id?: string;
  label: React.ReactNode | string;
  classNameLabel?: string;
  value: boolean;
  labelSide?: &apos;left&apos; | &apos;right&apos;;
  onChange?: (event: CheckboxChangeEvent) =&gt; void;
  size?: &apos;xs&apos; | &apos;m&apos; | &apos;normal&apos;;
}

export const WdCheckbox = ({
  id: defaultId,
  label,
  className,
  classNameLabel,
  value,
  onChange,
  labelSide = &apos;right&apos;,
  size = &apos;normal&apos;,
}: WdCheckboxProps &amp; WithClassName) =&gt; {
  const id = useMemo(() =&gt; defaultId || (++counter).toString(), [defaultId]);

  const labelElement = (
    &lt;label
      htmlFor={id}
      className={clsx(
        classes.Label,
        &apos;select-none&apos;,
        {
          [&apos;ml-1&apos;]: labelSide === &apos;right&apos; &amp;&amp; size === &apos;xs&apos;,
          [&apos;mr-1&apos;]: labelSide === &apos;left&apos; &amp;&amp; size === &apos;xs&apos;,
          [&apos;ml-1.5&apos;]: labelSide === &apos;right&apos; &amp;&amp; (size === &apos;normal&apos; || size === &apos;m&apos;),
          [&apos;mr-1.5&apos;]: labelSide === &apos;left&apos; &amp;&amp; (size === &apos;normal&apos; || size === &apos;m&apos;),
        },
        classNameLabel,
      )}
    &gt;
      {label}
    &lt;/label&gt;
  );

  return (
    &lt;div className={clsx(className, &apos;flex items-center&apos;)}&gt;
      {labelSide === &apos;left&apos; &amp;&amp; labelElement}
      &lt;Checkbox
        inputId={id}
        className={clsx(classes.CheckboxRoot, {
          [classes.SizeNormal]: size === &apos;normal&apos;,
          [classes.SizeM]: size === &apos;m&apos;,
          [classes.SizeXS]: size === &apos;xs&apos;,
        })}
        onChange={onChange}
        checked={value}
      /&gt;
      {labelSide === &apos;right&apos; &amp;&amp; labelElement}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdEveEntityPortrait/index.ts">export * from &apos;./WdEveEntityPortrait.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdEveEntityPortrait/WdEveEntityPortrait.tsx">import clsx from &apos;clsx&apos;;
import { WithClassName } from &apos;@/hooks/Mapper/types/common.ts&apos;;

export enum WdEveEntityPortraitType {
  character,
  corporation,
  alliance,
  ship,
}

export enum WdEveEntityPortraitSize {
  default,
  w18,
  w33,
}

export const getLogo = (type: WdEveEntityPortraitType, eveId: string | number) =&gt; {
  switch (type) {
    case WdEveEntityPortraitType.alliance:
      return `url(https://images.evetech.net/alliances/${eveId}/logo?size=64)`;
    case WdEveEntityPortraitType.corporation:
      return `url(https://images.evetech.net/corporations/${eveId}/logo?size=64)`;
    case WdEveEntityPortraitType.character:
      return `url(https://images.evetech.net/characters/${eveId}/portrait)`;
    case WdEveEntityPortraitType.ship:
      return `url(https://images.evetech.net/types/${eveId}/icon)`;
  }

  return &apos;&apos;;
};

// TODO IF YOU NEED ANOTHER ONE SIZE PLEASE ADD IT HERE and IN WdEveEntityPortraitSize
const getSize = (size: WdEveEntityPortraitSize) =&gt; {
  switch (size) {
    case WdEveEntityPortraitSize.w18:
      return &apos;min-w-[18px] min-h-[18px] w-[18px] h-[18px]&apos;;
    case WdEveEntityPortraitSize.w33:
      return &apos;min-w-[33px] min-h-[33px] w-[33px] h-[33px]&apos;;
    default:
      return &apos;&apos;;
  }
};

export type WdEveEntityPortraitProps = {
  eveId: string | undefined;
  type?: WdEveEntityPortraitType;
  size?: WdEveEntityPortraitSize;
} &amp; WithClassName;

export const WdEveEntityPortrait = ({
  eveId,
  size = WdEveEntityPortraitSize.default,
  type = WdEveEntityPortraitType.character,
  className,
}: WdEveEntityPortraitProps) =&gt; {
  if (eveId == null) {
    return null;
  }

  return (
    &lt;span
      className={clsx(
        getSize(size),
        &apos;flex transition-[border-color,opacity] duration-250 border border-gray-800 bg-transparent rounded-none&apos;,
        &apos;wd-bg-default&apos;,
        className,
      )}
      style={{ backgroundImage: getLogo(type, eveId) }}
    /&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdImgButton/index.ts">export * from &apos;./WdImgButton&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdImgButton/WdImgButton.module.scss">.WdImgButtonRoot {
  transition: opacity 200ms;
  opacity: 0.5;
  pointer-events: initial !important;

  &amp;.Disabled {
    opacity: 0.3;
    cursor: auto;
  }

  &amp;:hover:not(&amp;.Disabled) {
    opacity: 1;
  }
}

.Normal {
  font-size: 12px;
}

.Large {
  font-size: 16px;
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdImgButton/WdImgButton.tsx">import classes from &apos;./WdImgButton.module.scss&apos;;
import clsx from &apos;clsx&apos;;
import { WithClassName } from &apos;@/hooks/Mapper/types/common.ts&apos;;
import { HTMLProps, MouseEvent } from &apos;react&apos;;
import { WdTooltipWrapper, WdTooltipWrapperProps } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper&apos;;

export enum WdImageSize {
  off = &apos;off&apos;,
  small = &apos;small&apos;,
  normal = &apos;normal&apos;,
  large = &apos;large&apos;,
}

export type WdImgButtonProps = {
  onClick?(e: MouseEvent): void;
  source?: string;
  width?: number;
  height?: number;
  tooltip?: Pick&lt;WdTooltipWrapperProps, &apos;content&apos; | &apos;position&apos; | &apos;offset&apos; | &apos;className&apos;&gt;;
  textSize?: WdImageSize;
} &amp; WithClassName &amp;
  HTMLProps&lt;HTMLDivElement&gt;;

export const WdImgButton = ({
  onClick,
  className,
  source,
  width = 20,
  height = 20,
  textSize = WdImageSize.normal,
  tooltip,
  disabled,
  ...props
}: WdImgButtonProps) =&gt; {
  const content = (
    &lt;div
      {...props}
      className={clsx(
        classes.WdImgButtonRoot,
        {
          [classes.Normal]: textSize === WdImageSize.normal,
          [classes.Large]: textSize === WdImageSize.large,
          [classes.Disabled]: disabled,
        },
        &apos;pi cursor-pointer&apos;,
        className,
      )}
      onClick={disabled ? undefined : onClick}
    &gt;
      {source &amp;&amp; &lt;img src={source} width={width} height={height} className=&quot;external-icon&quot; /&gt;}
    &lt;/div&gt;
  );

  if (tooltip) {
    return &lt;WdTooltipWrapper {...tooltip}&gt;{content}&lt;/WdTooltipWrapper&gt;;
  }

  return content;
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdRadioButton/index.ts">import WdRadioButton from &apos;./WdRadioButton&apos;;

export default WdRadioButton;
export type { WdRadioButtonProps } from &apos;./WdRadioButton&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdRadioButton/WdRadioButton.module.scss">.RadioInput {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  width: 1.25rem;
  height: 1.25rem;
  border: 2px solid var(--surface-border, #ccc);
  border-radius: 50%;
  background-color: var(--surface-card, #fff);
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  
  &amp;:hover {
    border-color: var(--primary-color, #3B82F6);
  }
  
  &amp;:checked {
    border-color: var(--primary-color, #3B82F6);
    
    &amp;::after {
      content: &apos;&apos;;
      width: 0.625rem;
      height: 0.625rem;
      background-color: var(--primary-color, #3B82F6);
      border-radius: 50%;
      display: block;
    }
    
    &amp;:hover {
      border-color: var(--primary-color-dark, #2563EB);
      
      &amp;::after {
        background-color: var(--primary-color-dark, #2563EB);
      }
    }
  }
  
  &amp;:focus {
    outline: none;
    box-shadow: 0 0 0 0.2rem var(--primary-color-light, rgba(59, 130, 246, 0.25));
  }
  
  &amp;:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    border-color: var(--surface-border, #ccc);
    
    &amp;:checked::after {
      background-color: var(--surface-border, #ccc);
    }
  }
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdRadioButton/WdRadioButton.tsx">import React from &apos;react&apos;;
import clsx from &apos;clsx&apos;;
import styles from &apos;./WdRadioButton.module.scss&apos;;

export interface WdRadioButtonProps {
  id: string;
  name: string;
  checked: boolean;
  onChange: (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; void;
  label?: string;
  className?: string;
  disabled?: boolean;
}

const WdRadioButton: React.FC&lt;WdRadioButtonProps&gt; = ({
  id,
  name,
  checked,
  onChange,
  label,
  className,
  disabled = false,
}) =&gt; {
  return (
    &lt;div className={clsx(&apos;flex items-center&apos;, className)}&gt;
      &lt;input
        id={id}
        type=&quot;radio&quot;
        name={name}
        checked={checked}
        onChange={onChange}
        disabled={disabled}
        className={clsx(
          styles.RadioInput,
          &apos;w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600&apos;,
        )}
      /&gt;
      {label &amp;&amp; (
        &lt;label
          htmlFor={id}
          className=&quot;ml-2 text-sm font-medium text-gray-900 dark:text-gray-300 cursor-pointer&quot;
        &gt;
          {label}
        &lt;/label&gt;
      )}
    &lt;/div&gt;
  );
};

export default WdRadioButton;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdResponsiveCheckBox/index.ts">export * from &apos;./WdResponsiveCheckbox&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdResponsiveCheckBox/WdResponsiveCheckbox.tsx">import React from &apos;react&apos;;
import clsx from &apos;clsx&apos;;
import { WdCheckbox, WdTooltipWrapper } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

/**
 * Display modes for the responsive checkbox.
 *
 * - &quot;full&quot;: show the full label (e.g. &quot;Show offline&quot; or &quot;Show ship name&quot;)
 * - &quot;abbr&quot;: show the abbreviated label (e.g. &quot;Offline&quot; or &quot;Ship name&quot;)
 * - &quot;checkbox&quot;: show only the checkbox (no text)
 * - &quot;hide&quot;: do not render the checkbox at all
 */
export type WdDisplayMode = &apos;full&apos; | &apos;abbr&apos; | &apos;checkbox&apos; | &apos;hide&apos;;

export interface WdResponsiveCheckboxProps {
  tooltipContent: string;
  size: &apos;xs&apos; | &apos;normal&apos; | &apos;m&apos;;
  labelFull: string;
  labelAbbreviated: string;
  value: boolean;
  onChange: () =&gt; void;
  classNameLabel?: string;
  containerClassName?: string;
  labelSide?: &apos;left&apos; | &apos;right&apos;;
  displayMode: WdDisplayMode;
}

export const WdResponsiveCheckbox: React.FC&lt;WdResponsiveCheckboxProps&gt; = ({
  tooltipContent,
  size,
  labelFull,
  labelAbbreviated,
  value,
  onChange,
  classNameLabel,
  containerClassName,
  labelSide = &apos;left&apos;,
  displayMode,
}) =&gt; {
  if (displayMode === &apos;hide&apos;) {
    return null;
  }

  const label =
    displayMode === &apos;full&apos;
      ? labelFull
      : displayMode === &apos;abbr&apos;
        ? labelAbbreviated
        : displayMode === &apos;checkbox&apos;
          ? &apos;&apos;
          : labelFull;

  const checkbox = (
    &lt;div className={clsx(&apos;min-w-0&apos;, containerClassName)}&gt;
      &lt;WdCheckbox
        size={size}
        labelSide={labelSide}
        label={label}
        value={value}
        classNameLabel={classNameLabel}
        onChange={onChange}
      /&gt;
    &lt;/div&gt;
  );

  return tooltipContent ? &lt;WdTooltipWrapper content={tooltipContent}&gt;{checkbox}&lt;/WdTooltipWrapper&gt; : checkbox;
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdTooltip/index.ts">export * from &apos;./WdTooltip&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdTooltip/WdTooltip.module.scss">@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.tooltip {
  animation: fadeIn 0.3s ease-in-out;

  font-size: 12px;
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdTooltip/WdTooltip.tsx">import React, { ForwardedRef, forwardRef, useCallback, useEffect, useImperativeHandle, useRef, useState } from &apos;react&apos;;
import { createPortal } from &apos;react-dom&apos;;
import clsx from &apos;clsx&apos;;
import debounce from &apos;lodash.debounce&apos;;
import classes from &apos;./WdTooltip.module.scss&apos;;

export enum TooltipPosition {
  default = &apos;default&apos;,
  left = &apos;left&apos;,
  right = &apos;right&apos;,
  top = &apos;top&apos;,
  bottom = &apos;bottom&apos;,
}

export interface TooltipProps extends Omit&lt;React.HTMLAttributes&lt;HTMLDivElement&gt;, &apos;content&apos;&gt; {
  position?: TooltipPosition;
  offset?: number;
  content: (() =&gt; React.ReactNode) | React.ReactNode;
  targetSelector?: string;
  interactive?: boolean;
}

export interface OffsetPosition {
  top: number;
  left: number;
}

export interface WdTooltipHandlers {
  show: (e?: React.MouseEvent) =&gt; void;
  hide: () =&gt; void;
  getIsMouseInside: () =&gt; boolean;
}

interface TriggerInfo {
  clientX: number;
  clientY: number;
  rect: DOMRect;
}

const LEAVE_DELAY = 100;

export const WdTooltip = forwardRef(
  (
    {
      content,
      targetSelector,
      position: tPosition = TooltipPosition.default,
      offset = 5,
      interactive = false,
      className,
      ...restProps
    }: TooltipProps,
    ref: ForwardedRef&lt;WdTooltipHandlers&gt;,
  ) =&gt; {
    // Always initialize position so we never have a null value.
    const [visible, setVisible] = useState(false);
    const [pos, setPos] = useState&lt;OffsetPosition | null&gt;(null);
    const tooltipRef = useRef&lt;HTMLDivElement&gt;(null);

    const [isMouseInsideTooltip, setIsMouseInsideTooltip] = useState(false);

    const [triggerInfo, setTriggerInfo] = useState&lt;TriggerInfo | null&gt;(null);

    const hideTimeoutRef = useRef&lt;ReturnType&lt;typeof setTimeout&gt; | null&gt;(null);

    const calcTooltipPosition = useCallback(({ x, y }: { x: number; y: number }) =&gt; {
      if (!tooltipRef.current) return { left: x, top: y };

      const tooltipWidth = tooltipRef.current.offsetWidth;
      const tooltipHeight = tooltipRef.current.offsetHeight;

      let newLeft = x;
      let newTop = y;

      if (newLeft &lt; 0) {
        newLeft = 10;
      }

      if (newTop &lt; 0) {
        newTop = 10;
      }

      const rightEdge = newLeft + tooltipWidth + 10;
      if (rightEdge &gt; window.innerWidth) {
        newLeft = window.innerWidth - tooltipWidth - 10;
      }

      const bottomEdge = newTop + tooltipHeight + 10;
      if (bottomEdge &gt; window.innerHeight) {
        newTop = window.innerHeight - tooltipHeight - 10;
      }

      return { left: newLeft, top: newTop };
    }, []);

    const scheduleHide = useCallback(() =&gt; {
      if (!interactive) {
        setVisible(false);
        setPos(null);
        return;
      }
      if (!hideTimeoutRef.current) {
        hideTimeoutRef.current = setTimeout(() =&gt; {
          setVisible(false);
          setPos(null);
        }, LEAVE_DELAY);
      }
    }, [interactive]);

    useImperativeHandle(ref, () =&gt; ({
      show: (e?: React.MouseEvent) =&gt; {
        if (hideTimeoutRef.current) {
          clearTimeout(hideTimeoutRef.current);
          hideTimeoutRef.current = null;
        }
        if (e) {
          // Use e.currentTarget (or fallback to e.target) to determine the trigger element.
          const triggerEl = (e.currentTarget as HTMLElement) || (e.target as HTMLElement);
          if (triggerEl) {
            const rect = triggerEl.getBoundingClientRect();
            setTriggerInfo({ clientX: e.clientX, clientY: e.clientY, rect });
          }
        }
        setVisible(true);
      },
      hide: () =&gt; {
        if (hideTimeoutRef.current) {
          clearTimeout(hideTimeoutRef.current);
        }
        setVisible(false);
        setPos(null);
      },
      getIsMouseInside: () =&gt; isMouseInsideTooltip,
    }));

    useEffect(() =&gt; {
      if (!tooltipRef.current || !triggerInfo) return;

      const tooltipEl = tooltipRef.current;
      const { rect } = triggerInfo;
      let x = triggerInfo.clientX;
      let y = triggerInfo.clientY;

      if (tPosition === TooltipPosition.left) {
        const tooltipBounds = tooltipEl.getBoundingClientRect();
        x = rect.left - tooltipBounds.width - offset;
        y = rect.top + rect.height / 2 - tooltipBounds.height / 2;

        if (x &lt;= 0) {
          x = rect.left + rect.width + offset;
        }

        setPos(calcTooltipPosition({ x, y }));
        return;
      }

      if (tPosition === TooltipPosition.right) {
        x = rect.left + rect.width + offset;
        y = rect.top + rect.height / 2 - tooltipEl.offsetHeight / 2;
        setPos(calcTooltipPosition({ x, y }));
        return;
      }

      if (tPosition === TooltipPosition.top) {
        x = rect.left + rect.width / 2 - tooltipEl.offsetWidth / 2;
        y = rect.top - tooltipEl.offsetHeight - offset;
        setPos(calcTooltipPosition({ x, y }));
        return;
      }

      if (tPosition === TooltipPosition.bottom) {
        x = rect.left + rect.width / 2 - tooltipEl.offsetWidth / 2;
        y = rect.bottom + offset;
        setPos(calcTooltipPosition({ x, y }));
        return;
      }

      // Default case: use stored coordinates.
      setPos(calcTooltipPosition({ x, y }));
    }, [calcTooltipPosition, triggerInfo, tPosition, offset]);

    useEffect(() =&gt; {
      if (!targetSelector) return;

      const handleMouseMove = (evt: MouseEvent) =&gt; {
        const targetEl = evt.target as HTMLElement | null;
        if (!targetEl) {
          scheduleHide();
          return;
        }

        const triggerEl = targetEl.closest(targetSelector);
        const insideTooltip = interactive &amp;&amp; tooltipRef.current?.contains(targetEl);

        if (!triggerEl &amp;&amp; !insideTooltip) {
          scheduleHide();
          return;
        }

        if (hideTimeoutRef.current) {
          clearTimeout(hideTimeoutRef.current);
          hideTimeoutRef.current = null;
        }

        setVisible(true);

        if (triggerEl &amp;&amp; tooltipRef.current) {
          const rect = triggerEl.getBoundingClientRect();
          const tooltipEl = tooltipRef.current;

          let x = evt.clientX;
          let y = evt.clientY;

          switch (tPosition) {
            case TooltipPosition.left:
              x = rect.left - tooltipEl.offsetWidth - offset;
              y = rect.top + rect.height / 2 - tooltipEl.offsetHeight / 2;

              if (x &lt;= 0) {
                x = rect.left + rect.width + offset;
              }
              break;
            case TooltipPosition.right:
              x = rect.left + rect.width + offset;
              y = rect.top + rect.height / 2 - tooltipEl.offsetHeight / 2;
              break;
            case TooltipPosition.top:
              x = rect.left + rect.width / 2 - tooltipEl.offsetWidth / 2;
              y = rect.top - tooltipEl.offsetHeight - offset;
              break;
            case TooltipPosition.bottom:
              x = rect.left + rect.width / 2 - tooltipEl.offsetWidth / 2;
              y = rect.bottom + offset;
              break;
          }

          setPos(calcTooltipPosition({ x, y }));
        }
      };

      const debounced = debounce(handleMouseMove, 15);

      document.addEventListener(&apos;mousemove&apos;, debounced);
      return () =&gt; {
        document.removeEventListener(&apos;mousemove&apos;, debounced);
        debounced.cancel();
      };
    }, [targetSelector, interactive, tPosition, offset, calcTooltipPosition, scheduleHide]);

    useEffect(() =&gt; {
      return () =&gt; {
        if (hideTimeoutRef.current) {
          clearTimeout(hideTimeoutRef.current);
        }
      };
    }, []);

    if (!visible) {
      return null;
    }

    return createPortal(
      &lt;div
        ref={tooltipRef}
        className={clsx(
          classes.tooltip,
          interactive ? &apos;pointer-events-auto&apos; : &apos;pointer-events-none&apos;,
          &apos;absolute px-1 py-1&apos;,
          &apos;border rounded-sm border-green-300 border-opacity-10 bg-stone-900 bg-opacity-90&apos;,
          pos == null &amp;&amp; &apos;invisible&apos;,
          className,
        )}
        style={{
          top: pos?.top ?? 0,
          left: pos?.left ?? 0,
          zIndex: 10000,
        }}
        onMouseEnter={() =&gt; {
          if (interactive &amp;&amp; hideTimeoutRef.current) {
            clearTimeout(hideTimeoutRef.current);
            hideTimeoutRef.current = null;
          }
          setIsMouseInsideTooltip(true);
        }}
        onMouseLeave={() =&gt; {
          setIsMouseInsideTooltip(false);
          if (interactive) {
            scheduleHide();
          }
        }}
        {...restProps}
      &gt;
        {typeof content === &apos;function&apos; ? content() : content}
      &lt;/div&gt;,
      document.body,
    );
  },
);

WdTooltip.displayName = &apos;WdTooltip&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdTooltipWrapper/index.ts">export * from &apos;./WdTooltipWrapper&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdTooltipWrapper/utils.ts">import classes from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper/WdTooltipWrapper.module.scss&apos;;

export enum TooltipSize {
  xs = &apos;xs&apos;,
  sm = &apos;sm&apos;,
  md = &apos;md&apos;,
  lg = &apos;lg&apos;,
}

export const sizeClass = (size: TooltipSize) =&gt; {
  switch (size) {
    case TooltipSize.xs:
      return classes.wdTooltipSizeXs;
    case TooltipSize.sm:
      return classes.wdTooltipSizeSm;
    case TooltipSize.md:
      return classes.wdTooltipSizeMd;
    case TooltipSize.lg:
      return classes.wdTooltipSizeLg;
    default:
      return undefined;
  }
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdTooltipWrapper/WdTooltipWrapper.module.scss">/* WdTooltipWrapper.module.scss */

.WdTooltipWrapperRoot {
  display: inline-block;
}

.wdTooltipSizeXs {
  font-size: 0.7rem;
  max-width: 150px;
}

.wdTooltipSizeSm {
  font-size: 0.8rem;
  max-width: 200px;
}

.wdTooltipSizeMd {
  font-size: 0.9rem;
  max-width: 250px;
}

.wdTooltipSizeLg {
  font-size: 1rem !important;
  min-width: 350px;
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdTooltipWrapper/WdTooltipWrapper.tsx">import { forwardRef, HTMLProps, ReactNode, useMemo } from &apos;react&apos;;
import clsx from &apos;clsx&apos;;
import { WdTooltip, WdTooltipHandlers, TooltipProps } from &apos;@/hooks/Mapper/components/ui-kit&apos;;
import classes from &apos;./WdTooltipWrapper.module.scss&apos;;
import { sizeClass, TooltipSize } from &apos;@/hooks/Mapper/components/ui-kit/WdTooltipWrapper/utils.ts&apos;;

export type WdTooltipWrapperProps = {
  content?: (() =&gt; ReactNode) | ReactNode;
  size?: TooltipSize;
  interactive?: boolean;
  tooltipClassName?: string;
} &amp; Omit&lt;HTMLProps&lt;HTMLDivElement&gt;, &apos;content&apos; | &apos;size&apos;&gt; &amp;
  Omit&lt;TooltipProps, &apos;content&apos;&gt;;

export const WdTooltipWrapper = forwardRef&lt;WdTooltipHandlers, WdTooltipWrapperProps&gt;(
  (
    { className, children, content, offset, position, targetSelector, interactive, size, tooltipClassName, ...props },
    forwardedRef,
  ) =&gt; {
    const suffix = useMemo(() =&gt; Math.random().toString(36).slice(2, 7), []);
    const autoClass = `wdTooltipAutoTrigger-${suffix}`;
    const finalTargetSelector = targetSelector || `.${autoClass}`;

    return (
      &lt;div className={clsx(classes.WdTooltipWrapperRoot, className)} {...props}&gt;
        {targetSelector ? &lt;&gt;{children}&lt;/&gt; : &lt;div className={autoClass}&gt;{children}&lt;/div&gt;}

        &lt;WdTooltip
          ref={forwardedRef}
          offset={offset}
          position={position}
          content={content}
          interactive={interactive}
          targetSelector={finalTargetSelector}
          className={clsx(size &amp;&amp; sizeClass(size), tooltipClassName)}
        /&gt;
      &lt;/div&gt;
    );
  },
);

WdTooltipWrapper.displayName = &apos;WdTooltipWrapper&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdTransition/index.ts">export * from &apos;./WdTransition&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdTransition/WdTransition.module.scss">.FadeEnter {
  opacity: 0;
  transform: scale(0.95);
}

.FadeEnterActive {
  opacity: 1;
  transform: scale(1);
  transition: opacity 200ms, transform 200ms;
}

.FadeExit {
  opacity: 1;
  transform: scale(1);
}

.FadeExitActive {
  opacity: 0;
  transform: scale(0.95);
  transition: opacity 200ms, transform 200ms;
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/WdTransition/WdTransition.tsx">import classes from &apos;./WdTransition.module.scss&apos;;
import { CSSTransition, SwitchTransition } from &apos;react-transition-group&apos;;
import { WithChildren } from &apos;@/hooks/Mapper/types/common.ts&apos;;
import { TransitionProps } from &apos;react-transition-group/Transition&apos;;

const FADE_CLASSES = {
  enter: classes.FadeEnter,
  enterActive: classes.FadeEnterActive,
  exit: classes.FadeExit,
  exitActive: classes.FadeExitActive,
};

export type WdTransitionProps = {
  active: boolean;
} &amp; WithChildren &amp;
  TransitionProps;

export const WdTransition = ({ active, children, ...transition }: WdTransitionProps) =&gt; {
  return (
    &lt;SwitchTransition&gt;
      &lt;CSSTransition key={active ? &apos;one&apos; : &apos;two&apos;} {...transition} classNames={FADE_CLASSES}&gt;
        {children}
      &lt;/CSSTransition&gt;
    &lt;/SwitchTransition&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/WHClassView/index.ts">export * from &apos;./WHClassView&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WHClassView/WHClassView.module.scss">.WHClassViewRoot {
}

.WHClassViewContent {
  display: flex;
  gap: 2px;

  &amp;.NoOffset {
    gap: 4px;
    align-items: center;
  }
}

.WHClassName {
  position: relative;
  font-size: 10px;
  font-weight: bold;
  top: -2px;
}

.NoOffset {
  *.WHClassName {
    position: relative;
    font-size: 12px;
    font-weight: initial !important;
    top: initial !important;
  }
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/WHClassView/WHClassView.tsx">import classes from &apos;./WHClassView.module.scss&apos;;
import { Tooltip } from &apos;primereact/tooltip&apos;;
import clsx from &apos;clsx&apos;;
import { InfoDrawer } from &apos;@/hooks/Mapper/components/ui-kit/InfoDrawer&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { WORMHOLE_CLASS_STYLES, WORMHOLES_ADDITIONAL_INFO } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { useMemo } from &apos;react&apos;;

const prepareMass = (mass: number) =&gt; {
  if (mass === 0) {
    return `0 t`;
  }

  return `${(mass / 1000).toLocaleString(&apos;de-DE&apos;)} t`;
};

export interface WHClassViewProps {
  whClassName: string;
  noOffset?: boolean;
  useShortTitle?: boolean;
  hideTooltip?: boolean;
  hideWhClass?: boolean;
  hideWhClassName?: boolean;
  highlightName?: boolean;
  className?: string;
  classNameWh?: string;
}

export const WHClassView = ({
  whClassName,
  noOffset,
  useShortTitle,
  hideTooltip,
  hideWhClass,
  hideWhClassName,
  highlightName,
  className,
  classNameWh,
}: WHClassViewProps) =&gt; {
  const {
    data: { wormholesData },
  } = useMapRootState();

  const whData = useMemo(() =&gt; wormholesData[whClassName], [whClassName, wormholesData]);
  const whClass = useMemo(() =&gt; WORMHOLES_ADDITIONAL_INFO[whData.dest], [whData.dest]);
  const whClassStyle = WORMHOLE_CLASS_STYLES[whClass?.wormholeClassID] ?? &apos;&apos;;

  const uid = useMemo(() =&gt; new Date().getTime().toString(), []);

  return (
    &lt;div className={clsx(classes.WHClassViewRoot, className)}&gt;
      {!hideTooltip &amp;&amp; (
        &lt;Tooltip
          target={`.wh-name${whClassName}${uid}`}
          position=&quot;right&quot;
          mouseTrack
          mouseTrackLeft={20}
          mouseTrackTop={30}
          className=&quot;border border-green-300 rounded border-opacity-10 bg-stone-900 bg-opacity-90 &quot;
        &gt;
          &lt;div className=&quot;flex gap-3&quot;&gt;
            &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
              &lt;InfoDrawer title=&quot;Total mass&quot;&gt;{prepareMass(whData.total_mass)}&lt;/InfoDrawer&gt;
              &lt;InfoDrawer title=&quot;Jump mass&quot;&gt;{prepareMass(whData.max_mass_per_jump)}&lt;/InfoDrawer&gt;
            &lt;/div&gt;
            &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
              &lt;InfoDrawer title=&quot;Lifetime&quot;&gt;{whData.lifetime}h&lt;/InfoDrawer&gt;
              &lt;InfoDrawer title=&quot;Mass regen&quot;&gt;{prepareMass(whData.mass_regen)}&lt;/InfoDrawer&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/Tooltip&gt;
      )}

      &lt;div
        className={clsx(
          classes.WHClassViewContent,
          { [classes.NoOffset]: noOffset },
          &apos;wh-name select-none cursor-help&apos;,
          `wh-name${whClassName}${uid}`,
        )}
      &gt;
        {!hideWhClassName &amp;&amp; &lt;span className={clsx({ [whClassStyle]: highlightName })}&gt;{whClassName}&lt;/span&gt;}
        {!hideWhClass &amp;&amp; whClass &amp;&amp; (
          &lt;span className={clsx(classes.WHClassName, whClassStyle, classNameWh)}&gt;
            {useShortTitle ? whClass.shortTitle : whClass.shortName}
          &lt;/span&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/WHEffectView/index.ts">export * from &apos;./WHEffectView.tsx&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WHEffectView/WHEffectView.module.scss">.WHEffectViewRoot {

}

.WHEffectViewContent {
  display: grid;
  grid-template-columns: 1fr auto;
  align-items: center;
  row-gap: 4px;
  column-gap: 12px;

  &amp; &gt; span {
    line-height: initial;
  }

  &amp; &gt; span:nth-child(2n) {
    justify-self: end;
  }
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/WHEffectView/WHEffectView.tsx">import classes from &apos;./WHEffectView.module.scss&apos;;
import clsx from &apos;clsx&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { EFFECT_FOREGROUND_STYLES, EFFECT_NAME } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { EffectRaw } from &apos;@/hooks/Mapper/types/effect.ts&apos;;
import { Fragment, useMemo } from &apos;react&apos;;
import { FixedTooltip } from &apos;@/hooks/Mapper/components/ui-kit&apos;;

type PreparedEffectType = {
  name: string;
  power: string;
  positive: boolean;
};

const prepareEffects = (effects: Record&lt;string, EffectRaw&gt;, effectName: string, effectPower: number) =&gt; {
  const effect = effects[effectName];
  const out: PreparedEffectType[] = [];

  effect.modifiers.map(mod =&gt; {
    const modPower = mod.power[effectPower - 1];

    out.push({
      name: mod.name,
      power: modPower,
      positive: mod.positive,
    });
  });

  out.sort((a, b) =&gt; (a.positive === b.positive ? 0 : a.positive ? -1 : 1));

  return out;
};

let counter = 0;

export interface WHEffectViewProps {
  effectName: string;
  effectPower: number;
  className?: string;
}

export const WHEffectView = ({ effectName, effectPower, className }: WHEffectViewProps) =&gt; {
  const {
    data: { effects },
  } = useMapRootState();

  const effectClass = EFFECT_FOREGROUND_STYLES[effectName];
  const effectInfo = effects[effectName];

  const preparedEffect = useMemo(
    () =&gt; prepareEffects(effects, effectName, effectPower),
    [effectName, effectPower, effects],
  );

  const targetClass = useMemo(() =&gt; `wh-effect-name${effectInfo.id}-${counter++}`, []);

  return (
    &lt;div className={classes.WHEffectViewRoot}&gt;
      &lt;FixedTooltip
        target={`.${targetClass}`}
        position=&quot;right&quot;
        mouseTrack
        mouseTrackLeft={20}
        mouseTrackTop={30}
        className={clsx(&apos;bg-gradient-to-br &apos;, {
          [&apos;from-black/10 to-yellow-500/10&apos;]: effectName === EFFECT_NAME.cataclysmicVariable,
          [&apos;from-black/10 to-fuchsia-500/10&apos;]: effectName === EFFECT_NAME.magnetar,
          [&apos;from-black/10 to-blue-500/20&apos;]: effectName === EFFECT_NAME.pulsar,
          [&apos;from-black/10 to-red-500/10&apos;]: effectName === EFFECT_NAME.redGiant,
          [&apos;from-black/10 to-amber-500/10&apos;]: effectName === EFFECT_NAME.wolfRayetStar,
        })}
      &gt;
        &lt;div className={clsx(classes.WHEffectViewContent, &apos;text-xs&apos;)}&gt;
          {preparedEffect.map(({ name, power, positive }) =&gt; (
            &lt;Fragment key={name}&gt;
              &lt;span&gt;{name}&lt;/span&gt;
              &lt;span
                className={clsx({
                  [&apos;text-green-500&apos;]: positive,
                  [&apos;text-red-500&apos;]: !positive,
                })}
              &gt;
                {power}
              &lt;/span&gt;
            &lt;/Fragment&gt;
          ))}
        &lt;/div&gt;
      &lt;/FixedTooltip&gt;

      &lt;div className={clsx(&apos;font-bold select-none cursor-help w-min-content&apos;, effectClass, targetClass, className)}&gt;
        {effectName}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/WindowManager/index.ts">export * from &apos;./WindowManager&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/WindowManager/types.ts">import React from &apos;react&apos;;

export type WindowProps = {
  id: string | number;
  content: (w: WindowProps) =&gt; React.ReactNode;
  position: { x: number; y: number };
  size: { width: number; height: number };
  zIndex: number;
  visible?: boolean;
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/WindowManager/utils.ts">import { WindowProps } from &apos;@/hooks/Mapper/components/ui-kit/WindowManager/WindowManager.tsx&apos;;

export function getWindowsBySides(windows: WindowProps[], containerWidth: number, containerHeight: number) {
  const centerX = containerWidth / 2;
  const centerY = containerHeight / 2;

  const top = windows.filter(window =&gt; window.position.y + window.size.height / 2 &lt; centerY);
  const bottom = windows.filter(window =&gt; window.position.y + window.size.height / 2 &gt;= centerY);
  const left = windows.filter(window =&gt; window.position.x + window.size.width / 2 &lt; centerX);
  const right = windows.filter(window =&gt; window.position.x + window.size.width / 2 &gt;= centerX);

  return { top, bottom, left, right };
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/WindowManager/WindowManager.module.scss">.windowContainer {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.window {
  position: absolute;
  //background: #fff;
  //border: 1px solid #000;
  //box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  user-select: none;

  pointer-events: initial;
}

.resizeHandle {
  position: absolute;
  //background: rgba(0, 0, 0, 0.2);
  width: 15px;
  height: 15px;
}

.topRight,
.bottomLeft {
  cursor: nesw-resize;
}

.topLeft,
.bottomRight {
  cursor: nwse-resize;
}

.topLeft {
  top: -7.5px;
  left: -7.5px;

  &amp;::after {
    position: relative;
    top: 7.5px;
    left: 7.5px;
    display: block;
    content: &quot; &quot;;
    width: 5px;
    height: 5px;
    border-left: 1px solid var(--window-corner);
    border-top: 1px solid var(--window-corner);
    pointer-events: none;
  }
}

.topRight {
  top: -7.5px;
  right: -7.5px;

  &amp;::after {
    position: relative;
    top: 7.5px;
    right: -2.5px;
    display: block;
    content: &quot; &quot;;
    width: 5px;
    height: 5px;
    border-right: 1px solid var(--window-corner);
    border-top: 1px solid var(--window-corner);
    pointer-events: none;
  }
}

.bottomLeft {
  bottom: -7.5px;
  left: -7.5px;

  &amp;::after {
    position: relative;
    top: 2.5px;
    left: 7.5px;
    display: block;
    content: &quot; &quot;;
    width: 5px;
    height: 5px;
    border-left: 1px solid var(--window-corner);
    border-bottom: 1px solid var(--window-corner);
    pointer-events: none;
  }
}

.bottomRight {
  bottom: -7.5px;
  right: -7.5px;

  &amp;::after {
    position: relative;
    top: 2.5px;
    right: -2.5px;
    display: block;
    content: &quot; &quot;;
    width: 5px;
    height: 5px;
    border-right: 1px solid var(--window-corner);
    border-bottom: 1px solid var(--window-corner);
    pointer-events: none;
  }
}

.top {
  top: -5px;
  left: 0;
  right: 0;
  height: 10px;
  cursor: ns-resize;
}

.bottom {
  bottom: -5px;
  left: 0;
  right: 0;
  height: 10px;
  cursor: ns-resize;
}

.left {
  top: 0;
  bottom: 0;
  left: -5px;
  width: 10px;
  cursor: ew-resize;
}

.right {
  top: 0;
  bottom: 0;
  right: -5px;
  width: 10px;
  cursor: ew-resize;
}</file><file path="assets/js/hooks/Mapper/components/ui-kit/WindowManager/WindowManager.tsx">import React, { useState, useRef, useEffect, useMemo, useCallback } from &apos;react&apos;;
import styles from &apos;./WindowManager.module.scss&apos;;
import debounce from &apos;lodash.debounce&apos;;
import { WindowProps } from &apos;@/hooks/Mapper/components/ui-kit/WindowManager/types.ts&apos;;
import fastDeepEqual from &apos;fast-deep-equal&apos;;

const MIN_WINDOW_SIZE = 100;
const SNAP_THRESHOLD = 10;
export const SNAP_GAP = 10;

export enum ActionType {
  Drag = &apos;drag&apos;,
  Resize = &apos;resize&apos;,
}

export const DefaultWindowState = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
};

function getWindowsBySides(windows: WindowProps[], containerWidth: number, containerHeight: number) {
  const centerX = containerWidth / 2;
  const centerY = containerHeight / 2;

  const top = windows.filter(window =&gt; window.position.y + window.size.height / 2 &lt; centerY);
  const bottom = windows.filter(window =&gt; window.position.y + window.size.height / 2 &gt;= centerY);
  const left = windows.filter(window =&gt; window.position.x + window.size.width / 2 &lt; centerX);
  const right = windows.filter(window =&gt; window.position.x + window.size.width / 2 &gt;= centerX);

  return { top, bottom, left, right };
}

export type WindowWrapperProps = {
  onDrag: (e: React.MouseEvent, windowId: string | number) =&gt; void;
  onResize: (e: React.MouseEvent, windowId: string | number, resizeDirection: string) =&gt; void;
} &amp; WindowProps;

export const WindowWrapper = ({ onResize, onDrag, ...window }: WindowWrapperProps) =&gt; {
  const handleMouseDownRoot = (e: React.MouseEvent) =&gt; {
    onDrag(e, window.id);
  };

  const { handleResizeTL, handleResizeTR, handleResizeBL, handleResizeBR } = useMemo(() =&gt; {
    const handleResizeTL = (e: React.MouseEvent) =&gt; onResize(e, window.id, &apos;top left&apos;);
    const handleResizeTR = (e: React.MouseEvent) =&gt; onResize(e, window.id, &apos;top right&apos;);
    const handleResizeBL = (e: React.MouseEvent) =&gt; onResize(e, window.id, &apos;bottom left&apos;);
    const handleResizeBR = (e: React.MouseEvent) =&gt; onResize(e, window.id, &apos;bottom right&apos;);

    return {
      handleResizeTL,
      handleResizeTR,
      handleResizeBL,
      handleResizeBR,
    };
  }, [window]);

  return (
    &lt;div
      key={window.id}
      className={`drag-handle ${styles.window}`}
      style={{
        width: window.size.width,
        height: window.size.height,
        top: window.position.y,
        left: window.position.x,
        zIndex: window.zIndex,
      }}
      onMouseDown={handleMouseDownRoot}
    &gt;
      {window.content(window)}
      &lt;div className={styles.resizeHandle + &apos; &apos; + styles.topLeft} onMouseDown={handleResizeTL} /&gt;
      &lt;div className={styles.resizeHandle + &apos; &apos; + styles.topRight} onMouseDown={handleResizeTR} /&gt;
      &lt;div className={styles.resizeHandle + &apos; &apos; + styles.bottomLeft} onMouseDown={handleResizeBL} /&gt;
      &lt;div className={styles.resizeHandle + &apos; &apos; + styles.bottomRight} onMouseDown={handleResizeBR} /&gt;
    &lt;/div&gt;
  );
};
export type ViewPortProps = { w: number; h: number };
export type WindowsManagerOnChange = (props: { windows: WindowProps[]; viewPort: ViewPortProps }) =&gt; void;

type WindowManagerProps = {
  windows: WindowProps[];
  viewPort?: ViewPortProps;
  dragSelector?: string;
  onChange?: WindowsManagerOnChange;
};

export const WindowManager: React.FC&lt;WindowManagerProps&gt; = ({
  windows: initialWindows,
  viewPort,
  dragSelector,
  onChange,
}) =&gt; {
  const [windows, setWindows] = useState(
    initialWindows.map((window, index) =&gt; ({
      ...window,
      zIndex: index + 1,
    })),
  );

  const refPrevSize = useRef({ w: 0, h: 0 });
  const ref = useRef({ windows, viewPort, onChange });
  ref.current = { windows, viewPort, onChange };

  useEffect(() =&gt; {
    if (!viewPort) {
      return;
    }

    refPrevSize.current = viewPort;
  }, [viewPort]);

  useEffect(() =&gt; {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const next = initialWindows.map(({ content, ...x }) =&gt; x);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const prev = ref.current.windows.map(({ content, ...x }) =&gt; x);

    // Here we avoid unnecessary renders if changes was emitted from here.
    if (fastDeepEqual(next, prev)) {
      return;
    }

    setWindows(initialWindows.slice(0));
  }, [initialWindows]);

  const containerRef = useRef&lt;HTMLDivElement | null&gt;(null);
  const activeWindowIdRef = useRef&lt;string | number | null&gt;(null);
  const actionTypeRef = useRef&lt;ActionType | null&gt;(null);
  const resizeDirectionRef = useRef&lt;string | null&gt;(null);
  const startMousePositionRef = useRef&lt;{ x: number; y: number }&gt;({ x: 0, y: 0 });
  const startWindowStateRef = useRef&lt;{ x: number; y: number; width: number; height: number }&gt;(DefaultWindowState);

  const onDebouncedChange = useMemo(() =&gt; {
    return debounce(() =&gt; {
      ref.current.onChange?.({
        windows: ref.current.windows,
        viewPort: refPrevSize.current,
      });
    }, 20);
  }, []);

  const handleMouseDown = (
    e: React.MouseEvent,
    windowId: string | number,
    actionType: ActionType,
    resizeDirection?: string,
  ) =&gt; {
    if (dragSelector &amp;&amp; actionType === ActionType.Drag &amp;&amp; !(e.target as HTMLElement).closest(dragSelector)) {
      return;
    }

    e.stopPropagation();
    activeWindowIdRef.current = windowId;
    actionTypeRef.current = actionType;
    resizeDirectionRef.current = resizeDirection || null;
    startMousePositionRef.current = { x: e.clientX, y: e.clientY };
    const targetWindow = windows.find(win =&gt; win.id === windowId);
    if (targetWindow) {
      startWindowStateRef.current = {
        x: targetWindow.position.x,
        y: targetWindow.position.y,
        width: targetWindow.size.width,
        height: targetWindow.size.height,
      };
    }

    // Bring window to front by updating zIndex
    setWindows(prevWindows =&gt; {
      const maxZIndex = Math.max(...prevWindows.map(w =&gt; w.zIndex));
      return prevWindows.map(window =&gt; (window.id === windowId ? { ...window, zIndex: maxZIndex + 1 } : window));
    });

    window.addEventListener(&apos;mousemove&apos;, handleMouseMove);
    window.addEventListener(&apos;mouseup&apos;, handleMouseUp);
  };

  const handleMouseMove = (e: MouseEvent) =&gt; {
    if (activeWindowIdRef.current !== null &amp;&amp; actionTypeRef.current) {
      const deltaX = e.clientX - startMousePositionRef.current.x;
      const deltaY = e.clientY - startMousePositionRef.current.y;
      const container = containerRef.current;

      setWindows(prevWindows =&gt;
        prevWindows.map(window =&gt; {
          if (window.id === activeWindowIdRef.current) {
            let newX = startWindowStateRef.current.x;
            let newY = startWindowStateRef.current.y;
            let newWidth = startWindowStateRef.current.width;
            let newHeight = startWindowStateRef.current.height;

            if (actionTypeRef.current === ActionType.Drag) {
              newX += deltaX;
              newY += deltaY;

              // Ensure the window stays within the container boundaries
              if (container) {
                newX = Math.max(SNAP_GAP, Math.min(container.clientWidth - window.size.width - SNAP_GAP, newX));
                newY = Math.max(SNAP_GAP, Math.min(container.clientHeight - window.size.height - SNAP_GAP, newY));
              }

              // Snap to other windows with or without gap
              prevWindows.forEach(otherWindow =&gt; {
                if (otherWindow.id === window.id) {
                  return;
                }

                // Snap vertically (top and bottom)
                if (Math.abs(newY - otherWindow.position.y) &lt; SNAP_THRESHOLD) {
                  newY = otherWindow.position.y; // Align top without gap
                } else if (Math.abs(newY + window.size.height - otherWindow.position.y) &lt; SNAP_THRESHOLD) {
                  newY = otherWindow.position.y - window.size.height - SNAP_GAP; // Bottom aligns to top
                } else if (Math.abs(newY - (otherWindow.position.y + otherWindow.size.height)) &lt; SNAP_THRESHOLD) {
                  newY = otherWindow.position.y + otherWindow.size.height + SNAP_GAP; // Align bottom without gap
                } else if (
                  Math.abs(newY + window.size.height - (otherWindow.position.y + otherWindow.size.height)) &lt;
                  SNAP_THRESHOLD
                ) {
                  newY = otherWindow.position.y + otherWindow.size.height - window.size.height; // Bottom aligns bottom
                }

                // Snap horizontally (left and right)
                if (Math.abs(newX - otherWindow.position.x) &lt; SNAP_THRESHOLD) {
                  newX = otherWindow.position.x; // Align left without gap
                } else if (Math.abs(newX + window.size.width - otherWindow.position.x) &lt; SNAP_THRESHOLD) {
                  newX = otherWindow.position.x - window.size.width - SNAP_GAP; // Right aligns to left
                } else if (Math.abs(newX - (otherWindow.position.x + otherWindow.size.width)) &lt; SNAP_THRESHOLD) {
                  newX = otherWindow.position.x + otherWindow.size.width + SNAP_GAP; // Align right without gap
                } else if (
                  Math.abs(newX + window.size.width - (otherWindow.position.x + otherWindow.size.width)) &lt;
                  SNAP_THRESHOLD
                ) {
                  newX = otherWindow.position.x + otherWindow.size.width - window.size.width; // Right aligns right
                }
              });
            }

            if (actionTypeRef.current === ActionType.Resize &amp;&amp; resizeDirectionRef.current) {
              if (resizeDirectionRef.current.includes(&apos;right&apos;)) {
                newWidth = Math.max(MIN_WINDOW_SIZE, startWindowStateRef.current.width + deltaX);

                // –°–Ω–∞–ø –¥–ª—è –ø—Ä–∞–≤–æ–π –≥—Ä–∞–Ω–∏—Ü—ã —Å –æ—Ç—Å—Ç—É–ø–æ–º SNAP_THRESHOLD
                prevWindows.forEach(otherWindow =&gt; {
                  if (otherWindow.id !== window.id) {
                    // –ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ —Ç–µ–∫—É—â–µ–≥–æ –æ–∫–Ω–∞ –∫ –ª–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü–µ –¥—Ä—É–≥–æ–≥–æ –æ–∫–Ω–∞
                    const snapRightToLeft =
                      otherWindow.position.x - (startWindowStateRef.current.x + newWidth) - SNAP_THRESHOLD;
                    if (Math.abs(snapRightToLeft) &lt; SNAP_THRESHOLD) {
                      newWidth = otherWindow.position.x - startWindowStateRef.current.x - SNAP_THRESHOLD;
                    }

                    // –ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ —Ç–µ–∫—É—â–µ–≥–æ –æ–∫–Ω–∞ –∫ –ø—Ä–∞–≤–æ–π –≥—Ä–∞–Ω–∏—Ü–µ –¥—Ä—É–≥–æ–≥–æ –æ–∫–Ω–∞
                    const snapRightToRight =
                      otherWindow.position.x + otherWindow.size.width - (startWindowStateRef.current.x + newWidth);
                    if (Math.abs(snapRightToRight) &lt; SNAP_THRESHOLD) {
                      newWidth = otherWindow.position.x + otherWindow.size.width - startWindowStateRef.current.x;
                    }
                  }
                });
              }

              if (resizeDirectionRef.current.includes(&apos;left&apos;)) {
                newWidth = Math.max(MIN_WINDOW_SIZE, startWindowStateRef.current.width - deltaX);
                newX = startWindowStateRef.current.x + (startWindowStateRef.current.width - newWidth);

                // –°–Ω–∞–ø –¥–ª—è –ª–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü—ã —Å –æ—Ç—Å—Ç—É–ø–æ–º SNAP_THRESHOLD
                prevWindows.forEach(otherWindow =&gt; {
                  if (otherWindow.id !== window.id) {
                    // –õ–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ —Ç–µ–∫—É—â–µ–≥–æ –æ–∫–Ω–∞ –∫ –ø—Ä–∞–≤–æ–π –≥—Ä–∞–Ω–∏—Ü–µ –¥—Ä—É–≥–æ–≥–æ –æ–∫–Ω–∞
                    const snapLeftToRight = newX - (otherWindow.position.x + otherWindow.size.width + SNAP_THRESHOLD);
                    if (Math.abs(snapLeftToRight) &lt; SNAP_THRESHOLD) {
                      newX = otherWindow.position.x + otherWindow.size.width + SNAP_THRESHOLD;
                      newWidth = startWindowStateRef.current.width + startWindowStateRef.current.x - newX;
                    }

                    // –õ–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ —Ç–µ–∫—É—â–µ–≥–æ –æ–∫–Ω–∞ –∫ –ª–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü–µ –¥—Ä—É–≥–æ–≥–æ –æ–∫–Ω–∞
                    const snapLeftToLeft = newX - otherWindow.position.x;
                    if (Math.abs(snapLeftToLeft) &lt; SNAP_THRESHOLD) {
                      newX = otherWindow.position.x;
                      newWidth = startWindowStateRef.current.width + startWindowStateRef.current.x - newX;
                    }
                  }
                });
              }

              if (resizeDirectionRef.current.includes(&apos;bottom&apos;)) {
                newHeight = Math.max(MIN_WINDOW_SIZE, startWindowStateRef.current.height + deltaY);

                // –°–Ω–∞–ø –¥–ª—è –Ω–∏–∂–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü—ã —Å –æ—Ç—Å—Ç—É–ø–æ–º SNAP_THRESHOLD
                prevWindows.forEach(otherWindow =&gt; {
                  if (otherWindow.id !== window.id) {
                    // –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ —Ç–µ–∫—É—â–µ–≥–æ –æ–∫–Ω–∞ –∫ –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü–µ –¥—Ä—É–≥–æ–≥–æ –æ–∫–Ω–∞
                    const snapBottomToTop =
                      otherWindow.position.y - (startWindowStateRef.current.y + newHeight) - SNAP_THRESHOLD;
                    if (Math.abs(snapBottomToTop) &lt; SNAP_THRESHOLD) {
                      newHeight = otherWindow.position.y - startWindowStateRef.current.y - SNAP_THRESHOLD;
                    }

                    // –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ —Ç–µ–∫—É—â–µ–≥–æ –æ–∫–Ω–∞ –∫ –Ω–∏–∂–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü–µ –¥—Ä—É–≥–æ–≥–æ –æ–∫–Ω–∞
                    const snapBottomToBottom =
                      otherWindow.position.y + otherWindow.size.height - (startWindowStateRef.current.y + newHeight);
                    if (Math.abs(snapBottomToBottom) &lt; SNAP_THRESHOLD) {
                      newHeight = otherWindow.position.y + otherWindow.size.height - startWindowStateRef.current.y;
                    }
                  }
                });
              }

              if (resizeDirectionRef.current.includes(&apos;top&apos;)) {
                newHeight = Math.max(MIN_WINDOW_SIZE, startWindowStateRef.current.height - deltaY);
                newY = startWindowStateRef.current.y + (startWindowStateRef.current.height - newHeight);

                // –°–Ω–∞–ø –¥–ª—è –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü—ã —Å –æ—Ç—Å—Ç—É–ø–æ–º SNAP_THRESHOLD
                prevWindows.forEach(otherWindow =&gt; {
                  if (otherWindow.id !== window.id) {
                    // –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ —Ç–µ–∫—É—â–µ–≥–æ –æ–∫–Ω–∞ –∫ –Ω–∏–∂–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü–µ –¥—Ä—É–≥–æ–≥–æ –æ–∫–Ω–∞
                    const snapTopToBottom = newY - (otherWindow.position.y + otherWindow.size.height + SNAP_THRESHOLD);
                    if (Math.abs(snapTopToBottom) &lt; SNAP_THRESHOLD) {
                      newY = otherWindow.position.y + otherWindow.size.height + SNAP_THRESHOLD;
                      newHeight = startWindowStateRef.current.height + startWindowStateRef.current.y - newY;
                    }

                    // –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ —Ç–µ–∫—É—â–µ–≥–æ –æ–∫–Ω–∞ –∫ –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü–µ –¥—Ä—É–≥–æ–≥–æ –æ–∫–Ω–∞
                    const snapTopToTop = newY - otherWindow.position.y;
                    if (Math.abs(snapTopToTop) &lt; SNAP_THRESHOLD) {
                      newY = otherWindow.position.y;
                      newHeight = startWindowStateRef.current.height + startWindowStateRef.current.y - newY;
                    }
                  }
                });
              }

              // Ensure the window stays within the container boundaries
              if (container) {
                newX = Math.max(0 + SNAP_GAP, Math.min(container.clientWidth - newWidth - SNAP_GAP, newX));
                newY = Math.max(0 + SNAP_GAP, Math.min(container.clientHeight - newHeight - SNAP_GAP, newY));
              }
            }

            return {
              ...window,
              position: { x: newX, y: newY },
              size: { width: newWidth, height: newHeight },
            };
          }
          return window;
        }),
      );

      onDebouncedChange();
    }
  };

  const handleMouseUp = useCallback(() =&gt; {
    activeWindowIdRef.current = null;
    actionTypeRef.current = null;
    resizeDirectionRef.current = null;

    onDebouncedChange();
    window.removeEventListener(&apos;mousemove&apos;, handleMouseMove);
    window.removeEventListener(&apos;mouseup&apos;, handleMouseUp);
  }, []);

  // Handle resize of the container and reposition windows
  useEffect(() =&gt; {
    if (ref.current.viewPort == null &amp;&amp; containerRef.current) {
      refPrevSize.current = { w: containerRef.current.clientWidth, h: containerRef.current.clientHeight };
    }

    const handleResize = () =&gt; {
      const container = containerRef.current;
      const { windows } = ref.current;
      if (!container) {
        return;
      }

      const deltaX = container.clientWidth - refPrevSize.current.w;
      const deltaY = container.clientHeight - refPrevSize.current.h;

      const { bottom, right } = getWindowsBySides(windows, refPrevSize.current.w, refPrevSize.current.h);

      setWindows(w =&gt; {
        return w.map(x =&gt; {
          let next = { ...x };

          if (right.some(r =&gt; r.id === x.id)) {
            next = {
              ...next,
              position: {
                ...next.position,
                x: next.position.x + deltaX,
              },
            };
          }

          if (bottom.some(r =&gt; r.id === x.id)) {
            next = {
              ...next,
              position: {
                ...next.position,
                y: next.position.y + deltaY,
              },
            };
          }

          if (next.position.x + next.size.width &gt; container.clientWidth - SNAP_GAP) {
            next.position.x = container.clientWidth - next.size.width - SNAP_GAP;
          }

          if (next.position.y + next.size.height &gt; container.clientHeight - SNAP_GAP) {
            next.position.y = container.clientHeight - next.size.height - SNAP_GAP;
          }

          if (next.position.y &lt; SNAP_GAP) {
            next.position.y = 0;
          }

          if (next.position.x &lt; SNAP_GAP) {
            next.position.x = SNAP_GAP;
          }

          return next;
        });
      });

      onDebouncedChange();

      refPrevSize.current = { w: container.clientWidth, h: container.clientHeight };
    };

    const tid = setTimeout(handleResize, 10);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; {
      clearTimeout(tid);
      window.removeEventListener(&apos;resize&apos;, handleResize);
    };
  }, []);

  const handleDrag = (e: React.MouseEvent, windowId: string | number) =&gt; {
    handleMouseDown(e, windowId, ActionType.Drag);
  };

  const handleResize = (e: React.MouseEvent, windowId: string | number, resizeDirection: string) =&gt; {
    handleMouseDown(e, windowId, ActionType.Resize, resizeDirection);
  };

  return (
    &lt;div ref={containerRef} className={styles.windowContainer}&gt;
      {windows.map(window =&gt; (
        &lt;WindowWrapper key={window.id} onDrag={handleDrag} onResize={handleResize} {...window} /&gt;
      ))}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/index.ts">export * from &apos;./CharacterCard&apos;;
export * from &apos;./InfoDrawer&apos;;
export * from &apos;./FixedTooltip&apos;;
export * from &apos;./LayoutEventBlocker&apos;;
export * from &apos;./SystemView&apos;;
export * from &apos;./SystemViewStandalone&apos;;
export * from &apos;./TimeLeft&apos;;
export * from &apos;./WHEffectView&apos;;
export * from &apos;./WHClassView&apos;;
export * from &apos;./WdImgButton&apos;;
export * from &apos;./WdTooltip&apos;;
export * from &apos;./WdCheckbox&apos;;
export * from &apos;./TimeAgo&apos;;
export * from &apos;./WdTooltipWrapper&apos;;
export * from &apos;./WdResponsiveCheckBox&apos;;
export * from &apos;./WdRadioButton&apos;;
export * from &apos;./WdEveEntityPortrait&apos;;
export * from &apos;./WdTransition&apos;;
export * from &apos;./LoadingWrapper&apos;;</file><file path="assets/js/hooks/Mapper/components/ui-kit/LayoutEventBlocker.tsx">import { MouseEvent } from &apos;react&apos;;
import { WithChildren, WithClassName } from &apos;@/hooks/Mapper/types/common.ts&apos;;

const preventMousedownFunc = (e: MouseEvent) =&gt; {
  e.preventDefault();
  e.stopPropagation();
};

// TODO this components need for preventing events on headers of widgets
//      otherwise on mousedown to btn window will moving...
export const LayoutEventBlocker = ({ children, className }: WithChildren &amp; WithClassName) =&gt; {
  return (
    &lt;div onMouseDown={preventMousedownFunc} className={className}&gt;
      {children}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/LoadingWrapper.tsx">import React from &apos;react&apos;;
import { ProgressSpinner } from &apos;primereact/progressspinner&apos;;

type LoadingWrapperProps = {
  loading?: boolean;
  children: React.ReactNode;
};

export const LoadingWrapper: React.FC&lt;LoadingWrapperProps&gt; = ({ loading, children }) =&gt; {
  return (
    &lt;div className=&quot;relative w-full h-full&quot;&gt;
      {children}
      {loading &amp;&amp; (
        &lt;div className=&quot;absolute inset-0 bg-stone-950/50 flex items-center justify-center z-10&quot;&gt;
          &lt;ProgressSpinner
            style={{ width: &apos;50px&apos;, height: &apos;50px&apos; }}
            strokeWidth=&quot;2&quot;
            fill=&quot;transparent&quot;
            animationDuration=&quot;2s&quot;
          /&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};</file><file path="assets/js/hooks/Mapper/components/ui-kit/SvgIconWrapper.tsx">import React from &apos;react&apos;;
import clsx from &apos;clsx&apos;;

export type SvgIconProps = React.SVGAttributes&lt;SVGElement&gt; &amp; {
  width?: number;
  height?: number;
  className?: string;
};

export const SvgIconWrapper = ({
  width = 24,
  height = 24,
  children,
  className,
  ...props
}: SvgIconProps &amp; { children: React.ReactNode }) =&gt; {
  return (
    &lt;svg
      width={width}
      height={height}
      fill=&quot;none&quot;
      xmlns=&quot;http://www.w3.org/2000/svg&quot;
      className={clsx(&apos;w-[19px] h-[19px]&apos;, className)}
      {...props}
    &gt;
      {children}
    &lt;/svg&gt;
  );
};</file><file path="assets/js/hooks/Mapper/events/index.ts">import { createEvent } from &apos;react-event-hook&apos;;

import { Command, CommandData } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;

export interface MapEvent&lt;T extends Command&gt; {
  name: T;
  data: CommandData[T];
}

const { useMapEventListener, emitMapEvent } = createEvent(&apos;map-event&apos;)&lt;MapEvent&lt;Command&gt;&gt;();

export { useMapEventListener, emitMapEvent };</file><file path="assets/js/hooks/Mapper/helpers/getEveImageUrl.ts">/**
 * Constants for EVE Online image URLs
 */
const BASE_IMAGE_URL = &apos;https://images.evetech.net&apos;;

/**
 * Generates a URL for any EVE Online image resource
 * @param category - The category of the image (characters, corporations, alliances, types)
 * @param id - The EVE Online ID of the entity
 * @param variation - The variation of the image (icon, portrait, render, logo)
 * @param size - The size of the image (optional)
 * @returns The URL to the EVE Online image, or null if the ID is invalid
 */
export const getEveImageUrl = (
  category: &apos;characters&apos; | &apos;corporations&apos; | &apos;alliances&apos; | &apos;types&apos;,
  id?: number | string | null,
  variation: string = &apos;icon&apos;,
  size?: number,
): string | null =&gt; {
  if (!id || (typeof id === &apos;number&apos; &amp;&amp; id &lt;= 0)) {
    return null;
  }

  let url = `${BASE_IMAGE_URL}/${category}/${id}/${variation}`;
  if (size) {
    url += `?size=${size}`;
  }

  return url;
};

/**
 * Generates the URL for an EVE Online character portrait
 * @param characterEveId - The EVE Online character ID
 * @param size - The size of the portrait (default: 64)
 * @returns The URL to the character&apos;s portrait, or an empty string if the ID is invalid
 */
export const getCharacterPortraitUrl = (characterEveId: string | number | undefined, size: number = 64): string =&gt; {
  const portraitUrl = getEveImageUrl(&apos;characters&apos;, characterEveId, &apos;portrait&apos;, size);
  return portraitUrl || &apos;&apos;;
};</file><file path="assets/js/hooks/Mapper/helpers/getSystemById.ts">import { SolarSystemRawType, SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types&apos;;

export const getSystemById = (systems: SolarSystemRawType[], systemId: string) =&gt; systems.find(x =&gt; x.id === systemId);

export const getSystemStaticById = (systems: SolarSystemStaticInfoRaw[], systemId: string) =&gt;
  systems.find(x =&gt; x.solar_system_id.toString() === systemId);</file><file path="assets/js/hooks/Mapper/helpers/getWhSize.ts">import { SHIP_MASSES_SIZE } from &apos;../components/map/constants&apos;;
import { ShipSizeStatus } from &apos;../types/connection&apos;;
import { WormholeDataRaw } from &apos;../types/wormholes&apos;;

export const getWhSize = (whDatas: WormholeDataRaw[], whType: string): ShipSizeStatus | null =&gt; {
  if (whType === &apos;K162&apos; || whType == null) return null;

  const wormholeData = whDatas.find(wh =&gt; wh.name === whType);

  if (!wormholeData?.max_mass_per_jump) return null;

  return SHIP_MASSES_SIZE[wormholeData.max_mass_per_jump] ?? ShipSizeStatus.large;
};</file><file path="assets/js/hooks/Mapper/helpers/index.ts">export * from &apos;./sortWHClasses&apos;;
export * from &apos;./parseSignatures&apos;;
export * from &apos;./getSystemById&apos;;
export * from &apos;./getEveImageUrl&apos;;</file><file path="assets/js/hooks/Mapper/helpers/isDocked.ts">import { LocationRaw } from &apos;@/hooks/Mapper/types&apos;;

export const isDocked = (location: LocationRaw | null) =&gt; {
  if (!location) {
    return false;
  }

  return location.station_id != null || location.structure_id != null;
};</file><file path="assets/js/hooks/Mapper/helpers/parseSignatureCustomInfo.ts">import { SignatureCustomInfo } from &apos;@/hooks/Mapper/types&apos;;

export const parseSignatureCustomInfo = (str: string | undefined): SignatureCustomInfo =&gt; {
  if (str == null || str === &apos;&apos;) {
    return {};
  }

  return JSON.parse(str);
};</file><file path="assets/js/hooks/Mapper/helpers/parseSignatures.ts">import {
  MAPPING_GROUP_TO_ENG,
  MAPPING_TYPE_TO_ENG,
} from &apos;@/hooks/Mapper/components/mapInterface/widgets/SystemSignatures/constants.ts&apos;;
import { SignatureGroup, SignatureKind, SystemSignature } from &apos;@/hooks/Mapper/types&apos;;

export const UNKNOWN_SIGNATURE_NAME = &apos;Unknown&apos;;

export const parseSignatures = (value: string, availableKeys: string[]): SystemSignature[] =&gt; {
  const outArr: SystemSignature[] = [];
  const rows = value.split(&apos;\n&apos;);

  for (let a = 0; a &lt; rows.length; a++) {
    const row = rows[a];

    const sigArrInfo = row.split(&apos;	&apos;);

    if (sigArrInfo.length !== 6) {
      continue;
    }

    // Extract the signature ID and check if it&apos;s valid (XXX-XXX format)
    const sigId = sigArrInfo[0];

    if (!sigId || !sigId.match(/^[A-Z]{3}-\d{3}$/)) {
      continue;
    }

    // Try to map the kind, or fall back to CosmicSignature if unknown
    const typeString = sigArrInfo[1];
    let kind = SignatureKind.CosmicSignature;

    // Try to map the kind using the flattened mapping
    const mappedKind = MAPPING_TYPE_TO_ENG[typeString];

    if (mappedKind &amp;&amp; availableKeys.includes(mappedKind)) {
      kind = mappedKind;
    }

    // Try to map the group, or fall back to CosmicSignature if unknown
    const rawGroup = sigArrInfo[2];
    let group = SignatureGroup.CosmicSignature;

    // Try to map the group using the flattened mapping
    const mappedGroup = MAPPING_GROUP_TO_ENG[rawGroup];
    if (mappedGroup) {
      group = mappedGroup;
    }

    const signature: SystemSignature = {
      eve_id: sigId,
      kind,
      group,
      name: sigArrInfo[3] || UNKNOWN_SIGNATURE_NAME,
      type: &apos;&apos;,
    };

    outArr.push(signature);
  }

  return outArr;
};</file><file path="assets/js/hooks/Mapper/helpers/sortWHClasses.ts">import { WORMHOLES_ADDITIONAL_INFO } from &apos;@/hooks/Mapper/components/map/constants.ts&apos;;
import { WormholeDataRaw } from &apos;@/hooks/Mapper/types&apos;;

export const sortWHClasses = (wormholesData: Record&lt;string, WormholeDataRaw&gt;, statics: string[]) =&gt; {
  if (!statics || !wormholesData) {
    return [];
  }

  return statics
    .map(x =&gt; wormholesData[x])
    .filter(x =&gt; !!x)
    .map(x =&gt; ({ name: x.name, ...WORMHOLES_ADDITIONAL_INFO[x.dest] }))
    .sort((a, b) =&gt; a.wormholeClassID - b.wormholeClassID)
    .map(x =&gt; x.name);
};</file><file path="assets/js/hooks/Mapper/hooks/index.ts">export * from &apos;./usePageVisibility&apos;;
export * from &apos;./useClipboard&apos;;
export * from &apos;./useHotkey&apos;;
export * from &apos;./useSkipContextMenu&apos;;
export * from &apos;./useActualizeSettings&apos;;</file><file path="assets/js/hooks/Mapper/hooks/useActualizeSettings.ts">import { useEffect } from &apos;react&apos;;

type Settings = Record&lt;string, unknown&gt;;
export const useActualizeSettings = &lt;T extends Settings&gt;(defaultVals: T, vals: T, setVals: (newVals: T) =&gt; void) =&gt; {
  useEffect(() =&gt; {
    let foundNew = false;
    const newVals = Object.keys(defaultVals).reduce((acc, x) =&gt; {
      if (Object.keys(acc).includes(x)) {
        return acc;
      }

      foundNew = true;

      // @ts-ignore
      return { ...acc, [x]: defaultVals[x] };
    }, vals);

    if (foundNew) {
      setVals(newVals);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
};</file><file path="assets/js/hooks/Mapper/hooks/useClipboard.ts">import { useState, useEffect, useCallback } from &apos;react&apos;;

export const useClipboard = () =&gt; {
  const [clipboardContent, setClipboardContent] = useState&lt;{ text: string } | null&gt;(null);
  const [error, setError] = useState&lt;string | null&gt;(null);

  const getClipboardContent = useCallback(async () =&gt; {
    try {
      const text = await navigator.clipboard.readText();
      setClipboardContent({ text });
      setError(null);
    } catch (err) {
      setError(&apos;Failed to read clipboard content.&apos;);
    }
  }, []);

  useEffect(() =&gt; {
    const handlePaste = (event: ClipboardEvent) =&gt; {
      const text = event.clipboardData?.getData(&apos;text&apos;);
      if (text) {
        setClipboardContent({ text });
        setError(null);
      }
    };

    window.addEventListener(&apos;paste&apos;, handlePaste);

    return () =&gt; {
      window.removeEventListener(&apos;paste&apos;, handlePaste);
    };
  }, []);

  return { clipboardContent, error, getClipboardContent, setClipboardContent };
};</file><file path="assets/js/hooks/Mapper/hooks/useDoubleClick.ts">import { useCallback, useRef } from &apos;react&apos;;

export const useDoubleClick = (onDoubleClick: () =&gt; void, delay: number = 250) =&gt; {
  const ref = useRef({ clickCount: 0, firstClickTime: 0 });

  return useCallback(() =&gt; {
    ref.current.clickCount += 1;
    if (ref.current.clickCount === 1) {
      ref.current.firstClickTime = new Date().getTime();
      return;
    }

    const expired = ref.current.firstClickTime + delay;
    if (expired &lt; new Date().getTime()) {
      ref.current.firstClickTime = new Date().getTime();
      ref.current.clickCount = 1;
      return;
    }

    ref.current.clickCount = 0;
    onDoubleClick();
  }, [delay, onDoubleClick]);
};</file><file path="assets/js/hooks/Mapper/hooks/useHotkey.ts">import { useEffect } from &apos;react&apos;;

export const useHotkey = (isMetaKey: boolean, hotkeys: string[], callback: (e: KeyboardEvent) =&gt; void) =&gt; {
  useEffect(() =&gt; {
    const handleKeyDown = (event: KeyboardEvent) =&gt; {
      if ((!isMetaKey || event.ctrlKey || event.metaKey) &amp;&amp; hotkeys.includes(event.key)) {
        if (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) {
          return;
        }
        event.preventDefault();
        callback(event);
      }
    };

    // TODO not sure that capture still needs
    window.addEventListener(&apos;keydown&apos;, handleKeyDown, { capture: false });

    return () =&gt; {
      // TODO not sure that capture still needs
      window.removeEventListener(&apos;keydown&apos;, handleKeyDown, { capture: false });
    };
  }, [isMetaKey, hotkeys, callback]);
};</file><file path="assets/js/hooks/Mapper/hooks/useMaxWidth.ts">import { useState, useEffect, RefObject } from &apos;react&apos;;

const useMaxWidth = (ref: RefObject&lt;HTMLElement&gt;, maxWidth: number): boolean =&gt; {
  const [isExceeded, setIsExceeded] = useState(false);

  useEffect(() =&gt; {
    if (!ref.current) return;

    const observer = new ResizeObserver(entries =&gt; {
      for (const entry of entries) {
        if (entry.contentRect.width &lt;= maxWidth) {
          setIsExceeded(true);
        } else {
          setIsExceeded(false);
        }
      }
    });

    observer.observe(ref.current);

    return () =&gt; {
      if (ref.current) observer.unobserve(ref.current);
    };
  }, [ref, maxWidth]);

  return isExceeded;
};

export default useMaxWidth;</file><file path="assets/js/hooks/Mapper/hooks/usePageVisibility.ts">import { useState, useEffect } from &apos;react&apos;;

function usePageVisibility() {
  const [isVisible, setIsVisible] = useState(!document.hidden);

  useEffect(() =&gt; {
    const handleVisibilityChange = () =&gt; {
      setIsVisible(!document.hidden);
    };

    document.addEventListener(&apos;visibilitychange&apos;, handleVisibilityChange);

    return () =&gt; {
      document.removeEventListener(&apos;visibilitychange&apos;, handleVisibilityChange);
    };
  }, []);

  return isVisible;
}

export default usePageVisibility;</file><file path="assets/js/hooks/Mapper/hooks/useSkipContextMenu.ts">import { useEffect } from &apos;react&apos;;

export const useSkipContextMenu = () =&gt; {
  useEffect(() =&gt; {
    function handleContextMenu(e) {
      e.preventDefault();
    }

    window.addEventListener(`contextmenu`, handleContextMenu);

    return () =&gt; {
      window.removeEventListener(`contextmenu`, handleContextMenu);
    };
  }, []);
};</file><file path="assets/js/hooks/Mapper/hooks/useTheme.ts">import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { AvailableThemes } from &apos;@/hooks/Mapper/mapRootProvider/types.ts&apos;;

export const useTheme = (): AvailableThemes =&gt; {
  const { storedSettings } = useMapRootState();

  return storedSettings.interfaceSettings.theme;
};</file><file path="assets/js/hooks/Mapper/icons/index.ts">export * from &apos;./MapDeleteIcon&apos;;
export * from &apos;./MapAddIcon&apos;;
export * from &apos;./MapUserAddIcon&apos;;
export * from &apos;./MapUserDeleteIcon&apos;;

export const ANOIK_ICON =
  &apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAvdQTFRFHBMTIBoVJR8aIh4dIBwbLigjJSUeIhcTKR4aJBkVNjAqOjQuPzkzRT85PjIuOi4qMSYiMSEeLCEdNSUjNisnMyIbNyUeMR8ZKhQOKBQUJhUNKRgSLRwWKhoYLhkZJBAOHRgSISAaJyklLC8sJhsYMiwmT0hCQjYyRjImNB0ZNR8fHhQPLyMgU1NLPz44TUE9YFhRU0ZCST05PywlOykiLRcTLBwaGBQTKSQeXlxRT05GOjoyMC8oXE9NaF9WZldUMRsWHBELREQ9RTcuPTUqLiEZfWxpNi4kPzEpOSsjdm1jSjwzOyonU0U8STc0V0VCTTs5QjEuGhMNKiMZLygeMyYeVU5IYFFHcWFfNyAbKh4WfmlhY05HOSIdJR4VRz80Z1hOPCQgPiciIh0YZ2ZdbHJndnxzeGZXWUU+cmJZRDEqTzs0jqOSgo99jZmJkpiOcnBkbFdPdWBYgG5fQysmSUlBpKyVp7eorLGjxdPHnZiNhYR8iIJ1V09EcFtOj31tk351hXVxX0xJPScmSTYvVFNGeYt/ko+Fi3VtyL2xoIiARi8v2Ofh5vXsucS2Ukk/r56V0r+6Lzk0X2ZcbHxx+/77bWJSl4t5n4p1x7CrVlxSf3hte3JggXlnqJqDs52HiHZnvaegoYmHhG9nOSMjQSgfhouAm5WCqKKPu6WPrpeImod4ZktFXEI9Uzo6MRYTR01ET1VM397PuaWV39nE8/Hms6yZqpWNhmpkdFhSOR0aZFNEbVJMVDo1Ry8qzMe1/vDqtZ2WknZyk4B8el5YPiEfREE1ZnRpurKXwryn8NvV383Hlnt6TTQw7uG+kId1RikmNBkXinxltZiVyKmkGhAQlopz29CwOh0W7NDBQiUiPyEabGdVg21UTjktQCwhSzEoVTYuQyUdwZyXn3t3JBQSIREOSy0qJxgWUDIvUTEpTC0lVjc0MR4TWkFBRykhcFhcQh8bSCUiWDMyHg8ROyMaUy4oWDEmTCcdYjovd0M0NBcQLhMQdoqRdQAADR1JREFUeJw9V21AU+cVvkm95uYDyAe5N0BAqgQaE1G4NxhBMREUEBSD1XCFVBK0jaEfSpO1q9paQWXYFq1ip3a2irRdq6LdqpAKrUpa15YurKazYWslWwIlrpnOVlf8sfPe0J2QD36c533Ox3PeczGMx39gGj59+nQ+TyDg8eCDEPJxkUgsSQCTSBKTpFKZXKqQJUsVSpJSpahS09LUivSMGXHDHuBlPjhz1ky+YMqyhMkajUaUnQ3OgJHNWUJOYmJSYpJC/ZBSq1KlpqalzM7ISIkDTMucPmvmA3CwDkwgFPL1Gr1kzpxcsQbH9VIpQktOnps9Ly8/L4+m1GqKSVGpVAZVwWwZRwKb/+DM6Yi4DiOQvxEXJywoLEIkNAtx+BQnJUul0qT8/EXFi+cmydQGE61WqVIyVBkZCgPHYOY0XiY63Qz8CVy0JLfIiIMnspLSpJyExCTZUn1yfsLcecsW5zMMlWZQkoBgUBlMCuCAzZzGuQN9nRA3iorAGZfiUo2oTCQSleYkJJSUV1RUkImJ+fOWL65cTFdRaooiDSkqg0GVMVuFcoDFw9fxNbgIN2pw49Kl0rKy0rKypGRRYqIkMVkhrShfUbJy0bLl1assVVVVapWSMaA8qAwyFZZZg9XUQPQCSJrGON3IJ1Y/vEYqLROXirkarM1LSEyWkeWVK6y1yxbnWZgqmskwsXEEg0GGzQcACJ8vIuQijZEnWCfXy/XJotJ4ARMk+fmJiTl5+TmWEmtdbb01DyiQpE3LsnGEDDh+PucvNC40CoHJIwRhFEnWJ2QXZq+dB8fPzYb6k8n5c/OsDQ0N9Xl5K2k7TbMGh1KF0mDA5s8383iNoka+kafLWgeVkONisTh77doFGzY+umHB2uy1OVDI5KSc6obHGpzWTdWLVrqaaJvJpGVRCAZgwGtsnCXk83mQSIFASIA/0F+w8fHHn3jyqc0b5hUDharkxJz8LY81O5vqn26w1jvddtZkIE0GgwkAMvmNIj7/QR6qhIBPiEQJniVLCjc+8eSvnnn2188+t3Vb8faScgVdMtf69PPOJmf9Czte3OlqYbUmU6vBpJ2N1fB4OGhJoDPrdEK9USxeUlRUOGfXgs2PPvnE7mcAYc/m7etLKitLKje9sAUAtrT9pr121V47y5rsbq1Ji2Xy+Jrps7hWEOK4WJO7JDfXM2cXIDzx+O7HX3r5pVf2FHckQBEbNr2wyep0btm3f1/zzlWOFttslmZNJgCYNetVngDo86S4BF+4pEhS5JkDFA5s3H1w9zMvd3a+snXzhgar9dBrv316k7V62f7DbXX11a6WlhYb64AcZPJffZUvQI2s0YhxUVGZSOIpLASEOYULDhw5+Epn58tPHd28bdvrvzv2xpvPN9TuO36ia3G9s2nv3paT2m6tCePNfPVBFIDACMorKtI8rBF7NhwpnFNY6PEU7jrw1kudnc88tXXbtrff+f277z3dfOL4iRdrT5121p9xOE6ypod6AGBaJhoGSAkLi/DVoOezBw6cm3PEs359R8eCo+9DDM9tfWvr0X1/eOPdtrbj7ctqt9Q7653VDruN1TrsGA+JOVMnEMk1+EL5aqNekwsABw+eLRVVdnRYl/+x84Pzby8vXr5n2/l9F9oPX+hdtnPxlr7Tp880nXTbWO9DIKZMMwDgcgLH+XKjHi/KPXtk9+5zRZqyyg8PLd/zQef74G+1Hn2v68K+/Yd3NG+p6+292A/mtjtY0wA0EswSHYHzCRCiERqhyHPk4MEjZ8Vlou2vvXP+o87Oj7YdLbYWd22q69r/8aXLzXVX6gZP9fc7nQM+aAYbNh/8zTqjns8nHlm3erWmqPSTA59+euRsriSh+J2r589/8P6f9ry1efmLzc1d+z77/PiVL9q6ui6eOtXv7B9yuH2sFrRsNmMCI4EAQImih0uXnN115JzHs37BhmNfHnvt/HNXr/756NEX67ra97df+fzS5bq+tkFE4XT/gN/HDmPzAcDMbxRyCFlLH8YlklyP59w5z4GOjr98eWh58dGrV99suHLlSvtXdctO7L/W2zfYPth38dTp0/1un8/LAQRq+LxGADCuzjIacZiGkAfPuV1rt3/9V+v2ju3Hrlprr7R/caF58PKJry5c7u3r6uUoDCAALwDMrxHweSDnRqOckBulOC6Vij7xSBI8679+vbKkvOPrD1tr23Zcbu4a7L107VJ772Bf78VT/QMD7iEAuI7V6DCzUAgAMFKMhB6HgUboy3IlYklpeUklTOQVK+idg/W9F/ugi745fOlEL/Rhf//QQHe3Pegb8UISAzVCmCN8uA34cB9I9QCwRiSRfCJOpko3vv637eUuS+vFU311xz//+Jvjbc1Ol8s1APzdbocjGPRikMJMobCRMKKbDK4jqVROwA9Nwq7k9HWeQ3//lqZbSVd971fffPzZpbYGZ5PrO/o799DQjaHRAXcwBAA6TIcA5MAeEijVAwXgok8Sy1bKZRUV5ZTa0upsv3btH//cUVfvbG110WADQ2D97m7fdQAwwywQZhFGOfKEXua+5PL0dKVUGo6o1JTFebp3R2/vYN0W50rgTzN2u2PA4XePjQVHfBgaZWiYAgSw0MvhbYRyCMfHU1ILZOHIjDQqx+Wqb+471d/U1Opy07QSLgX7gHvs+4kbUQ7AHAcQEoAgJ0BQRgL+SwvPSCXpqnSifP1c1uWsv3h6AA4Hf4YFBQwNjY3enJhAIQCAmVsMhFnAAVkWkSUQhOHsGf9iXJaS7dlK26qdP/T9MATxu1qbXIzN4XAP+Me+Hxvz+/y/AHAkCDm4CxGYIBIOz5iRqk5TK9k0yrJo584f9lpo2uF2N9HAgAUd+ccQwAiGNgMAwBACDzzRd5YgHImEU8Ip6PYymJi82trFQ4yFYewM08SykAO3wxeLfj8RDEEOOApoKnOp4PyFYbDx9II0tMyYmOpltf/+YS9zkmEcZKsLEWDdvmAsOhENhoIcA0wXX5Hi9YDzw2FBOKVA0QLXj9Z+03/r9n9ukqyWsTvcTQ5Wa2dtCCA2EQuFRqATYSIATIALRRcWjI+PQwIEwEJWNdvWksEGvbf7z1SpTSRtZywuG9TQ7nb7QsAgFgsGMXNNIBAAV0AKQDARRAJKEBEQUgVsI5Yze1c5q6tpWM9oBw19YLPZ3A5IgS8OEIoDAAIWiCOEIRcRznTSxHzY7RblLapeKYP1jnS39g+5HTbIoNvrC/nG/DF/dGQKIMD5B8wRWDY477AOPsalOflglRZKrWQoytVKu212LajQDgSC/qDf3/0Lg4B5KoQ7YQzORjEgE/IJvaKiCtYydTrFgIhIGMQOh83G+kKghWg0FkXzIGDmKIBxeTRHfvGPQHtLNVVrYEVOSyOrGJJkUAptdtYbgvz5o/5QDJYsM8eeoxEIQAoRee4DEmnUlCZWKNVpaVSBUlHB0CRrs9vtrP16zOcLTowhBoEa7BdvwNFxHSEAXcoJSEYYVtekCopSMgpSRpHljJZFMWhNIZ8PejkajU5g6FgzYNyJFwM1I9IWSAI0MT6eRshkVIXFUgV1cJWvUTrgeKXBFvL6gmOxMf9oDJuiHn9jOh4CQFdFBGkqLTU1XSaDNCoyUrQ0Q66BZnbYTdofvd5gzH87GB2NTvHnmgAyyckynoBxmPFEOqGXyWTKAoNaaSdJimRIB9yodhsiELx9czSKGExlMICZuRCmJBXmRpRcDv4URWmRgpRKJQnzxGRDBMaCt25HJ/xB7P/541IQ4dxB1aAmIRpxUoVCiSwOQNI0xUIXsMExf/TWrYmbY3401uONi9oHhJSVnp4FL2pdwVJqjRQqRzOo/gwaBrSLtv/Y3T0yErsRDY3c/umn6Ohd0GEknAovMPQ0pS4AwkuhcCTyoqfsIbDvbnz7bXd3LHrjRiw6Onrv3r27d+/+9+efOQY6Xbzx0BQBUxPr4KFCpgCMNdzhAIGGIW1n4fwfQ7EbN0IjI7fv3RsdvXs3ngPQAAIyIwwUBwqjADpAn6SAJFQlWSw5FlJJoUR4WTQNrl+/HroVisZit+ONdOcO98e1r4CDkKUXFBRACyikVRVJSVUkFEKrZdHbDoUcnpwECJ8f+hHj8h+JwNedAGBgUwAolHQOQaZUUug5iVLCgq2FYWY3DQ8PX5/0+vxwMfmn5sAdMGhnTsmC8LgwjsCRkBXANFKrTRS4o2lmG+7p6ZnkOgEEhRhwhTRHUCxA4I5AMJ4+XpAepzAFAP4mtYklgT9rmJzsGe4Z9vrBnwsBKETgaMgB/NKZ9brweBg5j08BAH+TSZYB8xnFr+0xDN/vmezxBuP+cQYRVAUIIQxiMAsisnHkGg+hIINC/NWz4UkNlKjtuQ82eX8S+XrR3xQA8kfnc5OdO5t7F6RTahllUmtNSrYFPeYYOPf7k9dHfD47rFhTAKgEd5AedVgY/OMAiAOCyFBrWWq28iTUwGDoMdz3qu5PhqCMXpsbNhzf/wDqH9yTspBlMwAAAABJRU5ErkJggg==&apos;;

export const DOTLAN_ICON =
  &apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAACF9JREFUeJztWWlwHMUVdggBy7Y4TaiIcMQVQkXyzFoIa3etmdFyBMJhqHAUEEIwVQnmKAixK4TgHzjYXMWRgpxgwEDK4B3tihQYYUe295Bw5XBMdMyxWu/OyoqFuBLbGBuMbPG9Xc2qp3d2tZbXOD/cVa9md6b7ve+9fv369etJkw63w+3/o42MXPPVgQF/ldbfVKelmiQto9zQm5EWaJY8T08ritYv19J36neosebbxsGGKT1pWdQs5V4AXQ3aBtoDGgbtA42M0nDuvTSkW/IaPO8y+qUG02yqPiTAI5HAkVpavhoUYkDuL+3F+FW6pVxLhvjSwPda8kU5K04YeAGBX0TPKJccVOBZ/7aUpyBwewGIjPw5nv2w5vOa1Xwz+Xx3ShFs0q0mHwDeoWeal+GZHO3PK7IDM/IEyak4eMMKnAGh7S5CP4RSr5sZ5bxk8uKjy+G1cWPD14y0ciGUbcX4/7rNRlcy8M3KgYcFwfhfLuDfTKQCUrFxa7rEqRtgzQ0lLEqKkwEKlMgo/9TTc04/YPAIh6eBYTcn4F0InU+WZPtGEg3TY7r447ghPBHThWDMEGP4HcFzPSgUM8XfR03h5nV6vQMYhVU9Lf8EM/wBK6c3LW/s7pdmTBg8RQayMgd+q8ZZvdOsr4kZwp8AMgX6DDRSgj4HDcQN8ZVY38zvOoyVbpbBfzMnb/Xg4Nz9j1AjI5O+oqWVpbzlaXHmFcQMRE3xNgAaGgd0Mfo4aoj3gU8eIPYHL6Jc2ilXeni/FaCokY0KY4y2G5YUYMBPiRmeZ4qC00Uds7IGzzb8Xw3qAu1x6wslXm1LfvsYm7eRafZzi/uzwR0XFF1rLtYPHEmRgGGwT89ItzvBiytcwOyImZ5HIqb4/Y4+YUbEOmMyzRLAHd2h1Z4W18Tz6Tv6bSsYa4orI+/MOm7MgPLd7Cz0bW1uV7Xao8pSwMgoVzqnUGkjl7K/w6pLXcD/La6LZ5fDP6Z56gH4TZ4Hxv/BlkOK0y7NLOg91tC5V5TD/yhEgw5WATMVOMf+GDfFqyHsU6e7CEHWj8tpFCCwfpa5GOImu08PXJbch1kLf8Xr0nKqq6unYxG9SlbHoLcw6H5tdOre7hK/Dr/+h1OgsIriPcuD8qRQ0HtVSPXeG2rx/6416PtlWPXeGA43fIPtR+OiuvBnTgGLwrHdhxZwDofSBrd6saqq6tTxjHNEdvoAmt9ZAfYWTlgP+TbP4I03GqaEVF93WPWNcLQJ729j+7anGo4Fn00OVzLFX9jfaY8gHAyeI8ZTwLV1mmdVk7Wdgjy3uvUlP25VfUtdFCDaGw76HnUYRhcu4Rb0Fq3cBVtui2v1tWD8Pyb0mWt7Zp5sA1682GmZ8EqvD2CHiyixD+71M7svpRqca+6KaqJcUQU6DM9lDusb4rP2N1X1VwHUb+H3P7LfrVohHY9364soQJRofanxRLt/1PAsYPjvwx6zsKIKYJrvYATsjSeEn44p4K1lgIVeU70N9D7c4l1YQoE9oaD/+jz/PkHh1sHLFVUAFn+QEfBJPOFptL+Fgr6bOHAfws+XhNXGS/F7oKgSQd9im0dHos4DN9rOyFhdMfAqIgGmeDmbw8RSgpBXQPUtKuYmYdU/WEwBWuhOBcSPGBd9q2IKUEMa/AA7Ax19otf+BjDzSrhKUaJ9wuYB6wucAu2VVcDw3MkoMMzumKra+K0SEacY7YLrzbV5RBIeiU3F2SBRGQX0md9zbmKeZ+xvFEJbW3zB/VTg721tYxsl+M1noxDyorsrqkCnKZ4Fxu8zQrrZo2J45ZzZALWtTPDDrSu9+cSMslXwizr2gcSs2RVVgHbG7CmKFWKI17N9Wlv8lwHce+OA/zjc4ruHHVc4u2JXRcHbLaZ7rgXz3YygTesSnlPYPq+p/kZEnhaK8y7g1XDQey5vGPDp5BLE+RMGWVNTMwV5eBQpdTJLlrReG/CfQN8oyYOAdZy1nkIq4UgjaGcOrfCemZsR/w+xPq4Mr5g9Y/nywOQCoxjiYxw/Y4NWd0JewbT0nI0F2WjXtGnT6sZVoictP82dhfNJ23pDaIaQnaxQRKgnS5VO3Bql3JR1cjO6O5oQLs7jyJ0HxopoOODg9dQSbHMtNaCcyVXfUj2blXweHjWEBZzViELlLrxszDfF5wp5CA/bs9k1dOFUyP0Ley7W09KNZVsIU/YYVy17hS2LQ4mnXQAMUnilxM/OVO2WzTgpbdbFPyIYZPixtNOzB3uqXju8IC2vJaXKViAx4D8FA//NHuxxUvu5/Z3SCwBaEuOPlzkiF9uKWL7ZJvzv513P3hRxKnueQqnNu8B1LHknTorlVyXspmekH3BFWCqH38n2iRp1c2lPcAFWDhkRQ5jH8jMsuRly3jvgupDdejPSEm5BD1PJg61SxJP1J0Wwc8Kv12YTvdKgaRbWwY1+xbuZllYuB/9BznVWHVC1ms6hAPwkp8ReOmDzFWQ632Jt+JH4XQOQ99sUN4RfQ7lFMVO4IWbMnMPWf6hZVmDyqKF28mXFRCIwfdKBNlq8VLd3qU5bFGI1LTBtInzJsnRZolnKOwW8M3K78Z/zTxyfS5kte6VkyQ+BPi0UJvVoGWUhqD6ZlE8qxSeVuuBYuuyjayWMjboYhXw+OB6fCTe4znVZwO5XRbsxU529GXkZ+t1D5Uj8vopK5/Qfu+rjVJzSspciruM/wphFB/0Wk25rYMFHIHBXESD81VPpPjl6gW4tDyrwAkVS0ndGS/CWswRYBmUVk4ZotjRrzixy0S8VPNtGt/0rsCB/k61q51xsC+j9LOVuXig8mvj+Nlmb0oKKLtJKNspes/dqqSapt19uomdPqukcc0tTzaHGdrgdjPYF7O5Y/gYUmgUAAAAASUVORK5CYII=&apos;;

export const ZKB_ICON =
  &apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAApElEQVR4XuWNTQqFIBSF+zEIElxCQ/chtA230Dp0H00TnOjAmZBFIS2pC8J7IT14wwfvm91zz8cpij8FIeS93/d9Xddt20IIx3Gc5xljhBNCeEGhLMvc/Jb7ArAsy2shJQ8Lfd/P8/xJ0FpTSt/tBMZYSgnaXZimSQhBCMnbibquOefGmCQopcZxbJom72Uwxpxz1tphGKqqyt+PtG3bdV2e/ioXDldzWtMp7McAAAAASUVORK5CYII=&apos;;</file><file path="assets/js/hooks/Mapper/icons/MapAddIcon.tsx">import { SvgIconProps, SvgIconWrapper } from &apos;@/hooks/Mapper/components/ui-kit/SvgIconWrapper.tsx&apos;;

export const MapAddIcon = (props: SvgIconProps) =&gt; (
  &lt;SvgIconWrapper width={800} height={800} viewBox=&quot;0 0 800 800&quot; {...props}&gt;
    &lt;path
      d=&quot;M416.667 234.716C411.247 233.807 405.68 233.333 400 233.333C344.77 233.333 300 278.105 300 333.333C300 388.563 344.77 433.333 400 433.333C455.23 433.333 500 388.563 500 333.333C500 327.655 499.527 322.087 498.617 316.667&quot;
      stroke=&quot;currentColor&quot;
      strokeWidth=&quot;50&quot;
      strokeLinecap=&quot;round&quot;
    /&gt;
    &lt;path
      d=&quot;M166.667 507.203C145.085 452.073 133.333 393.377 133.333 338.11C133.333 188.196 252.724 66.6667 400 66.6667C547.277 66.6667 666.667 188.196 666.667 338.11C666.667 486.85 581.557 660.413 448.763 722.48C417.81 736.95 382.19 736.95 351.237 722.48C308.825 702.657 271.277 671.463 239.813 633.333&quot;
      stroke=&quot;currentColor&quot;
      strokeWidth=&quot;50&quot;
      strokeLinecap=&quot;round&quot;
    /&gt;
  &lt;/SvgIconWrapper&gt;
);</file><file path="assets/js/hooks/Mapper/icons/MapDeleteIcon.tsx">import { SvgIconProps, SvgIconWrapper } from &apos;@/hooks/Mapper/components/ui-kit/SvgIconWrapper.tsx&apos;;

export const MapDeleteIcon = (props: SvgIconProps) =&gt; (
  &lt;SvgIconWrapper width={800} height={800} viewBox=&quot;0 0 800 800&quot; {...props}&gt;
    &lt;path
      d=&quot;M416.667 234.716C411.247 233.807 405.68 233.333 400 233.333C344.77 233.333 300 278.105 300 333.333C300 388.563 344.77 433.333 400 433.333C455.23 433.333 500 388.563 500 333.333C500 327.655 499.527 322.087 498.617 316.667&quot;
      stroke=&quot;currentColor&quot;
      strokeWidth=&quot;50&quot;
      strokeLinecap=&quot;round&quot;
    /&gt;
    &lt;path
      d=&quot;M166.667 507.203C145.085 452.073 133.333 393.377 133.333 338.11C133.333 188.196 252.724 66.6666 400 66.6666C547.277 66.6666 666.667 188.196 666.667 338.11C666.667 486.85 581.557 660.413 448.763 722.48C417.81 736.95 382.19 736.95 351.237 722.48C308.825 702.657 271.277 671.463 239.813 633.333&quot;
      stroke=&quot;currentColor&quot;
      strokeWidth=&quot;50&quot;
      strokeLinecap=&quot;round&quot;
    /&gt;
    &lt;path d=&quot;M747.901 90L105 732.9&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;63&quot; strokeLinecap=&quot;round&quot; /&gt;
  &lt;/SvgIconWrapper&gt;
);</file><file path="assets/js/hooks/Mapper/icons/MapUserAddIcon.tsx">import { SvgIconProps, SvgIconWrapper } from &apos;@/hooks/Mapper/components/ui-kit/SvgIconWrapper.tsx&apos;;

export const MapUserAddIcon = (props: SvgIconProps) =&gt; (
  &lt;SvgIconWrapper width={800} height={800} viewBox=&quot;0 0 800 800&quot; {...props}&gt;
    &lt;path
      d=&quot;M259.095 617.422C288.199 652.691 322.293 680.967 360.022 698.982L361.822 699.832L361.823 699.833L362.963 700.355C371.571 704.236 380.618 706.7 389.783 707.749L392.258 758.116C374.601 757.137 357.082 752.809 340.65 745.128V745.129C294.272 723.452 253.892 689.676 220.529 649.245L239.812 633.334L259.095 617.422ZM223.9 614.051C234.55 605.263 250.307 606.773 259.095 617.422L220.529 649.245C211.742 638.596 213.251 622.839 223.9 614.051ZM400 41.667C515.7 41.6671 615.317 110.002 662.514 208.804C653.511 207.614 644.327 207 635 207C625.128 207 615.417 207.686 605.911 209.017C563.301 138.509 486.858 91.6671 400 91.667C266.948 91.6672 158.333 201.583 158.333 338.11C158.333 389.156 169.046 443.842 188.989 495.627L189.946 498.09L190.174 498.694C194.779 511.398 188.435 525.529 175.779 530.483C163.123 535.437 148.873 529.369 143.63 516.915L143.387 516.317L142.334 513.607C120.393 456.639 108.333 395.871 108.333 338.11C108.333 174.81 238.5 41.6672 400 41.667ZM400 208.334C406.63 208.334 413.153 208.852 419.529 209.854L420.803 210.061L421.438 210.176C434.704 212.748 443.57 225.448 441.321 238.853C439.072 252.257 426.546 261.369 413.167 259.471L412.529 259.372L411.768 259.248C407.948 258.648 404.02 258.334 400 258.334C358.578 258.334 325 291.913 325 333.334C325 374.756 358.577 408.334 400 408.334C409.643 408.334 418.861 406.513 427.329 403.198C427.111 407.104 427 411.039 427 415C427 428.513 428.289 441.725 430.75 454.521C420.913 457.009 410.611 458.334 400 458.334C330.963 458.334 275 402.371 275 333.334C275 264.299 330.963 208.334 400 208.334Z&quot;
      fill=&quot;currentColor&quot;
    /&gt;
    &lt;path
      d=&quot;M661.071 406.777C661.071 381.914 640.868 361.666 615.833 361.666C590.798 361.666 570.595 381.914 570.595 406.777C570.595 431.641 590.798 451.889 615.833 451.889C640.868 451.889 661.071 431.641 661.071 406.777ZM727.737 406.777C727.737 457.286 694.219 499.913 648.248 513.79C727.063 528.912 786.666 598.136 786.666 681.333C786.666 699.742 771.742 714.666 753.333 714.666C734.924 714.666 720 699.742 720 681.333C720 623.977 673.414 577.389 615.833 577.389C558.253 577.389 511.666 623.977 511.666 681.333C511.666 699.742 496.742 714.666 478.333 714.666C459.924 714.666 445 699.742 445 681.333C445 598.136 504.603 528.912 583.417 513.79C537.446 499.913 503.929 457.286 503.929 406.777C503.929 344.993 554.081 295 615.833 295C677.584 295 727.737 344.993 727.737 406.777Z&quot;
      fill=&quot;currentColor&quot;
    /&gt;
  &lt;/SvgIconWrapper&gt;
);</file><file path="assets/js/hooks/Mapper/icons/MapUserDeleteIcon.tsx">import { SvgIconProps, SvgIconWrapper } from &apos;@/hooks/Mapper/components/ui-kit/SvgIconWrapper.tsx&apos;;

export const MapUserDeleteIcon = (props: SvgIconProps) =&gt; (
  &lt;SvgIconWrapper width={800} height={800} viewBox=&quot;0 0 800 800&quot; {...props}&gt;
    &lt;path
      d=&quot;M259.095 617.422C288.199 652.691 322.293 680.967 360.022 698.982L361.822 699.832L361.823 699.833L362.963 700.355C371.571 704.236 380.618 706.7 389.783 707.749L392.258 758.116C374.601 757.137 357.082 752.809 340.65 745.128V745.129C294.272 723.452 253.892 689.676 220.529 649.245L239.812 633.334L259.095 617.422ZM223.9 614.051C234.55 605.263 250.307 606.773 259.095 617.422L220.529 649.245C211.742 638.596 213.251 622.839 223.9 614.051ZM400 41.667C515.7 41.6671 615.317 110.002 662.514 208.804C653.511 207.614 644.327 207 635 207C625.128 207 615.417 207.686 605.911 209.017C563.301 138.509 486.858 91.6671 400 91.667C266.948 91.6672 158.333 201.583 158.333 338.11C158.333 389.156 169.046 443.842 188.989 495.627L189.946 498.09L190.174 498.694C194.779 511.398 188.435 525.529 175.779 530.483C163.123 535.437 148.873 529.369 143.63 516.915L143.387 516.317L142.334 513.607C120.393 456.639 108.333 395.871 108.333 338.11C108.333 174.81 238.5 41.6672 400 41.667ZM400 208.334C406.63 208.334 413.153 208.852 419.529 209.854L420.803 210.061L421.438 210.176C434.704 212.748 443.57 225.448 441.321 238.853C439.072 252.257 426.546 261.369 413.167 259.471L412.529 259.372L411.768 259.248C407.948 258.648 404.02 258.334 400 258.334C358.578 258.334 325 291.913 325 333.334C325 374.756 358.577 408.334 400 408.334C409.643 408.334 418.861 406.513 427.329 403.198C427.111 407.104 427 411.039 427 415C427 428.513 428.289 441.725 430.75 454.521C420.913 457.009 410.611 458.334 400 458.334C330.963 458.334 275 402.371 275 333.334C275 264.299 330.963 208.334 400 208.334Z&quot;
      fill=&quot;currentColor&quot;
    /&gt;
    &lt;path
      d=&quot;M661.071 406.777C661.071 381.914 640.868 361.666 615.833 361.666C590.798 361.666 570.595 381.914 570.595 406.777C570.595 431.641 590.798 451.889 615.833 451.889C640.868 451.889 661.071 431.641 661.071 406.777ZM727.737 406.777C727.737 457.286 694.219 499.913 648.248 513.79C727.063 528.912 786.666 598.136 786.666 681.333C786.666 699.742 771.742 714.666 753.333 714.666C734.924 714.666 720 699.742 720 681.333C720 623.977 673.414 577.389 615.833 577.389C558.253 577.389 511.666 623.977 511.666 681.333C511.666 699.742 496.742 714.666 478.333 714.666C459.924 714.666 445 699.742 445 681.333C445 598.136 504.603 528.912 583.417 513.79C537.446 499.913 503.929 457.286 503.929 406.777C503.929 344.993 554.081 295 615.833 295C677.584 295 727.737 344.993 727.737 406.777Z&quot;
      fill=&quot;currentColor&quot;
    /&gt;
    &lt;path d=&quot;M750.901 72L108 714.9&quot; stroke=&quot;currentColor&quot; strokeWidth=&quot;63&quot; strokeLinecap=&quot;round&quot; /&gt;
  &lt;/SvgIconWrapper&gt;
);</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/index.ts">export * from &apos;./useMapInit&apos;;
export * from &apos;./useMapUpdated&apos;;
export * from &apos;./useMapCheckPermissions&apos;;
export * from &apos;./useMapGetOption&apos;;
export * from &apos;./useRoutes&apos;;
export * from &apos;./useCommandsConnections&apos;;
export * from &apos;./useCommandsSystems&apos;;
export * from &apos;./useCommandsCharacters&apos;;
export * from &apos;./useCommandComments&apos;;
export * from &apos;./useGetCacheCharacter&apos;;
export * from &apos;./useCommandsActivity&apos;;</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useCommandComments.ts">import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { CommandCommentAdd, CommandCommentRemoved } from &apos;@/hooks/Mapper/types&apos;;
import { useCallback, useRef } from &apos;react&apos;;

export const useCommandComments = () =&gt; {
  const { comments } = useMapRootState();
  const ref = useRef(comments);
  ref.current = comments;

  const addComment = useCallback((data: CommandCommentAdd) =&gt; {
    ref.current.addComment(data.solarSystemId, data.comment);
  }, []);

  const removeComment = useCallback((data: CommandCommentRemoved) =&gt; {
    ref.current.removeComment(data.solarSystemId.toString(), data.commentId);
  }, []);

  return { addComment, removeComment };
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useCommandsActivity.ts">import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import {
  CommandCharacterActivityData,
  CommandTrackingCharactersData,
  CommandUserSettingsUpdated,
  Commands,
} from &apos;@/hooks/Mapper/types/mapHandlers&apos;;
import { MapRootData } from &apos;@/hooks/Mapper/mapRootProvider/MapRootProvider&apos;;
import { emitMapEvent } from &apos;@/hooks/Mapper/events&apos;;

export const useCommandsActivity = () =&gt; {
  const { update } = useMapRootState();

  const ref = useRef({ update });
  ref.current = { update };

  const characterActivityData = useCallback((data: CommandCharacterActivityData) =&gt; {
    try {
      ref.current.update((state: MapRootData) =&gt; ({
        ...state,
        characterActivityData: {
          activity: data.activity,
          loading: data.loading,
        },
        showCharacterActivity: true,
      }));
    } catch (error) {
      console.error(&apos;Failed to process character activity data:&apos;, error);
    }
  }, []);

  const trackingCharactersData = useCallback((data: CommandTrackingCharactersData) =&gt; {
    ref.current.update((state: MapRootData) =&gt; ({
      ...state,
      trackingCharactersData: data.characters,
      showTrackAndFollow: true,
    }));
  }, []);

  const hideActivity = useCallback(() =&gt; {
    ref.current.update((state: MapRootData) =&gt; ({
      ...state,
      showCharacterActivity: false,
    }));
  }, []);

  const userSettingsUpdated = useCallback((data: CommandUserSettingsUpdated) =&gt; {
    emitMapEvent({ name: Commands.userSettingsUpdated, data });
  }, []);

  return { characterActivityData, trackingCharactersData, userSettingsUpdated, hideActivity };
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useCommandsCharacters.ts">import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import {
  CommandCharacterAdded,
  CommandCharacterRemoved,
  CommandCharactersUpdated,
  CommandCharacterUpdated,
  CommandPresentCharacters,
} from &apos;@/hooks/Mapper/types&apos;;

export const useCommandsCharacters = () =&gt; {
  const { update } = useMapRootState();

  const ref = useRef({ update });
  ref.current = { update };

  const charactersUpdated = useCallback((characters: CommandCharactersUpdated) =&gt; {
    ref.current.update(() =&gt; ({ characters: characters.slice() }));
  }, []);

  const characterAdded = useCallback((value: CommandCharacterAdded) =&gt; {
    ref.current.update(state =&gt; {
      return { characters: [...state.characters.filter(x =&gt; x.eve_id !== value.eve_id), value] };
    });
  }, []);

  const characterRemoved = useCallback((value: CommandCharacterRemoved) =&gt; {
    ref.current.update(state =&gt; {
      return { characters: [...state.characters.filter(x =&gt; x.eve_id !== value.eve_id)] };
    });
  }, []);

  const characterUpdated = useCallback((value: CommandCharacterUpdated) =&gt; {
    ref.current.update(state =&gt; {
      return { characters: [...state.characters.filter(x =&gt; x.eve_id !== value.eve_id), value] };
    });
  }, []);

  const presentCharacters = useCallback((value: CommandPresentCharacters) =&gt; {
    ref.current.update(() =&gt; ({ presentCharacters: value }));
  }, []);

  return { charactersUpdated, characterAdded, characterRemoved, characterUpdated, presentCharacters };
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useCommandsConnections.ts">import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { CommandAddConnections, CommandRemoveConnections, CommandUpdateConnection } from &apos;@/hooks/Mapper/types&apos;;

export const useCommandsConnections = () =&gt; {
  const {
    update,
    data: { connections },
  } = useMapRootState();

  const ref = useRef({ update, connections });
  ref.current = { update, connections };

  const addConnections = useCallback((toAdd: CommandAddConnections) =&gt; {
    const { update, connections } = ref.current;
    update({
      connections: [...connections, ...toAdd],
    });
  }, []);

  const removeConnections = useCallback((toRemove: CommandRemoveConnections) =&gt; {
    const { update, connections } = ref.current;
    update({
      connections: connections.filter(x =&gt; !toRemove.includes(x.id)),
    });
  }, []);

  const updateConnection = useCallback((newConn: CommandUpdateConnection) =&gt; {
    const { update, connections } = ref.current;

    update({
      connections: [...connections.filter(x =&gt; x.id !== newConn.id), newConn],
    });
  }, []);

  return { addConnections, removeConnections, updateConnection };
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useCommandsSystems.ts">import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import {
  CommandAddSystems,
  CommandRemoveSystems,
  CommandUpdateSystems,
  CommandLinkSignatureToSystem,
} from &apos;@/hooks/Mapper/types&apos;;
import { useLoadSystemStatic } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic.ts&apos;;
import { OutCommand } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { emitMapEvent } from &apos;@/hooks/Mapper/events&apos;;
import { Commands } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { DetailedKill } from &apos;@/hooks/Mapper/types/kills&apos;;
export const useCommandsSystems = () =&gt; {
  const {
    update,
    data: { systems, systemSignatures, detailedKills },
    outCommand,
  } = useMapRootState();

  const { addSystemStatic } = useLoadSystemStatic({ systems: [] });

  const ref = useRef({ systems, systemSignatures, update, addSystemStatic, detailedKills });
  ref.current = { systems, systemSignatures, update, addSystemStatic, detailedKills };

  const addSystems = useCallback((systemsToAdd: CommandAddSystems) =&gt; {
    const { update, addSystemStatic, systems } = ref.current;

    systemsToAdd.forEach(sys =&gt; {
      if (sys.system_static_info) {
        addSystemStatic(sys.system_static_info);
      }
    });

    update(
      {
        systems: [...systems.filter(sys =&gt; !systemsToAdd.some(x =&gt; sys.id === x.id)), ...systemsToAdd],
      },
      true,
    );
  }, []);

  const removeSystems = useCallback((toRemove: CommandRemoveSystems) =&gt; {
    const { update, systems } = ref.current;
    update(
      {
        systems: systems.filter(x =&gt; !toRemove.includes(parseInt(x.id))),
      },
      true,
    );
  }, []);

  const updateSystems = useCallback((updatedSystems: CommandUpdateSystems) =&gt; {
    const { update, systems } = ref.current;

    const out = systems.map(current =&gt; {
      const newSystem = updatedSystems.find(x =&gt; current.id === x.id);
      if (!newSystem) {
        return current;
      }

      return newSystem;
    });

    update({ systems: out }, true);

    emitMapEvent({ name: Commands.updateSystems, data: out });
  }, []);

  const updateSystemSignatures = useCallback(
    async (systemId: string) =&gt; {
      const { update, systemSignatures } = ref.current;
      const { signatures } = await outCommand({
        type: OutCommand.getSignatures,
        data: { system_id: `${systemId}` },
      });
      const out = { ...systemSignatures, [`${systemId}`]: signatures };
      update({ systemSignatures: out }, true);
    },
    [outCommand],
  );

  const updateLinkSignatureToSystem = useCallback(async (command: CommandLinkSignatureToSystem) =&gt; {
    const { update } = ref.current;
    update({ linkSignatureToSystem: command }, true);
  }, []);

  const updateDetailedKills = useCallback((newKillsMap: Record&lt;string, DetailedKill[]&gt;) =&gt; {
    const { update, detailedKills } = ref.current;

    const updated = { ...detailedKills };
    for (const [systemId, killsArr] of Object.entries(newKillsMap)) {
      updated[systemId] = killsArr;
    }

    update({ detailedKills: updated }, true);
  }, []);

  return {
    addSystems,
    removeSystems,
    updateSystems,
    updateSystemSignatures,
    updateLinkSignatureToSystem,
    updateDetailedKills,
  };
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useGetCacheCharacter.ts">import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useEffect, useMemo, useRef } from &apos;react&apos;;

export const useGetCacheCharacter = (characterEveId: string | undefined) =&gt; {
  const {
    charactersCache: { characters, loadCharacter, lastUpdateKey },
  } = useMapRootState();

  const ref = useRef({ loadCharacter });
  ref.current = { loadCharacter };

  useEffect(() =&gt; {
    if (!characterEveId) {
      return;
    }

    ref.current.loadCharacter(characterEveId);
  }, [characterEveId]);

  return useMemo(() =&gt; {
    if (!characterEveId) {
      return;
    }

    return characters.get(characterEveId);
  }, [characters, lastUpdateKey]);
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useMapCheckPermissions.ts">import { useMemo } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { UserPermission } from &apos;@/hooks/Mapper/types/permissions.ts&apos;;

export const useMapCheckPermissions = (permissions: UserPermission[]) =&gt; {
  const {
    data: { userPermissions },
  } = useMapRootState();

  return useMemo(() =&gt; permissions.every(x =&gt; userPermissions[x]), [permissions, userPermissions]);
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useMapGetOption.ts">import { useMemo } from &apos;react&apos;;
import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

export const useMapGetOption = (option: string) =&gt; {
  const {
    data: { options },
  } = useMapRootState();

  return useMemo(() =&gt; options[option], [option, options]);
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useMapInit.ts">import { useCallback } from &apos;react&apos;;
import { CommandInit } from &apos;@/hooks/Mapper/types&apos;;
import { MapRootData, useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useLoadSystemStatic } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic.ts&apos;;

export const useMapInit = () =&gt; {
  const { update } = useMapRootState();

  const { addSystemStatic } = useLoadSystemStatic({ systems: [] });

  return useCallback(
    (props: CommandInit) =&gt; {
      const {
        systems,
        system_signatures,
        connections,
        effects,
        wormholes,
        system_static_infos,
        characters,
        user_characters,
        present_characters,
        hubs,
        user_permissions,
        options,
        is_subscription_active,
        main_character_eve_id,
        following_character_eve_id,
        user_hubs,
      } = props;

      const updateData: Partial&lt;MapRootData&gt; = {};

      if (wormholes) {
        updateData.wormholesData = wormholes.reduce((acc, x) =&gt; ({ ...acc, [x.name]: x }), {});
        updateData.wormholes = wormholes;
      }

      if (effects) {
        updateData.effects = effects.reduce((acc, x) =&gt; ({ ...acc, [x.name]: x }), {});
      }

      if (characters) {
        updateData.characters = characters.slice();
      }

      if (user_characters) {
        updateData.userCharacters = user_characters;
      }

      if (present_characters) {
        updateData.presentCharacters = present_characters;
      }

      if (systems) {
        updateData.systems = systems;
      }

      if (system_signatures) {
        updateData.systemSignatures = system_signatures;
      }

      if (connections) {
        updateData.connections = connections;
      }

      if (user_permissions) {
        updateData.userPermissions = user_permissions;
      }

      if (hubs) {
        updateData.hubs = hubs;
      }

      if (user_hubs) {
        updateData.userHubs = user_hubs;
      }

      if (options) {
        updateData.options = options;
      }

      if (is_subscription_active) {
        updateData.isSubscriptionActive = is_subscription_active;
      }

      if (system_static_infos) {
        system_static_infos.forEach(static_info =&gt; {
          addSystemStatic(static_info);
        });
      }

      if (main_character_eve_id) {
        updateData.mainCharacterEveId = main_character_eve_id;
      }

      if (&apos;following_character_eve_id&apos; in props) {
        updateData.followingCharacterEveId = following_character_eve_id;
      }

      update(updateData);
    },
    [update, addSystemStatic],
  );
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useMapUpdated.ts">import { useCallback, useRef } from &apos;react&apos;;
import { CommandMapUpdated } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { MapRootData, useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;

export const useMapUpdated = () =&gt; {
  const { update } = useMapRootState();

  const ref = useRef({ update });
  ref.current = { update };

  return useCallback((props: CommandMapUpdated) =&gt; {
    const { update } = ref.current;

    const out: Partial&lt;MapRootData&gt; = {};

    if (&apos;hubs&apos; in props) {
      out.hubs = props.hubs;
    }

    if (&apos;user_hubs&apos; in props) {
      out.userHubs = props.user_hubs;
    }

    if (&apos;system_signatures&apos; in props) {
      out.systemSignatures = props.system_signatures;
    }

    if (&apos;following_character_eve_id&apos; in props) {
      out.userCharacters = props.user_characters;
    }

    if (&apos;following_character_eve_id&apos; in props) {
      out.followingCharacterEveId = props.following_character_eve_id;
    }

    if (&apos;main_character_eve_id&apos; in props) {
      out.mainCharacterEveId = props.main_character_eve_id;
    }

    update(out);
  }, []);
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/api/useRoutes.ts">import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback, useRef } from &apos;react&apos;;
import { CommandRoutes } from &apos;@/hooks/Mapper/types&apos;;
import { RoutesList, Route } from &apos;@/hooks/Mapper/types/routes.ts&apos;;

export const sortRoutes = (routes: Route[]): Route[] =&gt; {
  return routes.sort((a, b) =&gt; {
    if (a.origin !== b.origin) {
      return a.origin - b.origin;
    }
    return a.destination - b.destination;
  });
};

export const areIntegerArraysEqual = (arr1?: number[], arr2?: number[]): boolean =&gt; {
  if (arr1 === undefined || arr2 === undefined) {
    return arr1 === arr2;
  }
  // Sort both arrays
  const sortedArr1 = [...arr1].sort((a, b) =&gt; a - b);
  const sortedArr2 = [...arr2].sort((a, b) =&gt; a - b);

  // Check if sorted arrays have the same length
  if (sortedArr1.length !== sortedArr2.length) {
    return false;
  }

  // Check if all elements in the sorted arrays are equal
  for (let i = 0; i &lt; sortedArr1.length; i++) {
    if (sortedArr1[i] !== sortedArr2[i]) {
      return false;
    }
  }

  return true;
};

export const areRoutesEqual = (route1: Route, route2: Route): boolean =&gt; {
  return (
    route1.origin === route2.origin &amp;&amp;
    route1.destination === route2.destination &amp;&amp;
    route1.has_connection === route2.has_connection &amp;&amp;
    areIntegerArraysEqual(route1.systems, route2.systems) &amp;&amp;
    route1.success === route2.success
  );
};

// Function to compare two RoutesList objects
export const areRoutesListsEqual = (list1?: RoutesList, list2?: RoutesList): boolean =&gt; {
  if (list1 === undefined || list2 === undefined) {
    return list1 === list2;
  }
  // First, compare the solar_system_id
  if (list1.solar_system_id !== list2.solar_system_id) {
    return false;
  }

  // Sort the routes in each list
  const sortedRoutes1 = sortRoutes(list1.routes);
  const sortedRoutes2 = sortRoutes(list2.routes);

  // Compare the sorted routes arrays
  if (sortedRoutes1.length !== sortedRoutes2.length) {
    return false;
  }

  for (let i = 0; i &lt; sortedRoutes1.length; i++) {
    if (!areRoutesEqual(sortedRoutes1[i], sortedRoutes2[i])) {
      return false;
    }
  }

  return true;
};

export const useRoutes = () =&gt; {
  const {
    update,
    data: { routes },
  } = useMapRootState();

  const ref = useRef({ update, routes });
  ref.current = { update, routes };

  return useCallback((value: CommandRoutes) =&gt; {
    const { update, routes } = ref.current;

    if (areRoutesListsEqual(routes, value)) {
      return;
    }

    update({ routes: value });
  }, []);
};

export const useUserRoutes = () =&gt; {
  const {
    update,
    data: { userRoutes },
  } = useMapRootState();

  const ref = useRef({ update, userRoutes });
  ref.current = { update, userRoutes };

  return useCallback((value: CommandRoutes) =&gt; {
    const { update, userRoutes } = ref.current;

    if (areRoutesListsEqual(userRoutes, value)) {
      return;
    }

    update({ userRoutes: value });
  }, []);
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/index.ts">export * from &apos;./useMapRootHandlers.ts&apos;;
export * from &apos;./useComments.ts&apos;;
export * from &apos;./useCharactersCache.ts&apos;;</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/useCharactersCache.ts">import { useCallback, useRef, useState } from &apos;react&apos;;
import { CharacterCache, OutCommand, OutCommandHandler, UseCharactersCacheData } from &apos;@/hooks/Mapper/types&apos;;

interface UseCharactersCacheProps {
  outCommand: OutCommandHandler;
}
export const useCharactersCache = ({ outCommand }: UseCharactersCacheProps): UseCharactersCacheData =&gt; {
  const charactersRef = useRef&lt;Map&lt;string, CharacterCache&gt;&gt;(new Map());
  const [lastUpdateKey, setLastUpdateKey] = useState(0);

  const loadCharacter = useCallback(async (characterId: string) =&gt; {
    let character = charactersRef.current.get(characterId);

    if (character?.loading || character?.loaded) {
      return;
    }

    if (!character) {
      character = {
        loading: false,
        loaded: false,
        data: null,
      };
    }

    character.loading = true;
    charactersRef.current.set(characterId, character);

    try {
      const res = await outCommand({
        type: OutCommand.getCharacterInfo,
        data: { characterEveId: characterId },
      });
      character.data = res;
      character.loaded = true;
    } catch (error) {
      console.error(error);
    }

    charactersRef.current.set(characterId, character);
    character.loading = false;
    setLastUpdateKey(x =&gt; x + 1);
  }, []);

  return { loadCharacter, characters: charactersRef.current, lastUpdateKey };
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/useComments.ts">import { useCallback, useRef, useState } from &apos;react&apos;;
import { CommentSystem, CommentType, OutCommand, OutCommandHandler, UseCommentsData } from &apos;@/hooks/Mapper/types&apos;;

interface UseCommentsProps {
  outCommand: OutCommandHandler;
}

export const useComments = ({ outCommand }: UseCommentsProps): UseCommentsData =&gt; {
  const [lastUpdateKey, setLastUpdateKey] = useState(0);

  const commentBySystemsRef = useRef&lt;Map&lt;string, CommentSystem&gt;&gt;(new Map());

  const ref = useRef({ outCommand });
  ref.current = { outCommand };

  const loadComments = useCallback(async (systemId: string) =&gt; {
    let cSystem = commentBySystemsRef.current.get(systemId);
    if (cSystem?.loading || cSystem?.loaded) {
      return;
    }

    if (!cSystem) {
      cSystem = {
        loading: false,
        loaded: false,
        comments: [],
      };
    }

    cSystem.loading = true;

    const result: { comments: CommentType[] } = await ref.current.outCommand({
      type: OutCommand.getSystemComments,
      data: {
        solarSystemId: systemId,
      },
    });

    cSystem.loaded = true;
    cSystem.loading = false;
    cSystem.comments = [...cSystem.comments, ...result.comments];

    commentBySystemsRef.current.set(systemId, cSystem);

    setLastUpdateKey(x =&gt; x + 1);
  }, []);

  const addComment = useCallback((systemId: string, comment: CommentType) =&gt; {
    const cSystem = commentBySystemsRef.current.get(systemId);
    if (cSystem) {
      cSystem.comments.push(comment);
      setLastUpdateKey(x =&gt; x + 1);
      return;
    }

    commentBySystemsRef.current.set(systemId, {
      loading: false,
      loaded: false,
      comments: [comment],
    });
    setLastUpdateKey(x =&gt; x + 1);
  }, []);

  const removeComment = useCallback((systemId: string, commentId: string) =&gt; {
    const cSystem = commentBySystemsRef.current.get(systemId);
    if (!cSystem) {
      return;
    }

    const index = cSystem.comments.findIndex(x =&gt; x.id === commentId);

    if (index === -1) {
      return;
    }

    cSystem.comments = [...cSystem.comments.slice(0, index), ...cSystem.comments.splice(index + 1)];
    setLastUpdateKey(x =&gt; x + 1);
  }, []);

  return { loadComments, comments: commentBySystemsRef.current, lastUpdateKey, addComment, removeComment };
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/useLoadSystemStatic.ts">import { useMapRootState } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import { useCallback, useEffect, useRef, useState } from &apos;react&apos;;
import { OutCommand, OutCommandHandler, SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types&apos;;

type SystemStaticResult = {
  system_static_infos: SolarSystemStaticInfoRaw[];
};

// TODO maybe later we can store in Static data in provider
const cache = new Map&lt;number, SolarSystemStaticInfoRaw&gt;();

export const getSystemStaticInfo = (solarSystemId: number | string | undefined) =&gt; {
  if (!solarSystemId) {
    return;
  }
  return cache.get(typeof solarSystemId == &apos;number&apos; ? solarSystemId : parseInt(solarSystemId));
};

export const loadSystemStaticInfo = async (outCommand: OutCommandHandler, systems: number[]) =&gt; {
  const result = await outCommand({
    type: OutCommand.getSystemStaticInfos,
    data: {
      solar_system_ids: systems,
    },
  });

  return (result as SystemStaticResult).system_static_infos;
};

interface UseLoadSystemStaticProps {
  systems: (number | string)[];
}

export const useLoadSystemStatic = ({ systems = [] }: UseLoadSystemStaticProps) =&gt; {
  const { outCommand } = useMapRootState();
  const [loading, setLoading] = useState(false);
  const [lastUpdateKey, setLastUpdateKey] = useState(0);

  const ref = useRef({ outCommand });
  ref.current = { outCommand };

  const addSystemStatic = useCallback((static_info: SolarSystemStaticInfoRaw) =&gt; {
    cache.set(static_info.solar_system_id, static_info);
    setLastUpdateKey(new Date().getTime());
  }, []);

  const loadSystems = useCallback(async (systems: (number | string)[]) =&gt; {
    setLoading(true);
    const allSystems = systems.map(x =&gt; (typeof x == &apos;number&apos; ? x : parseInt(x)));
    const toLoad = allSystems.filter(x =&gt; !cache.has(x));

    if (toLoad.length &gt; 0) {
      const res = await loadSystemStaticInfo(ref.current.outCommand, toLoad);
      res.forEach(x =&gt; cache.set(x.solar_system_id, x));
      setLastUpdateKey(new Date().getTime());
    }
    setLoading(false);
  }, []);

  useEffect(() =&gt; {
    if (!systems.length) {
      return;
    }
    loadSystems(systems);
    // eslint-disable-next-line
  }, [systems]);

  return { addSystemStatic, systems: cache, lastUpdateKey, loading, loadSystems };
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/useMapRootHandlers.ts">import { ForwardedRef, useImperativeHandle } from &apos;react&apos;;
import {
  CommandAddConnections,
  CommandAddSystems,
  CommandCharacterActivityData,
  CommandCharacterAdded,
  CommandCharacterRemoved,
  CommandCharactersUpdated,
  CommandCharacterUpdated,
  CommandCommentAdd,
  CommandInit,
  CommandLinkSignatureToSystem,
  CommandMapUpdated,
  CommandPresentCharacters,
  CommandRemoveConnections,
  CommandRemoveSystems,
  CommandRoutes,
  CommandSignaturesUpdated,
  CommandTrackingCharactersData,
  CommandUpdateConnection,
  CommandUpdateSystems,
  CommandUserSettingsUpdated,
  Commands,
  MapHandlers,
  CommandCommentRemoved,
} from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;

import {
  useCommandComments,
  useCommandsCharacters,
  useCommandsConnections,
  useCommandsSystems,
  useMapInit,
  useMapUpdated,
  useRoutes,
  useUserRoutes,
} from &apos;./api&apos;;

import { useCommandsActivity } from &apos;./api/useCommandsActivity&apos;;
import { emitMapEvent } from &apos;@/hooks/Mapper/events&apos;;
import { DetailedKill } from &apos;../../types/kills&apos;;

export const useMapRootHandlers = (ref: ForwardedRef&lt;MapHandlers&gt;) =&gt; {
  const mapInit = useMapInit();
  const {
    addSystems,
    removeSystems,
    updateSystems,
    updateSystemSignatures,
    updateLinkSignatureToSystem,
    updateDetailedKills,
  } = useCommandsSystems();
  const { addConnections, removeConnections, updateConnection } = useCommandsConnections();
  const { charactersUpdated, characterAdded, characterRemoved, characterUpdated, presentCharacters } =
    useCommandsCharacters();
  const mapUpdated = useMapUpdated();
  const mapRoutes = useRoutes();
  const mapUserRoutes = useUserRoutes();
  const { addComment, removeComment } = useCommandComments();
  const { characterActivityData, trackingCharactersData, userSettingsUpdated } = useCommandsActivity();

  useImperativeHandle(
    ref,
    () =&gt; {
      return {
        command(type, data) {
          switch (type) {
            case Commands.init: // USED
              mapInit(data as CommandInit);
              break;
            case Commands.addSystems: // USED
              addSystems(data as CommandAddSystems);
              break;
            case Commands.updateSystems: // USED
              updateSystems(data as CommandUpdateSystems);
              break;
            case Commands.removeSystems: // USED
              removeSystems(data as CommandRemoveSystems);
              break;
            case Commands.addConnections: // USED
              addConnections(data as CommandAddConnections);
              break;
            case Commands.removeConnections: // USED
              removeConnections(data as CommandRemoveConnections);
              break;
            case Commands.updateConnection: // USED
              updateConnection(data as CommandUpdateConnection);
              break;
            case Commands.charactersUpdated: // USED
              charactersUpdated(data as CommandCharactersUpdated);
              break;
            case Commands.characterAdded: // USED
              characterAdded(data as CommandCharacterAdded);
              break;
            case Commands.characterRemoved: // USED
              characterRemoved(data as CommandCharacterRemoved);
              break;
            case Commands.characterUpdated: // USED
              characterUpdated(data as CommandCharacterUpdated);
              break;
            case Commands.presentCharacters: // USED
              presentCharacters(data as CommandPresentCharacters);
              break;
            case Commands.mapUpdated: // USED
              mapUpdated(data as CommandMapUpdated);
              break;
            case Commands.routes:
              mapRoutes(data as CommandRoutes);
              break;
            case Commands.userRoutes:
              mapUserRoutes(data as CommandRoutes);
              break;

            case Commands.signaturesUpdated: // USED
              updateSystemSignatures(data as CommandSignaturesUpdated);
              break;

            case Commands.linkSignatureToSystem: // USED
              setTimeout(() =&gt; {
                updateLinkSignatureToSystem(data as CommandLinkSignatureToSystem);
              }, 200);
              break;

            case Commands.centerSystem: // USED
              // do nothing here
              break;

            case Commands.selectSystem: // USED
              // do nothing here
              break;

            case Commands.killsUpdated:
              // do nothing here
              break;

            case Commands.detailedKillsUpdated:
              updateDetailedKills(data as Record&lt;string, DetailedKill[]&gt;);
              break;

            case Commands.characterActivityData:
              characterActivityData(data as CommandCharacterActivityData);
              break;

            case Commands.trackingCharactersData:
              trackingCharactersData(data as CommandTrackingCharactersData);
              break;

            case Commands.updateActivity:
              break;

            case Commands.updateTracking:
              break;

            case Commands.userSettingsUpdated:
              userSettingsUpdated(data as CommandUserSettingsUpdated);
              break;

            case Commands.systemCommentAdded:
              addComment(data as CommandCommentAdd);
              break;

            case Commands.systemCommentRemoved:
              removeComment(data as CommandCommentRemoved);
              break;

            default:
              console.warn(`JOipP Interface handlers: Unknown command: ${type}`, data);
              break;
          }

          emitMapEvent({ name: type, data });
        },
      };
    },
    [],
  );
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/useMapUserSettings.ts">import useLocalStorageState from &apos;use-local-storage-state&apos;;
import { InterfaceStoredSettings, RoutesType } from &apos;@/hooks/Mapper/mapRootProvider/types.ts&apos;;
import { DEFAULT_ROUTES_SETTINGS, STORED_INTERFACE_DEFAULT_VALUES } from &apos;@/hooks/Mapper/mapRootProvider/constants.ts&apos;;
import { useActualizeSettings } from &apos;@/hooks/Mapper/hooks&apos;;
import { useEffect } from &apos;react&apos;;
import { SESSION_KEY } from &apos;@/hooks/Mapper/constants.ts&apos;;

export const useMigrationRoutesSettingsV1 = (update: (upd: RoutesType) =&gt; void) =&gt; {
  //TODO if current Date is more than 01.01.2026 - remove this hook.

  useEffect(() =&gt; {
    const items = localStorage.getItem(SESSION_KEY.routes);
    if (items) {
      update(JSON.parse(items));
      localStorage.removeItem(SESSION_KEY.routes);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
};

export const useMapUserSettings = () =&gt; {
  const [interfaceSettings, setInterfaceSettings] = useLocalStorageState&lt;InterfaceStoredSettings&gt;(
    &apos;window:interface:settings&apos;,
    {
      defaultValue: STORED_INTERFACE_DEFAULT_VALUES,
    },
  );

  const [settingsRoutes, settingsRoutesUpdate] = useLocalStorageState&lt;RoutesType&gt;(&apos;window:interface:routes&apos;, {
    defaultValue: DEFAULT_ROUTES_SETTINGS,
  });

  useActualizeSettings(STORED_INTERFACE_DEFAULT_VALUES, interfaceSettings, setInterfaceSettings);
  useActualizeSettings(DEFAULT_ROUTES_SETTINGS, settingsRoutes, settingsRoutesUpdate);

  useMigrationRoutesSettingsV1(settingsRoutesUpdate);

  return { interfaceSettings, setInterfaceSettings, settingsRoutes, settingsRoutesUpdate };
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/hooks/useStoreWidgets.ts">import useLocalStorageState from &apos;use-local-storage-state&apos;;
import {
  CURRENT_WINDOWS_VERSION,
  DEFAULT_WIDGETS,
  STORED_VISIBLE_WIDGETS_DEFAULT,
  WidgetsIds,
  WINDOWS_LOCAL_STORE_KEY,
} from &apos;@/hooks/Mapper/components/mapInterface/constants.tsx&apos;;
import { WindowProps } from &apos;@/hooks/Mapper/components/ui-kit/WindowManager/types.ts&apos;;
import { useCallback, useEffect, useRef } from &apos;react&apos;;
import { SNAP_GAP, WindowsManagerOnChange } from &apos;@/hooks/Mapper/components/ui-kit/WindowManager&apos;;

export type StoredWindowProps = Omit&lt;WindowProps, &apos;content&apos;&gt;;
export type WindowStoreInfo = {
  version: number;
  windows: StoredWindowProps[];
  visible: WidgetsIds[];
  viewPort?: { w: number; h: number } | undefined;
};
export type UpdateWidgetSettingsFunc = (widgets: WindowProps[]) =&gt; void;
export type ToggleWidgetVisibility = (widgetId: WidgetsIds) =&gt; void;

export const getDefaultWidgetProps = () =&gt; ({
  version: CURRENT_WINDOWS_VERSION,
  visible: STORED_VISIBLE_WIDGETS_DEFAULT,
  windows: DEFAULT_WIDGETS,
});

export const useStoreWidgets = () =&gt; {
  const [windowsSettings, setWindowsSettings] = useLocalStorageState&lt;WindowStoreInfo&gt;(WINDOWS_LOCAL_STORE_KEY, {
    defaultValue: getDefaultWidgetProps(),
  });

  const ref = useRef({ windowsSettings, setWindowsSettings });
  ref.current = { windowsSettings, setWindowsSettings };

  const updateWidgetSettings: WindowsManagerOnChange = useCallback(({ windows, viewPort }) =&gt; {
    const { setWindowsSettings } = ref.current;

    setWindowsSettings(({ version, visible /*, windows*/ }: WindowStoreInfo) =&gt; {
      return {
        version,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        windows: DEFAULT_WIDGETS.map(({ content, ...x }) =&gt; {
          const windowProp = windows.find(j =&gt; j.id === x.id);
          if (windowProp) {
            return windowProp;
          }

          return x;
        }),
        viewPort,
        visible,
      };
    });
  }, []);

  const toggleWidgetVisibility: ToggleWidgetVisibility = useCallback(widgetId =&gt; {
    const { setWindowsSettings } = ref.current;

    setWindowsSettings(({ visible, windows, ...x }) =&gt; {
      const isCheckedPrev = visible.includes(widgetId);
      if (!isCheckedPrev) {
        const maxZIndex = Math.max(...windows.map(w =&gt; w.zIndex));
        return {
          ...x,
          windows: windows.map(wnd =&gt; {
            if (wnd.id === widgetId) {
              return { ...wnd, position: { x: SNAP_GAP, y: SNAP_GAP }, zIndex: maxZIndex + 1 };
            }

            return wnd;
          }),
          visible: [...visible, widgetId],
        };
      }

      return {
        ...x,
        windows,
        visible: visible.filter(x =&gt; x !== widgetId),
      };
    });
  }, []);

  useEffect(() =&gt; {
    const { setWindowsSettings } = ref.current;

    const raw = localStorage.getItem(WINDOWS_LOCAL_STORE_KEY);
    if (!raw) {
      console.warn(&apos;No windows found in local storage!!&apos;);

      setWindowsSettings(getDefaultWidgetProps());
      return;
    }

    const { version, windows, visible, viewPort } = JSON.parse(raw) as WindowStoreInfo;
    if (!version || CURRENT_WINDOWS_VERSION &gt; version) {
      setWindowsSettings(getDefaultWidgetProps());
    }

    // eslint-disable-next-line no-debugger
    const out = windows.filter(x =&gt; DEFAULT_WIDGETS.find(def =&gt; def.id === x.id));

    setWindowsSettings({
      version: CURRENT_WINDOWS_VERSION,
      windows: out as WindowProps[],
      visible,
      viewPort,
    });
  }, []);

  const resetWidgets = useCallback(() =&gt; ref.current.setWindowsSettings(getDefaultWidgetProps()), []);

  return {
    windowsSettings,
    updateWidgetSettings,
    toggleWidgetVisibility,
    resetWidgets,
  };
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/constants.ts">import { AvailableThemes, InterfaceStoredSettings, RoutesType } from &apos;@/hooks/Mapper/mapRootProvider/types.ts&apos;;

export const STORED_INTERFACE_DEFAULT_VALUES: InterfaceStoredSettings = {
  isShowMenu: false,
  isShowMinimap: true,
  isShowKSpace: false,
  isThickConnections: false,
  isShowUnsplashedSignatures: false,
  isShowBackgroundPattern: true,
  isSoftBackground: false,
  theme: AvailableThemes.default,
};

export const DEFAULT_ROUTES_SETTINGS: RoutesType = {
  path_type: &apos;shortest&apos;,
  include_mass_crit: true,
  include_eol: true,
  include_frig: true,
  include_cruise: true,
  include_thera: true,
  avoid_wormholes: false,
  avoid_pochven: false,
  avoid_edencom: false,
  avoid_triglavian: false,
  avoid: [],
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/index.ts">export * from &apos;./MapRootProvider&apos;;</file><file path="assets/js/hooks/Mapper/mapRootProvider/MapRootProvider.tsx">import { ContextStoreDataUpdate, useContextStore } from &apos;@/hooks/Mapper/utils&apos;;
import { createContext, Dispatch, ForwardedRef, forwardRef, SetStateAction, useContext } from &apos;react&apos;;
import {
  ActivitySummary,
  CommandLinkSignatureToSystem,
  MapUnionTypes,
  OutCommandHandler,
  SolarSystemConnection,
  TrackingCharacter,
  UseCharactersCacheData,
  UseCommentsData,
} from &apos;@/hooks/Mapper/types&apos;;
import { useCharactersCache, useComments, useMapRootHandlers } from &apos;@/hooks/Mapper/mapRootProvider/hooks&apos;;
import { WithChildren } from &apos;@/hooks/Mapper/types/common.ts&apos;;
import {
  ToggleWidgetVisibility,
  useStoreWidgets,
  WindowStoreInfo,
} from &apos;@/hooks/Mapper/mapRootProvider/hooks/useStoreWidgets.ts&apos;;
import { WindowsManagerOnChange } from &apos;@/hooks/Mapper/components/ui-kit/WindowManager&apos;;
import { DetailedKill } from &apos;../types/kills&apos;;
import { InterfaceStoredSettings, RoutesType } from &apos;@/hooks/Mapper/mapRootProvider/types.ts&apos;;
import { DEFAULT_ROUTES_SETTINGS, STORED_INTERFACE_DEFAULT_VALUES } from &apos;@/hooks/Mapper/mapRootProvider/constants.ts&apos;;
import { useMapUserSettings } from &apos;@/hooks/Mapper/mapRootProvider/hooks/useMapUserSettings.ts&apos;;

export type MapRootData = MapUnionTypes &amp; {
  selectedSystems: string[];
  selectedConnections: Pick&lt;SolarSystemConnection, &apos;source&apos; | &apos;target&apos;&gt;[];
  linkSignatureToSystem: CommandLinkSignatureToSystem | null;
  detailedKills: Record&lt;string, DetailedKill[]&gt;;
  showCharacterActivity: boolean;
  characterActivityData: {
    activity: ActivitySummary[];
    loading?: boolean;
  };
  trackingCharactersData: TrackingCharacter[];
};

const INITIAL_DATA: MapRootData = {
  wormholesData: {},
  wormholes: [],
  effects: {},
  characters: [],
  showCharacterActivity: false,
  characterActivityData: {
    activity: [],
    loading: false,
  },
  trackingCharactersData: [],
  userCharacters: [],
  presentCharacters: [],
  systems: [],
  systemSignatures: {},
  hubs: [],
  userHubs: [],
  routes: undefined,
  userRoutes: undefined,
  kills: [],
  connections: [],
  detailedKills: {},
  selectedSystems: [],
  selectedConnections: [],
  userPermissions: {},
  options: {},
  isSubscriptionActive: false,
  linkSignatureToSystem: null,
  mainCharacterEveId: null,
  followingCharacterEveId: null,
};

export enum InterfaceStoredSettingsProps {
  isShowMenu = &apos;isShowMenu&apos;,
  isShowMinimap = &apos;isShowMinimap&apos;,
  isShowKSpace = &apos;isShowKSpace&apos;,
  isThickConnections = &apos;isThickConnections&apos;,
  isShowUnsplashedSignatures = &apos;isShowUnsplashedSignatures&apos;,
  isShowBackgroundPattern = &apos;isShowBackgroundPattern&apos;,
  isSoftBackground = &apos;isSoftBackground&apos;,
  theme = &apos;theme&apos;,
}

export interface MapRootContextProps {
  update: ContextStoreDataUpdate&lt;MapRootData&gt;;
  data: MapRootData;
  outCommand: OutCommandHandler;
  windowsSettings: WindowStoreInfo;
  toggleWidgetVisibility: ToggleWidgetVisibility;
  updateWidgetSettings: WindowsManagerOnChange;
  resetWidgets: () =&gt; void;
  comments: UseCommentsData;
  charactersCache: UseCharactersCacheData;

  /**
   * !!!
   * DO NOT PASS THIS PROP INTO COMPONENT
   * !!!
   * */
  storedSettings: {
    interfaceSettings: InterfaceStoredSettings;
    setInterfaceSettings: Dispatch&lt;SetStateAction&lt;InterfaceStoredSettings&gt;&gt;;
    settingsRoutes: RoutesType;
    settingsRoutesUpdate: Dispatch&lt;SetStateAction&lt;RoutesType&gt;&gt;;
  };
}

const MapRootContext = createContext&lt;MapRootContextProps&gt;({
  update: () =&gt; {},
  data: { ...INITIAL_DATA },
  // @ts-ignore
  outCommand: async () =&gt; void 0,
  comments: {
    loadComments: async () =&gt; {},
    comments: new Map(),
    lastUpdateKey: 0,
    addComment: function (): void {
      throw new Error(&apos;Function not implemented.&apos;);
    },
    removeComment: function (): void {
      throw new Error(&apos;Function not implemented.&apos;);
    },
  },
  charactersCache: {
    loadCharacter: function (): Promise&lt;void&gt; {
      throw new Error(&apos;Function not implemented.&apos;);
    },
    characters: new Map(),
    lastUpdateKey: 0,
  },
  storedSettings: {
    interfaceSettings: STORED_INTERFACE_DEFAULT_VALUES,
    setInterfaceSettings: () =&gt; null,
    settingsRoutes: DEFAULT_ROUTES_SETTINGS,
    settingsRoutesUpdate: () =&gt; null,
  },
});

type MapRootProviderProps = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  fwdRef: ForwardedRef&lt;any&gt;;
  outCommand: OutCommandHandler;
} &amp; WithChildren;

// eslint-disable-next-line react/display-name
const MapRootHandlers = forwardRef(({ children }: WithChildren, fwdRef: ForwardedRef&lt;any&gt;) =&gt; {
  useMapRootHandlers(fwdRef);
  return &lt;&gt;{children}&lt;/&gt;;
});

// eslint-disable-next-line react/display-name
export const MapRootProvider = ({ children, fwdRef, outCommand }: MapRootProviderProps) =&gt; {
  const { update, ref } = useContextStore&lt;MapRootData&gt;({ ...INITIAL_DATA });

  const storedSettings = useMapUserSettings();

  const { windowsSettings, toggleWidgetVisibility, updateWidgetSettings, resetWidgets } = useStoreWidgets();
  const comments = useComments({ outCommand });
  const charactersCache = useCharactersCache({ outCommand });

  return (
    &lt;MapRootContext.Provider
      value={{
        update,
        data: ref,
        outCommand,
        windowsSettings,
        updateWidgetSettings,
        toggleWidgetVisibility,
        resetWidgets,
        comments,
        charactersCache,
        storedSettings,
      }}
    &gt;
      &lt;MapRootHandlers ref={fwdRef}&gt;{children}&lt;/MapRootHandlers&gt;
    &lt;/MapRootContext.Provider&gt;
  );
};

export const useMapRootState = () =&gt; {
  const context = useContext&lt;MapRootContextProps&gt;(MapRootContext);
  return context;
};</file><file path="assets/js/hooks/Mapper/mapRootProvider/types.ts">export enum AvailableThemes {
  default = &apos;default&apos;,
  pathfinder = &apos;pathfinder&apos;,
}

export type InterfaceStoredSettings = {
  isShowMenu: boolean;
  isShowMinimap: boolean;
  isShowKSpace: boolean;
  isThickConnections: boolean;
  isShowUnsplashedSignatures: boolean;
  isShowBackgroundPattern: boolean;
  isSoftBackground: boolean;
  theme: AvailableThemes;
};

export type RoutesType = {
  path_type: &apos;shortest&apos; | &apos;secure&apos; | &apos;insecure&apos;;
  include_mass_crit: boolean;
  include_eol: boolean;
  include_frig: boolean;
  include_cruise: boolean;
  include_thera: boolean;
  avoid_wormholes: boolean;
  avoid_pochven: boolean;
  avoid_edencom: boolean;
  avoid_triglavian: boolean;
  avoid: number[];
};</file><file path="assets/js/hooks/Mapper/types/character.ts">export type ShipTypeInfoRaw = {
  capacity: string;
  group_id: number;
  group_name: string;
  mass: string;
  name: string;
  type_id: number;
  volume: string;
};

export type ShipTypeRaw = {
  ship_name: string;
  ship_type_id: number;
  ship_type_info: ShipTypeInfoRaw;
};

export type LocationRaw = {
  solar_system_id: number | null;
  structure_id: number | null;
  station_id: number | null;
};

export type CharacterTypeRaw = {
  eve_id: string;
  location: LocationRaw | null;
  name: string;
  online: boolean;
  ship: ShipTypeRaw | null;

  alliance_id: number | null;
  alliance_name: string | null;
  alliance_ticker: string | null;
  corporation_id: number;
  corporation_name: string;
  corporation_ticker: string;
};

export interface TrackingCharacter {
  character: CharacterTypeRaw;
  tracked: boolean;
}

export type WithIsOwnCharacter = {
  isOwn: boolean;
};

export interface EveCharacterType {
  alliance_ticker: string;
  corporation_ticker: string;
  eve_id: string;
  name: string;
}

export interface CharacterCache {
  loading: boolean;
  loaded: boolean;
  data: EveCharacterType | null;
}

export interface UseCharactersCacheData {
  loadCharacter: (systemId: string) =&gt; Promise&lt;void&gt;;
  characters: Map&lt;string, CharacterCache&gt;;
  lastUpdateKey: number;
}

export interface ActivitySummary {
  character: CharacterTypeRaw;
  passages: number;
  connections: number;
  signatures: number;
}</file><file path="assets/js/hooks/Mapper/types/commandsIn.ts">import { TrackingCharacter } from &apos;./character.ts&apos;;

export type CommandInCharactersTrackingInfo = {
  characters: TrackingCharacter[];
  following: string | null;
  main: string | null;
};</file><file path="assets/js/hooks/Mapper/types/comment.ts">export type CommentType = {
  characterEveId: string;
  id: string;
  solarSystemId: number;
  text: string;
  updated_at: string;
};

export type CommentSystem = {
  loading: boolean;
  loaded: boolean;
  comments: CommentType[];
};

export interface UseCommentsData {
  loadComments: (systemId: string) =&gt; Promise&lt;void&gt;;
  addComment: (systemId: string, comment: CommentType) =&gt; void;
  removeComment: (systemId: string, commentId: string) =&gt; void;
  comments: Map&lt;string, CommentSystem&gt;;
  lastUpdateKey: number;
}</file><file path="assets/js/hooks/Mapper/types/common.ts">import React from &apos;react&apos;;

export interface WithChildren {
  children?: React.ReactNode;
}

export interface WithClassName {
  className?: string;
}

export type WithHTMLProps = React.HTMLAttributes&lt;HTMLDivElement&gt;;

export type IncomingEvent&lt;T&gt; = { data: T };</file><file path="assets/js/hooks/Mapper/types/connection.ts">export enum ConnectionType {
  wormhole,
  gate,
}

export enum MassState {
  normal,
  half,
  verge,
}

export enum TimeStatus {
  default,
  eol,
}

export enum ShipSizeStatus {
  small = 0, // frigates, destroyers - less than 5K t
  medium = 1, // less than 62K t
  large = 2, // less than 375K t
  freight = 3, // less than 1M t
  capital = 4, // less than 1.8M t
}

export type SolarSystemConnection = {
  // expect that it will be string which joined solarSystemSource and solarSystemTarget
  id: string;

  time_status: TimeStatus;
  mass_status: MassState;
  ship_size_type: ShipSizeStatus;
  locked: boolean;

  source: string;
  target: string;

  type?: ConnectionType;
};</file><file path="assets/js/hooks/Mapper/types/connectionPassages.ts">import { CharacterTypeRaw, ShipTypeRaw } from &apos;@/hooks/Mapper/types/character.ts&apos;;

export type PassageLimitedCharacterType = Pick&lt;
  CharacterTypeRaw,
  &apos;alliance_ticker&apos; | &apos;corporation_ticker&apos; | &apos;eve_id&apos; | &apos;name&apos;
&gt;;

export type Passage = {
  inserted_at: string; // Date
  ship: ShipTypeRaw;
  character: PassageLimitedCharacterType;
};

export type ConnectionInfoOutput = {
  marl_eol_time: string;
};

export type ConnectionOutput = {
  passages: Passage[];
};</file><file path="assets/js/hooks/Mapper/types/effect.ts">export type EffectModifierRaw = {
  name: string;
  positive: boolean;
  power: string[];
};

export type EffectRaw = {
  id: string;
  name: string;
  modifiers: EffectModifierRaw[];
};</file><file path="assets/js/hooks/Mapper/types/index.ts">export * from &apos;./wormholes&apos;;
export * from &apos;./character&apos;;
export * from &apos;./connection&apos;;
export * from &apos;./mapHandlers&apos;;
export * from &apos;./system&apos;;
export * from &apos;./mapUnionTypes&apos;;
export * from &apos;./signatures&apos;;
export * from &apos;./connectionPassages&apos;;
export * from &apos;./permissions&apos;;
export * from &apos;./comment&apos;;</file><file path="assets/js/hooks/Mapper/types/kills.ts">export type Kill = {
  solar_system_id: number;
  kills: number;
};

export interface DetailedKill {
  killmail_id: number;
  solar_system_id: number;
  kill_time?: string;

  zkb?: Record&lt;string, unknown&gt;;

  victim_char_id?: number | null;
  victim_char_name?: string;
  victim_corp_id?: number | null;
  victim_corp_ticker?: string;
  victim_corp_name?: string;
  victim_alliance_id?: number | null;
  victim_alliance_ticker?: string;
  victim_alliance_name?: string;
  victim_ship_type_id?: number | null;
  victim_ship_name?: string;

  final_blow_char_id?: number | null;
  final_blow_char_name?: string;
  final_blow_corp_id?: number | null;
  final_blow_corp_ticker?: string;
  final_blow_corp_name?: string;
  final_blow_alliance_id?: number | null;
  final_blow_alliance_ticker?: string;
  final_blow_alliance_name?: string;
  final_blow_ship_type_id?: number | null;
  final_blow_ship_name?: string;

  attacker_count?: number | null;
  total_value?: number | null;
  npc?: boolean;
}</file><file path="assets/js/hooks/Mapper/types/mapHandlers.ts">import { SolarSystemRawType, SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types/system.ts&apos;;
import { SolarSystemConnection } from &apos;@/hooks/Mapper/types/connection.ts&apos;;
import { WormholeDataRaw } from &apos;@/hooks/Mapper/types/wormholes.ts&apos;;
import { ActivitySummary, CharacterTypeRaw, TrackingCharacter } from &apos;@/hooks/Mapper/types/character.ts&apos;;
import { RoutesList } from &apos;@/hooks/Mapper/types/routes.ts&apos;;
import { DetailedKill, Kill } from &apos;@/hooks/Mapper/types/kills.ts&apos;;
import { CommentType, SystemSignature, UserPermissions } from &apos;@/hooks/Mapper/types&apos;;

export enum Commands {
  init = &apos;init&apos;,
  addSystems = &apos;add_systems&apos;,
  updateSystems = &apos;update_systems&apos;,
  systemCommentsUpdated = &apos;system_comments_updated&apos;,
  removeSystems = &apos;remove_systems&apos;,
  addConnections = &apos;add_connections&apos;,
  removeConnections = &apos;remove_connections&apos;,
  charactersUpdated = &apos;characters_updated&apos;,
  characterAdded = &apos;character_added&apos;,
  characterRemoved = &apos;character_removed&apos;,
  characterUpdated = &apos;character_updated&apos;,
  presentCharacters = &apos;present_characters&apos;,
  updateConnection = &apos;update_connection&apos;,
  mapUpdated = &apos;map_updated&apos;,
  killsUpdated = &apos;kills_updated&apos;,
  detailedKillsUpdated = &apos;detailed_kills_updated&apos;,
  routes = &apos;routes&apos;,
  userRoutes = &apos;user_routes&apos;,
  centerSystem = &apos;center_system&apos;,
  selectSystem = &apos;select_system&apos;,
  linkSignatureToSystem = &apos;link_signature_to_system&apos;,
  signaturesUpdated = &apos;signatures_updated&apos;,
  systemCommentAdded = &apos;system_comment_added&apos;,
  systemCommentRemoved = &apos;system_comment_removed&apos;,
  characterActivityData = &apos;character_activity_data&apos;,
  trackingCharactersData = &apos;tracking_characters_data&apos;,
  updateActivity = &apos;update_activity&apos;,
  updateTracking = &apos;update_tracking&apos;,
  userSettingsUpdated = &apos;user_settings_updated&apos;,
  showTracking = &apos;show_tracking&apos;,
}

export type Command =
  | Commands.init
  | Commands.addSystems
  | Commands.updateSystems
  | Commands.removeSystems
  | Commands.removeConnections
  | Commands.addConnections
  | Commands.charactersUpdated
  | Commands.characterAdded
  | Commands.characterRemoved
  | Commands.characterUpdated
  | Commands.presentCharacters
  | Commands.updateConnection
  | Commands.mapUpdated
  | Commands.killsUpdated
  | Commands.detailedKillsUpdated
  | Commands.routes
  | Commands.userRoutes
  | Commands.selectSystem
  | Commands.centerSystem
  | Commands.linkSignatureToSystem
  | Commands.signaturesUpdated
  | Commands.systemCommentAdded
  | Commands.systemCommentRemoved
  | Commands.systemCommentsUpdated
  | Commands.characterActivityData
  | Commands.trackingCharactersData
  | Commands.userSettingsUpdated
  | Commands.updateActivity
  | Commands.updateTracking
  | Commands.showTracking;

export type CommandInit = {
  systems: SolarSystemRawType[];
  system_signatures: Record&lt;string, SystemSignature[]&gt;;
  kills: Kill[];
  system_static_infos: SolarSystemStaticInfoRaw[];
  connections: SolarSystemConnection[];
  wormholes: WormholeDataRaw[];
  effects: any[];
  characters: CharacterTypeRaw[];
  present_characters: string[];
  user_characters: string[];
  user_permissions: UserPermissions;
  hubs: string[];
  user_hubs: string[];
  routes: RoutesList;
  options: Record&lt;string, string | boolean&gt;;
  reset?: boolean;
  is_subscription_active?: boolean;
  main_character_eve_id?: string | null;
  following_character_eve_id?: string | null;
};

export type CommandAddSystems = SolarSystemRawType[];
export type CommandUpdateSystems = SolarSystemRawType[];
export type CommandRemoveSystems = number[];
export type CommandAddConnections = SolarSystemConnection[];
export type CommandRemoveConnections = string[];
export type CommandCharactersUpdated = CharacterTypeRaw[];
export type CommandCharacterAdded = CharacterTypeRaw;
export type CommandCharacterRemoved = CharacterTypeRaw;
export type CommandCharacterUpdated = CharacterTypeRaw;
export type CommandPresentCharacters = string[];
export type CommandUpdateConnection = SolarSystemConnection;
export type CommandSignaturesUpdated = string;
export type CommandMapUpdated = Partial&lt;CommandInit&gt;;
export type CommandRoutes = RoutesList;
export type CommandUserRoutes = RoutesList;
export type CommandKillsUpdated = Kill[];
export type CommandDetailedKillsUpdated = Record&lt;string, DetailedKill[]&gt;;
export type CommandSelectSystem = string | undefined;
export type CommandCenterSystem = string | undefined;
export type CommandLinkSignatureToSystem = {
  solar_system_source: number;
  solar_system_target: number;
};
export type CommandLinkSignaturesUpdated = number;
export type CommandCommentAdd = {
  solarSystemId: string;
  comment: CommentType;
};
export type CommandCommentRemoved = {
  commentId: string;
  solarSystemId: number;
};
export type CommandCharacterActivityData = { activity: ActivitySummary[]; loading?: boolean };
export type CommandTrackingCharactersData = { characters: TrackingCharacter[] };
export type CommandUserSettingsUpdated = {
  settings: UserSettings;
};

export type CommandShowTracking = null;
export type CommandUpdateActivity = {
  characterId: number;
  systemId: number;
  shipTypeId: number;
  timestamp: number;
};
export type CommandUpdateTracking = {
  characterId: number;
  track: boolean;
  follow: boolean;
};

export interface UserSettings {
  primaryCharacterId?: string;
  mapSettings?: {
    showGrid?: boolean;
    snapToGrid?: boolean;
    gridSize?: number;
  };
  interfaceSettings?: {
    theme?: string;
    showMinimap?: boolean;
    showMenu?: boolean;
  };
  [key: string]: unknown;
}

export interface CommandData {
  [Commands.init]: CommandInit;
  [Commands.addSystems]: CommandAddSystems;
  [Commands.updateSystems]: CommandUpdateSystems;
  [Commands.removeSystems]: CommandRemoveSystems;
  [Commands.addConnections]: CommandAddConnections;
  [Commands.removeConnections]: CommandRemoveConnections;
  [Commands.charactersUpdated]: CommandCharactersUpdated;
  [Commands.characterAdded]: CommandCharacterAdded;
  [Commands.characterRemoved]: CommandCharacterRemoved;
  [Commands.characterUpdated]: CommandCharacterUpdated;
  [Commands.presentCharacters]: CommandPresentCharacters;
  [Commands.updateConnection]: CommandUpdateConnection;
  [Commands.mapUpdated]: CommandMapUpdated;
  [Commands.routes]: CommandRoutes;
  [Commands.userRoutes]: CommandUserRoutes;
  [Commands.killsUpdated]: CommandKillsUpdated;
  [Commands.detailedKillsUpdated]: CommandDetailedKillsUpdated;
  [Commands.selectSystem]: CommandSelectSystem;
  [Commands.centerSystem]: CommandCenterSystem;
  [Commands.linkSignatureToSystem]: CommandLinkSignatureToSystem;
  [Commands.signaturesUpdated]: CommandLinkSignaturesUpdated;
  [Commands.characterActivityData]: CommandCharacterActivityData;
  [Commands.trackingCharactersData]: CommandTrackingCharactersData;
  [Commands.userSettingsUpdated]: CommandUserSettingsUpdated;
  [Commands.updateActivity]: CommandUpdateActivity;
  [Commands.updateTracking]: CommandUpdateTracking;
  [Commands.systemCommentAdded]: CommandCommentAdd;
  [Commands.systemCommentRemoved]: CommandCommentRemoved;
  [Commands.systemCommentsUpdated]: unknown;
  [Commands.showTracking]: CommandShowTracking;
}

export interface MapHandlers {
  command&lt;T extends Command&gt;(type: T, data: CommandData[T]): void;
}

export enum OutCommand {
  addHub = &apos;add_hub&apos;,
  deleteHub = &apos;delete_hub&apos;,
  addUserHub = &apos;add_user_hub&apos;,
  deleteUserHub = &apos;delete_user_hub&apos;,
  getRoutes = &apos;get_routes&apos;,
  getUserRoutes = &apos;get_user_routes&apos;,
  getCharacterJumps = &apos;get_character_jumps&apos;,
  getStructures = &apos;get_structures&apos;,
  getSignatures = &apos;get_signatures&apos;,
  getSystemStaticInfos = &apos;get_system_static_infos&apos;,
  getConnectionInfo = &apos;get_connection_info&apos;,
  loadSignatures = &apos;load_signatures&apos;,
  updateConnectionTimeStatus = &apos;update_connection_time_status&apos;,
  updateConnectionType = &apos;update_connection_type&apos;,
  updateConnectionMassStatus = &apos;update_connection_mass_status&apos;,
  updateConnectionShipSizeType = &apos;update_connection_ship_size_type&apos;,
  updateConnectionLocked = &apos;update_connection_locked&apos;,
  updateConnectionCustomInfo = &apos;update_connection_custom_info&apos;,
  updateStructures = &apos;update_structures&apos;,
  updateSignatures = &apos;update_signatures&apos;,
  updateSystemName = &apos;update_system_name&apos;,
  updateSystemTemporaryName = &apos;update_system_temporary_name&apos;,
  updateSystemDescription = &apos;update_system_description&apos;,
  updateSystemLabels = &apos;update_system_labels&apos;,
  updateSystemLocked = &apos;update_system_locked&apos;,
  updateSystemStatus = &apos;update_system_status&apos;,
  updateSystemTag = &apos;update_system_tag&apos;,
  updateSystemPosition = &apos;update_system_position&apos;,
  updateSystemPositions = &apos;update_system_positions&apos;,
  deleteSystems = &apos;delete_systems&apos;,
  manualAddSystem = &apos;manual_add_system&apos;,
  manualAddConnection = &apos;manual_add_connection&apos;,
  manualDeleteConnection = &apos;manual_delete_connection&apos;,
  setAutopilotWaypoint = &apos;set_autopilot_waypoint&apos;,
  addSystem = &apos;add_system&apos;,
  openUserSettings = &apos;open_user_settings&apos;,
  getPassages = &apos;get_passages&apos;,
  linkSignatureToSystem = &apos;link_signature_to_system&apos;,
  getCorporationNames = &apos;get_corporation_names&apos;,
  getCorporationTicker = &apos;get_corporation_ticker&apos;,
  getSystemKills = &apos;get_system_kills&apos;,
  getSystemsKills = &apos;get_systems_kills&apos;,
  addSystemComment = &apos;addSystemComment&apos;,
  deleteSystemComment = &apos;deleteSystemComment&apos;,
  getSystemComments = &apos;getSystemComments&apos;,
  toggleFollow = &apos;toggle_follow&apos;,
  getCharacterInfo = &apos;getCharacterInfo&apos;,
  getCharactersTrackingInfo = &apos;getCharactersTrackingInfo&apos;,
  updateCharacterTracking = &apos;updateCharacterTracking&apos;,
  updateFollowingCharacter = &apos;updateFollowingCharacter&apos;,
  updateMainCharacter = &apos;updateMainCharacter&apos;,
  openSettings = &apos;open_settings&apos;,
  showActivity = &apos;show_activity&apos;,
  showTracking = &apos;show_tracking&apos;,
  getUserSettings = &apos;get_user_settings&apos;,
  updateUserSettings = &apos;update_user_settings&apos;,
  unlinkSignature = &apos;unlink_signature&apos;,
  searchSystems = &apos;search_systems&apos;,
  undoDeleteSignatures = &apos;undo_delete_signatures&apos;,
}

export type OutCommandHandler = &lt;T = unknown&gt;(event: { type: OutCommand; data: unknown }) =&gt; Promise&lt;T&gt;;</file><file path="assets/js/hooks/Mapper/types/mapUnionTypes.ts">import { WormholeDataRaw } from &apos;@/hooks/Mapper/types/wormholes.ts&apos;;
import { EffectRaw } from &apos;@/hooks/Mapper/types/effect.ts&apos;;
import { CharacterTypeRaw } from &apos;@/hooks/Mapper/types/character.ts&apos;;
import { SolarSystemRawType } from &apos;@/hooks/Mapper/types/system.ts&apos;;
import { RoutesList } from &apos;@/hooks/Mapper/types/routes.ts&apos;;
import { SolarSystemConnection } from &apos;@/hooks/Mapper/types/connection.ts&apos;;
import { UserPermissions } from &apos;@/hooks/Mapper/types&apos;;
import { SystemSignature } from &apos;@/hooks/Mapper/types/signatures&apos;;

export type MapUnionTypes = {
  wormholesData: Record&lt;string, WormholeDataRaw&gt;;
  wormholes: WormholeDataRaw[];
  effects: Record&lt;string, EffectRaw&gt;;
  characters: CharacterTypeRaw[];
  userCharacters: string[];
  presentCharacters: string[];
  hubs: string[];
  userHubs: string[];
  systems: SolarSystemRawType[];
  systemSignatures: Record&lt;string, SystemSignature[]&gt;;
  routes?: RoutesList;
  userRoutes?: RoutesList;
  kills: Record&lt;number, number&gt;;
  connections: SolarSystemConnection[];
  userPermissions: Partial&lt;UserPermissions&gt;;
  options: Record&lt;string, string | boolean&gt;;
  isSubscriptionActive: boolean;

  mainCharacterEveId: string | null;
  followingCharacterEveId: string | null;
};</file><file path="assets/js/hooks/Mapper/types/permissions.ts">export enum UserPermission {
  ADMIN_MAP = &apos;admin_map&apos;,
  MANAGE_MAP = &apos;manage_map&apos;,
  VIEW_SYSTEM = &apos;view_system&apos;,
  VIEW_CHARACTER = &apos;view_character&apos;,
  VIEW_CONNECTION = &apos;view_connection&apos;,
  ADD_SYSTEM = &apos;add_system&apos;,
  ADD_CONNECTION = &apos;add_connection&apos;,
  UPDATE_SYSTEM = &apos;update_system&apos;,
  TRACK_CHARACTER = &apos;track_character&apos;,
  DELETE_CONNECTION = &apos;delete_connection&apos;,
  DELETE_SYSTEM = &apos;delete_system&apos;,
  LOCK_SYSTEM = &apos;lock_system&apos;,
  ADD_ACL = &apos;add_acl&apos;,
  DELETE_ACL = &apos;delete_acl&apos;,
  DELETE_MAP = &apos;delete_map&apos;,
}

export type UserPermissions = Record&lt;UserPermission, boolean&gt;;</file><file path="assets/js/hooks/Mapper/types/routes.ts">import { SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types/system.ts&apos;;

export type SystemStaticInfoShort = Pick&lt;
  SolarSystemStaticInfoRaw,
  | &apos;class_title&apos;
  | &apos;security&apos;
  | &apos;solar_system_id&apos;
  | &apos;solar_system_name&apos;
  | &apos;system_class&apos;
  | &apos;triglavian_invasion_status&apos;
  | &apos;region_name&apos;
&gt;;

type MappedSystem = SolarSystemStaticInfoRaw | undefined;

export type Route = {
  destination: number;
  has_connection: boolean;
  origin: number;
  systems?: number[];
  mapped_systems?: MappedSystem[];
  success?: boolean;
};

export type RoutesList = {
  loading: boolean;
  solar_system_id: string;
  routes: Route[];
  systems_static_data: SolarSystemStaticInfoRaw[];
};</file><file path="assets/js/hooks/Mapper/types/signatures.ts">import { SolarSystemStaticInfoRaw } from &apos;@/hooks/Mapper/types&apos;;

export enum SignatureGroup {
  CosmicSignature = &apos;Cosmic Signature&apos;,
  Wormhole = &apos;Wormhole&apos;,
  GasSite = &apos;Gas Site&apos;,
  RelicSite = &apos;Relic Site&apos;,
  DataSite = &apos;Data Site&apos;,
  OreSite = &apos;Ore Site&apos;,
  CombatSite = &apos;Combat Site&apos;,
}

export enum SignatureKind {
  CosmicSignature = &apos;Cosmic Signature&apos;,
  CosmicAnomaly = &apos;Cosmic Anomaly&apos;,
  Structure = &apos;Structure&apos;,
  Ship = &apos;Ship&apos;,
  Deployable = &apos;Deployable&apos;,
  Drone = &apos;Drone&apos;,
  Starbase = &apos;Starbase&apos;,
}

export type GroupType = {
  id: string;
  icon: string;
  w: number;
  h: number;
};

export type SignatureCustomInfo = {
  k162Type?: string;
  isEOL?: boolean;
  isCrit?: boolean;
};

export type SystemSignature = {
  eve_id: string;
  character_eve_id?: string;
  character_name?: string;
  kind: SignatureKind;
  name: string;
  // SignatureCustomInfo
  custom_info?: string;
  description?: string;
  group: SignatureGroup;
  type: string;
  linked_system?: SolarSystemStaticInfoRaw;
  inserted_at?: string;
  updated_at?: string;
  deleted?: boolean;
};

export interface ExtendedSystemSignature extends SystemSignature {
  pendingDeletion?: boolean;
  pendingAddition?: boolean;
  pendingUntil?: number;
  finalTimeoutId?: number;
  deleted?: boolean;
}

export enum SignatureKindENG {
  CosmicSignature = &apos;Cosmic Signature&apos;,
  CosmicAnomaly = &apos;Cosmic Anomaly&apos;,
  Structure = &apos;Structure&apos;,
  Ship = &apos;Ship&apos;,
  Deployable = &apos;Deployable&apos;,
  Drone = &apos;Drone&apos;,
  Starbase = &apos;Starbase&apos;,
}

export enum SignatureKindRU {
  CosmicSignature = &apos;–°–∫—Ä—ã—Ç—ã–π —Å–∏–≥–Ω–∞–ª&apos;,
  CosmicAnomaly = &apos;–ö–æ—Å–º–∏—á–µ—Å–∫–∞—è –∞–Ω–æ–º–∞–ª–∏—è&apos;,
  Structure = &apos;–°–æ–æ—Ä—É–∂–µ–Ω–∏–µ&apos;,
  Ship = &apos;–ö–æ—Ä–∞–±–ª—å&apos;,
  Deployable = &apos;–ü–æ–ª–µ–≤—ã–µ –±–ª–æ–∫–∏&apos;,
  Drone = &apos;–î—Ä–æ–Ω&apos;,
  Starbase = &apos;Starbase&apos;,
}

export enum SignatureKindFR {
  CosmicSignature = &apos;Signature cosmique (type)&apos;,
  CosmicAnomaly = &apos;Anomalie cosmique&apos;,
  Structure = &apos;Structure&apos;,
  Ship = &apos;Vaisseau&apos;,
  Deployable = &apos;D√©ployable&apos;,
  Drone = &apos;Drone&apos;,
  Starbase = &apos;Base stellaire&apos;,
}

export enum SignatureKindDE {
  CosmicSignature = &apos;Kosmische Signatur (typ)&apos;,
  CosmicAnomaly = &apos;Kosmische Anomalie&apos;,
  Structure = &apos;Struktur&apos;,
  Ship = &apos;Schiff&apos;,
  Deployable = &apos;Mobile Struktur&apos;,
  Drone = &apos;Drohne&apos;,
  Starbase = &apos;Sternenbasis&apos;,
}

export enum SignatureGroupENG {
  CosmicSignature = &apos;Cosmic Signature&apos;,
  Wormhole = &apos;Wormhole&apos;,
  GasSite = &apos;Gas Site&apos;,
  RelicSite = &apos;Relic Site&apos;,
  DataSite = &apos;Data Site&apos;,
  OreSite = &apos;Ore Site&apos;,
  CombatSite = &apos;Combat Site&apos;,
}

export enum SignatureGroupRU {
  CosmicSignature = &apos;–°–∫—Ä—ã—Ç—ã–π —Å–∏–≥–Ω–∞–ª&apos;,
  Wormhole = &apos;–ß–µ—Ä–≤–æ—Ç–æ—á–∏–Ω–∞&apos;,
  GasSite = &apos;–ì–∞–∑–æ–≤—ã–π —Ä–∞–π–æ–Ω&apos;,
  RelicSite = &apos;–ê—Ä—Ö–µ–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π —Ä–∞–π–æ–Ω&apos;,
  DataSite = &apos;–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ä–∞–π–æ–Ω&apos;,
  OreSite = &apos;–ê—Å—Ç–µ—Ä–æ–∏–¥–Ω—ã–π —Ä–∞–π–æ–Ω&apos;,
  CombatSite = &apos;–ë–æ–µ–≤–æ–π —Ä–∞–π–æ–Ω&apos;,
}

export enum SignatureGroupFR {
  CosmicSignature = &apos;Signature cosmique (groupe)&apos;,
  Wormhole = &apos;Trou de ver&apos;,
  GasSite = &apos;Site de gaz&apos;,
  RelicSite = &apos;Site de reliques&apos;,
  DataSite = &apos;Site de donn√©es&apos;,
  OreSite = &apos;Site de minerai&apos;,
  CombatSite = &apos;Site de combat&apos;,
}

export enum SignatureGroupDE {
  CosmicSignature = &apos;Kosmische Signatur (gruppe)&apos;,
  Wormhole = &apos;Wurmloch&apos;,
  GasSite = &apos;Gasgebiet&apos;,
  RelicSite = &apos;Reliktgebiet&apos;,
  DataSite = &apos;Datengebiet&apos;,
  OreSite = &apos;Mineraliengebiet&apos;,
  CombatSite = &apos;Kampfgebiet&apos;,
}</file><file path="assets/js/hooks/Mapper/types/system.ts">import { XYPosition } from &apos;reactflow&apos;;

import { SystemSignature } from &apos;./signatures&apos;;

export enum SolarSystemStaticInfoRawNames {
  regionId = &apos;region_id&apos;,
  constellationId = &apos;constellation_id&apos;,
  solarSystemId = &apos;solar_system_id&apos;,
  solarSystemName = &apos;solar_system_name&apos;,
  solarSystemNameLc = &apos;solar_system_name_lc&apos;,
  constellationName = &apos;constellation_name&apos;,
  regionName = &apos;region_name&apos;,
  systemClass = &apos;system_class&apos;,
  security = &apos;security&apos;,
  typeDescription = &apos;type_description&apos;,
  classTitle = &apos;class_title&apos;,
  isShattered = &apos;is_shattered&apos;,
  effectName = &apos;effect_name&apos;,
  effectPower = &apos;effect_power&apos;,
  statics = &apos;statics&apos;,
  wandering = &apos;wandering&apos;,
  triglavianInvasionStatus = &apos;triglavian_invasion_status&apos;,
  sunTypeId = &apos;sun_type_id&apos;,
}

export enum SolarSystemStaticInfoNames {
  regionId = &apos;regionId&apos;,
  constellationId = &apos;constellationId&apos;,
  solarSystemId = &apos;solarSystemId&apos;,
  solarSystemName = &apos;solarSystemName&apos;,
  solarSystemNameLc = &apos;solarSystemNameLc&apos;,
  constellationName = &apos;constellationName&apos;,
  regionName = &apos;regionName&apos;,
  systemClass = &apos;systemClass&apos;,
  security = &apos;security&apos;,
  typeDescription = &apos;typeDescription&apos;,
  classTitle = &apos;classTitle&apos;,
  isShattered = &apos;isShattered&apos;,
  effectName = &apos;effectName&apos;,
  effectPower = &apos;effectPower&apos;,
  statics = &apos;statics&apos;,
  wandering = &apos;wandering&apos;,
  triglavianInvasionStatus = &apos;triglavianInvasionStatus&apos;,
  sunTypeId = &apos;sunTypeId&apos;,
}

export const SYSTEM_STATIC_INFO_MAP = {
  [SolarSystemStaticInfoRawNames.regionId]: SolarSystemStaticInfoNames.regionId,
  [SolarSystemStaticInfoRawNames.constellationId]: SolarSystemStaticInfoNames.constellationId,
  [SolarSystemStaticInfoRawNames.solarSystemId]: SolarSystemStaticInfoNames.solarSystemId,
  [SolarSystemStaticInfoRawNames.solarSystemName]: SolarSystemStaticInfoNames.solarSystemName,
  [SolarSystemStaticInfoRawNames.solarSystemNameLc]: SolarSystemStaticInfoNames.solarSystemNameLc,
  [SolarSystemStaticInfoRawNames.constellationName]: SolarSystemStaticInfoNames.constellationName,
  [SolarSystemStaticInfoRawNames.regionName]: SolarSystemStaticInfoNames.regionName,
  [SolarSystemStaticInfoRawNames.systemClass]: SolarSystemStaticInfoNames.systemClass,
  [SolarSystemStaticInfoRawNames.security]: SolarSystemStaticInfoNames.security,
  [SolarSystemStaticInfoRawNames.typeDescription]: SolarSystemStaticInfoNames.typeDescription,
  [SolarSystemStaticInfoRawNames.classTitle]: SolarSystemStaticInfoNames.classTitle,
  [SolarSystemStaticInfoRawNames.isShattered]: SolarSystemStaticInfoNames.isShattered,
  [SolarSystemStaticInfoRawNames.effectName]: SolarSystemStaticInfoNames.effectName,
  [SolarSystemStaticInfoRawNames.effectPower]: SolarSystemStaticInfoNames.effectPower,
  [SolarSystemStaticInfoRawNames.statics]: SolarSystemStaticInfoNames.statics,
  [SolarSystemStaticInfoRawNames.wandering]: SolarSystemStaticInfoNames.wandering,
  [SolarSystemStaticInfoRawNames.triglavianInvasionStatus]: SolarSystemStaticInfoNames.triglavianInvasionStatus,
  [SolarSystemStaticInfoRawNames.sunTypeId]: SolarSystemStaticInfoNames.sunTypeId,
};

export type SolarSystemStaticInfoRaw = {
  region_id: number;
  constellation_id: number;
  solar_system_id: number;
  solar_system_name: string;
  solar_system_name_lc: string;
  constellation_name: string;
  region_name: string;
  system_class: number;
  security: string;
  type_description: string;
  class_title: string;
  is_shattered: boolean;
  effect_name: string;
  effect_power: number;
  statics: string[];
  wandering: string[];
  triglavian_invasion_status: string;
  sun_type_id: number;
};

export type SolarSystemStaticInfo = {
  regionId: number;
  constellationId: number;
  solarSystemId: number;
  solarSystemName: string;
  solarSystemNameLc: string;
  constellationName: string;
  regionName: string;
  systemClass: number;
  security: string;
  typeDescription: string;
  classTitle: string;
  isShattered: boolean;
  effectName: string;
  effectPower: number;
  statics: string[];
  wandering: string[];
  triglavianInvasionStatus: string;
  sunTypeId: number;
};

export type SolarSystemRawType = {
  id: string;
  position: XYPosition;
  description: string | null;
  labels: string | null;
  locked: boolean;
  tag: string | null;
  status: number;
  name: string | null;
  temporary_name: string | null;
  linked_sig_eve_id: string | null;

  system_static_info: SolarSystemStaticInfoRaw;
  system_signatures: SystemSignature[];
};

export type SearchSystemItem = {
  class_title: string;
  constellation_name: string;
  label: string;
  region_name: string;
  system_static_info: SolarSystemStaticInfoRaw;
  value: number;
};</file><file path="assets/js/hooks/Mapper/types/wormholes.ts">export enum Respawn {
  static = &apos;static&apos;,
  wandering = &apos;wandering&apos;,
  reverse = &apos;reverse&apos;,
}

export type WormholeDataRaw = {
  dest: string;
  id: number;
  lifetime: string;
  mass_regen: number;
  max_mass_per_jump: number;
  name: string;
  respawn: Respawn[];
  src: string[];
  static: boolean;
  total_mass: number;
};</file><file path="assets/js/hooks/Mapper/utils/contextStore/index.ts">export * from &apos;./types&apos;;
export * from &apos;./useContextStore.ts&apos;;</file><file path="assets/js/hooks/Mapper/utils/contextStore/types.ts">export type AnyProperty&lt;T&gt; = T[keyof T];

export type PCDHandleBeforeUpdate&lt;T&gt; = (
  newVal: AnyProperty&lt;T&gt;,
  prev: AnyProperty&lt;T&gt;,
) =&gt; {
  value: AnyProperty&lt;T&gt;;
  prevent?: boolean;
} | void;

export type UpdateFunc&lt;T&gt; = (props: T) =&gt; Partial&lt;T&gt;;
export type ContextStoreDataUpdate&lt;T&gt; = (values: Partial&lt;T&gt; | UpdateFunc&lt;T&gt;, force?: boolean) =&gt; void;

export type ContextStoreDataOpts&lt;T&gt; = {
  notNeedRerender?: boolean;
  handleBeforeUpdate?: PCDHandleBeforeUpdate&lt;T&gt;;
  onAfterAUpdate?: (values: Partial&lt;T&gt;) =&gt; void;
};

export type ProvideConstateDataReturnType&lt;T&gt; = {
  update: ContextStoreDataUpdate&lt;T&gt;;
  ref: T;
};</file><file path="assets/js/hooks/Mapper/utils/contextStore/useContextStore.ts">import { useCallback, useRef, useState, useEffect } from &apos;react&apos;;

import { ContextStoreDataOpts, ProvideConstateDataReturnType, ContextStoreDataUpdate, UpdateFunc } from &apos;./types&apos;;

export const useContextStore = &lt;T&gt;(
  initialValue: T,
  { notNeedRerender = false, handleBeforeUpdate, onAfterAUpdate }: ContextStoreDataOpts&lt;T&gt; = {},
): ProvideConstateDataReturnType&lt;T&gt; =&gt; {
  const ref = useRef&lt;T&gt;(initialValue);
  const queueRef = useRef&lt;{ valOrFunc: Partial&lt;T&gt; | UpdateFunc&lt;T&gt;; force: boolean }[]&gt;([]);
  const [, setRerenderKey] = useState(0);

  const refWrapper = useRef({ notNeedRerender, handleBeforeUpdate, onAfterAUpdate });
  refWrapper.current = { notNeedRerender, handleBeforeUpdate, onAfterAUpdate };

  const update: ContextStoreDataUpdate&lt;T&gt; = useCallback((valOrFunc, force = false) =&gt; {
    queueRef.current.push({ valOrFunc, force });
  }, []);

  const processNextQueue = useCallback(() =&gt; {
    const next = queueRef.current.shift();

    if (!next) {
      return;
    }

    const { valOrFunc, force } = next;

    // It need to force prevent unnecessary rerendering
    // update will create once
    const { notNeedRerender, handleBeforeUpdate, onAfterAUpdate } = refWrapper.current;
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    const availableKeys = Object.keys(ref.current);

    const values = typeof valOrFunc === &apos;function&apos; ? valOrFunc(ref.current) : valOrFunc;

    let callRerender = false;
    Object.keys(values).forEach(key =&gt; {
      if (!availableKeys.includes(key)) {
        // TODO maybe need show error
        return;
      }

      if (!handleBeforeUpdate || force) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        ref.current[key] = values[key];
        // !notNeedRerender &amp;&amp; setRerenderKey(x =&gt; x + 1);
        if (!notNeedRerender) {
          callRerender = true;
        }
        return;
      }
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error
      const updateResult = handleBeforeUpdate(values[key], ref.current[key]);
      if (!updateResult) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        ref.current[key] = values[key];
        // !notNeedRerender &amp;&amp; setRerenderKey(x =&gt; x + 1);
        if (!notNeedRerender) {
          callRerender = true;
        }
        return;
      }

      if (updateResult?.prevent) {
        return;
      }

      if (Object.keys(updateResult).includes(&apos;value&apos;)) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        ref.current[key] = updateResult.value;
        // !notNeedRerender &amp;&amp; setRerenderKey(x =&gt; x + 1);
        if (!notNeedRerender) {
          callRerender = true;
        }
        return;
      }
    });

    if (callRerender) {
      setRerenderKey(x =&gt; x + 1);
    }

    onAfterAUpdate?.(ref.current);
  }, []);

  useEffect(() =&gt; {
    let requestId: number;
    const process = () =&gt; {
      processNextQueue();
      requestId = requestAnimationFrame(process);
    };

    process();

    return () =&gt; {
      cancelAnimationFrame(requestId);
    };
  });

  return { update, ref: ref.current };
};</file><file path="assets/js/hooks/Mapper/utils/abstractContextProvider.tsx">import { createContext, ReactNode, useContext, useState } from &apos;react&apos;;

type ContextType&lt;T&gt; = {
  value: T;
  setValue: (newValue: T) =&gt; void;
};

export const createGenericContext = &lt;T,&gt;() =&gt; {
  const context = createContext&lt;ContextType&lt;T&gt; | undefined&gt;(undefined);

  const Provider = ({ children, initialValue }: { children: ReactNode; initialValue: T }) =&gt; {
    const [value, setValue] = useState&lt;T&gt;(initialValue);

    return &lt;context.Provider value={{ value, setValue }}&gt;{children}&lt;/context.Provider&gt;;
  };

  const useContextValue = () =&gt; {
    const contextValue = useContext(context);
    if (!contextValue) {
      throw new Error(&apos;useContextValue must be used within a Provider&apos;);
    }
    return contextValue;
  };

  return { Provider, useContextValue };
};</file><file path="assets/js/hooks/Mapper/utils/contextManager.ts">import { ContextMenu } from &apos;primereact/contextmenu&apos;;

class ContextManager {
  private prev: ContextMenu | null = null;
  private prevId: string | null = null;

  next(id: string | null, ctx: ContextMenu | null) {
    if (id === null &amp;&amp; this.prev !== null) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error
      this.prev.hide();
      return;
    }

    if (this.prevId === id) {
      return;
    }

    if (this.prev !== null &amp;&amp; this.prevId !== id) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error
      this.prev.hide();
    }

    this.prev = ctx;
    this.prevId = id;
  }
  reset() {
    if (this.prev != null) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error
      this.prev.hide();
    }
  }
}

export const ctxManager = new ContextManager();</file><file path="assets/js/hooks/Mapper/utils/getQueryVariable.ts">export const getQueryVariable = (variable: string) =&gt; {
  const query = window.location.search.substring(1);
  const vars = query.split(&apos;&amp;&apos;);
  for (let i = 0; i &lt; vars.length; i++) {
    const pair = vars[i].split(&apos;=&apos;);
    if (pair[0] == variable) {
      return pair[1];
    }
  }
  return false;
};</file><file path="assets/js/hooks/Mapper/utils/index.ts">export * from &apos;./contextStore&apos;;
export * from &apos;./getQueryVariable&apos;;</file><file path="assets/js/hooks/Mapper/utils/kgToTons.ts">const formatWithSpaces = (num: number): string =&gt; {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, &apos; &apos;);
};

export const kgToTons = (kg: number): string =&gt; {
  const tons = kg / 1000;

  let formattedTons: string;

  if (tons &gt;= 1000000) {
    formattedTons = `${(tons / 1000000).toFixed(1)}M t`;
  } else if (tons &gt;= 100000) {
    formattedTons = `${formatWithSpaces(Math.floor(tons))}k t`;
  } else {
    formattedTons = `${formatWithSpaces(parseFloat(tons.toFixed(3)))} t`;
  }

  return formattedTons;
};</file><file path="assets/js/hooks/Mapper/utils/labelsManager.ts">export type LabelsType = {
  customLabel: string;
  labels: string[];
};

export class LabelsManager {
  protected labelsRaw: string;
  protected parsedLabels: LabelsType = {
    labels: [],
    customLabel: &apos;&apos;,
  };
  constructor(labels: string) {
    this.labelsRaw = labels;
    this.parsedLabels = this.parse();
  }

  parse(): LabelsType {
    try {
      return JSON.parse(this.labelsRaw) as LabelsType;
    } catch (err) {
      return {
        customLabel: &apos;&apos;,
        labels: this.labelsRaw.split(&apos;,&apos;),
      };
    }
  }

  parse2(): LabelsType {
    if (this.labelsRaw.length === 0) {
      return {
        labels: [],
        customLabel: &apos;&apos;,
      };
    }

    const [labels, customLabel] = this.labelsRaw.split(&apos;:&apos;);
    return {
      labels: labels.split(&apos;,&apos;),
      customLabel: customLabel ?? &apos;&apos;,
    };
  }

  toString() {
    return JSON.stringify(this.parsedLabels);
  }

  toString2() {
    return `${this.parsedLabels.labels.join(&apos;,&apos;)}`;
  }

  valueOf() {
    return this.toString();
  }

  updateCustomLabel(label: string) {
    this.parsedLabels.customLabel = label;
  }

  addLabels(labels: string[]) {
    this.parsedLabels.labels = [...new Set([...this.parsedLabels.labels, ...labels])];
  }

  delLabels(labels: string[]) {
    this.parsedLabels.labels = this.parsedLabels.labels.filter(x =&gt; !labels.includes(x));
  }

  hasLabel(label: string) {
    return this.parsedLabels.labels?.includes(label);
  }

  toggleLabel(label: string) {
    if (this.parsedLabels.labels.includes(label)) {
      this.delLabels([label]);
    } else {
      this.addLabels([label]);
    }
  }

  clearLabels() {
    this.parsedLabels.labels = [];
  }

  get customLabel() {
    return this.parsedLabels.customLabel;
  }

  get list() {
    return this.parsedLabels.labels;
  }
}</file><file path="assets/js/hooks/Mapper/constants.ts">export enum SESSION_KEY {
  viewPort = &apos;viewPort&apos;,
  windows = &apos;windows&apos;,
  windowsVisible = &apos;windowsVisible&apos;,
  routes = &apos;routes&apos;,
}

export const GRADIENT_MENU_ACTIVE_CLASSES = &apos;bg-gradient-to-br from-transparent/10 to-fuchsia-300/10&apos;;

export enum Regions {
  Derelik = 10000001,
  TheForge = 10000002,
  Lonetrek = 10000016,
  SinqLaison = 10000032,
  Aridia = 10000054,
  BlackRise = 10000069,
  TheBleakLands = 10000038,
  TheCitadel = 10000033,
  Devoid = 10000036,
  Domain = 10000043,
  Essence = 10000064,
  Everyshore = 10000037,
  Genesis = 10000067,
  Heimatar = 10000030,
  Kador = 10000052,
  Khanid = 10000049,
  KorAzor = 10000065,
  Metropolis = 10000042,
  MoldenHeath = 10000028,
  Placid = 10000048,
  Solitude = 10000044,
  TashMurkon = 10000020,
  VergeVendor = 10000068,
}

export enum Spaces {
  &apos;Caldari&apos; = &apos;Caldari&apos;,
  &apos;Gallente&apos; = &apos;Gallente&apos;,
  &apos;Matar&apos; = &apos;Matar&apos;,
  &apos;Amarr&apos; = &apos;Amarr&apos;,
}

export const REGIONS_MAP: Record&lt;number, Spaces&gt; = {
  [Regions.Derelik]: Spaces.Amarr,
  [Regions.TheForge]: Spaces.Caldari,
  [Regions.Lonetrek]: Spaces.Caldari,
  [Regions.SinqLaison]: Spaces.Gallente,
  [Regions.Aridia]: Spaces.Amarr,
  [Regions.BlackRise]: Spaces.Caldari,
  [Regions.TheBleakLands]: Spaces.Amarr,
  [Regions.TheCitadel]: Spaces.Caldari,
  [Regions.Devoid]: Spaces.Amarr,
  [Regions.Domain]: Spaces.Amarr,
  [Regions.Essence]: Spaces.Gallente,
  [Regions.Everyshore]: Spaces.Gallente,
  [Regions.Genesis]: Spaces.Amarr,
  [Regions.Heimatar]: Spaces.Matar,
  [Regions.Kador]: Spaces.Amarr,
  [Regions.Khanid]: Spaces.Amarr,
  [Regions.KorAzor]: Spaces.Amarr,
  [Regions.Metropolis]: Spaces.Matar,
  [Regions.MoldenHeath]: Spaces.Matar,
  [Regions.Placid]: Spaces.Gallente,
  [Regions.Solitude]: Spaces.Gallente,
  [Regions.TashMurkon]: Spaces.Amarr,
  [Regions.VergeVendor]: Spaces.Gallente,
};

export type K162Type = {
  label: string;
  value: string;
  whClassName: string;
};

export const K162_TYPES: K162Type[] = [
  {
    label: &apos;Hi-Sec&apos;,
    value: &apos;hs&apos;,
    whClassName: &apos;A641&apos;,
  },
  {
    label: &apos;Low-Sec&apos;,
    value: &apos;ls&apos;,
    whClassName: &apos;J377&apos;,
  },
  {
    label: &apos;Null-Sec&apos;,
    value: &apos;ns&apos;,
    whClassName: &apos;C248&apos;,
  },
  {
    label: &apos;C1&apos;,
    value: &apos;c1&apos;,
    whClassName: &apos;E004&apos;,
  },
  {
    label: &apos;C2&apos;,
    value: &apos;c2&apos;,
    whClassName: &apos;D382&apos;,
  },
  {
    label: &apos;C3&apos;,
    value: &apos;c3&apos;,
    whClassName: &apos;L477&apos;,
  },
  {
    label: &apos;C4&apos;,
    value: &apos;c4&apos;,
    whClassName: &apos;M001&apos;,
  },
  {
    label: &apos;C5&apos;,
    value: &apos;c5&apos;,
    whClassName: &apos;L614&apos;,
  },
  {
    label: &apos;C6&apos;,
    value: &apos;c6&apos;,
    whClassName: &apos;G008&apos;,
  },
  {
    label: &apos;C13&apos;,
    value: &apos;c13&apos;,
    whClassName: &apos;A009&apos;,
  },
  {
    label: &apos;Thera&apos;,
    value: &apos;thera&apos;,
    whClassName: &apos;F353&apos;,
  },
  {
    label: &apos;Pochven&apos;,
    value: &apos;pochven&apos;,
    whClassName: &apos;F216&apos;,
  },
];

export const K162_TYPES_MAP: { [key: string]: K162Type } = K162_TYPES.reduce(
  (acc, x) =&gt; ({ ...acc, [x.value]: x }),
  {},
);</file><file path="assets/js/hooks/Mapper/index.tsx">import { createRoot } from &apos;react-dom/client&apos;;
import Mapper from &apos;./MapRoot&apos;;

const LAST_VERSION_KEY = &apos;wandererLastVersion&apos;;
const UI_LOADED_EVENT = &apos;ui_loaded&apos;;

export default {
  _rootEl: null,
  _errorCount: 0,

  mounted() {
    // create react root element
    const rootEl = document.getElementById(this.el.id);
    const activeVersion = localStorage.getItem(LAST_VERSION_KEY);
    this._rootEl = createRoot(rootEl!);

    const handleError = (error: Error, componentStack: string) =&gt; {
      this.pushEvent(&apos;log_map_error&apos;, { error: error.message, componentStack });
    };

    this.render({
      handleEvent: this.handleEventWrapper.bind(this),
      pushEvent: this.pushEvent.bind(this),
      pushEventAsync: this.pushEventAsync.bind(this),
      onError: handleError,
    });

    this.pushEvent(UI_LOADED_EVENT, { version: activeVersion });
  },

  handleEventWrapper(event: string, handler: (payload: any) =&gt; void) {
    this.handleEvent(event, (body: any) =&gt; {
      handler(body);
    });
  },

  reconnected() {
    const activeVersion = localStorage.getItem(LAST_VERSION_KEY);
    this.pushEvent(UI_LOADED_EVENT, { version: activeVersion });
  },

  async pushEventAsync(event: string, payload: any) {
    return new Promise((accept, reject) =&gt; {
      this.pushEvent(event, payload, reply =&gt; {
        accept(reply);
      });
    });
  },

  render(hooks) {
    this._rootEl.render(&lt;Mapper hooks={hooks} /&gt;);
  },

  destroyed() {
    this._rootEl.unmount();
  },
};</file><file path="assets/js/hooks/Mapper/MapRoot.tsx">import { PrimeReactProvider } from &apos;primereact/api&apos;;
import { ErrorBoundary } from &apos;react-error-boundary&apos;;

import { MapHandlers } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { ErrorInfo, useCallback, useEffect, useRef } from &apos;react&apos;;
import { ReactFlowProvider } from &apos;reactflow&apos;;
import { useMapperHandlers } from &apos;./useMapperHandlers&apos;;

import { MapRootContent } from &apos;@/hooks/Mapper/components/mapRootContent/MapRootContent.tsx&apos;;
import { MapRootProvider } from &apos;@/hooks/Mapper/mapRootProvider&apos;;
import &apos;./common-styles/main.scss&apos;;

const ErrorFallback = () =&gt; {
  return &lt;div className=&quot;!z-100 absolute w-screen h-screen bg-transparent&quot;&gt;&lt;/div&gt;;
};

export default function MapRoot({ hooks }) {
  const providerRef = useRef&lt;MapHandlers&gt;(null);
  const hooksRef = useRef&lt;any&gt;(hooks);

  const mapperHandlerRefs = useRef([providerRef]);

  const { handleCommand, handleMapEvent } = useMapperHandlers(mapperHandlerRefs.current, hooksRef);

  const logError = useCallback((error: Error, info: ErrorInfo) =&gt; {
    if (!hooksRef.current) {
      return;
    }
    hooksRef.current.onError(error, info.componentStack);
  }, []);

  useEffect(() =&gt; {
    if (!hooksRef.current) {
      return;
    }

    hooksRef.current.handleEvent(&apos;map_event&apos;, handleMapEvent);
  }, []);

  return (
    &lt;PrimeReactProvider&gt;
      &lt;MapRootProvider fwdRef={providerRef} outCommand={handleCommand}&gt;
        &lt;ErrorBoundary FallbackComponent={ErrorFallback} onError={logError}&gt;
          &lt;ReactFlowProvider&gt;
            &lt;MapRootContent /&gt;
          &lt;/ReactFlowProvider&gt;
        &lt;/ErrorBoundary&gt;
      &lt;/MapRootProvider&gt;
    &lt;/PrimeReactProvider&gt;
  );
}</file><file path="assets/js/hooks/Mapper/useMapperHandlers.ts">import { MapHandlers } from &apos;@/hooks/Mapper/types/mapHandlers.ts&apos;;
import { RefObject, useCallback } from &apos;react&apos;;

// Force reload the page after 5 minutes of inactivity
const FORCE_PAGE_RELOAD_TIMEOUT = 1000 * 60 * 5;

export const useMapperHandlers = (handlerRefs: RefObject&lt;MapHandlers&gt;[], hooksRef: RefObject&lt;any&gt;) =&gt; {
  const handleCommand = useCallback(
    async ({ type, data }) =&gt; {
      if (!hooksRef.current) {
        return;
      }

      return await hooksRef.current.pushEventAsync(type, data);
    },
    [hooksRef.current],
  );

  const handleMapEvent = useCallback(({ type, body, timestamp }) =&gt; {
    const timeDiff = Date.now() - Date.parse(timestamp);
    // If the event is older than the timeout, force reload the page
    if (timeDiff &gt; FORCE_PAGE_RELOAD_TIMEOUT) {
      window.location.reload();
      return;
    }
    handlerRefs.forEach(ref =&gt; {
      if (!ref.current) {
        return;
      }

      ref.current?.command(type, body);
    });
  }, []);

  return { handleCommand, handleMapEvent };
};</file><file path="assets/js/hooks/maps/mapAction.ts">export default {
  mounted() {
    const hook = this;
    this.el.addEventListener(&apos;click&apos;, e =&gt; {
      e.preventDefault();
      e.stopPropagation();
      if (hook.el.dataset.confirm) {
        if (!confirm(hook.el.dataset.confirm)) {
          return;
        }
      }
      this.pushEvent(hook.el.dataset.event, { data: hook.el.dataset.data });
    });
  },
};</file><file path="assets/js/hooks/clientTime.ts">export default {
  mounted() {
    this.updated();
  },
  updated() {
    const dt = new Date(Number(this.el.textContent));
    const options = { hour12: false, timeZone: &apos;UTC&apos; };
    this.el.textContent = `${dt.toLocaleString(&apos;en-US&apos;, options)}`;
    this.el.classList.remove(&apos;invisible&apos;);
  },
};</file><file path="assets/js/hooks/copyToClipboard.ts">export default {
  mounted() {
    const button = this.el;

    button.addEventListener(&apos;click&apos;, function () {

      button.classList.remove(&apos;copied&apos;);

      // Copy the URL to the clipboard
      navigator.clipboard
        .writeText(button.dataset.url)
        .then(() =&gt; {
          button.classList.add(&apos;copied&apos;);
        })
        .catch(err =&gt; {
          console.error(&apos;Failed to copy URL:&apos;, err);
        });
    });
  },
};</file><file path="assets/js/hooks/downloadJson.ts">export default {
  content: &apos;&apos;,

  mounted() {
    const hook = this;
    const button = this.el;

    button.addEventListener(&apos;click&apos;, function () {
      // Create a Blob from the JSON string
      const blob = new Blob([hook.el.dataset.content || &apos;{}&apos;], { type: &apos;application/json&apos; });

      // Create a link element
      const link = document.createElement(&apos;a&apos;);

      // Set the download attribute with a filename
      link.download = `${hook.el.dataset.name}.json`;

      // Create a URL for the Blob and set it as the href attribute
      link.href = URL.createObjectURL(blob);

      // Append the link to the body (it won&apos;t be visible)
      document.body.appendChild(link);

      // Programmatically click the link to trigger the download
      link.click();

      // Remove the link from the document
      document.body.removeChild(link);
    });
  },
};</file><file path="assets/js/hooks/drag.ts">import { Droppable } from &apos;@shopify/draggable&apos;;

export default {
  mounted() {
    let lastDropzone = null;
    const hook = this;
    const containers = document.querySelectorAll(&apos;.dropzone&apos;);
    const selector = &apos;#&apos; + this.el.id;

    const droppable = new Droppable(containers, {
      delay: 100,
      draggable: &apos;.draggable&apos;,
      dropzone: &apos;.dropzone&apos;,
      mirror: {
        constrainDimensions: true,
      },
    });

    let droppableOrigin;

    // --- Draggable events --- //
    droppable.on(&apos;drag:start&apos;, evt =&gt; {
      lastDropzone = null;
      droppableOrigin = evt.originalSource;
    });

    droppable.on(&apos;droppable:dropped&apos;, evt =&gt; {
      if (droppableOrigin.parentNode.dataset.dropzone !== evt.dropzone.dataset.dropzone) {
        lastDropzone = evt.dropzone.dataset.dropzone;
        evt.cancel();
      }
    });

    droppable.on(&apos;droppable:stop&apos;, evt =&gt; {
      if (!lastDropzone) {
        return;
      }
      hook.pushEventTo(selector, &apos;dropped&apos;, { draggedId: droppableOrigin.id, dropzoneId: lastDropzone });
    });
  },
};</file><file path="assets/js/hooks/index.ts">import Drag from &apos;./drag&apos;;
import Mapper from &apos;./Mapper&apos;;
import LocalTime from &apos;./localTime&apos;;
import ClientTime from &apos;./clientTime&apos;;
import LocalStorageSetting from &apos;./localStorageSetting&apos;;
import Ping from &apos;./ping&apos;;
import CopyToClipboard from &apos;./copyToClipboard&apos;;
import DownloadJson from &apos;./downloadJson&apos;;
import NewVersionUpdate from &apos;./newVersionUpdate&apos;;
import MapAction from &apos;./maps/mapAction&apos;;
import ShowCharactersAddAlert from &apos;./showCharactersAddAlert&apos;;

export default {
  DownloadJson,
  Drag,
  MapAction,
  Mapper,
  LocalTime,
  ClientTime,
  LocalStorageSetting,
  Ping,
  CopyToClipboard,
  NewVersionUpdate,
  ShowCharactersAddAlert,
};</file><file path="assets/js/hooks/localStorageSetting.ts">export default {
  key(): string {
    return this.el.dataset.key;
  },

  getItem(key: string) {
    return localStorage.getItem(key);
  },

  setItem(key: string, value: string) {
    return localStorage.setItem(key, value);
  },

  mounted() {
    const key = this.key();
    this.pushEvent(`ls_restore_${key}`, { value: this.getItem(key) });
    this.handleEvent(`ls_update_${key}`, ({ value }) =&gt; this.setItem(key, value));
  },
};</file><file path="assets/js/hooks/localTime.ts">export default {
  mounted() {
    this.updated();
  },

  updated() {
    const dt = new Date(this.el.textContent);
    const options = { hour12: false };
    this.el.textContent = `${dt.toLocaleString(&apos;en-US&apos;, options)}`;
    this.el.classList.remove(&apos;invisible&apos;);
  },
};</file><file path="assets/js/hooks/newVersionUpdate.ts">const countdown = (secondsCount: number) =&gt; {
  let minutes, seconds;

  const dateEnd = new Date().getTime() + secondsCount * 1000;

  const timer = setInterval(calculate, 1000);

  function calculate() {
    const dateStartDefault = new Date();
    const dateStart = new Date(
      dateStartDefault.getUTCFullYear(),
      dateStartDefault.getUTCMonth(),
      dateStartDefault.getUTCDate(),
      dateStartDefault.getUTCHours(),
      dateStartDefault.getUTCMinutes(),
      dateStartDefault.getUTCSeconds(),
    );
    let timeRemaining = parseInt((dateEnd - dateStart.getTime()) / 1000);

    if (timeRemaining &gt;= 0) {
      timeRemaining = timeRemaining % 86400;
      timeRemaining = timeRemaining % 3600;
      minutes = parseInt(timeRemaining / 60);
      timeRemaining = timeRemaining % 60;
      seconds = parseInt(timeRemaining);

      document.getElementById(&apos;version-update-seconds&apos;).innerHTML = minutes * 60 + seconds;
    } else {
      return;
    }
  }
};

const LAST_VERSION_KEY = &apos;wandererLastVersion&apos;;

const updateVerion = (newVersion: string) =&gt; {
  localStorage.setItem(LAST_VERSION_KEY, newVersion);

  window.location.reload();
};

export default {
  mounted() {
    const hook = this;

    const refreshZone = hook.el.querySelector(&apos;#refresh-area&apos;);

    const handleUpdate = function (e: Event) {
      const hexBricks = hook.el.querySelectorAll(&apos;.hex-brick&apos;);

      // Add a new class to each element
      hexBricks.forEach(el =&gt; {
        el.classList.add(&apos;hex-brick--active&apos;);
      });

      updateVerion(hook.el.dataset.version);
    };

    refreshZone.addEventListener(&apos;click&apos;, handleUpdate);
    refreshZone.addEventListener(&apos;mouseover&apos;, handleUpdate);

    this.updated();
  },

  reconnected() {
    this.updated();
  },

  updated() {
    const hook = this;
    const activeVersion = this.getItem(LAST_VERSION_KEY);
    const lastVersion = hook.el.dataset.version;
    if (activeVersion === lastVersion) {
      return;
    }
    const enabled = hook.el.dataset.enabled;
    if (enabled === &apos;true&apos;) {
      hook.el.classList.remove(&apos;hidden&apos;);
      const autoRefreshTimeout = Math.floor(Math.random() * (150 - 75 + 1)) + 75;
      countdown(autoRefreshTimeout);
      setTimeout(() =&gt; {
        updateVerion(hook.el.dataset.version);
      }, autoRefreshTimeout * 1000);
    } else {
      updateVerion(hook.el.dataset.version);
    }
  },

  getItem(key: string) {
    return localStorage.getItem(key);
  },

  setItem(key: string, value: string) {
    return localStorage.setItem(key, value);
  },
};</file><file path="assets/js/hooks/ping.ts">export default {
  _nowMs: Date.now(),

  mounted() {
    const hook = this;
    this.handleEvent(&apos;pong&apos;, () =&gt; {
      const rtt = Date.now() - this._nowMs;
      hook.el.dataset.tip = `ping: ${rtt}ms`;

      setTimeout(() =&gt; {
        hook.ping(rtt);
      }, 1000 * 60);
    });
    this.ping(null);
  },
  reconnected() {
    this.ping(null);
  },
  disconnected() {
    // this.el.dataset.tip = `ping: No connection`;
    // this.el.classList.add(&apos;text-red-500&apos;);
  },
  ping(rtt) {
    this._nowMs = Date.now();
    this.pushEvent(&apos;ping&apos;, { rtt: rtt });
  },
};</file><file path="assets/js/hooks/showCharactersAddAlert.ts">export default {
  mounted() {
    this.pushEvent(&apos;restore_show_characters_add_alert&apos;, {
      value: localStorage.getItem(&apos;wanderer:hide_characters_add_alert&apos;) !== &apos;true&apos;,
    });

    document.getElementById(&apos;characters-add-alert-hide&apos;)?.addEventListener(&apos;click&apos;, e =&gt; {
      localStorage.setItem(&apos;wanderer:hide_characters_add_alert&apos;, &apos;true&apos;);
    });
  },
};</file><file path="assets/js/typings.d.ts">declare module &apos;*.module.scss&apos; {
  const styles: { [className: string]: string };
  export default styles;
}</file><file path="assets/lib/phoenix/index.js">// Include phoenix_html to handle method=PUT/DELETE in forms and buttons.
import &apos;phoenix_html&apos;;

import &apos;./live_reload.css&apos;;

const animateBg = function (bgCanvas) {
  const { TweenMax, _ } = window;
  /**
   * Utility function for returning a random integer in a given range
   * @param {Int} max
   * @param {Int} min
   */
  const randomInRange = (max, min) =&gt; Math.floor(Math.random() * (max - min + 1)) + min;
  const BASE_SIZE = 1;
  const VELOCITY_INC = 1.01;
  const VELOCITY_INIT_INC = 0.525;
  const JUMP_VELOCITY_INC = 0.55;
  const JUMP_SIZE_INC = 1.15;
  const SIZE_INC = 1.01;
  const RAD = Math.PI / 180;
  const WARP_COLORS = [
    [197, 239, 247],
    [25, 181, 254],
    [77, 5, 232],
    [165, 55, 253],
    [255, 255, 255],
  ];
  /**
   * Class for storing the particle metadata
   * position, size, length, speed etc.
   */
  class Star {
    STATE = {
      alpha: Math.random(),
      angle: randomInRange(0, 360) * RAD,
    };
    reset = () =&gt; {
      const angle = randomInRange(0, 360) * (Math.PI / 180);
      const vX = Math.cos(angle);
      const vY = Math.sin(angle);
      const travelled =
        Math.random() &gt; 0.5
          ? Math.random() * Math.max(window.innerWidth, window.innerHeight) + Math.random() * (window.innerWidth * 0.24)
          : Math.random() * (window.innerWidth * 0.25);
      this.STATE = {
        ...this.STATE,
        iX: undefined,
        iY: undefined,
        active: travelled ? true : false,
        x: Math.floor(vX * travelled) + window.innerWidth / 2,
        vX,
        y: Math.floor(vY * travelled) + window.innerHeight / 2,
        vY,
        size: BASE_SIZE,
      };
    };
    constructor() {
      this.reset();
    }
  }

  const generateStarPool = size =&gt; new Array(size).fill().map(() =&gt; new Star());

  // Class for the actual app
  // Not too much happens in here
  // Initiate the drawing process and listen for user interactions üëç
  class JumpToHyperspace {
    STATE = {
      stars: generateStarPool(300),
      bgAlpha: 0,
      sizeInc: SIZE_INC,
      velocity: VELOCITY_INC,
    };
    canvas = null;
    context = null;
    constructor(canvas) {
      this.canvas = canvas;
      this.context = canvas.getContext(&apos;2d&apos;);
      this.bind();
      this.setup();
      this.render();
    }
    render = () =&gt; {
      const {
        STATE: { bgAlpha, velocity, sizeInc, initiating, jumping, stars },
        context,
        render,
      } = this;
      // Clear the canvas
      context.clearRect(0, 0, window.innerWidth, window.innerHeight);
      if (bgAlpha &gt; 0) {
        context.fillStyle = `rgba(31, 58, 157, ${bgAlpha})`;
        context.fillRect(0, 0, window.innerWidth, window.innerHeight);
      }
      // 1. Shall we add a new star
      const nonActive = stars.filter(s =&gt; !s.STATE.active);
      if (!initiating &amp;&amp; nonActive.length &gt; 0) {
        // Introduce a star
        nonActive[0].STATE.active = true;
      }
      // 2. Update the stars and draw them.
      for (const star of stars.filter(s =&gt; s.STATE.active)) {
        const { active, x, y, iX, iY, iVX, iVY, size, vX, vY } = star.STATE;
        // Check if the star needs deactivating
        if (
          ((iX || x) &lt; 0 || (iX || x) &gt; window.innerWidth || (iY || y) &lt; 0 || (iY || y) &gt; window.innerHeight) &amp;&amp;
          active &amp;&amp;
          !initiating
        ) {
          star.reset(true);
        } else if (active) {
          const newIX = initiating ? iX : iX + iVX;
          const newIY = initiating ? iY : iY + iVY;
          const newX = x + vX;
          const newY = y + vY;
          // Just need to work out if it overtakes the original line that&apos;s all
          const caught =
            (vX &lt; 0 &amp;&amp; newIX &lt; x) || (vX &gt; 0 &amp;&amp; newIX &gt; x) || (vY &lt; 0 &amp;&amp; newIY &lt; y) || (vY &gt; 0 &amp;&amp; newIY &gt; y);
          star.STATE = {
            ...star.STATE,
            iX: caught ? undefined : newIX,
            iY: caught ? undefined : newIY,
            iVX: caught ? undefined : iVX * VELOCITY_INIT_INC,
            iVY: caught ? undefined : iVY * VELOCITY_INIT_INC,
            x: newX,
            vX: star.STATE.vX * velocity,
            y: newY,
            vY: star.STATE.vY * velocity,
            size: initiating ? size : size * (iX || iY ? SIZE_INC : sizeInc),
          };
          let color = `rgba(255, 255, 255, ${star.STATE.alpha})`;
          if (jumping) {
            const [r, g, b] = WARP_COLORS[randomInRange(0, WARP_COLORS.length)];
            color = `rgba(${r}, ${g}, ${b}, ${star.STATE.alpha})`;
          }
          context.strokeStyle = color;
          context.lineWidth = size;
          context.beginPath();
          context.moveTo(star.STATE.iX || x, star.STATE.iY || y);
          context.lineTo(star.STATE.x, star.STATE.y);
          context.stroke();
        }
      }
      requestAnimationFrame(render);
    };
    initiate = () =&gt; {
      if (this.STATE.jumping || this.STATE.initiating) return;
      this.STATE = {
        ...this.STATE,
        initiating: true,
        initiateTimestamp: new Date().getTime(),
      };
      TweenMax.to(this.STATE, 0.25, { velocity: VELOCITY_INIT_INC, bgAlpha: 0.3 });
      // When we initiate, stop the XY origin from moving so that we draw
      // longer lines until the jump
      for (const star of this.STATE.stars.filter(s =&gt; s.STATE.active)) {
        star.STATE = {
          ...star.STATE,
          iX: star.STATE.x,
          iY: star.STATE.y,
          iVX: star.STATE.vX,
          iVY: star.STATE.vY,
        };
      }
    };
    jump = () =&gt; {
      this.STATE = {
        ...this.STATE,
        bgAlpha: 0,
        jumping: true,
      };
      TweenMax.to(this.STATE, 0.25, { velocity: JUMP_VELOCITY_INC, bgAlpha: 0.75, sizeInc: JUMP_SIZE_INC });
      setTimeout(() =&gt; {
        this.STATE = {
          ...this.STATE,
          jumping: false,
        };
        TweenMax.to(this.STATE, 0.25, { bgAlpha: 0, velocity: VELOCITY_INC, sizeInc: SIZE_INC });
      }, 5000);
    };
    enter = () =&gt; {
      if (this.STATE.jumping) return;
      const { initiateTimestamp } = this.STATE;
      this.STATE = {
        ...this.STATE,
        initiating: false,
        initiateTimestamp: undefined,
      };
      if (new Date().getTime() - initiateTimestamp &gt; 600) {
        this.jump();
      } else {
        TweenMax.to(this.STATE, 0.25, { velocity: VELOCITY_INC, bgAlpha: 0 });
      }
    };
    bind = () =&gt; {
      this.canvas.addEventListener(&apos;mousedown&apos;, this.initiate);
      this.canvas.addEventListener(&apos;touchstart&apos;, this.initiate);
      this.canvas.addEventListener(&apos;mouseup&apos;, this.enter);
      this.canvas.addEventListener(&apos;touchend&apos;, this.enter);
    };
    setup = () =&gt; {
      this.context.lineCap = &apos;round&apos;;
      this.canvas.height = window.innerHeight;
      this.canvas.width = window.innerWidth;
    };
    reset = () =&gt; {
      this.STATE = {
        ...this.STATE,
        stars: generateStarPool(300),
      };
      this.setup();
    };
  }
  window.myJump = new JumpToHyperspace(bgCanvas);
  window.addEventListener(
    &apos;resize&apos;,
    _.debounce(() =&gt; {
      window.myJump.reset();
    }, 250),
  );
};

document.addEventListener(&apos;DOMContentLoaded&apos;, function () {
  // animage background
  const canvas = document.getElementById(&apos;bg-canvas&apos;);
  if (canvas) {
    animateBg(canvas);
  }

  // Select all buttons with the &apos;share-link&apos; class
  const buttons = document.querySelectorAll(&apos;button.copy-link&apos;);

  buttons.forEach(button =&gt; {
    button.addEventListener(&apos;click&apos;, function () {
      // Get the URL from the data attribute
      const url = button.dataset.url;

      button.classList.remove(&apos;copied&apos;);

      // Copy the URL to the clipboard
      navigator.clipboard
        .writeText(url)
        .then(() =&gt; {
          // Add the &apos;copied&apos; class to the button
          button.classList.add(&apos;copied&apos;);
        })
        .catch(err =&gt; {
          console.error(&apos;Failed to copy URL:&apos;, err);
        });
    });
  });

  const navbar = document.querySelector(&apos;navbar.navbar&apos;);

  const scrollState = {
    top: true,
    topThreshold: 10,
    onScroll: function () {
      if (this.top &amp;&amp; window.scrollY &gt; this.topThreshold) {
        this.top = false;
        this.updateUI();
      } else if (!this.top &amp;&amp; window.scrollY &lt;= this.topThreshold) {
        this.top = true;
        this.updateUI();
      }
    },
    updateUI: function () {
      navbar.classList.toggle(&apos;bg-opacity-30&apos;);
      navbar.classList.toggle(&apos;backdrop-filter&apos;);
      navbar.classList.toggle(&apos;backdrop-blur-lg&apos;);
    },
  };
  window.addEventListener(&apos;scroll&apos;, () =&gt; scrollState.onScroll());
});</file><file path="assets/lib/phoenix/live_reload.css">/* hide iframe of phoenix-live-reload */
iframe[hidden] {
  display: none;
}</file><file path="assets/lib/phoenix_live_view/index.js">/* Phoenix Socket and LiveView configuration. */

import { Socket } from &apos;phoenix&apos;;
import { LiveSocket } from &apos;phoenix_live_view&apos;;
import live_select from &apos;live_select&apos;;

import topbar from &apos;topbar&apos;;

import customHooks from &apos;../../js/hooks&apos;;

const csrfToken = document.querySelector(&quot;meta[name=&apos;csrf-token&apos;]&quot;).getAttribute(&apos;content&apos;);

const basePath = document.querySelector(&apos;html&apos;).dataset.basePath || &apos;&apos;;

const hooks = {
  ...customHooks,
  ...live_select,
};

const liveSocket = new LiveSocket(`${basePath}/live`, Socket, {
  params: { _csrf_token: csrfToken },
  hooks,
});

topbar.config({
  barThickness: 2,
  barColors: {
    0: &apos;rgba(0,  0, 0, .7)&apos;,
    &apos;1.0&apos;: &apos;rgba(34, 197, 94, .7)&apos;,
  },
  shadowColor: &apos;rgba(0, 0, 0, .3)&apos;,
});

const timeouts = new Map();

const execJS = (selector, attr) =&gt; {
  document.querySelectorAll(selector).forEach(el =&gt; liveSocket.execJS(el, el.getAttribute(attr)));
};

// Show progress bar on live navigation and form submits if the results do not appear within 200ms.
window.addEventListener(&apos;phx:page-loading-start&apos;, _info =&gt; topbar.show(500));
window.addEventListener(&apos;phx:page-loading-stop&apos;, _info =&gt; topbar.hide());
// loading transitions
window.addEventListener(&apos;phx:page-loading-start&apos;, info =&gt; {
  if (info.detail.kind == &apos;redirect&apos;) {
    const main = document.querySelector(&apos;.main&apos;);
    main.classList.add(&apos;phx-page-loading&apos;);
  }
});

window.addEventListener(&apos;phx:page-loading-stop&apos;, info =&gt; {
  const main = document.querySelector(&apos;.main&apos;);
  if (main) {
    main.classList.remove(&apos;phx-page-loading&apos;);
  }
});

window.addEventListener(&apos;phx:js-exec&apos;, ({ detail }) =&gt; {
  document.querySelectorAll(detail.to).forEach(el =&gt; {
    if (detail.timeout) {
      if (timeouts.has(detail.to)) {
        clearTimeout(timeouts.get(detail.to));
      }
      timeouts.set(
        detail.to,
        setTimeout(() =&gt; liveSocket.execJS(el, el.getAttribute(detail.attr)), detail.timeout),
      );
    } else {
      if (timeouts.has(detail.to)) {
        clearTimeout(timeouts.get(detail.to));
      }
      liveSocket.execJS(el, el.getAttribute(detail.attr));
    }
  });
});

window.addEventListener(&apos;phx:toggle-on&apos;, e =&gt; {
  let el = document.getElementById(e.detail.id);
  if (el) {
    el.checked = true;
  }
});

window.addEventListener(&apos;phx:live_reload:attached&apos;, ({ detail: reloader }) =&gt; {
  // Enable server log streaming to client.
  // Disable with reloader.disableServerLogs()
  // reloader.enableServerLogs();
  window.liveReloader = reloader;
});

window.addEventListener(&apos;phx:fade-out-flash&apos;, e =&gt; {
  const targetAttr = &apos;data-handle-fadeout-flash&apos;;
  document.querySelectorAll(`[${targetAttr}]`).forEach(el =&gt; {
    const key = el.getAttribute(&apos;phx-value-key&apos;);
    if (key == e.detail.type) {
      liveSocket.execJS(el, el.getAttribute(targetAttr));
    }
  });
});

// connect if there are any LiveViews on the page
liveSocket.getSocket().onOpen(() =&gt; execJS(&apos;#connection-status&apos;, &apos;js-hide&apos;));
liveSocket.getSocket().onClose(() =&gt; execJS(&apos;#connection-status&apos;, &apos;js-show&apos;));
liveSocket.getSocket().onError(() =&gt; execJS(&apos;#connection-status&apos;, &apos;js-show&apos;));

liveSocket.connect();

// expose liveSocket on window for web console debug logs and latency simulation:
// &gt;&gt; liveSocket.enableDebug()
// &gt;&gt; liveSocket.enableLatencySim(1000)  // enabled for duration of browser session
// &gt;&gt; liveSocket.disableLatencySim()
window.liveSocket = liveSocket;</file><file path="assets/lib/tailwind/colors.js">const colors = window.TAILWIND_COLORS;

export default colors;</file><file path="assets/lib/tailwind/index.css">@tailwind base;
@tailwind utilities;
@tailwind variants;</file><file path="assets/vendor/heroicons/LICENSE.md">MIT License

Copyright (c) 2020 Refactoring UI Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</file><file path="assets/vendor/heroicons/UPGRADE.md">You are running heroicons v2.0.16. To upgrade in place, you can run the following command,
where your `HERO_VSN` export is your desired version:

    export HERO_VSN=&quot;2.0.16&quot; ; \
      curl -L &quot;https://github.com/tailwindlabs/heroicons/archive/refs/tags/v${HERO_VSN}.tar.gz&quot; | \
      tar -xvz --strip-components=1 heroicons-${HERO_VSN}/optimized</file><file path="assets/vendor/topbar.js">/**
 * @license MIT
 * topbar 2.0.0, 2023-02-04
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
(function (window, document) {
  &quot;use strict&quot;;

  // https://gist.github.com/paulirish/1579671
  (function () {
    var lastTime = 0;
    var vendors = [&quot;ms&quot;, &quot;moz&quot;, &quot;webkit&quot;, &quot;o&quot;];
    for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame =
        window[vendors[x] + &quot;RequestAnimationFrame&quot;];
      window.cancelAnimationFrame =
        window[vendors[x] + &quot;CancelAnimationFrame&quot;] ||
        window[vendors[x] + &quot;CancelRequestAnimationFrame&quot;];
    }
    if (!window.requestAnimationFrame)
      window.requestAnimationFrame = function (callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () {
          callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    if (!window.cancelAnimationFrame)
      window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
      };
  })();

  var canvas,
    currentProgress,
    showing,
    progressTimerId = null,
    fadeTimerId = null,
    delayTimerId = null,
    addEvent = function (elem, type, handler) {
      if (elem.addEventListener) elem.addEventListener(type, handler, false);
      else if (elem.attachEvent) elem.attachEvent(&quot;on&quot; + type, handler);
      else elem[&quot;on&quot; + type] = handler;
    },
    options = {
      autoRun: true,
      barThickness: 3,
      barColors: {
        0: &quot;rgba(26,  188, 156, .9)&quot;,
        &quot;.25&quot;: &quot;rgba(52,  152, 219, .9)&quot;,
        &quot;.50&quot;: &quot;rgba(241, 196, 15,  .9)&quot;,
        &quot;.75&quot;: &quot;rgba(230, 126, 34,  .9)&quot;,
        &quot;1.0&quot;: &quot;rgba(211, 84,  0,   .9)&quot;,
      },
      shadowBlur: 10,
      shadowColor: &quot;rgba(0,   0,   0,   .6)&quot;,
      className: null,
    },
    repaint = function () {
      canvas.width = window.innerWidth;
      canvas.height = options.barThickness * 5; // need space for shadow

      var ctx = canvas.getContext(&quot;2d&quot;);
      ctx.shadowBlur = options.shadowBlur;
      ctx.shadowColor = options.shadowColor;

      var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      for (var stop in options.barColors)
        lineGradient.addColorStop(stop, options.barColors[stop]);
      ctx.lineWidth = options.barThickness;
      ctx.beginPath();
      ctx.moveTo(0, options.barThickness / 2);
      ctx.lineTo(
        Math.ceil(currentProgress * canvas.width),
        options.barThickness / 2
      );
      ctx.strokeStyle = lineGradient;
      ctx.stroke();
    },
    createCanvas = function () {
      canvas = document.createElement(&quot;canvas&quot;);
      var style = canvas.style;
      style.position = &quot;fixed&quot;;
      style.top = style.left = style.right = style.margin = style.padding = 0;
      style.zIndex = 100001;
      style.display = &quot;none&quot;;
      if (options.className) canvas.classList.add(options.className);
      document.body.appendChild(canvas);
      addEvent(window, &quot;resize&quot;, repaint);
    },
    topbar = {
      config: function (opts) {
        for (var key in opts)
          if (options.hasOwnProperty(key)) options[key] = opts[key];
      },
      show: function (delay) {
        if (showing) return;
        if (delay) {
          if (delayTimerId) return;
          delayTimerId = setTimeout(() =&gt; topbar.show(), delay);
        } else  {
          showing = true;
          if (fadeTimerId !== null) window.cancelAnimationFrame(fadeTimerId);
          if (!canvas) createCanvas();
          canvas.style.opacity = 1;
          canvas.style.display = &quot;block&quot;;
          topbar.progress(0);
          if (options.autoRun) {
            (function loop() {
              progressTimerId = window.requestAnimationFrame(loop);
              topbar.progress(
                &quot;+&quot; + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2)
              );
            })();
          }
        }
      },
      progress: function (to) {
        if (typeof to === &quot;undefined&quot;) return currentProgress;
        if (typeof to === &quot;string&quot;) {
          to =
            (to.indexOf(&quot;+&quot;) &gt;= 0 || to.indexOf(&quot;-&quot;) &gt;= 0
              ? currentProgress
              : 0) + parseFloat(to);
        }
        currentProgress = to &gt; 1 ? 1 : to;
        repaint();
        return currentProgress;
      },
      hide: function () {
        clearTimeout(delayTimerId);
        delayTimerId = null;
        if (!showing) return;
        showing = false;
        if (progressTimerId != null) {
          window.cancelAnimationFrame(progressTimerId);
          progressTimerId = null;
        }
        (function loop() {
          if (topbar.progress(&quot;+.1&quot;) &gt;= 1) {
            canvas.style.opacity -= 0.05;
            if (canvas.style.opacity &lt;= 0.05) {
              canvas.style.display = &quot;none&quot;;
              fadeTimerId = null;
              return;
            }
          }
          fadeTimerId = window.requestAnimationFrame(loop);
        })();
      },
    };

  if (typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;) {
    module.exports = topbar;
  } else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
    define(function () {
      return topbar;
    });
  } else {
    this.topbar = topbar;
  }
}.call(this, window, document));</file><file path="assets/.eslintrc.cjs">module.exports = {
  root: true,
  env: { browser: true, es2020: true, jest: true },
  extends: [
    &apos;eslint:recommended&apos;,
    &apos;plugin:react/recommended&apos;,
    &apos;plugin:@typescript-eslint/recommended&apos;,
    &apos;plugin:@typescript-eslint/eslint-recommended&apos;,
    &apos;prettier&apos;,
    &apos;plugin:prettier/recommended&apos;,
    &apos;plugin:react-hooks/recommended&apos;,
  ],
  ignorePatterns: [&apos;dist&apos;, &apos;.eslintrc.cjs&apos;],
  parser: &apos;@typescript-eslint/parser&apos;,
  plugins: [&apos;@typescript-eslint&apos;, &apos;react-refresh&apos;],
  rules: {
    &apos;react-refresh/only-export-components&apos;: [&apos;warn&apos;, { allowConstantExport: true }],
    &apos;react/react-in-jsx-scope&apos;: &apos;off&apos;,
    &apos;@typescript-eslint/ban-ts-comment&apos;: &apos;off&apos;,
  },
};</file><file path="assets/.gitignore"># Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?</file><file path="assets/.prettierrc">{
  &quot;singleQuote&quot;: true,
  &quot;trailingComma&quot;: &quot;all&quot;,
  &quot;printWidth&quot;: 120,
  &quot;arrowParens&quot;: &quot;avoid&quot;,
  &quot;bracketSpacing&quot;: true,
  &quot;semi&quot;: true,
  &quot;tabWidth&quot;: 2,
  &quot;useTabs&quot;: false,
  &quot;endOfLine&quot;: &quot;lf&quot;
}</file><file path="assets/app.tsx">import &apos;./css/app.css&apos;;

import &apos;./lib/phoenix&apos;;
import &apos;./lib/phoenix_live_view&apos;;</file><file path="assets/package.json">{
  &quot;name&quot;: &quot;assets&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;tailwind.config.js&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;vite build --emptyOutDir false&quot;,
    &quot;watch&quot;: &quot;vite build --watch --minify false --emptyOutDir false --clearScreen true --mode development&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 18.0.0&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@codemirror/lang-markdown&quot;: &quot;^6.3.2&quot;,
    &quot;@codemirror/theme-one-dark&quot;: &quot;^6.1.2&quot;,
    &quot;@formkit/auto-animate&quot;: &quot;0.7.0&quot;,
    &quot;@shopify/draggable&quot;: &quot;^1.1.3&quot;,
    &quot;@uiw/react-codemirror&quot;: &quot;^4.23.10&quot;,
    &quot;clsx&quot;: &quot;^2.1.1&quot;,
    &quot;daisyui&quot;: &quot;^4.11.1&quot;,
    &quot;fast-deep-equal&quot;: &quot;^3.1.3&quot;,
    &quot;live_select&quot;: &quot;file:../deps/live_select&quot;,
    &quot;lodash.debounce&quot;: &quot;^4.0.8&quot;,
    &quot;lodash.isequal&quot;: &quot;^4.5.0&quot;,
    &quot;phoenix&quot;: &quot;file:../deps/phoenix&quot;,
    &quot;phoenix_html&quot;: &quot;file:../deps/phoenix_html&quot;,
    &quot;phoenix_live_view&quot;: &quot;file:../deps/phoenix_live_view&quot;,
    &quot;primeflex&quot;: &quot;^3.3.1&quot;,
    &quot;primeicons&quot;: &quot;^7.0.0&quot;,
    &quot;primereact&quot;: &quot;10.6.5&quot;,
    &quot;prism-themes&quot;: &quot;^1.9.0&quot;,
    &quot;react&quot;: &quot;^18.3.1&quot;,
    &quot;react-dom&quot;: &quot;^18.3.1&quot;,
    &quot;react-error-boundary&quot;: &quot;^4.0.13&quot;,
    &quot;react-event-hook&quot;: &quot;^3.1.2&quot;,
    &quot;react-flow-renderer&quot;: &quot;^10.3.17&quot;,
    &quot;react-hook-form&quot;: &quot;^7.53.1&quot;,
    &quot;react-markdown&quot;: &quot;^10.0.1&quot;,
    &quot;react-transition-group&quot;: &quot;^4.4.5&quot;,
    &quot;react-usestateref&quot;: &quot;^1.0.9&quot;,
    &quot;reactflow&quot;: &quot;^11.11.4&quot;,
    &quot;remark-breaks&quot;: &quot;^4.0.0&quot;,
    &quot;remark-gfm&quot;: &quot;^4.0.1&quot;,
    &quot;tailwindcss&quot;: &quot;^3.3.6&quot;,
    &quot;topbar&quot;: &quot;^3.0.0&quot;,
    &quot;use-local-storage-state&quot;: &quot;^19.3.1&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@tailwindcss/aspect-ratio&quot;: &quot;^0.4.2&quot;,
    &quot;@tailwindcss/forms&quot;: &quot;^0.5.7&quot;,
    &quot;@tailwindcss/typography&quot;: &quot;^0.5.13&quot;,
    &quot;@types/lodash.debounce&quot;: &quot;^4.0.9&quot;,
    &quot;@types/lodash.isequal&quot;: &quot;^4.5.8&quot;,
    &quot;@types/react&quot;: &quot;^18.3.12&quot;,
    &quot;@types/react-dom&quot;: &quot;^18.3.1&quot;,
    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^6.21.0&quot;,
    &quot;@typescript-eslint/parser&quot;: &quot;^6.21.0&quot;,
    &quot;@vitejs/plugin-react&quot;: &quot;^4.3.3&quot;,
    &quot;@vitejs/plugin-react-refresh&quot;: &quot;^1.3.6&quot;,
    &quot;autoprefixer&quot;: &quot;^10.4.19&quot;,
    &quot;child_process&quot;: &quot;^1.0.2&quot;,
    &quot;eslint&quot;: &quot;^8.57.0&quot;,
    &quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,
    &quot;eslint-plugin-prettier&quot;: &quot;^5.1.3&quot;,
    &quot;eslint-plugin-react&quot;: &quot;^7.34.1&quot;,
    &quot;eslint-plugin-react-hooks&quot;: &quot;^4.6.0&quot;,
    &quot;eslint-plugin-react-refresh&quot;: &quot;^0.4.6&quot;,
    &quot;heroicons&quot;: &quot;^2.0.18&quot;,
    &quot;merge-options&quot;: &quot;^3.0.4&quot;,
    &quot;postcss&quot;: &quot;^8.4.38&quot;,
    &quot;postcss-cli&quot;: &quot;^11.0.0&quot;,
    &quot;postcss-import&quot;: &quot;^16.1.0&quot;,
    &quot;prettier&quot;: &quot;^3.2.5&quot;,
    &quot;sass&quot;: &quot;^1.77.2&quot;,
    &quot;sass-loader&quot;: &quot;^14.2.1&quot;,
    &quot;typescript&quot;: &quot;^5.2.2&quot;,
    &quot;vite&quot;: &quot;^5.0.5&quot;,
    &quot;vite-plugin-cdn-import&quot;: &quot;^1.0.1&quot;
  },
  &quot;peerDependencies&quot;: {
    &quot;react&quot;: &quot;18.3.1&quot;,
    &quot;react-dom&quot;: &quot;18.3.1&quot;
  },
  &quot;optionalDependencies&quot;: {
    &quot;@rollup/rollup-linux-x64-gnu&quot;: &quot;4.9.5&quot;
  },
  &quot;resolutions&quot;: {
    &quot;react&quot;: &quot;18.3.1&quot;,
    &quot;react-dom&quot;: &quot;18.3.1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;packageManager&quot;: &quot;yarn@1.22.22+sha512.a6b2f7906b721bba3d67d4aff083df04dad64c399707841b7acf00f6b133b7ac24255f2652fa22ae3534329dc6180534e98d17432037ff6fd140556e2bb3137e&quot;
}</file><file path="assets/postcss.config.js">module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};</file><file path="assets/tailwind.config.js">// See the Tailwind configuration guide for advanced usage
// https://tailwindcss.com/docs/configuration

const plugin = require(&apos;tailwindcss/plugin&apos;);
const colors = require(&apos;tailwindcss/colors&apos;);
const fs = require(&apos;fs&apos;);
const path = require(&apos;path&apos;);

module.exports = {
  content: [
    &apos;./js/**/*.js&apos;,
    &apos;./js/**/*.ts&apos;,
    &apos;./js/**/*.tsx&apos;,
    &apos;../lib/wanderer_app_web.ex&apos;,
    &apos;../lib/wanderer_app_web/**/*.*ex&apos;,
    &apos;../deps/live_select/lib/live_select/component.*ex&apos;,
  ],
  theme: {
    extend: {
      animation: {
        text: &apos;text 30s ease infinite&apos;,
        &apos;horizontal-bounce&apos;: &apos;horizontal-bounce 1.5s ease-in-out infinite&apos;,
        gradient: &apos;gradient 8s linear infinite&apos;,
        rotate: &apos;rotate 10s linear infinite&apos;,
      },
      colors: {
        brand: &apos;#FD4F00&apos;,
        primary: colors.rose,
        neutral: colors.slate,
        info: colors.blue,
        success: colors.green,
        danger: colors.red,
      },
      transitionProperty: [&apos;visibility&apos;],
      transitionDuration: {
        2000: &apos;2000ms&apos;,
      },
      transitionDelay: {
        2000: &apos;2000ms&apos;,
        5000: &apos;5000ms&apos;,
      },
      keyframes: {
        text: {
          &apos;0%, 100%&apos;: {
            &apos;background-size&apos;: &apos;200% 200%&apos;,
            &apos;background-position&apos;: &apos;left center&apos;,
          },
          &apos;50%&apos;: {
            &apos;background-size&apos;: &apos;200% 200%&apos;,
            &apos;background-position&apos;: &apos;right center&apos;,
          },
        },
        &apos;horizontal-bounce&apos;: {
          &apos;0%, 100%&apos;: {
            transform: &apos;translateX(0)&apos;,
          },
          &apos;50%&apos;: {
            transform: &apos;translateX(15px)&apos;,
          },
        },
        gradient: {
          to: { &apos;background-position&apos;: &apos;200% center&apos; },
        },
        rotate: {
          &apos;0%&apos;: { transform: &apos;rotate(0deg) scale(10)&apos; },
          &apos;100%&apos;: { transform: &apos;rotate(-360deg) scale(10)&apos; },
        },
      },
    },
  },
  plugins: [
    require(&apos;daisyui&apos;),
    require(&apos;@tailwindcss/forms&apos;),
    require(&apos;@tailwindcss/typography&apos;),
    // Allows prefixing tailwind classes with LiveView classes to add rules
    // only when LiveView classes are applied, for example:
    //
    //     &lt;div class=&quot;phx-click-loading:animate-ping&quot;&gt;
    //
    plugin(({ addVariant }) =&gt; addVariant(&apos;phx-no-feedback&apos;, [&apos;.phx-no-feedback&amp;&apos;, &apos;.phx-no-feedback &amp;&apos;])),
    plugin(({ addVariant }) =&gt; addVariant(&apos;phx-click-loading&apos;, [&apos;.phx-click-loading&amp;&apos;, &apos;.phx-click-loading &amp;&apos;])),
    plugin(({ addVariant }) =&gt; addVariant(&apos;phx-submit-loading&apos;, [&apos;.phx-submit-loading&amp;&apos;, &apos;.phx-submit-loading &amp;&apos;])),
    plugin(({ addVariant }) =&gt; addVariant(&apos;phx-change-loading&apos;, [&apos;.phx-change-loading&amp;&apos;, &apos;.phx-change-loading &amp;&apos;])),
    plugin(({ addVariant }) =&gt; addVariant(&apos;phx-page-loading&apos;, [&apos;.phx-page-loading&amp;&apos;, &apos;.phx-page-loading &amp;&apos;])),

    // Embeds Heroicons (https://heroicons.com) into your app.css bundle
    // See your `CoreComponents.icon/1` for more information.
    //
    plugin(function ({ matchComponents, theme }) {
      let iconsDir = path.join(__dirname, &apos;./vendor/heroicons/optimized&apos;);
      let values = {};
      let icons = [
        [&apos;&apos;, &apos;/24/outline&apos;],
        [&apos;-solid&apos;, &apos;/24/solid&apos;],
        [&apos;-mini&apos;, &apos;/20/solid&apos;],
      ];
      icons.forEach(([suffix, dir]) =&gt; {
        fs.readdirSync(path.join(iconsDir, dir)).forEach(file =&gt; {
          let name = path.basename(file, &apos;.svg&apos;) + suffix;
          values[name] = { name, fullPath: path.join(iconsDir, dir, file) };
        });
      });
      matchComponents(
        {
          hero: ({ name, fullPath }) =&gt; {
            let content = fs
              .readFileSync(fullPath)
              .toString()
              .replace(/\r?\n|\r/g, &apos;&apos;);
            return {
              [`--hero-${name}`]: `url(&apos;data:image/svg+xml;utf8,${content}&apos;)`,
              &apos;-webkit-mask&apos;: `var(--hero-${name})`,
              mask: `var(--hero-${name})`,
              &apos;mask-repeat&apos;: &apos;no-repeat&apos;,
              &apos;background-color&apos;: &apos;currentColor&apos;,
              &apos;vertical-align&apos;: &apos;middle&apos;,
              display: &apos;inline-block&apos;,
              width: theme(&apos;spacing.5&apos;),
              height: theme(&apos;spacing.5&apos;),
            };
          },
        },
        { values },
      );
    }),
  ],
};</file><file path="assets/tsconfig.json">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ES2020&quot;,
    &quot;useDefineForClassFields&quot;: true,
    &quot;lib&quot;: [&quot;ES2020&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,

    /* Bundler mode */
    &quot;moduleResolution&quot;: &quot;Node&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;resolveJsonModule&quot;: true,
    &quot;isolatedModules&quot;: true,
    &quot;noEmit&quot;: true,
    &quot;jsx&quot;: &quot;react-jsx&quot;,

    /* Linting */
    &quot;strict&quot;: true,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;esModuleInterop&quot;: true,
    &quot;baseUrl&quot;: &quot;./js&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [&quot;./*&quot;],
    }
  },
  &quot;include&quot;: [&quot;js&quot;]
}</file><file path="assets/vite-env.d.ts">/// &lt;reference types=&quot;vite/client&quot; /&gt;</file><file path="assets/vite.config.js">import path from &apos;path&apos;;

import react from &apos;@vitejs/plugin-react&apos;;

export default {
  publicDir: &apos;./static&apos;,
  plugins: [react()],
  build: {
    target: &apos;es2018&apos;,
    format: &apos;esm&apos;,
    minify: false,
    outDir: &apos;../priv/static&apos;,
    emptyOutDir: true,
    assetsInlineLimit: 0,
    rollupOptions: {
      input: [&apos;app.tsx&apos;],
      output: {
        entryFileNames: &apos;assets/[name].js&apos;,
        chunkFileNames: &apos;assets/[name]-[hash].js&apos;,
        assetFileNames: &apos;assets/[name][extname]&apos;,
      },
      onwarn(warning, warn) {
        if (warning.code === &apos;MODULE_LEVEL_DIRECTIVE&apos;) {
          return;
        }
        warn(warning);
      },
    },
  },
  resolve: {
    alias: {
      &apos;@&apos;: path.resolve(__dirname, &apos;js&apos;),
    },
  },
};</file><file path="config/config.exs"># This file is responsible for configuring your application
# and its dependencies with the aid of the Config module.
#
# This configuration file is loaded before any dependency and
# is restricted to this project.

# General application configuration
import Config

config :wanderer_app, WandererApp.Cache,
  # When using :shards as backend
  # backend: :shards,
  # GC interval for pushing new generation: 12 hrs
  gc_interval: :timer.hours(12),
  # Max 1 million entries in cache
  max_size: 1_000_000,
  # Max 2 GB of memory
  allocated_memory: 2_000_000_000,
  # GC min timeout: 10 sec
  gc_cleanup_min_timeout: :timer.seconds(10),
  # GC max timeout: 10 min
  gc_cleanup_max_timeout: :timer.minutes(10)

config :wanderer_app,
  ecto_repos: [WandererApp.Repo],
  ash_domains: [WandererApp.Api],
  generators: [timestamp_type: :utc_datetime],
  ddrt: DDRT,
  logger: Logger,
  pubsub_client: Phoenix.PubSub

config :wanderer_app, WandererAppWeb.Endpoint,
  adapter: Bandit.PhoenixAdapter,
  url: [host: &quot;localhost&quot;],
  render_errors: [
    formats: [html: WandererAppWeb.ErrorHTML, json: WandererAppWeb.ErrorJSON],
    layout: false
  ],
  pubsub_server: WandererApp.PubSub,
  live_view: [signing_salt: &quot;LjxzzFQ1&quot;]

config :ueberauth, Ueberauth,
  providers: [
    eve:
      {WandererApp.Ueberauth.Strategy.Eve,
       [
         default_scope:
           &quot;esi-location.read_location.v1 esi-location.read_ship_type.v1 esi-location.read_online.v1 esi-ui.write_waypoint.v1 esi-search.search_structures.v1&quot;,
         wallet_scope:
           &quot;esi-location.read_location.v1 esi-location.read_ship_type.v1 esi-location.read_online.v1 esi-ui.write_waypoint.v1 esi-search.search_structures.v1 esi-wallet.read_character_wallet.v1&quot;,
         admin_scope:
           &quot;esi-location.read_location.v1 esi-location.read_ship_type.v1 esi-location.read_online.v1 esi-ui.write_waypoint.v1 esi-search.search_structures.v1 esi-wallet.read_character_wallet.v1 esi-wallet.read_corporation_wallets.v1 esi-mail.send_mail.v1&quot;,
         callback_path: &quot;/auth/eve/callback&quot;
       ]}
  ]

config :wanderer_app, WandererApp.Mailer, adapter: Swoosh.Adapters.Local

config :dart_sass, :version, &quot;1.54.5&quot;

config :tailwind, :version, &quot;3.2.7&quot;

config :wanderer_app, WandererApp.PromEx, manual_metrics_start_delay: :no_delay

config :wanderer_app,
  grafana_datasource_id: &quot;wanderer&quot;

config :phoenix_ddos,
  protections: [
    # ip rate limit
    {PhoenixDDoS.IpRateLimit, allowed: 10_000, period: {1, :minute}},
    {PhoenixDDoS.IpRateLimit, allowed: 1_000_000, period: {1, :hour}},
    # ip rate limit on specific request_path
    {PhoenixDDoS.IpRateLimitPerRequestPath,
     request_paths: [&quot;/auth/eve&quot;], allowed: 100, period: {1, :minute}}
  ]

config :ash_pagify,
  default_limit: 50,
  max_limit: 1000,
  scopes: %{
    role: []
  },
  reset_on_filter?: true,
  replace_invalid_params?: true,
  pagination: [opts: {WandererAppWeb.CoreComponents, :pagination_opts}],
  table: [opts: {WandererAppWeb.CoreComponents, :table_opts}]

# Configures Elixir&apos;s Logger
config :logger, :console,
  format: &quot;$time $metadata[$level] $message\n&quot;,
  metadata: [:application, :module, :function, :line, :request_id]

# Use Jason for JSON parsing in Phoenix
config :phoenix, :json_library, Jason

config :error_tracker,
  repo: WandererApp.Repo,
  otp_app: :wanderer_app

config :git_ops,
  mix_project: Mix.Project.get!(),
  changelog_file: &quot;CHANGELOG.md&quot;,
  repository_url: &quot;https://github.com/wanderer-industries/wanderer&quot;,
  types: [
    # Makes an allowed commit type called `tidbit` that is not
    # shown in the changelog
    tidbit: [
      hidden?: true
    ],
    # Makes an allowed commit type called `important` that gets
    # a section in the changelog with the header &quot;Important Changes&quot;
    important: [
      header: &quot;Important Changes&quot;
    ]
  ],
  tags: [
    # Only add commits to the changelog that has the &quot;backend&quot; tag
    allowed: [&quot;feat&quot;, &quot;fix&quot;, &quot;docs&quot;],
    # Filter out or not commits that don&apos;t contain tags
    allow_untagged?: true
  ],
  # Instructs the tool to manage your mix version in your `mix.exs` file
  # See below for more information
  manage_mix_version?: true,
  # Instructs the tool to manage the version in your README.md
  # Pass in `true` to use `&quot;README.md&quot;` or a string to customize
  manage_readme_version: &quot;README.md&quot;,
  version_tag_prefix: &quot;v&quot;

# Import environment specific config. This must remain at the bottom
# of this file so it overrides the configuration defined above.
import_config &quot;#{config_env()}.exs&quot;</file><file path="config/dev.exs">import Config

# Configure your database
config :wanderer_app, WandererApp.Repo,
  username: &quot;postgres&quot;,
  password: &quot;postgres&quot;,
  hostname: System.get_env(&quot;DB_HOST&quot;, &quot;localhost&quot;),
  database: &quot;wanderer_dev&quot;,
  stacktrace: true,
  show_sensitive_data_on_connection_error: true,
  pool_size: 10

# For development, we disable any cache and enable
# debugging and code reloading.
#
# The watchers configuration can be used to run external
# watchers to your application. For example, we can use it
# to bundle .js and .css sources.
config :wanderer_app, WandererAppWeb.Endpoint,
  # Binding to loopback ipv4 address prevents access from other machines.
  # Change to `ip: {0, 0, 0, 0}` to allow access from other machines.
  http: [ip: {0, 0, 0, 0}, port: 4444],
  check_origin: false,
  code_reloader: true,
  debug_errors: true,
  secret_key_base: &quot;gnfLCueSfLAkvP1m2Y/wNa+YoCf6nxaWlalFQYkZ4KYRKQk7SzsUL+7NzuRjRiIs&quot;,
  watchers: [
    npm: [&quot;run&quot;, &quot;watch&quot;, cd: Path.expand(&quot;../assets&quot;, __DIR__)]
  ]

# ## SSL Support
#
# In order to use HTTPS in development, a self-signed
# certificate can be generated by running the following
# Mix task:
#
#     mix phx.gen.cert
#
# Run `mix help phx.gen.cert` for more information.
#
# The `http:` config above can be replaced with:
#
#     https: [
#       port: 4001,
#       cipher_suite: :strong,
#       keyfile: &quot;priv/cert/selfsigned_key.pem&quot;,
#       certfile: &quot;priv/cert/selfsigned.pem&quot;
#     ],
#
# If desired, both `http:` and `https:` keys can be
# configured to run both http and https servers on
# different ports.

# Watch static and templates for browser reloading.
config :wanderer_app, WandererAppWeb.Endpoint,
  live_reload: [
    interval: 1000,
    patterns: [
      ~r&quot;priv/static/.*(js|css|png|jpeg|jpg|gif|svg)$&quot;,
      ~r&quot;priv/gettext/.*(po)$&quot;,
      ~r&quot;lib/wanderer_app_web/(controllers|live|components)/.*(ex|heex)$&quot;
    ]
  ]

config :wanderer_app,
  dev_routes: true

# Do not include metadata nor timestamps in development logs
config :logger, :console, format: &quot;[$level] $message\n&quot;

# Set a higher stacktrace during development. Avoid configuring such
# in production as building large stacktraces may be expensive.
config :phoenix, :stacktrace_depth, 20

# Initialize plugs at runtime for faster development compilation
config :phoenix, :plug_init_mode, :runtime

# Include HEEx debug annotations as HTML comments in rendered markup
config :phoenix_live_view, :debug_heex_annotations, true

# Disable swoosh api client as it is only required for production adapters.
config :swoosh, :api_client, false

config :logger, :console,
  level: :info,
  format: &quot;$time $metadata[$level] $message\n&quot;</file><file path="config/prod.exs">import Config

# Note we also include the path to a cache manifest
# containing the digested version of static files. This
# manifest is generated by the `mix assets.deploy` task,
# which you should run after static files are built and
# before starting your production server.
config :wanderer_app, WandererAppWeb.Endpoint,
  cache_static_manifest: &quot;priv/static/cache_manifest.json&quot;

config :wanderer_app, WandererApp.Repo,
  ssl: false,
  stacktrace: true,
  show_sensitive_data_on_connection_error: true,
  pool_size: 15,
  migration_timestamps: [type: :utc_datetime_usec],
  migration_lock: nil,
  queue_target: 5000

# Configures Swoosh API Client
config :swoosh, api_client: Swoosh.ApiClient.Finch, finch_name: WandererApp.Finch

# Disable Swoosh Local Memory Storage
config :swoosh, local: false

# Do not print debug messages in production
config :logger,
  level: :info

# Runtime production configuration, including reading
# of environment variables, is done on config/runtime.exs.</file><file path="config/runtime.exs">import Config
import WandererApp.ConfigHelpers

if System.get_env(&quot;PHX_SERVER&quot;) do
  config :wanderer_app, WandererAppWeb.Endpoint, server: true
end

config_dir = System.get_env(&quot;CONFIG_DIR&quot;, &quot;/run/secrets&quot;)

app_name = System.get_env(&quot;FLY_APP_NAME&quot;, &quot;NOT_FLY_APP&quot;)

host =
  case app_name == &quot;NOT_FLY_APP&quot; do
    true -&gt; System.get_env(&quot;PHX_HOST&quot;, &quot;localhost&quot;)
    _ -&gt; &quot;#{app_name}.fly.dev&quot;
  end

web_port =
  System.get_env(
    &quot;PORT&quot;,
    case config_env() do
      :test -&gt; &quot;5000&quot;
      _env -&gt; &quot;8000&quot;
    end
  )
  |&gt; String.to_integer()

web_app_url =
  case app_name == &quot;NOT_FLY_APP&quot; do
    true -&gt; System.get_env(&quot;WEB_APP_URL&quot;, &quot;http://#{host}:#{web_port}&quot;)
    _ -&gt; &quot;https://#{host}&quot;
  end

base_url = URI.parse(web_app_url)

if base_url.scheme not in [&quot;http&quot;, &quot;https&quot;] do
  raise &quot;WEB_APP_URL must start with `http` or `https`. Currently configured as `#{System.get_env(&quot;WEB_APP_URL&quot;)}`&quot;
end

http_port = System.get_env(&quot;HTTP_PORT&quot;, &quot;80&quot;) |&gt; String.to_integer()
https_port = System.get_env(&quot;HTTPS_PORT&quot;, &quot;443&quot;) |&gt; String.to_integer()

port =
  case app_name == &quot;NOT_FLY_APP&quot; do
    true -&gt; System.get_env(&quot;WEB_EXTERNAL_PORT&quot;, &quot;#{web_port}&quot;) |&gt; String.to_integer()
    _ -&gt; http_port
  end

scheme = System.get_env(&quot;WEB_EXTERNAL_SCHEME&quot;, &quot;http&quot;)

public_api_disabled =
  config_dir
  |&gt; get_var_from_path_or_env(&quot;WANDERER_PUBLIC_API_DISABLED&quot;, &quot;false&quot;)
  |&gt; String.to_existing_atom()

character_api_disabled =
  config_dir
  |&gt; get_var_from_path_or_env(&quot;WANDERER_CHARACTER_API_DISABLED&quot;, &quot;true&quot;)
  |&gt; String.to_existing_atom()

zkill_preload_disabled =
  config_dir
  |&gt; get_var_from_path_or_env(&quot;WANDERER_ZKILL_PRELOAD_DISABLED&quot;, &quot;false&quot;)
  |&gt; String.to_existing_atom()

map_subscriptions_enabled =
  config_dir
  |&gt; get_var_from_path_or_env(&quot;WANDERER_MAP_SUBSCRIPTIONS_ENABLED&quot;, &quot;false&quot;)
  |&gt; String.to_existing_atom()

map_subscription_characters_limit =
  config_dir
  |&gt; get_int_from_path_or_env(&quot;WANDERER_MAP_SUBSCRIPTION_CHARACTERS_LIMIT&quot;, 10_000)

map_subscription_hubs_limit =
  config_dir
  |&gt; get_int_from_path_or_env(&quot;WANDERER_MAP_SUBSCRIPTION_HUBS_LIMIT&quot;, 10)

map_subscription_base_price =
  config_dir
  |&gt; get_int_from_path_or_env(&quot;WANDERER_MAP_SUBSCRIPTION_BASE_PRICE&quot;, 100_000_000)

map_subscription_extra_characters_100_price =
  config_dir
  |&gt; get_int_from_path_or_env(&quot;WANDERER_MAP_SUBSCRIPTION_EXTRA_CHARACTERS_100_PRICE&quot;, 50_000_000)

map_subscription_extra_hubs_10_price =
  config_dir
  |&gt; get_int_from_path_or_env(&quot;WANDERER_MAP_SUBSCRIPTION_EXTRA_HUBS_10_PRICE&quot;, 10_000_000)

map_connection_auto_expire_hours =
  config_dir
  |&gt; get_int_from_path_or_env(&quot;WANDERER_MAP_CONNECTION_AUTO_EXPIRE_HOURS&quot;, 24)

map_connection_auto_eol_hours =
  config_dir
  |&gt; get_int_from_path_or_env(&quot;WANDERER_MAP_CONNECTION_AUTO_EOL_HOURS&quot;, 21)

map_connection_eol_expire_timeout_mins =
  config_dir
  |&gt; get_int_from_path_or_env(&quot;WANDERER_MAP_CONNECTION_EOL_EXPIRE_TIMEOUT_MINS&quot;, 60)

wallet_tracking_enabled =
  config_dir
  |&gt; get_var_from_path_or_env(&quot;WANDERER_WALLET_TRACKING_ENABLED&quot;, &quot;false&quot;)
  |&gt; String.to_existing_atom()

admins =
  System.get_env(&quot;WANDERER_ADMINS&quot;, &quot;&quot;)
  |&gt; case do
    &quot;&quot; -&gt; []
    admins -&gt; admins |&gt; String.split(&quot;,&quot;)
  end

restrict_maps_creation =
  config_dir
  |&gt; get_var_from_path_or_env(&quot;WANDERER_RESTRICT_MAPS_CREATION&quot;, &quot;false&quot;)
  |&gt; String.to_existing_atom()

config :wanderer_app,
  web_app_url: web_app_url,
  git_sha: System.get_env(&quot;GIT_SHA&quot;, &quot;111&quot;),
  custom_route_base_url: System.get_env(&quot;CUSTOM_ROUTE_BASE_URL&quot;),
  invites: System.get_env(&quot;WANDERER_INVITES&quot;, &quot;false&quot;) |&gt; String.to_existing_atom(),
  admin_username: System.get_env(&quot;WANDERER_ADMIN_USERNAME&quot;, &quot;admin&quot;),
  admin_password: System.get_env(&quot;WANDERER_ADMIN_PASSWORD&quot;),
  admins: admins,
  corp_id: System.get_env(&quot;WANDERER_CORP_ID&quot;, &quot;-1&quot;) |&gt; String.to_integer(),
  corp_wallet: System.get_env(&quot;WANDERER_CORP_WALLET&quot;, &quot;&quot;),
  public_api_disabled: public_api_disabled,
  character_api_disabled: character_api_disabled,
  zkill_preload_disabled: zkill_preload_disabled,
  map_subscriptions_enabled: map_subscriptions_enabled,
  map_connection_auto_expire_hours: map_connection_auto_expire_hours,
  map_connection_auto_eol_hours: map_connection_auto_eol_hours,
  map_connection_eol_expire_timeout_mins: map_connection_eol_expire_timeout_mins,
  wallet_tracking_enabled: wallet_tracking_enabled,
  restrict_maps_creation: restrict_maps_creation,
  subscription_settings: %{
    plans: [
      %{
        id: &quot;alpha&quot;,
        characters_limit: map_subscription_characters_limit,
        hubs_limit: map_subscription_hubs_limit,
        base_price: 0,
        monthly_discount: 0
      },
      %{
        id: &quot;omega&quot;,
        characters_limit: map_subscription_characters_limit * 2,
        hubs_limit: map_subscription_hubs_limit * 2,
        base_price: map_subscription_base_price,
        month_3_discount: 0.2,
        month_6_discount: 0.4,
        month_12_discount: 0.5
      }
    ],
    extra_characters_100: map_subscription_extra_characters_100_price,
    extra_hubs_10: map_subscription_extra_hubs_10_price
  }

config :ueberauth, Ueberauth,
  providers: [
    eve:
      {WandererApp.Ueberauth.Strategy.Eve,
       [
         default_scope:
           &quot;esi-location.read_location.v1 esi-location.read_ship_type.v1 esi-location.read_online.v1 esi-ui.write_waypoint.v1 esi-search.search_structures.v1&quot;,
         wallet_scope:
           &quot;esi-location.read_location.v1 esi-location.read_ship_type.v1 esi-location.read_online.v1 esi-ui.write_waypoint.v1 esi-search.search_structures.v1 esi-wallet.read_character_wallet.v1&quot;,
         admin_scope:
           &quot;esi-location.read_location.v1 esi-location.read_ship_type.v1 esi-location.read_online.v1 esi-ui.write_waypoint.v1 esi-search.search_structures.v1 esi-wallet.read_character_wallet.v1 esi-wallet.read_corporation_wallets.v1 esi-mail.send_mail.v1&quot;,
         callback_url: &quot;#{web_app_url}/auth/eve/callback&quot;
       ]}
  ]

config :ueberauth, WandererApp.Ueberauth.Strategy.Eve.OAuth,
  client_id: {WandererApp.Ueberauth, :client_id},
  client_secret: {WandererApp.Ueberauth, :client_secret},
  client_id_default: System.get_env(&quot;EVE_CLIENT_ID&quot;, &quot;&lt;EVE_CLIENT_ID&gt;&quot;),
  client_id_with_wallet:
    System.get_env(&quot;EVE_CLIENT_WITH_WALLET_ID&quot;, &quot;&lt;EVE_CLIENT_WITH_WALLET_ID&gt;&quot;),
  client_id_with_corp_wallet:
    System.get_env(&quot;EVE_CLIENT_WITH_CORP_WALLET_ID&quot;, &quot;&lt;EVE_CLIENT_WITH_CORP_WALLET_ID&gt;&quot;),
  client_secret_default: System.get_env(&quot;EVE_CLIENT_SECRET&quot;, &quot;&lt;EVE_CLIENT_SECRET&gt;&quot;),
  client_secret_with_wallet:
    System.get_env(&quot;EVE_CLIENT_WITH_WALLET_SECRET&quot;, &quot;&lt;EVE_CLIENT_WITH_WALLET_SECRET&gt;&quot;),
  client_secret_with_corp_wallet:
    System.get_env(&quot;EVE_CLIENT_WITH_CORP_WALLET_SECRET&quot;, &quot;&lt;EVE_CLIENT_WITH_CORP_WALLET_SECRET&gt;&quot;)

config :logger,
  truncate: :infinity,
  level:
    String.to_existing_atom(
      System.get_env(
        &quot;LOG_LEVEL&quot;,
        case config_env() do
          :prod -&gt; &quot;info&quot;
          :dev -&gt; &quot;info&quot;
          :test -&gt; &quot;debug&quot;
        end
      )
    )

sheduler_jobs =
  map_subscriptions_enabled
  |&gt; case do
    true -&gt;
      [
        {&quot;@hourly&quot;, {WandererApp.Map.SubscriptionManager, :process, []}}
      ]

    _ -&gt;
      []
  end

config :wanderer_app, WandererApp.Scheduler,
  timezone: :utc,
  jobs:
    [
      {&quot;@daily&quot;, {WandererApp.Map.Audit, :archive, []}}
    ] ++ sheduler_jobs,
  timeout: :infinity

if config_env() == :prod do
  database_unix_socket =
    System.get_env(&quot;DATABASE_UNIX_SOCKET&quot;)

  database =
    database_unix_socket
    |&gt; case do
      nil -&gt;
        System.get_env(&quot;DATABASE_URL&quot;) ||
          raise &quot;&quot;&quot;
          environment variable DATABASE_URL is missing.
          For example: ecto://USER:PASS@HOST/DATABASE
          &quot;&quot;&quot;

      _ -&gt;
        System.get_env(&quot;DATABASE_NAME&quot;) ||
          raise &quot;&quot;&quot;
          environment variable DATABASE_NAME is missing.
          For example: &quot;wanderer&quot;
          &quot;&quot;&quot;
    end

  config :wanderer_app, WandererApp.Repo,
    pool_size: String.to_integer(System.get_env(&quot;POOL_SIZE&quot;) || &quot;10&quot;)

  if not is_nil(database_unix_socket) do
    config :wanderer_app, WandererApp.Repo,
      socket_dir: database_unix_socket,
      database: database
  else
    db_ssl_enabled =
      config_dir
      |&gt; get_var_from_path_or_env(&quot;DATABASE_SSL_ENABLED&quot;, &quot;false&quot;)
      |&gt; String.to_existing_atom()

    db_ssl_verify_none =
      config_dir
      |&gt; get_var_from_path_or_env(&quot;DATABASE_SSL_VERIFY_NONE&quot;, &quot;false&quot;)
      |&gt; String.to_existing_atom()

    client_opts =
      if db_ssl_verify_none do
        [verify: :verify_none]
      end

    maybe_ipv6 =
      config_dir
      |&gt; get_var_from_path_or_env(&quot;ECTO_IPV6&quot;, &quot;false&quot;)
      |&gt; String.to_existing_atom()
      |&gt; case do
        true -&gt; [:inet6]
        _ -&gt; []
      end

    config :wanderer_app, WandererApp.Repo,
      url: database,
      ssl: db_ssl_enabled,
      ssl_opts: client_opts,
      socket_options: maybe_ipv6
  end

  # The secret key base is used to sign/encrypt cookies and other secrets.
  # A default value is used in config/dev.exs and config/test.exs but you
  # want to use a different value for prod and you most likely don&apos;t want
  # to check this value into version control, so we use an environment
  # variable instead.
  secret_key_base =
    System.get_env(&quot;SECRET_KEY_BASE&quot;) ||
      raise &quot;&quot;&quot;
      environment variable SECRET_KEY_BASE is missing.
      You can generate one by calling: mix phx.gen.secret
      &quot;&quot;&quot;

  config :wanderer_app, :dns_cluster_query, System.get_env(&quot;DNS_CLUSTER_QUERY&quot;)

  config :wanderer_app, WandererAppWeb.Endpoint,
    url: [scheme: base_url.scheme, host: base_url.host, path: base_url.path, port: base_url.port],
    http: [
      # Enable IPv6 and bind on all interfaces.
      # Set it to  {0, 0, 0, 0, 0, 0, 0, 1} for local network only access.
      # See the documentation on https://hexdocs.pm/plug_cowboy/Plug.Cowboy.html
      # for details about using IPv6 vs IPv4 and loopback vs public addresses.
      ip: {0, 0, 0, 0},
      port: web_port
    ],
    secret_key_base: secret_key_base

  if scheme == &quot;https&quot; &amp;&amp; http_port do
    config :wanderer_app, WandererAppWeb.Endpoint,
      url: [host: host, port: 443, scheme: scheme],
      server: true,
      force_ssl: [hsts: true],
      http: [
        port: http_port
      ],
      https: [
        port: https_port,
        cipher_suite: :strong,
        otp_app: :wanderer_app,
        keyfile: &quot;/certs/private.key&quot;,
        certfile: &quot;/certs/certificate.crt&quot;
      ]

    config :wanderer_app, WandererApp.PromEx,
      grafana: [
        host: System.get_env(&quot;GRAFANA_CLOUD_HOST&quot;, &quot;&lt;GRAFANA_CLOUD_HOST&gt;&quot;),
        auth_token: System.get_env(&quot;GRAFANA_CLOUD_AUTH_TOKEN&quot;, &quot;&lt;GRAFANA_CLOUD_AUTH_TOKEN&gt;&quot;),
        folder_name: System.get_env(&quot;GRAFANA_CLOUD_FOLDER_NAME&quot;, &quot;wanderer&quot;),
        upload_dashboards_on_start: true
      ]

    config :wanderer_app,
      grafana_datasource_id: System.get_env(&quot;GRAFANA_DATASOURCE_ID&quot;, &quot;wanderer&quot;)
  end

  promex_disabled? =
    config_dir
    |&gt; get_var_from_path_or_env(&quot;PROMEX_DISABLED&quot;, &quot;true&quot;)
    |&gt; String.to_existing_atom()

  config :wanderer_app, WandererApp.PromEx,
    disabled: promex_disabled?,
    manual_metrics_start_delay: :no_delay,
    metrics_server: [
      port: System.get_env(&quot;METRICS_PORT&quot;, &quot;4021&quot;) |&gt; String.to_integer(),
      path: &quot;/metrics&quot;,
      protocol: :http,
      pool_size: 5,
      cowboy_opts: [ip: {0, 0, 0, 0}]
    ]
end

# License Manager API Configuration
config :wanderer_app, :license_manager,
  api_url: System.get_env(&quot;LM_API_URL&quot;, &quot;http://localhost:4000&quot;),
  auth_key: System.get_env(&quot;LM_AUTH_KEY&quot;)</file><file path="config/test.exs">import Config

# Configure your database
#
# The MIX_TEST_PARTITION environment variable can be used
# to provide built-in test partitioning in CI environment.
# Run `mix help test` for more information.
config :wanderer_app, WandererApp.Repo,
  username: &quot;postgres&quot;,
  password: &quot;postgres&quot;,
  hostname: &quot;localhost&quot;,
  database: &quot;wanderer_test#{System.get_env(&quot;MIX_TEST_PARTITION&quot;)}&quot;,
  pool: Ecto.Adapters.SQL.Sandbox,
  pool_size: 10

config :wanderer_app,
  ddrt: Test.DDRTMock,
  logger: Test.LoggerMock,
  pubsub_client: Test.PubSubMock

# We don&apos;t run a server during test. If one is required,
# you can enable the server option below.
config :wanderer_app, WandererAppWeb.Endpoint,
  http: [ip: {127, 0, 0, 1}, port: 4002],
  secret_key_base: &quot;EwyoYRR07BYb4vIbKfPni4LVtxAxEIRtyNPpeKx2sJbErbvWrT+0pOMzONlJDzcL&quot;,
  server: false

# In test we don&apos;t send emails.
config :wanderer_app, WandererApp.Mailer, adapter: Swoosh.Adapters.Test

# Disable swoosh api client as it is only required for production adapters.
config :swoosh, :api_client, false

# Print only warnings and errors during test
config :logger, level: :warning

# Initialize plugs at runtime for faster test compilation
config :phoenix, :plug_init_mode, :runtime</file><file path="lib/wanderer_app/api/calculations/calc_map_permissions.ex">defmodule WandererApp.Api.Calculations.CalcMapPermissions do
  @moduledoc false

  use Ash.Resource.Calculation
  require Ash.Query

  @impl true
  def load(_query, _opts, _context) do
    [
      acls: [
        :owner_id,
        members: [:role, :eve_character_id, :eve_corporation_id, :eve_alliance_id]
      ]
    ]
  end

  @impl true
  def calculate([record], _opts, %{actor: actor}),
    do: WandererApp.Permissions.check_characters_access(actor.characters, record.acls)

  @impl true
  def calculate(_records, _opts, _context) do
    [0]
  end
end</file><file path="lib/wanderer_app/api/changes/slugify_name.ex">defmodule WandererApp.Api.Changes.SlugifyName do
  use Ash.Resource.Change

  alias Ash.Changeset

  @impl true
  @spec change(Changeset.t(), keyword, Change.context()) :: Changeset.t()
  def change(changeset, _options, _context) do
    Changeset.before_action(changeset, &amp;maybe_slugify_name/1)
  end

  defp maybe_slugify_name(changeset) do
    case Changeset.get_attribute(changeset, :slug) do
      slug when is_binary(slug) -&gt;
        Changeset.change_attribute(changeset, :slug, Slug.slugify(slug))

      _ -&gt;
        changeset
    end
  end
end</file><file path="lib/wanderer_app/api/preparations/filter_acls_by_roles.ex">defmodule WandererApp.Api.Preparations.FilterAclsByRoles do
  @moduledoc false

  use Ash.Resource.Preparation
  require Ash.Query

  def prepare(query, _params, %{actor: nil}) do
    query
    |&gt; Ash.Query.load([:owner, :members])
  end

  def prepare(query, _params, %{actor: actor}) do
    query
    |&gt; filter_membership(actor)
    |&gt; Ash.Query.load([:owner, :members])
  end

  defp filter_membership(query, actor) do
    characters = actor.characters

    character_ids = characters |&gt; Enum.map(&amp; &amp;1.id)
    character_eve_ids = characters |&gt; Enum.map(&amp; &amp;1.eve_id)

    Ash.Query.filter(
      query,
      owner_id in ^character_ids or
        (members.eve_character_id in ^character_eve_ids and members.role in [:admin, :manager])
    )
  end
end</file><file path="lib/wanderer_app/api/preparations/filter_maps_by_roles.ex">defmodule WandererApp.Api.Preparations.FilterMapsByRoles do
  @moduledoc false

  use Ash.Resource.Preparation
  require Ash.Query

  def prepare(query, _params, %{actor: nil}) do
    query
    |&gt; Ash.Query.filter(expr(deleted == false))
    |&gt; Ash.Query.load([:owner, :acls])
  end

  def prepare(query, _params, %{actor: actor}) do
    query
    |&gt; Ash.Query.filter(expr(deleted == false))
    |&gt; filter_membership(actor)
    |&gt; Ash.Query.load([:owner, :acls])
  end

  defp filter_membership(query, actor) do
    characters = actor.characters

    character_ids = characters |&gt; Enum.map(&amp; &amp;1.id)
    character_eve_ids = characters |&gt; Enum.map(&amp; &amp;1.eve_id)

    character_corporation_ids =
      characters |&gt; Enum.map(&amp; &amp;1.corporation_id) |&gt; Enum.map(&amp;to_string/1)

    character_alliance_ids = characters |&gt; Enum.map(&amp; &amp;1.alliance_id) |&gt; Enum.map(&amp;to_string/1)

    query
    |&gt; Ash.Query.filter(
      owner_id in ^character_ids or
        (acls.owner_id in ^character_ids or
           acls.members.eve_character_id in ^character_eve_ids or
           acls.members.eve_corporation_id in ^character_corporation_ids or
           acls.members.eve_alliance_id in ^character_alliance_ids)
    )
  end
end</file><file path="lib/wanderer_app/api/preparations/load_character.ex">defmodule WandererApp.Api.Preparations.LoadCharacter do
  @moduledoc false

  use Ash.Resource.Preparation
  require Ash.Query

  def prepare(query, _params, _) do
    query
    |&gt; Ash.Query.load([:character])
  end
end</file><file path="lib/wanderer_app/api/access_list_member.ex">defmodule WandererApp.Api.AccessListMember do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;access_list_members_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)
    define(:update_role, action: :update_role)
    define(:block, action: :block)
    define(:unblock, action: :unblock)
    define(:read_by_access_list, action: :read_by_access_list)
    define(:destroy, action: :destroy)

    define(:by_id,
      get_by: [:id],
      action: :read
    )
  end

  actions do
    default_accept [
      :access_list_id,
      :name,
      :eve_character_id,
      :eve_corporation_id,
      :eve_alliance_id,
      :role
    ]

    defaults [:create, :read, :update, :destroy]

    read :read_by_access_list do
      argument(:access_list_id, :string, allow_nil?: false)
      filter(expr(access_list_id == ^arg(:access_list_id)))
    end

    update :update_role do
      accept [:role]
      require_atomic? false
    end

    update :block do
      accept([])

      change(set_attribute(:blocked, true))
    end

    update :unblock do
      accept([])

      change(set_attribute(:blocked, false))
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :name, :string do
      allow_nil? false
    end

    attribute :eve_character_id, :string do
      allow_nil? true
    end

    attribute :eve_corporation_id, :string do
      allow_nil? true
    end

    attribute :eve_alliance_id, :string do
      allow_nil? true
    end

    attribute :role, :atom do
      default &quot;viewer&quot;

      constraints(
        one_of: [
          :admin,
          :manager,
          :member,
          :viewer,
          :blocked
        ]
      )

      allow_nil?(true)
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :access_list, WandererApp.Api.AccessList do
      attribute_writable? true
    end
  end

  postgres do
    references do
      reference :access_list, on_delete: :delete
    end
  end

  identities do
    identity :uniq_acl_character_id, [:access_list_id, :eve_character_id] do
      pre_check?(true)
    end

    identity :uniq_acl_corporation_id, [:access_list_id, :eve_corporation_id] do
      pre_check?(true)
    end

    identity :uniq_acl_alliance_id, [:access_list_id, :eve_alliance_id] do
      pre_check?(true)
    end
  end
end</file><file path="lib/wanderer_app/api/access_list.ex">defmodule WandererApp.Api.AccessList do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;access_lists_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)
    define(:available, action: :available)
    define(:new, action: :new)
    define(:read, action: :read)
    define(:update, action: :update)
    define(:destroy, action: :destroy)

    define(:by_id,
      get_by: [:id],
      action: :read
    )
  end

  actions do
    default_accept [
      :name,
      :description,
      :owner_id
    ]

    defaults [:create, :read, :destroy]

    read :available do
      prepare WandererApp.Api.Preparations.FilterAclsByRoles
    end

    create :new do
      # Added :api_key to the accepted attributes
      accept [:name, :description, :owner_id, :api_key]
      primary?(true)

      argument :owner_id, :uuid, allow_nil?: false

      change manage_relationship(:owner_id, :owner, on_lookup: :relate, on_no_match: nil)
    end

    update :update do
      accept [:name, :description, :owner_id, :api_key]
      primary?(true)
    end

    update :assign_owner do
      accept [:owner_id]
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :name, :string do
      allow_nil? false
    end

    attribute :description, :string do
      allow_nil? true
    end

    attribute :api_key, :string do
      allow_nil? true
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :owner, WandererApp.Api.Character do
      attribute_writable? true
    end

    has_many :members, WandererApp.Api.AccessListMember
  end
end</file><file path="lib/wanderer_app/api/character.ex">defmodule WandererApp.Api.Character do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer,
    extensions: [AshCloak]

  postgres do
    repo(WandererApp.Repo)
    table(&quot;character_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)
    define(:read, action: :read)
    define(:search_by_name, action: :search_by_name)
    define(:assign_user, action: :assign)
    define(:update, action: :update)
    define(:update_online, action: :update_online)
    define(:update_location, action: :update_location)
    define(:update_ship, action: :update_ship)
    define(:update_corporation, action: :update_corporation)
    define(:update_alliance, action: :update_alliance)
    define(:update_wallet_balance, action: :update_wallet_balance)
    define(:mark_as_deleted, action: :mark_as_deleted)

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_eve_id,
      get_by: [:eve_id],
      action: :read
    )

    define(:active_by_user,
      action: :active_by_user
    )
  end

  actions do
    default_accept [
      :eve_id,
      :name,
      :access_token,
      :refresh_token,
      :expires_at,
      :scopes
    ]

    defaults [:create, :read, :destroy]

    create :link do
      accept([:eve_id, :name, :user_id])
    end

    read :search_by_name do
      argument :name, :string, allow_nil?: true

      filter expr(contains(string_downcase(name), string_downcase(^arg(:name))))
    end

    read :active_by_user do
      argument(:user_id, :uuid, allow_nil?: false)
      filter(expr(user_id == ^arg(:user_id) and deleted == false))
    end

    read :available_by_map do
      argument(:map_id, :uuid, allow_nil?: false)
      filter(expr(user_id == ^arg(:user_id) and deleted == false))
    end

    update :assign do
      accept []
      require_atomic? false

      argument :user_id, :uuid do
        allow_nil? false
      end

      change manage_relationship(:user_id, :user, type: :append_and_remove)
    end

    update :update do
      require_atomic? false
      accept([:name, :access_token, :refresh_token, :expires_at, :scopes])

      change(set_attribute(:deleted, false))
    end

    update :mark_as_deleted do
      accept([])

      change(atomic_update(:deleted, true))
      change(atomic_update(:user_id, nil))
    end

    update :update_online do
      accept([:online])
    end

    update :update_location do
      require_atomic? false

      accept([:solar_system_id, :structure_id, :station_id])
    end

    update :update_ship do
      require_atomic? false

      accept([:ship, :ship_name, :ship_item_id])
    end

    update :update_corporation do
      require_atomic? false

      accept([:corporation_id, :corporation_name, :corporation_ticker, :alliance_id])
    end

    update :update_alliance do
      require_atomic? false

      accept([:alliance_id, :alliance_name, :alliance_ticker])
    end

    update :update_wallet_balance do
      require_atomic? false

      accept([:eve_wallet_balance])
    end
  end

  cloak do
    vault(WandererApp.Vault)

    attributes([
      :eve_wallet_balance,
      :location,
      :ship,
      :solar_system_id,
      :structure_id,
      :station_id,
      :access_token,
      :refresh_token
    ])

    decrypt_by_default([
      :location,
      :ship,
      :solar_system_id,
      :structure_id,
      :station_id,
      :access_token,
      :refresh_token
    ])
  end

  attributes do
    uuid_primary_key :id

    attribute :eve_id, :string do
      allow_nil? false
    end

    attribute :name, :string do
      allow_nil? false
    end

    attribute :online, :boolean do
      default(false)
      allow_nil?(true)
    end

    attribute :deleted, :boolean do
      default(false)
      allow_nil?(true)
    end

    attribute :scopes, :string
    attribute :character_owner_hash, :string
    attribute :access_token, :string
    attribute :refresh_token, :string
    attribute :token_type, :string
    attribute :expires_at, :integer
    attribute :location, :string
    attribute :solar_system_id, :integer
    attribute :structure_id, :integer
    attribute :station_id, :integer
    attribute :ship, :integer
    attribute :ship_name, :string
    attribute :ship_item_id, :integer
    attribute :corporation_id, :integer
    attribute :corporation_name, :string
    attribute :corporation_ticker, :string
    attribute :alliance_id, :integer
    attribute :alliance_name, :string
    attribute :alliance_ticker, :string
    attribute :eve_wallet_balance, :float

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :user, WandererApp.Api.User do
      attribute_writable? true
    end
  end

  identities do
    identity :unique_eve_id, [:eve_id]
  end
end</file><file path="lib/wanderer_app/api/corp_wallet_transaction.ex">defmodule WandererApp.Api.CorpWalletTransaction do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer,
    extensions: [AshCloak]

  postgres do
    repo(WandererApp.Repo)
    table(&quot;corp_wallet_transactions_v1&quot;)
  end

  code_interface do
    define(:latest, action: :read)
    define(:new, action: :new)

    define(:latest_by_characters,
      action: :latest_by_characters
    )
  end

  actions do
    default_accept [
      :eve_transaction_id,
      :amount_encoded,
      :balance_encoded,
      :first_party_id,
      :second_party_id,
      :date,
      :description,
      :reason_encoded,
      :ref_type
    ]

    defaults [:create, :read, :update, :destroy]

    create :new do
      accept [
        :eve_transaction_id,
        :amount_encoded,
        :balance_encoded,
        :first_party_id,
        :second_party_id,
        :date,
        :description,
        :reason_encoded,
        :ref_type
      ]

      primary?(true)
      upsert? true
      upsert_identity :eve_transaction_id

      upsert_fields [
        :amount_encoded,
        :balance_encoded,
        :first_party_id,
        :second_party_id,
        :date,
        :description,
        :reason_encoded,
        :ref_type
      ]
    end

    read :latest_by_characters do
      argument(:eve_character_ids, {:array, :integer}, allow_nil?: false)
      filter(expr(first_party_id in ^arg(:eve_character_ids)))
    end
  end

  cloak do
    vault(WandererApp.Vault)

    attributes([
      :amount_encoded,
      :balance_encoded,
      :reason_encoded
    ])

    decrypt_by_default([
      :amount_encoded,
      :balance_encoded,
      :reason_encoded
    ])
  end

  attributes do
    uuid_primary_key :id

    attribute :eve_transaction_id, :integer do
      allow_nil? false
    end

    attribute :amount_encoded, :float do
      allow_nil? false
    end

    attribute :balance_encoded, :float do
      allow_nil? false
    end

    attribute :first_party_id, :integer do
      allow_nil? false
    end

    attribute :second_party_id, :integer do
      allow_nil? false
    end

    attribute :date, :utc_datetime do
      allow_nil? true
    end

    attribute :description, :string
    attribute :reason_encoded, :string
    attribute :ref_type, :string

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  identities do
    identity :eve_transaction_id, [:eve_transaction_id] do
      pre_check?(true)
    end
  end
end</file><file path="lib/wanderer_app/api/license.ex">defmodule WandererApp.Api.License do
  @moduledoc &quot;&quot;&quot;
  Schema for bot licenses.

  A license is associated with a map subscription and allows access to bot functionality.
  Licenses have a unique key, validity status, and expiration date.
  &quot;&quot;&quot;

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_licenses_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)
    define(:by_id, get_by: [:id], action: :read)
    define(:by_key, get_by: [:license_key], action: :read)
    define(:by_map_id, action: :by_map_id)
    define(:invalidate, action: :invalidate)
    define(:set_valid, action: :set_valid)
    define(:update_expire_at, action: :update_expire_at)
    define(:update_key, action: :update_key)
    define(:destroy, action: :destroy)
  end

  actions do
    default_accept [
      :lm_id,
      :map_id,
      :license_key,
      :is_valid,
      :expire_at
    ]

    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      upsert? true
      upsert_identity :uniq_map_id

      upsert_fields [
        :lm_id,
        :is_valid,
        :license_key,
        :expire_at
      ]
    end

    read :by_map_id do
      argument(:map_id, :uuid, allow_nil?: false)
      filter(expr(map_id == ^arg(:map_id)))
    end

    update :invalidate do
      accept([])

      change(set_attribute(:is_valid, false))
    end

    update :set_valid do
      accept([])

      change(set_attribute(:is_valid, true))
    end

    update :update_expire_at do
      accept [:expire_at]
      require_atomic? false
    end

    update :update_key do
      accept [:license_key]
      require_atomic? false
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :lm_id, :string do
      allow_nil? false
    end

    attribute :license_key, :string do
      allow_nil? false
    end

    attribute :is_valid, :boolean do
      default true
      allow_nil? false
    end

    attribute :expire_at, :utc_datetime do
      allow_nil? true
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :map, WandererApp.Api.Map do
      attribute_writable? true
    end
  end

  identities do
    identity :uniq_map_id, [:map_id] do
      pre_check?(true)
    end
  end
end</file><file path="lib/wanderer_app/api/map_access_list.ex">defmodule WandererApp.Api.MapAccessList do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_access_lists_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)

    define(:read_by_map,
      action: :read_by_map
    )
  end

  actions do
    default_accept [
      :map_id,
      :access_list_id
    ]

    defaults [:create, :read, :update, :destroy]

    read :read_by_map do
      argument(:map_id, :string, allow_nil?: false)
      filter(expr(map_id == ^arg(:map_id)))
    end
  end

  attributes do
    uuid_primary_key :id

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :map, WandererApp.Api.Map, primary_key?: true, allow_nil?: false
    belongs_to :access_list, WandererApp.Api.AccessList, primary_key?: true, allow_nil?: false
  end

  postgres do
    references do
      reference :map, on_delete: :delete
      reference :access_list, on_delete: :delete
    end
  end

  identities do
    identity :unique_map_acl, [:map_id, :access_list_id] do
      pre_check?(false)
    end
  end
end</file><file path="lib/wanderer_app/api/map_chain_passages.ex">defmodule WandererApp.Api.MapChainPassages do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  import Ecto.Query

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_chain_passages_v1&quot;)
  end

  code_interface do
    define(:new, action: :new)
    define(:read, action: :read)
    define(:by_map_id, action: :by_map_id)
    define(:by_connection, action: :by_connection)
  end

  actions do
    default_accept [
      :ship_type_id,
      :ship_name,
      :solar_system_source_id,
      :solar_system_target_id
    ]

    defaults [:create, :read, :update, :destroy]

    create :new do
      accept [
        :ship_type_id,
        :ship_name,
        :solar_system_source_id,
        :solar_system_target_id,
        :map_id,
        :character_id
      ]

      primary?(true)

      argument :map_id, :uuid, allow_nil?: false
      argument :character_id, :uuid, allow_nil?: false

      change manage_relationship(:map_id, :map, on_lookup: :relate, on_no_match: nil)
      change manage_relationship(:character_id, :character, on_lookup: :relate, on_no_match: nil)
    end

    action :by_map_id, {:array, :struct} do
      argument(:map_id, :string, allow_nil?: false)

      run fn input, _context -&gt;
        from(p in __MODULE__,
          join: c in assoc(p, :character),
          where:
            p.map_id == ^input.arguments.map_id and
              c.id == p.character_id,
          group_by: [c.id],
          select: [c, count()]
        )
        |&gt; WandererApp.Repo.all()
        |&gt; Enum.map(fn [character, count] -&gt; %{character: character, count: count} end)
        |&gt; Enum.sort_by(&amp; &amp;1.count, :desc)
        |&gt; then(&amp;{:ok, &amp;1})
      end
    end

    action :by_connection, {:array, :struct} do
      argument(:map_id, :string, allow_nil?: false)
      argument(:from, :string, allow_nil?: false)
      argument(:to, :string, allow_nil?: false)
      argument(:after, :utc_datetime, allow_nil?: false)

      run fn input, _context -&gt;
        from(p in __MODULE__,
          join: c in assoc(p, :character),
          where:
            p.map_id == ^input.arguments.map_id and
              c.id == p.character_id and
              p.solar_system_source_id == ^input.arguments.from and
              p.solar_system_target_id == ^input.arguments.to and
              p.inserted_at &gt;= ^input.arguments.after,
          select: [p, c]
        )
        |&gt; WandererApp.Repo.all()
        |&gt; Enum.map(fn [passage, character] -&gt;
          %{
            ship_type_id: passage.ship_type_id,
            ship_name: passage.ship_name,
            inserted_at: passage.inserted_at,
            character: character
          }
        end)
        |&gt; Enum.sort_by(&amp; &amp;1.inserted_at, :desc)
        |&gt; then(&amp;{:ok, &amp;1})
      end
    end
  end

  aggregates do
    count :jumps, :character do
      filter expr(not is_nil(character_id))
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :ship_type_id, :integer
    attribute :ship_name, :string
    attribute :solar_system_source_id, :integer
    attribute :solar_system_target_id, :integer

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :map, WandererApp.Api.Map,
      primary_key?: true,
      allow_nil?: false,
      attribute_writable?: true

    belongs_to :character, WandererApp.Api.Character,
      primary_key?: true,
      allow_nil?: false,
      attribute_writable?: true
  end
end</file><file path="lib/wanderer_app/api/map_character_settings.ex">defmodule WandererApp.Api.MapCharacterSettings do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer,
    extensions: [AshCloak]

  @derive {Jason.Encoder,
           only: [
             :id,
             :map_id,
             :character_id,
             :tracked,
             :followed,
             :inserted_at,
             :updated_at
           ]}

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_character_settings_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)
    define(:destroy, action: :destroy)
    define(:update, action: :update)

    define(:read_by_map, action: :read_by_map)
    define(:read_by_map_and_character, action: :read_by_map_and_character)
    define(:by_map_filtered, action: :by_map_filtered)
    define(:tracked_by_map_filtered, action: :tracked_by_map_filtered)
    define(:tracked_by_character, action: :tracked_by_character)
    define(:tracked_by_map_all, action: :tracked_by_map_all)

    define(:track, action: :track)
    define(:untrack, action: :untrack)

    define(:follow, action: :follow)
    define(:unfollow, action: :unfollow)
  end

  actions do
    default_accept [
      :map_id,
      :character_id,
      :tracked
    ]

    defaults [:read, :destroy]

    create :create do
      primary? true
      upsert? true
      upsert_identity :uniq_map_character

      upsert_fields [
        :map_id,
        :character_id
      ]

      accept [
        :map_id,
        :character_id,
        :tracked,
        :followed
      ]

      argument :map_id, :uuid, allow_nil?: false
      argument :character_id, :uuid, allow_nil?: false

      change manage_relationship(:map_id, :map, on_lookup: :relate, on_no_match: nil)
      change manage_relationship(:character_id, :character, on_lookup: :relate, on_no_match: nil)
    end

    read :by_map_filtered do
      argument(:map_id, :string, allow_nil?: false)
      argument(:character_ids, {:array, :uuid}, allow_nil?: false)

      filter(expr(map_id == ^arg(:map_id) and character_id in ^arg(:character_ids)))
    end

    read :tracked_by_map_filtered do
      argument(:map_id, :string, allow_nil?: false)
      argument(:character_ids, {:array, :uuid}, allow_nil?: false)

      filter(
        expr(map_id == ^arg(:map_id) and tracked == true and character_id in ^arg(:character_ids))
      )
    end

    read :read_by_map do
      argument(:map_id, :string, allow_nil?: false)
      filter(expr(map_id == ^arg(:map_id)))
    end

    read :read_by_map_and_character do
      get? true

      argument(:map_id, :string, allow_nil?: false)
      argument(:character_id, :uuid, allow_nil?: false)

      filter(expr(map_id == ^arg(:map_id) and character_id == ^arg(:character_id)))
    end

    read :tracked_by_map_all do
      argument(:map_id, :string, allow_nil?: false)
      filter(expr(map_id == ^arg(:map_id) and tracked == true))
    end

    read :tracked_by_character do
      argument(:character_id, :uuid, allow_nil?: false)
      filter(expr(character_id == ^arg(:character_id) and tracked == true))
    end

    update :update do
      primary? true
      require_atomic? false

      accept([
        :ship,
        :ship_name,
        :ship_item_id,
        :solar_system_id,
        :structure_id,
        :station_id
      ])
    end

    update :track do
      accept [:map_id, :character_id]
      argument :map_id, :string, allow_nil?: false
      argument :character_id, :uuid, allow_nil?: false

      # Load the record first
      load do
        filter expr(map_id == ^arg(:map_id) and character_id == ^arg(:character_id))
      end

      # Only update the tracked field
      change set_attribute(:tracked, true)
    end

    update :untrack do
      accept [:map_id, :character_id]
      argument :map_id, :string, allow_nil?: false
      argument :character_id, :uuid, allow_nil?: false

      # Load the record first
      load do
        filter expr(map_id == ^arg(:map_id) and character_id == ^arg(:character_id))
      end

      # Only update the tracked field
      change set_attribute(:tracked, false)
    end

    update :follow do
      accept [:map_id, :character_id]
      argument :map_id, :string, allow_nil?: false
      argument :character_id, :uuid, allow_nil?: false

      # Load the record first
      load do
        filter expr(map_id == ^arg(:map_id) and character_id == ^arg(:character_id))
      end

      # Only update the followed field
      change set_attribute(:followed, true)
    end

    update :unfollow do
      accept [:map_id, :character_id]
      argument :map_id, :string, allow_nil?: false
      argument :character_id, :uuid, allow_nil?: false

      # Load the record first
      load do
        filter expr(map_id == ^arg(:map_id) and character_id == ^arg(:character_id))
      end

      # Only update the followed field
      change set_attribute(:followed, false)
    end
  end

  cloak do
    vault(WandererApp.Vault)

    attributes([
      :ship,
      :ship_name,
      :ship_item_id,
      :solar_system_id,
      :structure_id,
      :station_id
    ])

    decrypt_by_default([
      :ship,
      :ship_name,
      :ship_item_id,
      :solar_system_id,
      :structure_id,
      :station_id
    ])
  end

  attributes do
    uuid_primary_key :id

    attribute :tracked, :boolean do
      default false
      allow_nil? true
    end

    attribute :followed, :boolean do
      default false
      allow_nil? true
    end

    attribute :solar_system_id, :integer
    attribute :structure_id, :integer
    attribute :station_id, :integer
    attribute :ship, :integer
    attribute :ship_name, :string
    attribute :ship_item_id, :integer

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :map, WandererApp.Api.Map, primary_key?: true, allow_nil?: false
    belongs_to :character, WandererApp.Api.Character, primary_key?: true, allow_nil?: false
  end

  identities do
    identity :uniq_map_character, [:map_id, :character_id]
  end
end</file><file path="lib/wanderer_app/api/map_connection.ex">defmodule WandererApp.Api.MapConnection do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_chain_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_locations, action: :read_by_locations)

    define(:read_by_map, action: :read_by_map)
    define(:get_link_pairs_advanced, action: :get_link_pairs_advanced)
    define(:destroy, action: :destroy)

    define(:update_mass_status, action: :update_mass_status)
    define(:update_time_status, action: :update_time_status)
    define(:update_ship_size_type, action: :update_ship_size_type)
    define(:update_locked, action: :update_locked)
    define(:update_custom_info, action: :update_custom_info)
    define(:update_type, action: :update_type)
    define(:update_wormhole_type, action: :update_wormhole_type)
  end

  actions do
    default_accept [
      :map_id,
      :solar_system_source,
      :solar_system_target,
      :type,
      :ship_size_type
    ]

    defaults [:create, :read, :update, :destroy]

    read :read_by_map do
      argument(:map_id, :string, allow_nil?: false)
      filter(expr(map_id == ^arg(:map_id)))
    end

    read :read_by_locations do
      argument(:map_id, :string, allow_nil?: false)
      argument(:solar_system_source, :integer, allow_nil?: false)
      argument(:solar_system_target, :integer, allow_nil?: false)

      filter(
        expr(
          map_id == ^arg(:map_id) and solar_system_source == ^arg(:solar_system_source) and
            solar_system_target == ^arg(:solar_system_target)
        )
      )
    end

    read :get_link_pairs_advanced do
      argument(:map_id, :string, allow_nil?: false)
      argument(:include_mass_crit, :boolean, allow_nil?: false)
      argument(:include_eol, :boolean, allow_nil?: false)
      argument(:include_frig, :boolean, allow_nil?: false)

      filter(
        expr(
          map_id == ^arg(:map_id) and (^arg(:include_mass_crit) or mass_status != 2) and
            (^arg(:include_eol) or time_status != 1) and
            (^arg(:include_frig) or ship_size_type != 0)
        )
      )
    end

    update :update_mass_status do
      accept [:mass_status]
    end

    update :update_time_status do
      accept [:time_status]
    end

    update :update_ship_size_type do
      accept [:ship_size_type]
    end

    update :update_locked do
      accept [:locked]
    end

    update :update_custom_info do
      accept [:custom_info]
    end

    update :update_type do
      accept [:type]
    end

    update :update_wormhole_type do
      accept [:wormhole_type]
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :solar_system_source, :integer
    attribute :solar_system_target, :integer

    # where 0 - greater than half
    # where 1 - less than half
    # where 2 - critical less than 10%
    attribute :mass_status, :integer do
      default(0)

      allow_nil?(true)
    end

    # where 0 - normal
    # where 1 - end of life
    attribute :time_status, :integer do
      default(0)

      allow_nil?(true)
    end

    # where 0 - Frigate (small
    # where 1 - Medium
    # where 2 - Large
    # where 3 - Freight
    # where 4 - Capital
    attribute :ship_size_type, :integer do
      default(2)

      allow_nil?(true)
    end

    # where 0 - Wormhole
    # where 1 - Gate
    attribute :type, :integer do
      default(0)

      allow_nil?(true)
    end

    attribute :wormhole_type, :string

    attribute :count_of_passage, :integer do
      default(0)

      allow_nil?(true)
    end

    attribute :locked, :boolean

    attribute :custom_info, :string do
      allow_nil? true
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :map, WandererApp.Api.Map do
      attribute_writable? true
    end
  end
end</file><file path="lib/wanderer_app/api/map_solar_system_jumps.ex">defmodule WandererApp.Api.MapSolarSystemJumps do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_solar_system_jumps_v1&quot;)
  end

  code_interface do
    define(:read,
      action: :read
    )

    define(:find, action: :find)
  end

  actions do
    default_accept [
      :from_solar_system_id,
      :to_solar_system_id
    ]

    defaults [:read, :destroy, :update]

    create :create do
      primary? true
      upsert? true
      upsert_identity :solar_system_from_to

      upsert_fields [
        :from_solar_system_id,
        :to_solar_system_id
      ]
    end

    read :find do
      argument(:before_system_id, :integer, allow_nil?: false)
      argument(:current_system_id, :integer, allow_nil?: false)

      filter(
        expr(
          (from_solar_system_id == ^arg(:before_system_id) and
             to_solar_system_id == ^arg(:current_system_id)) or
            (to_solar_system_id == ^arg(:before_system_id) and
               from_solar_system_id == ^arg(:current_system_id))
        )
      )
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :from_solar_system_id, :integer
    attribute :to_solar_system_id, :integer

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  identities do
    identity :solar_system_from_to, [:from_solar_system_id, :to_solar_system_id] do
      pre_check?(true)
    end
  end
end</file><file path="lib/wanderer_app/api/map_solar_system.ex">defmodule WandererApp.Api.MapSolarSystem do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_solar_system_v2&quot;)
  end

  code_interface do
    define(:read,
      action: :read
    )

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_solar_system_id,
      get_by: [:solar_system_id],
      action: :read
    )

    define(:find_by_name, action: :find_by_name)
    define(:get_wh_class_a, action: :get_wh_class_a)
    define(:get_trig_systems, action: :get_trig_systems)
  end

  actions do
    default_accept [
      :solar_system_id,
      :region_id,
      :constellation_id,
      :solar_system_name,
      :solar_system_name_lc,
      :constellation_name,
      :region_name,
      :system_class,
      :security,
      :type_description,
      :class_title,
      :is_shattered,
      :effect_name,
      :effect_power,
      :statics,
      :wandering,
      :triglavian_invasion_status,
      :sun_type_id
    ]

    defaults [:read, :destroy, :update]

    create :create do
      primary? true
      upsert? true
      upsert_identity :solar_system_id

      upsert_fields [
        :region_id,
        :constellation_id,
        :solar_system_name,
        :solar_system_name_lc,
        :constellation_name,
        :region_name,
        :system_class,
        :security,
        :type_description,
        :class_title,
        :is_shattered,
        :effect_name,
        :effect_power,
        :statics,
        :wandering,
        :triglavian_invasion_status,
        :sun_type_id
      ]
    end

    read :find_by_name do
      argument(:name, :string, allow_nil?: false)

      filter(expr(contains(solar_system_name_lc, string_downcase(^arg(:name)))))
    end

    read :get_wh_class_a do
      filter(expr(system_class == 1))
    end

    read :get_trig_systems do
      filter(expr(triglavian_invasion_status != &quot;Normal&quot;))
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :region_id, :integer
    attribute :constellation_id, :integer
    attribute :solar_system_id, :integer
    attribute :solar_system_name, :string
    attribute :solar_system_name_lc, :string
    attribute :constellation_name, :string
    attribute :region_name, :string
    attribute :system_class, :integer
    attribute :security, :string
    attribute :type_description, :string
    attribute :class_title, :string
    attribute :is_shattered, :boolean
    attribute :effect_name, :string
    attribute :effect_power, :integer

    attribute :statics, {:array, :string} do
      allow_nil?(true)

      default([])
    end

    attribute :wandering, {:array, :string} do
      allow_nil?(true)

      default([])
    end

    attribute :triglavian_invasion_status, :string
    attribute :sun_type_id, :integer

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  identities do
    identity :solar_system_id, [:solar_system_id] do
      pre_check?(true)
    end
  end
end</file><file path="lib/wanderer_app/api/map_state.ex">defmodule WandererApp.Api.MapState do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_state_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)
    define(:update, action: :update)
    define(:destroy, action: :destroy)

    define(:get_last_active, action: :last_active, args: [:from])

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_map_id,
      get_by: [:map_id],
      action: :read
    )
  end

  actions do
    default_accept [
      :map_id,
      :systems_last_activity,
      :connections_eol_time,
      :connections_start_time
    ]

    defaults [:read, :update, :destroy]

    create :create do
      primary? true
      upsert? true
      upsert_identity :uniq_map_id

      upsert_fields [
        :systems_last_activity,
        :connections_eol_time,
        :connections_start_time,
        :updated_at
      ]
    end

    read :last_active do
      argument(:from, :utc_datetime, allow_nil?: false)

      filter(expr(updated_at &gt; ^arg(:from)))
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :systems_last_activity, WandererApp.Schema.AshErlangBinary do
      allow_nil?(true)
    end

    attribute :connections_start_time, WandererApp.Schema.AshErlangBinary do
      allow_nil?(true)
    end

    attribute :connections_eol_time, WandererApp.Schema.AshErlangBinary do
      allow_nil?(true)
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :map, WandererApp.Api.Map do
      attribute_writable? true
    end
  end

  identities do
    identity(:uniq_map_id, [:map_id])
  end
end</file><file path="lib/wanderer_app/api/map_subscription.ex">defmodule WandererApp.Api.MapSubscription do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_subscriptions_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:all_active, action: :all_active)
    define(:all_by_map, action: :all_by_map)
    define(:active_by_map, action: :active_by_map)
    define(:destroy, action: :destroy)
    define(:cancel, action: :cancel)
    define(:expire, action: :expire)

    define(:update_plan, action: :update_plan)
    define(:update_characters_limit, action: :update_characters_limit)
    define(:update_hubs_limit, action: :update_hubs_limit)
    define(:update_active_till, action: :update_active_till)
    define(:update_auto_renew, action: :update_auto_renew)
  end

  actions do
    default_accept [
      :map_id,
      :plan,
      :active_till,
      :characters_limit,
      :hubs_limit,
      :auto_renew?
    ]

    defaults [:create, :read, :update, :destroy]

    read :all_active do
      prepare build(sort: [updated_at: :asc])

      filter(expr(status == :active))
    end

    read :all_by_map do
      argument(:map_id, :uuid, allow_nil?: false)

      prepare build(sort: [updated_at: :desc])

      filter(expr(map_id == ^arg(:map_id)))
    end

    read :active_by_map do
      argument(:map_id, :uuid, allow_nil?: false)

      prepare build(sort: [updated_at: :desc])

      filter(expr(map_id == ^arg(:map_id) and status == :active))
    end

    update :update_plan do
      accept [:plan]
    end

    update :update_characters_limit do
      accept [:characters_limit]
    end

    update :update_hubs_limit do
      accept [:hubs_limit]
    end

    update :update_active_till do
      accept [:active_till]
    end

    update :update_auto_renew do
      accept [:auto_renew?]
    end

    update :cancel do
      accept([])

      change(set_attribute(:status, :cancelled))
    end

    update :expire do
      accept([])

      change(set_attribute(:status, :expired))
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :plan, :atom do
      default &quot;alpha&quot;

      constraints(
        one_of: [
          :alpha,
          :omega,
          :advanced,
          :custom
        ]
      )

      allow_nil?(true)
    end

    attribute :status, :atom do
      default &quot;active&quot;

      constraints(
        one_of: [
          :active,
          :cancelled,
          :expired
        ]
      )

      allow_nil?(true)
    end

    attribute :characters_limit, :integer do
      default(100)

      allow_nil?(true)
    end

    attribute :hubs_limit, :integer do
      default(10)

      allow_nil?(true)
    end

    attribute :active_till, :utc_datetime do
      allow_nil? true
    end

    attribute :auto_renew?, :boolean do
      allow_nil? false
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :map, WandererApp.Api.Map do
      attribute_writable? true
    end
  end
end</file><file path="lib/wanderer_app/api/map_system_comment.ex">defmodule WandererApp.Api.MapSystemComment do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_system_comments_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)
    define(:destroy, action: :destroy)

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_system_id, action: :by_system_id, args: [:system_id])
  end

  actions do
    default_accept [
      :system_id,
      :character_id,
      :text
    ]

    defaults [:read, :destroy]

    create :create do
      primary? true

      accept [
        :system_id,
        :character_id,
        :text
      ]

      argument :system_id, :uuid, allow_nil?: false
      argument :character_id, :uuid, allow_nil?: false

      change manage_relationship(:system_id, :system, on_lookup: :relate, on_no_match: nil)
      change manage_relationship(:character_id, :character, on_lookup: :relate, on_no_match: nil)
    end

    read :by_system_id do
      argument(:system_id, :string, allow_nil?: false)

      filter(expr(system_id == ^arg(:system_id)))
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :text, :string do
      allow_nil? false
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :system, WandererApp.Api.MapSystem do
      attribute_writable? true
    end

    belongs_to :character, WandererApp.Api.Character do
      attribute_writable? true
    end
  end
end</file><file path="lib/wanderer_app/api/map_system_signature.ex">defmodule WandererApp.Api.MapSystemSignature do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_system_signatures_v1&quot;)
  end

  code_interface do
    define(:all_active, action: :all_active)
    define(:create, action: :create)
    define(:update, action: :update)
    define(:update_linked_system, action: :update_linked_system)
    define(:update_type, action: :update_type)
    define(:update_group, action: :update_group)

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_system_id, action: :by_system_id, args: [:system_id])
    define(:by_system_id_all, action: :by_system_id_all, args: [:system_id])

    define(:by_system_id_and_eve_ids,
      action: :by_system_id_and_eve_ids,
      args: [:system_id, :eve_ids]
    )

    define(:by_linked_system_id, action: :by_linked_system_id, args: [:linked_system_id])

    define(:by_deleted_and_updated_before!,
      action: :by_deleted_and_updated_before,
      args: [:deleted, :updated_before]
    )
  end

  actions do
    default_accept [
      :system_id,
      :eve_id,
      :character_eve_id,
      :name,
      :description,
      :kind,
      :group,
      :type,
      :deleted
    ]

    defaults [:read, :destroy]

    read :all_active do
      prepare build(sort: [updated_at: :desc])
    end

    create :create do
      primary? true
      upsert? true
      upsert_identity :uniq_system_eve_id

      upsert_fields [
        :system_id,
        :eve_id
      ]

      accept [
        :system_id,
        :eve_id,
        :character_eve_id,
        :name,
        :description,
        :kind,
        :group,
        :type,
        :custom_info,
        :deleted
      ]

      argument :system_id, :uuid, allow_nil?: false

      change manage_relationship(:system_id, :system, on_lookup: :relate, on_no_match: nil)
    end

    update :update do
      accept [
        :system_id,
        :eve_id,
        :character_eve_id,
        :name,
        :description,
        :kind,
        :group,
        :type,
        :custom_info,
        :deleted,
        :update_forced_at
      ]

      primary? true
      require_atomic? false
    end

    update :update_linked_system do
      accept [:linked_system_id]
    end

    update :update_type do
      accept [:type]
    end

    update :update_group do
      accept [:group]
    end

    read :by_system_id do
      argument(:system_id, :string, allow_nil?: false)

      filter(expr(system_id == ^arg(:system_id) and deleted == false))
    end

    read :by_system_id_all do
      argument(:system_id, :string, allow_nil?: false)
      filter(expr(system_id == ^arg(:system_id)))
    end

    read :by_system_id_and_eve_ids do
      argument(:system_id, :string, allow_nil?: false)
      argument(:eve_ids, {:array, :string}, allow_nil?: false)
      filter(expr(system_id == ^arg(:system_id) and eve_id in ^arg(:eve_ids)))
    end

    read :by_linked_system_id do
      argument(:linked_system_id, :integer, allow_nil?: false)

      filter(expr(linked_system_id == ^arg(:linked_system_id)))
    end

    read :by_deleted_and_updated_before do
      argument(:deleted, :boolean, allow_nil?: false)
      argument(:updated_before, :utc_datetime, allow_nil?: false)

      filter(expr(deleted == ^arg(:deleted) and updated_at &lt; ^arg(:updated_before)))
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :eve_id, :string do
      allow_nil? false
    end

    attribute :character_eve_id, :string do
      allow_nil? false
    end

    attribute :name, :string do
      allow_nil? true
    end

    attribute :description, :string do
      allow_nil? true
    end

    attribute :type, :string do
      allow_nil? true
    end

    attribute :linked_system_id, :integer do
      allow_nil? true
    end

    attribute :kind, :string
    attribute :group, :string

    attribute :custom_info, :string do
      allow_nil? true
    end

    attribute :deleted, :boolean do
      allow_nil? false
      default false
    end

    attribute :update_forced_at, :utc_datetime do
      allow_nil? true
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :system, WandererApp.Api.MapSystem do
      attribute_writable? true
    end
  end

  identities do
    identity :uniq_system_eve_id, [:system_id, :eve_id]
  end

  @derive {Jason.Encoder,
           only: [
             :id,
             :system_id,
             :eve_id,
             :character_eve_id,
             :name,
             :description,
             :type,
             :linked_system_id,
             :kind,
             :group,
             :custom_info,
             :deleted,
             :inserted_at,
             :updated_at
           ]}
end</file><file path="lib/wanderer_app/api/map_system_structure.ex">defmodule WandererApp.Api.MapSystemStructure do
  @moduledoc &quot;&quot;&quot;
  Ash resource representing a structure in a given map system.

  &quot;&quot;&quot;

  @derive {Jason.Encoder,
    only: [
      :id,
      :system_id,
      :solar_system_id,
      :solar_system_name,
      :structure_type_id,
      :structure_type,
      :character_eve_id,
      :name,
      :notes,
      :owner_name,
      :owner_ticker,
      :owner_id,
      :status,
      :end_time,
      :inserted_at,
      :updated_at
    ]
  }

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_system_structures_v1&quot;)
  end

  code_interface do
    define(:all_active, action: :all_active)
    define(:create, action: :create)
    define(:update, action: :update)

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_system_id,
      action: :by_system_id,
      args: [:system_id]
    )
  end

  actions do
    default_accept [
      :system_id,
      :solar_system_name,
      :solar_system_id,
      :structure_type_id,
      :structure_type,
      :character_eve_id,
      :name,
      :notes,
      :owner_name,
      :owner_ticker,
      :owner_id,
      :status,
      :end_time
    ]

    defaults [:read, :destroy]

    read :all_active do
      prepare build(sort: [updated_at: :desc])
    end

    read :by_system_id do
      argument :system_id, :string, allow_nil?: false
      filter(expr(system_id == ^arg(:system_id)))
    end

    create :create do
      primary? true

      accept [
        :system_id,
        :solar_system_name,
        :solar_system_id,
        :structure_type_id,
        :structure_type,
        :character_eve_id,
        :name,
        :notes,
        :owner_name,
        :owner_ticker,
        :owner_id,
        :status,
        :end_time
      ]

      argument :system_id, :uuid, allow_nil?: false

      change manage_relationship(:system_id, :system,
        on_lookup: :relate,
        on_no_match: nil
      )

    end

    update :update do
      primary? true
      require_atomic? false

      accept [
        :system_id,
        :solar_system_name,
        :solar_system_id,
        :structure_type_id,
        :structure_type,
        :character_eve_id,
        :name,
        :notes,
        :owner_name,
        :owner_ticker,
        :owner_id,
        :status,
        :end_time
      ]

    end

  end

  attributes do
    uuid_primary_key :id

    attribute :structure_type_id, :string do
      allow_nil? false
    end

    attribute :structure_type, :string do
      allow_nil? false
    end

    attribute :character_eve_id, :string do
      allow_nil? false
    end

    attribute :solar_system_name, :string do
      allow_nil? false
    end

    attribute :solar_system_id, :integer do
      allow_nil? false
    end

    attribute :name, :string do
      allow_nil? false
    end

    attribute :notes, :string do
      allow_nil? true
    end

    attribute :owner_name, :string do
      allow_nil? true
    end

    attribute :owner_ticker, :string do
      allow_nil? true
    end

    attribute :owner_id, :string do
      allow_nil? true
    end

    attribute :status, :string do
      allow_nil? true
    end

    attribute :end_time, :utc_datetime_usec do
      allow_nil? true
    end

    create_timestamp :inserted_at
    update_timestamp :updated_at
  end

  relationships do
    belongs_to :system, WandererApp.Api.MapSystem do
      attribute_writable? true
    end
  end
end</file><file path="lib/wanderer_app/api/map_system.ex">defmodule WandererApp.Api.MapSystem do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_system_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)
    define(:destroy, action: :destroy)

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_solar_system_id,
      get_by: [:solar_system_id],
      action: :read
    )

    define(:by_map_id_and_solar_system_id,
      get_by: [:map_id, :solar_system_id],
      action: :read
    )

    define(:read_all_by_map,
      action: :read_all_by_map
    )

    define(:read_visible_by_map,
      action: :read_visible_by_map
    )

    define(:read_by_map_and_solar_system,
      action: :read_by_map_and_solar_system
    )

    define(:update_name, action: :update_name)
    define(:update_description, action: :update_description)
    define(:update_locked, action: :update_locked)
    define(:update_status, action: :update_status)
    define(:update_tag, action: :update_tag)
    define(:update_temporary_name, action: :update_temporary_name)
    define(:update_labels, action: :update_labels)
    define(:update_linked_sig_eve_id, action: :update_linked_sig_eve_id)
    define(:update_position, action: :update_position)
    define(:update_visible, action: :update_visible)
  end

  actions do
    default_accept [
      :map_id,
      :name,
      :solar_system_id,
      :position_x,
      :position_y,
      :status
    ]

    defaults [:create, :read, :update, :destroy]

    read :read_all_by_map do
      argument(:map_id, :string, allow_nil?: false)
      filter(expr(map_id == ^arg(:map_id)))
    end

    read :read_visible_by_map do
      argument(:map_id, :string, allow_nil?: false)
      filter(expr(map_id == ^arg(:map_id) and visible == true))
    end

    read :read_by_map_and_solar_system do
      argument(:map_id, :string, allow_nil?: false)
      argument(:solar_system_id, :integer, allow_nil?: false)

      get?(true)

      filter(expr(map_id == ^arg(:map_id) and solar_system_id == ^arg(:solar_system_id)))
    end

    update :update_name do
      accept [:name]
    end

    update :update_description do
      accept [:description]
    end

    update :update_locked do
      accept [:locked]
    end

    update :update_status do
      accept [:status]
    end

    update :update_tag do
      accept [:tag]
    end

    update :update_temporary_name do
      accept [:temporary_name]
    end

    update :update_labels do
      accept [:labels]
    end

    update :update_position do
      accept [:position_x, :position_y]

      change(set_attribute(:visible, true))
    end

    update :update_linked_sig_eve_id do
      accept [:linked_sig_eve_id]
    end

    update :update_visible do
      accept [:visible]
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :solar_system_id, :integer do
      allow_nil? false
    end

    # by default it will default solar system name
    attribute :name, :string do
      allow_nil? false
    end

    attribute :custom_name, :string do
      allow_nil? true
    end

    attribute :description, :string do
      allow_nil? true
    end

    attribute :tag, :string do
      allow_nil? true
    end

    attribute :temporary_name, :string do
      allow_nil? true
    end

    attribute :labels, :string do
      allow_nil? true
    end

    # unknown: 0
    # friendly: 1
    # warning: 2
    # targetPrimary: 3
    # targetSecondary: 4
    # dangerousPrimary: 5
    # dangerousSecondary: 6
    # lookingFor: 7
    # home: 8
    attribute :status, :integer do
      default 0

      allow_nil? true
    end

    attribute :visible, :boolean do
      default true
      allow_nil? true
    end

    attribute :locked, :boolean do
      default false
      allow_nil? true
    end

    attribute :position_x, :integer do
      default 0
      allow_nil? true
    end

    attribute :position_y, :integer do
      default 0
      allow_nil? true
    end

    attribute :added_at, :utc_datetime do
      allow_nil? true
    end

    attribute :linked_sig_eve_id, :string do
      allow_nil? true
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :map, WandererApp.Api.Map do
      attribute_writable? true
    end
  end

  identities do
    identity(:map_solar_system_id, [:map_id, :solar_system_id])
  end
end</file><file path="lib/wanderer_app/api/map_transaction.ex">defmodule WandererApp.Api.MapTransaction do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_transactions_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_map, action: :by_map)
    define(:by_user, action: :by_user)
  end

  actions do
    default_accept [
      :map_id,
      :user_id,
      :type,
      :amount
    ]

    defaults [:create, :read, :update, :destroy]

    read :by_map do
      argument(:map_id, :string, allow_nil?: false)
      filter(expr(map_id == ^arg(:map_id)))
    end

    read :by_user do
      prepare build(load: [:map])
      argument(:user_id, :uuid, allow_nil?: false)
      filter(expr(user_id == ^arg(:user_id)))
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :user_id, :uuid do
      allow_nil? true
    end

    attribute :type, :atom do
      default &quot;in&quot;

      constraints(
        one_of: [
          :in,
          :out
        ]
      )

      allow_nil?(true)
    end

    attribute :amount, :float do
      allow_nil? false
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :map, WandererApp.Api.Map do
      attribute_writable? true
    end
  end
end</file><file path="lib/wanderer_app/api/map_user_settings.ex">defmodule WandererApp.Api.MapUserSettings do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;map_user_settings_v1&quot;)
  end

  code_interface do
    define(:create, action: :create)

    define(:by_user_id,
      get_by: [:map_id, :user_id],
      action: :read
    )

    define(:update_settings, action: :update_settings)
    define(:update_main_character, action: :update_main_character)
    define(:update_following_character, action: :update_following_character)

    define(:update_hubs, action: :update_hubs)
  end

  actions do
    default_accept [
      :map_id,
      :user_id,
      :settings
    ]

    defaults [:create, :read, :update, :destroy]

    update :update_settings do
      accept [:settings]
    end

    update :update_main_character do
      accept [:main_character_eve_id]
    end

    update :update_following_character do
      accept [:following_character_eve_id]
    end

    update :update_hubs do
      accept [:hubs]
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :settings, :string do
      allow_nil? true
    end

    attribute :main_character_eve_id, :string do
      allow_nil? true
    end

    attribute :following_character_eve_id, :string do
      allow_nil? true
    end

    attribute :hubs, {:array, :string} do
      allow_nil?(true)

      default([])
    end
  end

  relationships do
    belongs_to :map, WandererApp.Api.Map, primary_key?: true, allow_nil?: false
    belongs_to :user, WandererApp.Api.User, primary_key?: true, allow_nil?: false
  end

  identities do
    identity :uniq_map_user, [:map_id, :user_id]
  end
end</file><file path="lib/wanderer_app/api/map.ex">defmodule WandererApp.Api.Map do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;maps_v1&quot;)
  end

  code_interface do
    define(:available, action: :available)
    define(:get_map_by_slug, action: :by_slug, args: [:slug])
    define(:new, action: :new)
    define(:create, action: :create)
    define(:update, action: :update)
    define(:update_acls, action: :update_acls)
    define(:update_hubs, action: :update_hubs)
    define(:update_options, action: :update_options)
    define(:assign_owner, action: :assign_owner)
    define(:mark_as_deleted, action: :mark_as_deleted)
    define(:update_api_key, action: :update_api_key)

    define(:by_id,
      get_by: [:id],
      action: :read
    )
  end

  calculations do
    calculate :user_permissions, :integer, {WandererApp.Api.Calculations.CalcMapPermissions, []}
    calculate :balance, :float, expr(transactions_amount_in - transactions_amount_out)
  end

  aggregates do
    sum :transactions_amount_in, :transactions, :amount do
      default 0.0
      filter type: :in
    end

    sum :transactions_amount_out, :transactions, :amount do
      default 0.0
      filter type: :out
    end
  end

  actions do
    defaults [:create, :read, :destroy]

    read :by_slug do
      get? true
      argument :slug, :string, allow_nil?: false

      filter expr(slug == ^arg(:slug))
    end

    read :available do
      prepare WandererApp.Api.Preparations.FilterMapsByRoles
    end

    create :new do
      accept [:name, :slug, :description, :scope, :only_tracked_characters, :owner_id]
      primary?(true)

      argument :owner_id, :uuid, allow_nil?: false
      argument :create_default_acl, :boolean, allow_nil?: true
      argument :acls, {:array, :uuid}, allow_nil?: true
      argument :acls_text_input, :string, allow_nil?: true
      argument :scope_text_input, :string, allow_nil?: true
      argument :acls_empty_selection, :string, allow_nil?: true

      change manage_relationship(:owner_id, :owner, on_lookup: :relate, on_no_match: nil)
      change manage_relationship(:acls, type: :append_and_remove)
      change WandererApp.Api.Changes.SlugifyName
    end

    update :update do
      primary? true
      require_atomic? false
      accept [:name, :slug, :description, :scope, :only_tracked_characters, :owner_id]

      argument :owner_id_text_input, :string, allow_nil?: true
      argument :acls_text_input, :string, allow_nil?: true
      argument :scope_text_input, :string, allow_nil?: true
      argument :acls_empty_selection, :string, allow_nil?: true
      argument :acls, {:array, :uuid}, allow_nil?: true

      change manage_relationship(:acls,
               on_lookup: :relate,
               on_no_match: :create,
               on_missing: :unrelate
             )

      change WandererApp.Api.Changes.SlugifyName
    end

    update :update_acls do
      require_atomic? false

      argument :acls, {:array, :uuid} do
        allow_nil? false
      end

      change manage_relationship(:acls, type: :append_and_remove)
    end

    update :assign_owner do
      accept [:owner_id]
    end

    update :update_hubs do
      accept [:hubs]
    end

    update :update_options do
      accept [:options]
    end

    update :mark_as_deleted do
      accept([])

      change(set_attribute(:deleted, true))
    end

    update :update_api_key do
      accept [:public_api_key]
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :name, :string do
      allow_nil? false
      constraints trim?: false, max_length: 20, min_length: 3, allow_empty?: false
    end

    attribute :slug, :string do
      allow_nil? false
      public? true
      constraints trim?: false, max_length: 40, min_length: 3, allow_empty?: false
    end

    attribute :description, :string
    attribute :personal_note, :string

    attribute :public_api_key, :string do
      allow_nil? true
    end

    attribute :hubs, {:array, :string} do
      allow_nil?(true)

      default([])
    end

    attribute :scope, :atom do
      default &quot;wormholes&quot;

      constraints(
        one_of: [
          :wormholes,
          :stargates,
          :none,
          :all
        ]
      )

      allow_nil?(false)
    end

    attribute :deleted, :boolean do
      default(false)
      allow_nil?(true)
    end

    attribute :only_tracked_characters, :boolean do
      default(false)
      allow_nil?(true)
    end

    attribute :options, :string do
      allow_nil? true
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  identities do
    identity :unique_slug, [:slug]
  end

  relationships do
    belongs_to :owner, WandererApp.Api.Character do
      attribute_writable? true
    end

    many_to_many :characters, WandererApp.Api.Character do
      through WandererApp.Api.MapCharacterSettings
      source_attribute_on_join_resource :map_id
      destination_attribute_on_join_resource :character_id
    end

    many_to_many :acls, WandererApp.Api.AccessList do
      through WandererApp.Api.MapAccessList
      source_attribute_on_join_resource :map_id
      destination_attribute_on_join_resource :access_list_id
    end

    has_many :transactions, WandererApp.Api.MapTransaction
  end
end</file><file path="lib/wanderer_app/api/ship_type_info.ex">defmodule WandererApp.Api.ShipTypeInfo do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;ship_type_infos_v1&quot;)
  end

  code_interface do
    define(:read,
      action: :read
    )

    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_type_id,
      get_by: [:type_id],
      action: :read
    )

    define(:find_by_name, action: :find_by_name)
  end

  actions do
    default_accept [
      :type_id,
      :group_id,
      :group_name,
      :name,
      :description,
      :mass,
      :capacity,
      :volume
    ]

    defaults [:read, :destroy, :update]

    create :create do
      primary? true
      upsert? true
      upsert_identity :type_id

      upsert_fields [
        :group_id,
        :group_name,
        :name,
        :description,
        :mass,
        :capacity,
        :volume
      ]
    end

    read :find_by_name do
      argument(:name, :string, allow_nil?: false)

      filter(expr(contains(name, string_downcase(^arg(:name)))))
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :type_id, :integer
    attribute :group_id, :integer
    attribute :group_name, :string
    attribute :name, :string
    attribute :description, :string
    attribute :mass, :string
    attribute :capacity, :string
    attribute :volume, :string

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  identities do
    identity :type_id, [:type_id] do
      pre_check?(true)
    end
  end
end</file><file path="lib/wanderer_app/api/user_activity.ex">defmodule WandererApp.Api.UserActivity do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  require Ash.Expr

  @ash_pagify_options %{
    default_limit: 15,
    scopes: %{
      role: []
    }
  }
  def ash_pagify_options, do: @ash_pagify_options

  postgres do
    repo(WandererApp.Repo)
    table(&quot;user_activity_v1&quot;)

    custom_indexes do
      index [:entity_id, :event_type, :inserted_at], unique: true
    end
  end

  code_interface do
    define(:new, action: :new)
    define(:read, action: :read)
  end

  actions do
    default_accept [
      :entity_id,
      :entity_type,
      :event_type,
      :event_data
    ]

    defaults [:create, :update, :destroy]

    read :read do
      primary?(true)

      pagination offset?: true,
                 default_limit: @ash_pagify_options.default_limit,
                 countable: true,
                 required?: false

      prepare WandererApp.Api.Preparations.LoadCharacter
    end

    create :new do
      accept [:entity_id, :entity_type, :event_type, :event_data]
      primary?(true)

      argument :user_id, :uuid, allow_nil?: false
      argument :character_id, :uuid, allow_nil?: true

      change manage_relationship(:user_id, :user, on_lookup: :relate, on_no_match: nil)
      change manage_relationship(:character_id, :character, on_lookup: :relate, on_no_match: nil)
    end

    destroy :archive do
      soft? false
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :entity_id, :string do
      allow_nil? false
    end

    attribute :entity_type, :atom do
      default &quot;map&quot;

      constraints(
        one_of: [
          :map,
          :access_list
        ]
      )

      allow_nil?(false)
    end

    attribute :event_type, :atom do
      default &quot;custom&quot;

      constraints(
        one_of: [
          :custom,
          :hub_added,
          :hub_removed,
          :system_added,
          :systems_removed,
          :system_updated,
          :character_added,
          :character_removed,
          :character_updated,
          :map_added,
          :map_removed,
          :map_updated,
          :map_acl_added,
          :map_acl_removed,
          :map_acl_updated,
          :map_acl_member_added,
          :map_acl_member_removed,
          :map_acl_member_updated,
          :map_connection_added,
          :map_connection_updated,
          :map_connection_removed,
          :signatures_added,
          :signatures_removed
        ]
      )

      allow_nil?(false)
    end

    attribute :event_data, :string

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :character, WandererApp.Api.Character do
      allow_nil? true
      attribute_writable? true
    end

    belongs_to :user, WandererApp.Api.User do
      primary_key? true
      allow_nil? false
      attribute_writable? true
    end
  end
end</file><file path="lib/wanderer_app/api/user_transaction.ex">defmodule WandererApp.Api.UserTransaction do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer

  postgres do
    repo(WandererApp.Repo)
    table(&quot;user_transaction_v1&quot;)
  end

  code_interface do
    define(:new, action: :new)
  end

  actions do
    default_accept [
      :journal_ref_id,
      :user_id,
      :date,
      :amount,
      :corporation_id
    ]

    defaults [:create, :read, :update, :destroy]

    create :new do
      accept [:journal_ref_id, :user_id, :date, :amount, :corporation_id]
      primary?(true)

      argument :user_id, :uuid, allow_nil?: false

      change manage_relationship(:user_id, :user, on_lookup: :relate, on_no_match: nil)
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :journal_ref_id, :integer do
      allow_nil? false
    end

    attribute :corporation_id, :integer do
      allow_nil? false
    end

    attribute :amount, :float do
      allow_nil? false
    end

    attribute :date, :utc_datetime do
      allow_nil? true
    end

    attribute :reason, :string

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :user, WandererApp.Api.User do
      primary_key? true
      allow_nil? false
      attribute_writable? true
    end
  end
end</file><file path="lib/wanderer_app/api/user.ex">defmodule WandererApp.Api.User do
  @moduledoc false

  use Ash.Resource,
    domain: WandererApp.Api,
    data_layer: AshPostgres.DataLayer,
    extensions: [AshCloak]

  postgres do
    repo(WandererApp.Repo)
    table(&quot;user_v1&quot;)
  end

  code_interface do
    define(:by_id,
      get_by: [:id],
      action: :read
    )

    define(:by_hash,
      get_by: [:hash],
      action: :read
    )

    define(:update_last_map,
      action: :update_last_map
    )

    define(:update_balance,
      action: :update_balance
    )
  end

  actions do
    default_accept [
      :name,
      :hash
    ]

    defaults [:create, :read, :update, :destroy]

    update :update_last_map do
      accept([:last_map_id])
    end

    update :update_balance do
      require_atomic? false

      accept([:balance])
    end
  end

  cloak do
    vault(WandererApp.Vault)

    attributes([:balance])
  end

  attributes do
    uuid_primary_key :id

    attribute :name, :string
    attribute :hash, :string
    attribute :last_map_id, :uuid

    attribute :balance, :float do
      default 0.0

      allow_nil?(true)
    end
  end

  relationships do
    has_many :characters, WandererApp.Api.Character
  end

  identities do
    identity :unique_hash, [:hash] do
      pre_check?(false)
    end
  end
end</file><file path="lib/wanderer_app/blog/blog.ex">defmodule WandererApp.Blog do
  alias WandererApp.Blog.Post

  use NimblePublisher,
    build: Post,
    from: Application.app_dir(:wanderer_app, &quot;priv/posts/**/*.md&quot;),
    as: :posts,
    highlighters: [:makeup_elixir, :makeup_erlang]

  # The @posts variable is first defined by NimblePublisher.
  # Let&apos;s further modify it by sorting all posts by descending date.
  @posts Enum.sort_by(@posts, &amp; &amp;1.date, {:desc, Date})

  # Let&apos;s also get all tags
  @tags @posts |&gt; Enum.flat_map(&amp; &amp;1.tags) |&gt; Enum.uniq() |&gt; Enum.sort()

  # And finally export them
  def all_posts, do: @posts
  def all_tags, do: @tags

  def recent_posts(count \\ 3) do
    @posts |&gt; Enum.take(count)
  end

  def get_by_id!(id) do
    @posts |&gt; Enum.find(&amp;(&amp;1.id == id))
  end

  def get_by_tag(tag) do
    @posts |&gt; Enum.filter(&amp;(&amp;1.tags |&gt; Enum.member?(tag)))
  end
end</file><file path="lib/wanderer_app/blog/post.ex">defmodule WandererApp.Blog.Post do
  @enforce_keys [:id, :author, :title, :cover_image_uri, :body, :description, :tags, :date]
  defstruct [:id, :author, :title, :cover_image_uri, :body, :description, :tags, :date]

  def build(filename, attrs, body) do
    [year, month_day_id] = filename |&gt; Path.rootname() |&gt; Path.split() |&gt; Enum.take(-2)
    [month, day, id] = String.split(month_day_id, &quot;-&quot;, parts: 3)
    date = Date.from_iso8601!(&quot;#{year}-#{month}-#{day}&quot;)
    struct!(__MODULE__, [id: id, date: date, body: body] ++ Map.to_list(attrs))
  end
end</file><file path="lib/wanderer_app/changelog/changelog.ex">defmodule WandererApp.Changelog do
  use NimblePublisher,
    build: WandererApp.Changelog.File,
    from: Application.app_dir(:wanderer_app, &quot;priv/changelog/CHANGELOG.md&quot;),
    as: :files,
    highlighters: [:makeup_elixir, :makeup_erlang]

  # And finally export them
  def all_files, do: @files
end</file><file path="lib/wanderer_app/changelog/file.ex">defmodule WandererApp.Changelog.File do
  @enforce_keys [:id, :title, :body]
  defstruct [:id, :title, :body]

  def build(_filename, attrs, body) do
    struct!(__MODULE__, [id: ~c&quot;changelog&quot;, body: body] ++ Map.to_list(attrs))
  end
end</file><file path="lib/wanderer_app/character/activity.ex">defmodule WandererApp.Character.Activity do
  @moduledoc &quot;&quot;&quot;
  Functions for processing and managing character activity data.
  &quot;&quot;&quot;
  require Logger

  @doc &quot;&quot;&quot;
  Finds the character with the most activity from a map of activities grouped by character_id.

  ## Parameters
  - `activities_by_character`: Map of activities grouped by character_id

  ## Returns
  - Character ID of the character with the most activity, or nil if no activities
  &quot;&quot;&quot;
  def find_most_active_character(activities_by_character) do
    if Enum.empty?(activities_by_character) do
      nil
    else
      {char_id, _} =
        activities_by_character
        |&gt; Enum.map(fn {char_id, activities} -&gt;
          total_activity =
            activities
            |&gt; Enum.map(fn a -&gt;
              Map.get(a, :passages, 0) +
                Map.get(a, :connections, 0) +
                Map.get(a, :signatures, 0)
            end)
            |&gt; Enum.sum()

          {char_id, total_activity}
        end)
        |&gt; Enum.max_by(fn {_, count} -&gt; count end, fn -&gt; {nil, 0} end)

      char_id
    end
  end

  @doc &quot;&quot;&quot;
  Processes character activity data for display.

  ## Parameters
  - `map_id`: ID of the map
  - `current_user`: Current user struct (used only to get user settings)

  ## Returns
  - List of processed activity data
  &quot;&quot;&quot;
  def process_character_activity(map_id, current_user) do
    with {:ok, map_user_settings} &lt;- get_map_user_settings(map_id, current_user.id),
         raw_activity &lt;- WandererApp.Map.get_character_activity(map_id),
         {:ok, user_characters} &lt;- WandererApp.Api.Character.active_by_user(%{user_id: current_user.id}) do

      result = process_activity_data(raw_activity, map_user_settings, user_characters)
      result
    end
  end

  def get_map_user_settings(map_id, user_id) do
    case WandererApp.MapUserSettingsRepo.get(map_id, user_id) do
      {:ok, settings} when not is_nil(settings) -&gt;
        {:ok, settings}
      _ -&gt;
        {:ok, %{main_character_eve_id: nil}}
    end
  end

  @doc &quot;&quot;&quot;
  Gets character settings for a map.

  ## Parameters
  - `map_id`: ID of the map

  ## Returns
  - `{:ok, settings}` with list of settings or empty list
  &quot;&quot;&quot;
  def get_map_character_settings(map_id) do
    case WandererApp.MapCharacterSettingsRepo.get_all_by_map(map_id) do
      {:ok, settings} -&gt; {:ok, settings}
      _ -&gt; {:ok, []}
    end
  end

  # Handle empty activity list
  defp process_activity_data([], _map_user_settings, _all_characters), do: []

  # Process activity data
  defp process_activity_data(all_activity, map_user_settings, all_characters) do
    # Group activities by user ID
    activities_by_user = Enum.group_by(all_activity, &amp;Map.get(&amp;1, :user_id, &quot;unknown&quot;))

    # Process each user&apos;s activities
    activities_by_user
    |&gt; Enum.flat_map(fn {user_id, user_activities} -&gt;
      process_user_activity(user_id, user_activities, map_user_settings, all_characters)
    end)
    |&gt; sort_by_timestamp()
  end

  defp process_user_activity(user_id, user_activities, %{user_id: user_id, main_character_eve_id: main_id} = _map_user_settings, all_characters)
       when not is_nil(main_id) do
    # Group activities by character
    activities_by_character = group_activities_by_character(user_activities)

    main_id_str = to_string(main_id)

    display_character = case Enum.find(all_characters, &amp;(to_string(&amp;1.eve_id) == main_id_str)) do
      nil -&gt; find_most_active_character_details(activities_by_character) # Fall back to most active
      main_char -&gt; main_char
    end

    build_activity_entry_if_valid(display_character, activities_by_character, user_id)
  end

  defp process_user_activity(user_id, user_activities, _map_user_settings, _all_characters) do
    # Group activities by character
    activities_by_character = group_activities_by_character(user_activities)

    # Find the most active character
    display_character = find_most_active_character_details(activities_by_character)

    build_activity_entry_if_valid(display_character, activities_by_character, user_id)
  end

  # Helper function to build activity entry only if display character is valid
  defp build_activity_entry_if_valid(nil, _activities_by_character, user_id) do
    Logger.warning(&quot;No suitable character found for user #{user_id}&quot;)
    []
  end

  defp build_activity_entry_if_valid(display_character, activities_by_character, _user_id) do
    build_activity_entry(display_character, activities_by_character)
  end

  # Group activities by character ID
  defp group_activities_by_character(activities) do
    Enum.group_by(activities, fn activity -&gt;
      cond do
        character = Map.get(activity, :character) -&gt; Map.get(character, :id)
        id = Map.get(activity, :character_id) -&gt; id
        id = Map.get(activity, :character_eve_id) -&gt; id
        true -&gt; &quot;unknown_#{System.unique_integer([:positive])}&quot;
      end
    end)
  end

  # Find the details of the most active character
  defp find_most_active_character_details(activities_by_character) do
    with most_active_id when not is_nil(most_active_id) &lt;- find_most_active_character(activities_by_character),
         most_active_activities &lt;- Map.get(activities_by_character, most_active_id, []),
         [first_activity | _] &lt;- most_active_activities,
         character when not is_nil(character) &lt;- Map.get(first_activity, :character) do
      character
    else
      _ -&gt;
        Logger.warning(&quot;Could not find most active character&quot;)
        nil
    end
  end

  # Build activity entry with the provided character and sum all activities
  defp build_activity_entry(character, activities_by_character) do
    # Sum up all activities
    all_passages = sum_all_activities(activities_by_character, :passages)
    all_connections = sum_all_activities(activities_by_character, :connections)
    all_signatures = sum_all_activities(activities_by_character, :signatures)

    # Only create entry if there&apos;s at least some activity
    if all_passages + all_connections + all_signatures &gt; 0 do
      [%{
        character: character,
        passages: all_passages,
        connections: all_connections,
        signatures: all_signatures,
        timestamp: get_latest_timestamp(activities_by_character)
      }]
    else
      Logger.warning(&quot;Character has no activity, not creating entry&quot;)
      []
    end
  end

  # Sum up activities of a specific type across all characters
  defp sum_all_activities(activities_by_character, key) do
    activities_by_character
    |&gt; Enum.flat_map(fn {_, char_activities} -&gt; char_activities end)
    |&gt; Enum.map(&amp;Map.get(&amp;1, key, 0))
    |&gt; Enum.sum()
  end

  # Get the most recent timestamp across all characters
  defp get_latest_timestamp(activities_by_character) do
    activities_by_character
    |&gt; Enum.flat_map(fn {_, char_activities} -&gt; char_activities end)
    |&gt; Enum.map(&amp;Map.get(&amp;1, :timestamp, DateTime.utc_now()))
    |&gt; Enum.sort_by(&amp; &amp;1, {:desc, DateTime})
    |&gt; List.first() || DateTime.utc_now()
  end

  defp sort_by_timestamp(activities) do
    Enum.sort_by(activities, &amp; &amp;1.timestamp, {:desc, DateTime})
  end
end</file><file path="lib/wanderer_app/character/tracker_manager_impl.ex">defmodule WandererApp.Character.TrackerManager.Impl do
  @moduledoc false
  require Logger

  defstruct [
    :characters,
    :opts
  ]

  @type t :: %__MODULE__{
          characters: [integer],
          opts: map
        }

  @garbage_collection_interval :timer.minutes(15)
  @untrack_characters_interval :timer.minutes(1)
  @inactive_character_timeout :timer.minutes(5)

  @logger Application.compile_env(:wanderer_app, :logger)

  def new(), do: __struct__()
  def new(args), do: __struct__(args)

  def init(args) do
    Process.send_after(self(), :garbage_collect, @garbage_collection_interval)
    Process.send_after(self(), :untrack_characters, @untrack_characters_interval)

    %{
      characters: [],
      opts: args
    }
    |&gt; new()
  end

  def start(state) do
    {:ok, tracked_characters} = WandererApp.Cache.lookup(&quot;tracked_characters&quot;, [])
    WandererApp.Cache.insert(&quot;tracked_characters&quot;, [])

    tracked_characters
    |&gt; Enum.each(fn character_id -&gt;
      start_tracking(state, character_id, %{})
    end)

    state
  end

  def start_tracking(state, character_id, opts) do
    with {:ok, characters} &lt;- WandererApp.Cache.lookup(&quot;tracked_characters&quot;, []),
         false &lt;- Enum.member?(characters, character_id) do
      Logger.debug(fn -&gt; &quot;Start character tracker: #{inspect(character_id)}&quot; end)

      tracked_characters = [character_id | characters] |&gt; Enum.uniq()
      WandererApp.Cache.insert(&quot;tracked_characters&quot;, tracked_characters)

      WandererApp.Character.update_character(character_id, %{online: false})

      WandererApp.Character.update_character_state(character_id, %{
        is_online: false
      })

      WandererApp.Character.TrackerPoolDynamicSupervisor.start_tracking(character_id)

      WandererApp.TaskWrapper.start_link(WandererApp.Character, :update_character_state, [
        character_id,
        %{opts: opts}
      ])
    end

    state
  end

  def stop_tracking(state, character_id) do
    with {:ok, characters} &lt;- WandererApp.Cache.lookup(&quot;tracked_characters&quot;, []),
         true &lt;- Enum.member?(characters, character_id),
         {:ok, %{start_time: start_time}} &lt;-
           WandererApp.Character.get_character_state(character_id, false) do
      Logger.debug(fn -&gt; &quot;Shutting down character tracker: #{inspect(character_id)}&quot; end)

      WandererApp.Cache.delete(&quot;character:#{character_id}:last_active_time&quot;)
      WandererApp.Cache.delete(&quot;character:#{character_id}:location_started&quot;)
      WandererApp.Cache.delete(&quot;character:#{character_id}:start_solar_system_id&quot;)
      WandererApp.Character.delete_character_state(character_id)

      tracked_characters =
        characters |&gt; Enum.reject(fn c_id -&gt; c_id == character_id end)

      WandererApp.Cache.insert(&quot;tracked_characters&quot;, tracked_characters)

      WandererApp.Character.TrackerPoolDynamicSupervisor.stop_tracking(character_id)

      duration = DateTime.diff(DateTime.utc_now(), start_time, :second)

      :telemetry.execute([:wanderer_app, :character, :tracker, :running], %{
        duration: duration
      })

      :telemetry.execute([:wanderer_app, :character, :tracker, :stopped], %{count: 1})
    end

    state
  end

  def update_track_settings(
        %__MODULE__{} = state,
        character_id,
        %{
          map_id: map_id,
          track: track
        } = track_settings
      ) do
    if track do
      WandererApp.Cache.insert_or_update(
        &quot;character_untrack_queue&quot;,
        [],
        fn untrack_queue -&gt;
          untrack_queue
          |&gt; Enum.reject(fn {m_id, c_id} -&gt; m_id == map_id and c_id == character_id end)
        end
      )

      {:ok, character_state} =
        WandererApp.Character.Tracker.update_settings(character_id, track_settings)

      WandererApp.Character.update_character_state(character_id, character_state)
    else
      WandererApp.Cache.insert_or_update(
        &quot;character_untrack_queue&quot;,
        [{map_id, character_id}],
        fn untrack_queue -&gt;
          [{map_id, character_id} | untrack_queue] |&gt; Enum.uniq()
        end
      )
    end

    state
  end

  def get_characters(
        state,
        _opts \\ []
      ) do
    {:ok, characters} = WandererApp.Cache.lookup(&quot;tracked_characters&quot;, [])
    {characters, state}
  end

  def handle_event({ref, result}, state) do
    Process.demonitor(ref, [:flush])

    case result do
      :ok -&gt;
        state

      {:error, :skipped} -&gt;
        state

      {:error, error} -&gt;
        @logger.error(&quot;#{__MODULE__} failed to process: #{inspect(error)}&quot;)
        state

      _ -&gt;
        state
    end
  end

  def handle_info(
        :garbage_collect,
        state
      ) do
    Process.send_after(self(), :garbage_collect, @garbage_collection_interval)

    {:ok, characters} = WandererApp.Cache.lookup(&quot;tracked_characters&quot;, [])

    characters
    |&gt; Task.async_stream(
      fn character_id -&gt;
        case WandererApp.Cache.lookup(&quot;character:#{character_id}:last_active_time&quot;) do
          {:ok, nil} -&gt;
            :skip

          {:ok, last_active_time} -&gt;
            duration = DateTime.diff(DateTime.utc_now(), last_active_time, :second)

            if duration * 1000 &gt; @inactive_character_timeout do
              {:stop, character_id}
            else
              :skip
            end
        end
      end,
      max_concurrency: System.schedulers_online(),
      on_timeout: :kill_task,
      timeout: :timer.seconds(15)
    )
    |&gt; Enum.map(fn result -&gt;
      case result do
        {:ok, {:stop, character_id}} -&gt;
          Process.send_after(self(), {:stop_track, character_id}, 100)

        _ -&gt;
          :ok
      end
    end)

    state
  end

  def handle_info(
        :untrack_characters,
        state
      ) do
    Process.send_after(self(), :untrack_characters, @untrack_characters_interval)

    WandererApp.Cache.get_and_remove!(&quot;character_untrack_queue&quot;, [])
    |&gt; Task.async_stream(
      fn {map_id, character_id} -&gt;
        if not character_is_present(map_id, character_id) do
          {:ok, character_state} =
            WandererApp.Character.Tracker.update_settings(character_id, %{
              map_id: map_id,
              track: false
            })

          {:ok, character} = WandererApp.Character.get_character(character_id)

          {:ok, _updated} =
            WandererApp.MapCharacterSettingsRepo.update(map_id, character_id, %{
              ship: character.ship,
              ship_name: character.ship_name,
              ship_item_id: character.ship_item_id,
              solar_system_id: character.solar_system_id,
              structure_id: character.structure_id,
              station_id: character.station_id
            })

          WandererApp.Character.update_character_state(character_id, character_state)
        end
      end,
      max_concurrency: System.schedulers_online(),
      on_timeout: :kill_task,
      timeout: :timer.seconds(30)
    )
    |&gt; Enum.map(fn _result -&gt; :ok end)

    state
  end

  def handle_info({:stop_track, character_id}, state) do
    if not WandererApp.Cache.has_key?(&quot;character:#{character_id}:is_stop_tracking&quot;) do
      WandererApp.Cache.insert(&quot;character:#{character_id}:is_stop_tracking&quot;, true)
      Logger.debug(fn -&gt; &quot;Stopping character tracker: #{inspect(character_id)}&quot; end)
      stop_tracking(state, character_id)
      WandererApp.Cache.delete(&quot;character:#{character_id}:is_stop_tracking&quot;)
    end

    state
  end

  def handle_info(_event, state),
    do: state

  def character_is_present(map_id, character_id) do
    {:ok, presence_character_ids} =
      WandererApp.Cache.lookup(&quot;map_#{map_id}:presence_character_ids&quot;, [])

    Enum.member?(presence_character_ids, character_id)
  end
end</file><file path="lib/wanderer_app/character/tracker_manager.ex">defmodule WandererApp.Character.TrackerManager do
  @moduledoc &quot;&quot;&quot;
  Manage character trackers
  &quot;&quot;&quot;
  use GenServer

  require Logger

  alias WandererApp.GenImpl
  alias WandererApp.Character.TrackerManager.Impl

  @spec start_link(keyword()) :: GenServer.on_start()
  def start_link(args) when is_list(args) do
    GenServer.start_link(__MODULE__, args, name: __MODULE__)
  end

  def start_tracking(character_id, opts \\ []),
    do: GenServer.cast(__MODULE__, {&amp;Impl.start_tracking/3, [character_id, opts]})

  def stop_tracking(character_id),
    do: GenServer.cast(__MODULE__, {&amp;Impl.stop_tracking/2, [character_id]})

  def get_characters(opts \\ []),
    do: GenServer.call(__MODULE__, {&amp;Impl.get_characters/2, [opts]})

  def update_track_settings(character_id, track_settings),
    do:
      GenServer.cast(__MODULE__, {&amp;Impl.update_track_settings/3, [character_id, track_settings]})

  @impl true
  def init(args) do
    Logger.info(&quot;#{__MODULE__} started&quot;)

    {:ok, Impl.init(args), {:continue, :start}}
  end

  @impl true
  def handle_continue(:start, state), do: {:noreply, state |&gt; Impl.start()}

  @impl true
  def terminate(_reason, _state), do: :ok

  @impl true
  def handle_call(:error, _, state), do: {:stop, :error, :ok, state}

  @impl true
  def handle_call(:stop, _, state), do: {:stop, :normal, :ok, state}

  @impl true
  def handle_call(
        {impl_function, args},
        _from,
        state
      )
      when is_function(impl_function),
      do: GenImpl.apply_call(impl_function, state, args)

  @impl true
  def handle_cast({impl_function, args}, state)
      when is_function(impl_function) do
    case GenImpl.apply_call(impl_function, state, args) do
      {:reply, _return, updated_state} -&gt;
        {:noreply, updated_state}

      _ -&gt;
        {:noreply, state}
    end
  end

  @impl true
  def handle_info(event, state), do: {:noreply, Impl.handle_info(event, state)}

  def start_transaction_tracker(character_id) do
    case DynamicSupervisor.start_child(
           {:via, PartitionSupervisor, {WandererApp.Character.DynamicSupervisors, self()}},
           {WandererApp.Character.TransactionsTrackerSupervisor, character_id: character_id}
         ) do
      {:ok, pid} -&gt;
        {:ok, pid}

      {:error, {:already_started, pid}} -&gt;
        {:ok, pid}

      {:error,
       {:shutdown,
        {:failed_to_start_child, WandererApp.Character.TransactionsTracker,
         {:already_started, pid}}}} -&gt;
        {:ok, pid}

      {:error, reason} -&gt;
        {:error, reason}
    end
  end

  def stop_transaction_tracker(character_id) do
    case WandererApp.Character.TransactionsTracker.pid(character_id) do
      pid when is_pid(pid) -&gt;
        GenServer.call(pid, :stop)

      nil -&gt;
        :ok
    end
  end
end</file><file path="lib/wanderer_app/character/tracker_pool_dynamic_supervisor.ex">defmodule WandererApp.Character.TrackerPoolDynamicSupervisor do
  @moduledoc false
  use DynamicSupervisor

  require Logger

  @cache :tracked_characters
  @registry :tracker_pool_registry
  @unique_registry :unique_tracker_pool_registry
  @tracker_pool_limit 100

  @name __MODULE__

  def start_link(_arg) do
    DynamicSupervisor.start_link(@name, [], name: @name, max_restarts: 10)
  end

  def init(_arg) do
    DynamicSupervisor.init(strategy: :one_for_one)
  end

  def start_tracking(tracked_id) do
    case Registry.lookup(@registry, WandererApp.Character.TrackerPool) do
      [] -&gt;
        start_child([tracked_id], 0)

      pools -&gt;
        case get_available_pool(pools) do
          nil -&gt;
            start_child([tracked_id], pools |&gt; Enum.count())

          pid -&gt;
            GenServer.cast(pid, {:add_tracked_id, tracked_id})
        end
    end
  end

  def stop_tracking(tracked_id) do
    {:ok, uuid} = Cachex.get(@cache, tracked_id)

    case Registry.lookup(
           @unique_registry,
           Module.concat(WandererApp.Character.TrackerPool, uuid)
         ) do
      [] -&gt;
        :ok

      [{pool_pid, _}] -&gt;
        GenServer.cast(pool_pid, {:remove_tracked_id, tracked_id})
    end
  end

  def is_not_tracked?(tracked_id) do
    {:ok, tracked_ids} = Cachex.get(@cache, :tracked_characters)
    tracked_ids |&gt; Enum.member?(tracked_id) |&gt; Kernel.not()
  end

  defp get_available_pool([]), do: nil

  defp get_available_pool([{pid, uuid} | pools]) do
    case Registry.lookup(@unique_registry, Module.concat(WandererApp.Character.TrackerPool, uuid)) do
      [] -&gt;
        nil

      uuid_pools -&gt;
        case get_available_pool_pid(uuid_pools) do
          nil -&gt;
            get_available_pool(pools)

          pid -&gt;
            pid
        end
    end
  end

  defp get_available_pool_pid([]), do: nil

  defp get_available_pool_pid([{pid, tracked_ids} | pools]) do
    if Enum.count(tracked_ids) &lt; @tracker_pool_limit do
      pid
    else
      get_available_pool_pid(pools)
    end
  end

  defp start_child(tracked_ids, pools_count) do
    case DynamicSupervisor.start_child(@name, {WandererApp.Character.TrackerPool, tracked_ids}) do
      {:ok, pid} -&gt;
        Logger.info(&quot;Starting tracking pool, total pools: #{pools_count + 1}&quot;)
        {:ok, pid}

      {:error, {:already_started, pid}} -&gt;
        {:ok, pid}
    end
  end

  defp stop_child(uuid) do
    case Registry.lookup(@registry, uuid) do
      [{pid, _}] -&gt;
        GenServer.cast(pid, :stop)

      _ -&gt;
        Logger.warn(&quot;Unable to locate pool assigned to #{inspect(uuid)}&quot;)
        :ok
    end
  end
end</file><file path="lib/wanderer_app/character/tracker_pool_supervisor.ex">defmodule WandererApp.Character.TrackerPoolSupervisor do
  @moduledoc false
  use Supervisor

  @name __MODULE__
  @registry :tracker_pool_registry
  @unique_registry :unique_tracker_pool_registry

  def start_link(_args) do
    Supervisor.start_link(@name, [], name: @name)
  end

  def init(_args) do
    children = [
      {Registry, [keys: :unique, name: @unique_registry]},
      {Registry, [keys: :duplicate, name: @registry]},
      {WandererApp.Character.TrackerPoolDynamicSupervisor, []}
    ]

    Supervisor.init(children, strategy: :rest_for_one, max_restarts: 10)
  end
end</file><file path="lib/wanderer_app/character/tracker_pool.ex">defmodule WandererApp.Character.TrackerPool do
  @moduledoc false
  use GenServer, restart: :transient

  require Logger

  defstruct [
    :tracked_ids,
    :uuid,
    :characters,
    server_online: true
  ]

  @name __MODULE__
  @cache :tracked_characters
  @registry :tracker_pool_registry
  @unique_registry :unique_tracker_pool_registry

  @update_location_interval :timer.seconds(2)
  @update_online_interval :timer.seconds(5)
  @check_online_errors_interval :timer.seconds(30)
  @update_ship_interval :timer.seconds(2)
  @update_info_interval :timer.minutes(1)
  @update_wallet_interval :timer.minutes(1)
  @inactive_character_timeout :timer.minutes(5)

  @logger Application.compile_env(:wanderer_app, :logger)

  def new(), do: __struct__()
  def new(args), do: __struct__(args)

  def start_link(tracked_ids) do
    uuid = UUID.uuid1()

    GenServer.start_link(
      @name,
      {uuid, tracked_ids},
      name: Module.concat(__MODULE__, uuid)
    )
  end

  @impl true
  def init({uuid, tracked_ids}) do
    {:ok, _} = Registry.register(@unique_registry, Module.concat(__MODULE__, uuid), tracked_ids)
    {:ok, _} = Registry.register(@registry, __MODULE__, uuid)

    # Cachex.get_and_update(@cache, :tracked_characters, fn ids -&gt;
    #   {:commit, ids ++ tracked_ids}
    # end)

    tracked_ids
    |&gt; Enum.each(fn id -&gt; Cachex.put(@cache, id, uuid) end)

    state =
      %{
        uuid: uuid,
        characters: tracked_ids
      }
      |&gt; new()

    {:ok, state, {:continue, :start}}
  end

  @impl true
  def terminate(_reason, _state) do
    :ok
  end

  @impl true
  def handle_cast(:stop, state), do: {:stop, :normal, state}

  @impl true
  def handle_cast({:add_tracked_id, tracked_id}, %{characters: characters, uuid: uuid} = state) do
    Registry.update_value(@unique_registry, Module.concat(__MODULE__, uuid), fn r_tracked_ids -&gt;
      [tracked_id | r_tracked_ids]
    end)

    # Cachex.get_and_update(@cache, :tracked_characters, fn ids -&gt;
    #   {:commit, ids ++ [tracked_id]}
    # end)

    Cachex.put(@cache, tracked_id, uuid)

    {:noreply, %{state | characters: [tracked_id | characters]}}
  end

  @impl true
  def handle_cast(
        {:remove_tracked_id, tracked_id},
        %{characters: characters, uuid: uuid} = state
      ) do
    Registry.update_value(@unique_registry, Module.concat(__MODULE__, uuid), fn r_tracked_ids -&gt;
      r_tracked_ids |&gt; Enum.reject(fn id -&gt; id == tracked_id end)
    end)

    # Cachex.get_and_update(@cache, :tracked_characters, fn ids -&gt;
    #   {:commit, ids |&gt; Enum.reject(fn id -&gt; id == tracked_id end)}
    # end)

    Cachex.del(@cache, tracked_id)

    {:noreply, %{state | characters: characters |&gt; Enum.reject(fn id -&gt; id == tracked_id end)}}
  end

  @impl true
  def handle_call(:error, _, state), do: {:stop, :error, :ok, state}

  @impl true
  def handle_continue(:start, state) do
    Logger.info(&quot;#{@name} started&quot;)

    Phoenix.PubSub.subscribe(
      WandererApp.PubSub,
      &quot;server_status&quot;
    )

    Process.send_after(self(), :update_online, 100)
    Process.send_after(self(), :check_online_errors, @check_online_errors_interval)
    Process.send_after(self(), :update_location, 300)
    Process.send_after(self(), :update_ship, 500)
    Process.send_after(self(), :update_info, 1500)

    if WandererApp.Env.wallet_tracking_enabled?() do
      Process.send_after(self(), :update_wallet, 1000)
    end

    {:noreply, state}
  end

  def handle_info({ref, result}, state) when is_reference(ref) do
    Process.demonitor(ref, [:flush])

    case result do
      {:error, error} -&gt;
        @logger.error(&quot;#{__MODULE__} failed to process: #{inspect(error)}&quot;)
        :ok

      _ -&gt;
        :ok
    end

    {:noreply, state}
  end

  def handle_info({:server_status, status}, state),
    do: {:noreply, %{state | server_online: not status.vip}}

  def handle_info(
        :update_online,
        %{
          characters: characters,
          server_online: true
        } =
          state
      ) do
    Process.send_after(self(), :update_online, @update_online_interval)

    characters
    |&gt; Enum.map(fn character_id -&gt;
      WandererApp.TaskWrapper.start_link(WandererApp.Character.Tracker, :update_online, [
        character_id
      ])
    end)

    {:noreply, state}
  end

  def handle_info(
        :update_online,
        %{
          characters: characters
        } =
          state
      ) do
    Process.send_after(self(), :update_online, @update_online_interval)

    characters
    |&gt; Enum.each(fn character_id -&gt;
      WandererApp.Character.update_character(character_id, %{online: false})

      WandererApp.Character.update_character_state(character_id, %{
        is_online: false
      })
    end)

    {:noreply, state}
  end

  def handle_info(
        :check_online_errors,
        %{
          characters: characters
        } =
          state
      ) do
    Process.send_after(self(), :check_online_errors, @check_online_errors_interval)

    characters
    |&gt; Task.async_stream(
      fn character_id -&gt;
        WandererApp.TaskWrapper.start_link(WandererApp.Character.Tracker, :check_online_errors, [
          character_id
        ])
      end,
      timeout: :timer.seconds(15),
      max_concurrency: System.schedulers_online(),
      on_timeout: :kill_task
    )
    |&gt; Enum.each(fn
      {:ok, _result} -&gt; :ok
      {:error, reason} -&gt; @logger.error(&quot;Error in check_online_errors: #{inspect(reason)}&quot;)
    end)

    {:noreply, state}
  end

  def handle_info(
        :update_location,
        %{
          characters: characters,
          server_online: true
        } =
          state
      ) do
    Process.send_after(self(), :update_location, @update_location_interval)

    characters
    |&gt; Enum.map(fn character_id -&gt;
      WandererApp.TaskWrapper.start_link(WandererApp.Character.Tracker, :update_location, [
        character_id
      ])
    end)

    {:noreply, state}
  end

  def handle_info(
        :update_location,
        state
      ) do
    Process.send_after(self(), :update_location, @update_location_interval)

    {:noreply, state}
  end

  def handle_info(
        :update_ship,
        %{
          characters: characters,
          server_online: true
        } =
          state
      ) do
    Process.send_after(self(), :update_ship, @update_ship_interval)

    characters
    |&gt; Enum.map(fn character_id -&gt;
      WandererApp.TaskWrapper.start_link(WandererApp.Character.Tracker, :update_ship, [
        character_id
      ])
    end)

    {:noreply, state}
  end

  def handle_info(
        :update_ship,
        state
      ) do
    Process.send_after(self(), :update_ship, @update_ship_interval)

    {:noreply, state}
  end

  def handle_info(
        :update_info,
        %{
          characters: characters,
          server_online: true
        } =
          state
      ) do
    Process.send_after(self(), :update_info, @update_info_interval)

    characters
    |&gt; Task.async_stream(
      fn character_id -&gt;
        WandererApp.TaskWrapper.start_link(WandererApp.Character.Tracker, :update_info, [
          character_id
        ])
      end,
      timeout: :timer.seconds(15),
      max_concurrency: System.schedulers_online(),
      on_timeout: :kill_task
    )
    |&gt; Enum.each(fn
      {:ok, _result} -&gt; :ok
      {:error, reason} -&gt; @logger.error(&quot;Error in update_info: #{inspect(reason)}&quot;)
    end)

    {:noreply, state}
  end

  def handle_info(
        :update_info,
        state
      ) do
    Process.send_after(self(), :update_info, @update_info_interval)

    {:noreply, state}
  end

  def handle_info(
        :update_wallet,
        %{
          characters: characters,
          server_online: true
        } =
          state
      ) do
    Process.send_after(self(), :update_wallet, @update_wallet_interval)

    characters
    |&gt; Task.async_stream(
      fn character_id -&gt;
        WandererApp.TaskWrapper.start_link(WandererApp.Character.Tracker, :update_wallet, [
          character_id
        ])
      end,
      timeout: :timer.seconds(15),
      max_concurrency: System.schedulers_online(),
      on_timeout: :kill_task
    )
    |&gt; Enum.each(fn
      {:ok, _result} -&gt; :ok
      {:error, reason} -&gt; @logger.error(&quot;Error in update_wallet: #{inspect(reason)}&quot;)
    end)

    {:noreply, state}
  end

  def handle_info(
        :update_wallet,
        state
      ) do
    Process.send_after(self(), :update_wallet, @update_wallet_interval)

    {:noreply, state}
  end

  defp via_tuple(uuid) do
    {:via, Registry, {@unique_registry, Module.concat(__MODULE__, uuid)}}
  end
end</file><file path="lib/wanderer_app/character/tracker_registry_helper.ex">defmodule WandererApp.Character.TrackerRegistryHelper do
  @moduledoc false

  alias WandererApp.Character.TrackerRegistry

  def list_all_trackers(),
    do: Registry.select(TrackerRegistry, [{{:&quot;$1&quot;, :&quot;$2&quot;, :_}, [], [%{id: :&quot;$1&quot;, pid: :&quot;$2&quot;}]}])

  def list_all_trackers_by_character_id(character_id) do
    match_all = {:&quot;$1&quot;, :&quot;$2&quot;, :&quot;$3&quot;}
    guards = [{:==, :&quot;$1&quot;, character_id}]
    map_result = [%{id: :&quot;$1&quot;, pid: :&quot;$2&quot;}]
    Registry.select(TrackerRegistry, [{match_all, guards, map_result}])
  end
end</file><file path="lib/wanderer_app/character/tracker_supervisor.ex">defmodule WandererApp.Character.TrackerSupervisor do
  @moduledoc false
  use Supervisor, restart: :transient

  alias WandererApp.Character.Tracker

  def start_link(args), do: Supervisor.start_link(__MODULE__, args)

  @impl true
  def init(args) do
    children = [
      {Tracker, args}
    ]

    Supervisor.init(children, strategy: :one_for_one, auto_shutdown: :all_significant)
  end
end</file><file path="lib/wanderer_app/character/tracker.ex">defmodule WandererApp.Character.Tracker do
  @moduledoc false
  require Logger

  alias WandererApp.Api.Character

  defstruct [
    :character_id,
    :alliance_id,
    :opts,
    server_online: true,
    start_time: nil,
    active_maps: [],
    is_online: false,
    track_online: true,
    track_location: true,
    track_ship: true,
    track_wallet: false,
    status: &quot;new&quot;
  ]

  @type t :: %__MODULE__{
          character_id: integer,
          opts: map,
          server_online: boolean,
          start_time: DateTime.t(),
          active_maps: [integer],
          is_online: boolean,
          track_online: boolean,
          track_location: boolean,
          track_ship: boolean,
          track_wallet: boolean,
          status: binary()
        }

  @online_error_timeout :timer.minutes(3)
  @forbidden_ttl :timer.minutes(1)
  @pubsub_client Application.compile_env(:wanderer_app, :pubsub_client)

  def new(), do: __struct__()
  def new(args), do: __struct__(args)

  def init(args) do
    %{
      character_id: args[:character_id],
      start_time: DateTime.utc_now(),
      opts: args
    }
    |&gt; new()
  end

  def update_settings(character_id, track_settings) do
    {:ok, character_state} = WandererApp.Character.get_character_state(character_id)

    {:ok,
     character_state
     |&gt; maybe_update_active_maps(track_settings)
     |&gt; maybe_stop_tracking(track_settings)
     |&gt; maybe_start_online_tracking(track_settings)
     |&gt; maybe_start_location_tracking(track_settings)
     |&gt; maybe_start_ship_tracking(track_settings)}
  end

  def update_info(character_id) do
    WandererApp.Cache.has_key?(&quot;character:#{character_id}:info_forbidden&quot;)
    |&gt; case do
      true -&gt;
        {:error, :skipped}

      false -&gt;
        {:ok, %{eve_id: eve_id}} = WandererApp.Character.get_character(character_id)

        case WandererApp.Esi.get_character_info(eve_id) do
          {:ok, _info} -&gt;
            {:ok, character_state} = WandererApp.Character.get_character_state(character_id)

            update = maybe_update_corporation(character_state, eve_id |&gt; String.to_integer())
            WandererApp.Character.update_character_state(character_id, update)

            :ok

          {:error, :forbidden} -&gt;
            Logger.warning(&quot;#{__MODULE__} failed to get_character_info: forbidden&quot;)

            WandererApp.Cache.put(
              &quot;character:#{character_id}:info_forbidden&quot;,
              true,
              ttl: @forbidden_ttl
            )

            {:error, :forbidden}

          {:error, error} -&gt;
            Logger.error(&quot;#{__MODULE__} failed to get_character_info: #{inspect(error)}&quot;)
            {:error, error}
        end
    end
  end

  def update_ship(character_id) when is_binary(character_id) do
    character_id
    |&gt; WandererApp.Character.get_character_state!()
    |&gt; update_ship()
  end

  def update_ship(
        %{character_id: character_id, track_ship: true, is_online: true} = character_state
      ) do
    character_id
    |&gt; WandererApp.Character.get_character()
    |&gt; case do
      {:ok, %{eve_id: eve_id, access_token: access_token}} when not is_nil(access_token) -&gt;
        WandererApp.Cache.has_key?(&quot;character:#{character_id}:ship_forbidden&quot;)
        |&gt; case do
          true -&gt;
            {:error, :skipped}

          _ -&gt;
            case WandererApp.Esi.get_character_ship(eve_id,
                   access_token: access_token,
                   character_id: character_id,
                   refresh_token?: true
                 ) do
              {:ok, ship} -&gt;
                character_state |&gt; maybe_update_ship(ship)

                :ok

              {:error, :forbidden} -&gt;
                Logger.warning(&quot;#{__MODULE__} failed to update_ship: forbidden&quot;)

                WandererApp.Cache.put(
                  &quot;character:#{character_id}:ship_forbidden&quot;,
                  true,
                  ttl: @forbidden_ttl
                )

                {:error, :forbidden}

              {:error, error} -&gt;
                Logger.error(&quot;#{__MODULE__} failed to update_ship: #{inspect(error)}&quot;)

                WandererApp.Cache.put(
                  &quot;character:#{character_id}:ship_forbidden&quot;,
                  true,
                  ttl: @forbidden_ttl
                )

                {:error, error}
            end
        end

      _ -&gt;
        {:error, :skipped}
    end
  end

  def update_ship(_), do: {:error, :skipped}

  def update_location(character_id) when is_binary(character_id) do
    character_id
    |&gt; WandererApp.Character.get_character_state!()
    |&gt; update_location()
  end

  def update_location(
        %{track_location: true, is_online: true, character_id: character_id} = character_state
      ) do
    case WandererApp.Character.get_character(character_id) do
      {:ok, %{eve_id: eve_id, access_token: access_token}} when not is_nil(access_token) -&gt;
        WandererApp.Cache.has_key?(&quot;character:#{character_id}:location_forbidden&quot;)
        |&gt; case do
          true -&gt;
            {:error, :skipped}

          _ -&gt;
            case WandererApp.Esi.get_character_location(eve_id,
                   access_token: access_token,
                   character_id: character_id,
                   refresh_token?: true
                 ) do
              {:ok, location} -&gt;
                character_state
                |&gt; maybe_update_location(location)

                :ok

              {:error, :forbidden} -&gt;
                Logger.warning(&quot;#{__MODULE__} failed to update_location: forbidden&quot;)

                WandererApp.Cache.put(
                  &quot;character:#{character_id}:location_forbidden&quot;,
                  true,
                  ttl: @forbidden_ttl
                )

                {:error, :forbidden}

              {:error, error} -&gt;
                Logger.error(&quot;#{__MODULE__} failed to update_location: #{inspect(error)}&quot;)

                WandererApp.Cache.put(
                  &quot;character:#{character_id}:location_forbidden&quot;,
                  true,
                  ttl: @forbidden_ttl
                )

                {:error, error}
            end

          _ -&gt;
            {:error, :skipped}
        end

      _ -&gt;
        {:error, :skipped}
    end
  end

  def update_location(_), do: {:error, :skipped}

  def update_online(character_id) when is_binary(character_id) do
    character_id
    |&gt; WandererApp.Character.get_character_state!()
    |&gt; update_online()
  end

  def update_online(%{track_online: true, character_id: character_id} = character_state) do
    case WandererApp.Character.get_character(character_id) do
      {:ok, %{eve_id: eve_id, access_token: access_token}}
      when not is_nil(access_token) -&gt;
        WandererApp.Cache.has_key?(&quot;character:#{character_id}:online_forbidden&quot;)
        |&gt; case do
          true -&gt;
            {:error, :skipped}

          _ -&gt;
            case WandererApp.Esi.get_character_online(eve_id,
                   access_token: access_token,
                   character_id: character_id,
                   refresh_token?: true
                 ) do
              {:ok, online} -&gt;
                online = get_online(online)

                WandererApp.Cache.delete(&quot;character:#{character_id}:online_forbidden&quot;)
                WandererApp.Cache.delete(&quot;character:#{character_id}:online_error_time&quot;)
                WandererApp.Character.update_character(character_id, online)

                if not online.online do
                  WandererApp.Cache.delete(&quot;character:#{character_id}:location_started&quot;)
                  WandererApp.Cache.delete(&quot;character:#{character_id}:start_solar_system_id&quot;)
                end

                update = %{
                  character_state
                  | is_online: online.online,
                    track_ship: online.online,
                    track_location: online.online
                }

                WandererApp.Character.update_character_state(character_id, update)

                :ok

              {:error, :forbidden} -&gt;
                Logger.warning(&quot;#{__MODULE__} failed to update_online: forbidden&quot;)

                if not WandererApp.Cache.lookup!(
                     &quot;character:#{character_id}:online_forbidden&quot;,
                     false
                   ) do
                  WandererApp.Cache.put(
                    &quot;character:#{character_id}:online_forbidden&quot;,
                    true,
                    ttl: @forbidden_ttl
                  )

                  if is_nil(
                       WandererApp.Cache.lookup(&quot;character:#{character_id}:online_error_time&quot;)
                     ) do
                    WandererApp.Cache.insert(
                      &quot;character:#{character_id}:online_error_time&quot;,
                      DateTime.utc_now()
                    )
                  end
                end

                :ok

              {:error, error} -&gt;
                Logger.error(&quot;#{__MODULE__} failed to update_online: #{inspect(error)}&quot;)

                if is_nil(WandererApp.Cache.lookup(&quot;character:#{character_id}:online_error_time&quot;)) do
                  WandererApp.Cache.insert(
                    &quot;character:#{character_id}:online_error_time&quot;,
                    DateTime.utc_now()
                  )
                end

                :ok
            end
        end

      _ -&gt;
        {:error, :skipped}
    end
  end

  def update_online(_), do: {:error, :skipped}

  def check_online_errors(character_id) do
    WandererApp.Cache.lookup!(&quot;character:#{character_id}:online_error_time&quot;)
    |&gt; case do
      nil -&gt;
        :skip

      error_time -&gt;
        duration = DateTime.diff(DateTime.utc_now(), error_time, :second)

        if duration &gt;= @online_error_timeout do
          WandererApp.Cache.delete(&quot;character:#{character_id}:online_forbidden&quot;)
          WandererApp.Cache.delete(&quot;character:#{character_id}:online_error_time&quot;)
          WandererApp.Character.update_character(character_id, %{online: false})

          WandererApp.Character.update_character_state(character_id, %{
            is_online: false
          })

          :ok
        else
          :skip
        end
    end
  end

  def update_wallet(character_id) do
    character_id
    |&gt; WandererApp.Character.get_character()
    |&gt; case do
      {:ok, %{eve_id: eve_id, access_token: access_token} = character}
      when not is_nil(access_token) -&gt;
        character
        |&gt; WandererApp.Character.can_track_wallet?()
        |&gt; case do
          true -&gt;
            WandererApp.Cache.has_key?(&quot;character:#{character_id}:wallet_forbidden&quot;)
            |&gt; case do
              true -&gt;
                {:error, :skipped}

              _ -&gt;
                case WandererApp.Esi.get_character_wallet(eve_id,
                       params: %{datasource: &quot;tranquility&quot;},
                       access_token: access_token,
                       character_id: character_id,
                       refresh_token?: true
                     ) do
                  {:ok, result} -&gt;
                    {:ok, state} = WandererApp.Character.get_character_state(character_id)
                    maybe_update_wallet(state, result)

                    :ok

                  {:error, :forbidden} -&gt;
                    Logger.warning(&quot;#{__MODULE__} failed to _update_wallet: forbidden&quot;)

                    WandererApp.Cache.put(
                      &quot;character:#{character_id}:wallet_forbidden&quot;,
                      true,
                      ttl: @forbidden_ttl
                    )

                    {:error, :forbidden}

                  {:error, error} -&gt;
                    Logger.error(&quot;#{__MODULE__} failed to _update_wallet: #{inspect(error)}&quot;)
                    {:error, error}
                end
            end

          _ -&gt;
            {:error, :skipped}
        end

      _ -&gt;
        {:error, :skipped}
    end
  end

  defp update_alliance(%{character_id: character_id} = state, alliance_id) do
    alliance_id
    |&gt; WandererApp.Esi.get_alliance_info()
    |&gt; case do
      {:ok, %{&quot;name&quot; =&gt; alliance_name, &quot;ticker&quot; =&gt; alliance_ticker}} -&gt;
        {:ok, character} = WandererApp.Character.get_character(character_id)

        character_update = %{
          alliance_id: alliance_id,
          alliance_name: alliance_name,
          alliance_ticker: alliance_ticker
        }

        {:ok, _character} =
          WandererApp.Api.Character.update_alliance(character, character_update)

        WandererApp.Character.update_character(character_id, character_update)

        @pubsub_client.broadcast(
          WandererApp.PubSub,
          &quot;character:#{character_id}:alliance&quot;,
          {:character_alliance, {character_id, character_update}}
        )

        state

      _error -&gt;
        Logger.error(&quot;Failed to get alliance info for #{alliance_id}&quot;)
        state
    end
  end

  defp update_corporation(%{character_id: character_id} = state, corporation_id) do
    corporation_id
    |&gt; WandererApp.Esi.get_corporation_info()
    |&gt; case do
      {:ok, %{&quot;name&quot; =&gt; corporation_name, &quot;ticker&quot; =&gt; corporation_ticker} = corporation_info} -&gt;
        alliance_id = Map.get(corporation_info, &quot;alliance_id&quot;)

        {:ok, character} =
          WandererApp.Character.get_character(character_id)

        character_update = %{
          corporation_id: corporation_id,
          corporation_name: corporation_name,
          corporation_ticker: corporation_ticker,
          alliance_id: alliance_id
        }

        {:ok, _character} =
          WandererApp.Api.Character.update_corporation(character, character_update)

        WandererApp.Character.update_character(character_id, character_update)

        @pubsub_client.broadcast(
          WandererApp.PubSub,
          &quot;character:#{character_id}:corporation&quot;,
          {:character_corporation,
           {character_id,
            %{
              corporation_id: corporation_id,
              corporation_name: corporation_name,
              corporation_ticker: corporation_ticker
            }}}
        )

        state
        |&gt; Map.merge(%{alliance_id: alliance_id, corporation_id: corporation_id})
        |&gt; maybe_update_alliance()

      error -&gt;
        Logger.warning(
          &quot;Failed to get corporation info for character #{character_id}: #{inspect(error)}&quot;,
          character_id: character_id,
          corporation_id: corporation_id
        )

        state
    end
  end

  defp maybe_update_ship(
         %{
           character_id: character_id
         } =
           state,
         ship
       ) do
    ship_type_id = Map.get(ship, &quot;ship_type_id&quot;)
    ship_name = Map.get(ship, &quot;ship_name&quot;)

    {:ok, %{ship: old_ship_type_id, ship_name: old_ship_name} = character} =
      WandererApp.Character.get_character(character_id)

    ship_updated = old_ship_type_id != ship_type_id || old_ship_name != ship_name

    if ship_updated do
      character_update = %{
        ship: ship_type_id,
        ship_name: ship_name
      }

      {:ok, _character} =
        WandererApp.Api.Character.update_ship(character, character_update)

      WandererApp.Character.update_character(character_id, character_update)
    end

    state
  end

  defp maybe_update_location(
         %{
           character_id: character_id
         } =
           state,
         location
       ) do
    location = get_location(location)

    if not is_location_started?(character_id) do
      WandererApp.Cache.lookup!(&quot;character:#{character_id}:start_solar_system_id&quot;, nil)
      |&gt; case do
        nil -&gt;
          WandererApp.Cache.put(
            &quot;character:#{character_id}:start_solar_system_id&quot;,
            location.solar_system_id
          )

        start_solar_system_id -&gt;
          if location.solar_system_id != start_solar_system_id do
            WandererApp.Cache.put(
              &quot;character:#{character_id}:location_started&quot;,
              true
            )
          end
      end
    end

    {:ok,
     %{solar_system_id: solar_system_id, structure_id: structure_id, station_id: station_id} =
       character} =
      WandererApp.Character.get_character(character_id)

    (not is_location_started?(character_id) ||
       is_location_updated?(location, solar_system_id, structure_id, station_id))
    |&gt; case do
      true -&gt;
        {:ok, _character} = WandererApp.Api.Character.update_location(character, location)
        WandererApp.Character.update_character(character_id, location)

        :ok

      _ -&gt;
        :ok
    end

    state
  end

  defp is_location_started?(character_id),
    do:
      WandererApp.Cache.lookup!(
        &quot;character:#{character_id}:location_started&quot;,
        false
      )

  defp is_location_updated?(
         %{
           solar_system_id: new_solar_system_id,
           station_id: new_station_id,
           structure_id: new_structure_id
         } = _location,
         solar_system_id,
         structure_id,
         station_id
       ),
       do:
         solar_system_id != new_solar_system_id ||
           solar_system_id != new_solar_system_id ||
           structure_id != new_structure_id ||
           station_id != new_station_id

  defp maybe_update_corporation(
         state,
         character_eve_id
       )
       when not is_nil(character_eve_id) and is_integer(character_eve_id) do
    case WandererApp.Esi.post_characters_affiliation([character_eve_id]) do
      {:ok, [character_aff_info]} when not is_nil(character_aff_info) -&gt;
        update_corporation(state, character_aff_info |&gt; Map.get(&quot;corporation_id&quot;))

      _error -&gt;
        state
    end
  end

  defp maybe_update_corporation(
         state,
         _info
       ),
       do: state

  defp maybe_update_alliance(
         %{character_id: character_id, alliance_id: alliance_id} =
           state
       ) do
    case alliance_id do
      nil -&gt;
        {:ok, character} = WandererApp.Character.get_character(character_id)

        character_update = %{
          alliance_id: nil,
          alliance_name: nil,
          alliance_ticker: nil
        }

        {:ok, _character} =
          Character.update_alliance(character, character_update)

        WandererApp.Character.update_character(character_id, character_update)

        @pubsub_client.broadcast(
          WandererApp.PubSub,
          &quot;character:#{character_id}:alliance&quot;,
          {:character_alliance, {character_id, character_update}}
        )

        state

      _ -&gt;
        update_alliance(state, alliance_id)
    end
  end

  defp maybe_update_wallet(
         %{character_id: character_id} =
           state,
         wallet_balance
       ) do
    {:ok, character} = WandererApp.Character.get_character(character_id)

    {:ok, _character} =
      WandererApp.Api.Character.update_wallet_balance(character, %{
        eve_wallet_balance: wallet_balance
      })

    WandererApp.Character.update_character(character_id, %{
      eve_wallet_balance: wallet_balance
    })

    @pubsub_client.broadcast(
      WandererApp.PubSub,
      &quot;character:#{character_id}&quot;,
      {:character_wallet_balance}
    )

    state
  end

  defp maybe_start_online_tracking(
         state,
         %{track_online: true} = _track_settings
       ),
       do: %{
         state
         | track_online: true,
           track_location: true,
           track_ship: true
       }

  defp maybe_start_online_tracking(
         state,
         _track_settings
       ),
       do: state

  defp maybe_start_location_tracking(
         state,
         %{track_location: true} = _track_settings
       ),
       do: %{state | track_location: true}

  defp maybe_start_location_tracking(
         state,
         _track_settings
       ),
       do: state

  defp maybe_start_ship_tracking(
         state,
         %{track_ship: true} = _track_settings
       ),
       do: %{state | track_ship: true}

  defp maybe_start_ship_tracking(
         state,
         _track_settings
       ),
       do: state

  defp maybe_update_active_maps(
         %{character_id: character_id, active_maps: active_maps} =
           state,
         %{map_id: map_id, track: true} = _track_settings
       ) do
    WandererApp.Cache.put(
      &quot;character:#{character_id}:map:#{map_id}:tracking_start_time&quot;,
      DateTime.utc_now()
    )

    WandererApp.Cache.take(&quot;character:#{character_id}:last_active_time&quot;)

    %{state | active_maps: [map_id | active_maps] |&gt; Enum.uniq()}
  end

  defp maybe_update_active_maps(
         %{character_id: character_id, active_maps: active_maps} = state,
         %{map_id: map_id, track: false} = _track_settings
       ) do
    WandererApp.Cache.take(&quot;character:#{character_id}:map:#{map_id}:tracking_start_time&quot;)
    |&gt; case do
      start_time when not is_nil(start_time) -&gt;
        duration = DateTime.diff(DateTime.utc_now(), start_time, :second)
        :telemetry.execute([:wanderer_app, :character, :tracker], %{duration: duration})

        :ok

      _ -&gt;
        :ok
    end

    %{state | active_maps: Enum.filter(active_maps, &amp;(&amp;1 != map_id))}
  end

  defp maybe_update_active_maps(
         state,
         _track_settings
       ),
       do: state

  defp maybe_stop_tracking(
         %{active_maps: [], character_id: character_id, opts: opts} = state,
         _track_settings
       ) do
    if is_nil(opts[:keep_alive]) do
      WandererApp.Cache.put(
        &quot;character:#{character_id}:last_active_time&quot;,
        DateTime.utc_now()
      )
    end

    state
  end

  defp maybe_stop_tracking(
         state,
         _track_settings
       ),
       do: state

  defp get_location(%{
         &quot;solar_system_id&quot; =&gt; solar_system_id,
         &quot;station_id&quot; =&gt; station_id
       }),
       do: %{solar_system_id: solar_system_id, structure_id: nil, station_id: station_id}

  defp get_location(%{
         &quot;solar_system_id&quot; =&gt; solar_system_id,
         &quot;structure_id&quot; =&gt; structure_id
       }),
       do: %{solar_system_id: solar_system_id, structure_id: structure_id, station_id: nil}

  defp get_location(%{&quot;solar_system_id&quot; =&gt; solar_system_id}),
    do: %{solar_system_id: solar_system_id, structure_id: nil, station_id: nil}

  defp get_location(_), do: %{solar_system_id: nil, structure_id: nil, station_id: nil}

  defp get_online(%{&quot;online&quot; =&gt; online}), do: %{online: online}

  defp get_online(_), do: %{online: false}
end</file><file path="lib/wanderer_app/character/tracking_utils.ex">defmodule WandererApp.Character.TrackingUtils do
  @moduledoc &quot;&quot;&quot;
  Utility functions for handling character tracking and following operations.

  &quot;&quot;&quot;

  require Logger

  @doc &quot;&quot;&quot;
  Toggles the tracking state for a character on a map.
  Returns the updated tracking data for all characters with access to the map.
  &quot;&quot;&quot;
  def update_tracking(
        map_id,
        character_eve_id,
        current_user_id,
        track,
        caller_pid,
        only_tracked_characters
      )
      when not is_nil(caller_pid) do
    with {:ok, character} &lt;-
           WandererApp.Character.get_by_eve_id(character_eve_id),
         {:ok, %{tracked: is_tracked}} &lt;-
           do_update_character_tracking(character, map_id, track, caller_pid) do
      # Determine which event to send based on tracking mode and previous state
      if only_tracked_characters &amp;&amp; not is_tracked do
        {:ok, nil, :not_all_characters_tracked}
      else
        # Get updated tracking data
        {:ok, tracking_data} = build_tracking_data(map_id, current_user_id)

        {:ok, tracking_data, %{event: :refresh_user_characters}}
      end
    else
      error -&gt;
        Logger.error(&quot;Failed to toggle tracking: #{inspect(error)}&quot;)
        {:error, &quot;Failed to toggle tracking&quot;}
    end
  end

  def update_tracking(
        _map_id,
        _character_id,
        _current_user_id,
        _track,
        _caller_pid,
        _only_tracked_characters
      ) do
    Logger.error(&quot;Failed to update tracking&quot;)
    {:error, &quot;Failed to update tracking&quot;}
  end

  @doc &quot;&quot;&quot;
  Builds tracking data for all characters with access to a map.
  &quot;&quot;&quot;
  def build_tracking_data(map_id, current_user_id) do
    with {:ok, map} &lt;- WandererApp.MapRepo.get(map_id, [:acls]),
         {:ok, character_settings} &lt;-
           WandererApp.Character.Activity.get_map_character_settings(map_id),
         {:ok, user_settings} &lt;- WandererApp.MapUserSettingsRepo.get(map_id, current_user_id),
         {:ok, %{characters: characters_with_access}} &lt;-
           WandererApp.Maps.load_characters(map, character_settings, current_user_id) do
      # Map characters to tracking data
      {:ok, characters_data} =
        build_character_tracking_data(characters_with_access, character_settings)

      {:ok, main_character} =
        get_main_character(user_settings, characters_with_access, characters_with_access)

      following_character_eve_id =
        case user_settings do
          nil -&gt; nil
          %{following_character_eve_id: following_character_eve_id} -&gt; following_character_eve_id
        end

      main_character_eve_id =
        case main_character do
          nil -&gt; nil
          %{eve_id: eve_id} -&gt; eve_id
        end

      {:ok,
       %{
         characters: characters_data,
         main: main_character_eve_id,
         following: following_character_eve_id
       }}
    else
      nil -&gt;
        Logger.warning(&quot;User not found when building tracking data&quot;, %{user_id: current_user_id})
        {:error, &quot;User not found&quot;}

      error -&gt;
        Logger.error(&quot;Error building tracking data: #{inspect(error)}&quot;)
        {:error, &quot;Failed to build tracking data&quot;}
    end
  end

  # Helper to build tracking data for each character
  defp build_character_tracking_data(characters, character_settings) do
    {:ok,
     Enum.map(characters, fn char -&gt;
       setting = Enum.find(character_settings, &amp;(&amp;1.character_id == char.id))

       %{
         character: char |&gt; WandererAppWeb.MapEventHandler.map_ui_character_stat(),
         tracked: (setting &amp;&amp; setting.tracked) || false
       }
     end)}
  end

  # Private implementation of update character tracking
  defp do_update_character_tracking(character, map_id, track, caller_pid) do
    WandererApp.MapCharacterSettingsRepo.get_by_map(map_id, character.id)
    |&gt; case do
      # Untracking flow
      {:ok, %{tracked: true} = existing_settings} -&gt;
        if not track do
          {:ok, updated_settings} =
            WandererApp.MapCharacterSettingsRepo.untrack(existing_settings)

          :ok = untrack([character], map_id, caller_pid)
          {:ok, updated_settings}
        else
          {:ok, existing_settings}
        end

      # Tracking flow
      {:ok, %{tracked: false} = existing_settings} -&gt;
        if track do
          {:ok, updated_settings} = WandererApp.MapCharacterSettingsRepo.track(existing_settings)
          :ok = track([character], map_id, true, caller_pid)
          {:ok, updated_settings}
        else
          {:ok, existing_settings}
        end

      {:error, :not_found} -&gt;
        if track do
          # Create new settings with tracking enabled
          {:ok, settings} =
            WandererApp.MapCharacterSettingsRepo.create(%{
              character_id: character.id,
              map_id: map_id,
              tracked: true
            })

          :ok = track([character], map_id, true, caller_pid)
          {:ok, settings}
        else
          {:error, &quot;Character settings not found&quot;}
        end

      error -&gt;
        error
    end
  end

  # Helper functions for character tracking

  def track([], _map_id, _is_track_character?, _), do: :ok

  def track([character | characters], map_id, is_track_allowed, caller_pid) do
    with :ok &lt;- track_character(character, map_id, is_track_allowed, caller_pid) do
      track(characters, map_id, is_track_allowed, caller_pid)
    end
  end

  defp track_character(
         %{
           id: character_id,
           eve_id: eve_id
         },
         map_id,
         is_track_allowed,
         caller_pid
       )
       when not is_nil(caller_pid) do
    WandererAppWeb.Presence.update(caller_pid, map_id, character_id, %{
      tracked: is_track_allowed,
      from: DateTime.utc_now()
    })
    |&gt; case do
      {:ok, _} -&gt;
        :ok

      {:error, :nopresence} -&gt;
        WandererAppWeb.Presence.track(caller_pid, map_id, character_id, %{
          tracked: is_track_allowed,
          from: DateTime.utc_now()
        })

      error -&gt;
        Logger.error(&quot;Failed to update presence: #{inspect(error)}&quot;)
        {:error, &quot;Failed to update presence&quot;}
    end

    cache_key = &quot;#{inspect(caller_pid)}_map_#{map_id}:character_#{character_id}:tracked&quot;

    case WandererApp.Cache.lookup!(cache_key, false) do
      true -&gt;
        :ok

      _ -&gt;
        :ok = Phoenix.PubSub.subscribe(WandererApp.PubSub, &quot;character:#{eve_id}&quot;)
        :ok = WandererApp.Cache.put(cache_key, true)
    end

    if is_track_allowed do
      :ok = WandererApp.Character.TrackerManager.start_tracking(character_id)
    end

    :ok
  end

  defp track_character(
         _character,
         _map_id,
         _is_track_allowed,
         _caller_pid
       ) do
    Logger.error(&quot;caller_pid is required for tracking characters&quot;)
    {:error, &quot;caller_pid is required&quot;}
  end

  def untrack(characters, map_id, caller_pid) do
    with false &lt;- is_nil(caller_pid) do
      character_ids = characters |&gt; Enum.map(&amp; &amp;1.id)

      character_ids
      |&gt; Enum.each(fn character_id -&gt;
        WandererAppWeb.Presence.update(caller_pid, map_id, character_id, %{
          tracked: false,
          from: DateTime.utc_now()
        })
      end)

      # WandererApp.Map.Server.untrack_characters(map_id, character_ids)

      :ok
    else
      true -&gt;
        Logger.error(&quot;caller_pid is required for untracking characters&quot;)
        {:error, &quot;caller_pid is required&quot;}
    end
  end

  # def add_characters([], _map_id, _track_character), do: :ok

  # def add_characters([character | characters], map_id, track_character) do
  #   :ok = WandererApp.Map.Server.add_character(map_id, character, track_character)
  #   add_characters(characters, map_id, track_character)
  # end

  # def remove_characters([], _map_id), do: :ok

  # def remove_characters([character | characters], map_id) do
  #   :ok = WandererApp.Map.Server.remove_character(map_id, character.id)
  #   remove_characters(characters, map_id)
  # end

  def get_main_character(
        nil,
        current_user_characters,
        available_map_characters
      ),
      do:
        get_main_character(
          %{main_character_eve_id: nil},
          current_user_characters,
          available_map_characters
        )

  def get_main_character(
        %{main_character_eve_id: nil} = _map_user_settings,
        _current_user_characters,
        available_map_characters
      ),
      do: {:ok, available_map_characters |&gt; Enum.sort_by(&amp; &amp;1.inserted_at) |&gt; List.first()}

  def get_main_character(
        %{main_character_eve_id: main_character_eve_id} = _map_user_settings,
        current_user_characters,
        _available_map_characters
      ),
      do:
        {:ok,
         current_user_characters
         |&gt; Enum.find(fn c -&gt; c.eve_id === main_character_eve_id end)}
end</file><file path="lib/wanderer_app/character/transactions_tracker_impl.ex">defmodule WandererApp.Character.TransactionsTracker.Impl do
  @moduledoc false
  require Logger

  alias WandererApp.Api.Character

  defstruct [
    :character_id,
    :character,
    :max_retries,
    :wallets,
    total_balance: 0,
    transactions: [],
    retries: 5,
    server_online: true,
    status: :started
  ]

  @update_interval :timer.minutes(1)

  def update(%__MODULE__{character: _character} = state) do
    state
  end

  def get_total_balance(%__MODULE__{total_balance: total_balance} = _state) do
    {:ok, total_balance}
  end

  def get_transactions(%__MODULE__{transactions: transactions} = _state) do
    {:ok, transactions}
  end

  def init(args) do
    character = load_character(args[:character_id])

    %__MODULE__{
      character_id: args[:character_id],
      character: character,
      wallets: [],
      max_retries: 5
    }
  end

  def start(%{character: character} = state) do
    Phoenix.PubSub.subscribe(
      WandererApp.PubSub,
      &quot;server_status&quot;
    )

    Phoenix.PubSub.subscribe(
      WandererApp.PubSub,
      &quot;character:#{character.id}&quot;
    )

    {:ok, latest_transactions} = WandererApp.Api.CorpWalletTransaction.latest()

    case WandererApp.Character.can_track_corp_wallet?(character) do
      true -&gt;
        Process.send_after(self(), :update_corp_wallets, 500)
        Process.send_after(self(), :check_wallets, 500)

      _ -&gt;
        :ok
    end

    %{state | transactions: latest_transactions}
  end

  def handle_event({:server_status, status}, state),
    do: %{state | server_online: not status.vip}

  def handle_event(:token_updated, %{character: character} = state),
    do: %{state | character: load_character(character.id)}

  def handle_event(
        :update_corp_wallets,
        %{character: character} = state
      ) do
    Process.send_after(self(), :update_corp_wallets, @update_interval)

    Task.async(fn -&gt; update_corp_wallets(character) end)

    state
  end

  def handle_event(
        :update_corp_wallets,
        state
      ) do
    Process.send_after(self(), :update_corp_wallets, :timer.seconds(15))

    state
  end

  def handle_event(
        :check_wallets,
        %{wallets: []} = state
      ) do
    Process.send_after(self(), :check_wallets, :timer.seconds(5))

    state
  end

  def handle_event(
        :check_wallets,
        %{character: character, wallets: wallets} = state
      ) do
    check_wallets(wallets, character)

    Process.send_after(self(), :check_wallets, @update_interval)

    state
  end

  def handle_event({ref, result}, state) do
    Process.demonitor(ref, [:flush])

    case result do
      {:corporation_wallets, result} -&gt;
        state |&gt; maybe_update_total_balance(result)

      {:corporation_wallet_journal, result} -&gt;
        state |&gt; maybe_update_transactions(result)

      {:error, _error} -&gt;
        state

      _ -&gt;
        state
    end
  end

  def handle_event(_action, state),
    do: state

  defp check_wallets([], _character), do: :ok

  defp check_wallets([wallet | wallets], character) do
    check_wallet(wallet, character)
    check_wallets(wallets, character)
  end

  defp check_wallet(%{&quot;division&quot; =&gt; division} = _wallet, character) do
    Task.async(fn -&gt; get_wallet_journal(character, division) end)
  end

  defp get_wallet_journal(
         %{corporation_id: corporation_id, access_token: access_token} = _character,
         division
       )
       when not is_nil(access_token) do
    case WandererApp.Esi.get_corporation_wallet_journal(corporation_id, division,
           params: %{datasource: &quot;tranquility&quot;},
           access_token: access_token
         ) do
      {:ok, result} -&gt;
        {:corporation_wallet_journal, result}

      {:error, :forbidden} -&gt;
        Logger.warning(&quot;#{__MODULE__} failed to get_wallet_journal: forbidden&quot;)
        {:error, :forbidden}

      {:error, :error_limited} -&gt;
        Logger.warning(&quot;#{__MODULE__} failed to get_wallet_journal: error_limited&quot;)
        {:error, :error_limited}

      {:error, error} -&gt;
        Logger.warning(&quot;#{__MODULE__} failed to get_wallet_journal: #{inspect(error)}&quot;)
        {:error, error}
    end
  end

  defp get_wallet_journal(_character, _division), do: {:error, :skipped}

  defp update_corp_wallets(
         %{corporation_id: corporation_id, access_token: access_token} = _character
       )
       when not is_nil(access_token) do
    case WandererApp.Esi.get_corporation_wallets(corporation_id,
           params: %{datasource: &quot;tranquility&quot;},
           access_token: access_token
         ) do
      {:ok, result} -&gt;
        {:corporation_wallets, result}

      {:error, :forbidden} -&gt;
        Logger.warning(&quot;#{__MODULE__} failed to update_corp_wallets: forbidden&quot;)
        {:error, :forbidden}

      {:error, :error_limited} -&gt;
        Logger.warning(&quot;#{__MODULE__} failed to update_corp_wallets: error_limited&quot;)
        {:error, :error_limited}

      {:error, error} -&gt;
        Logger.warning(&quot;#{__MODULE__} failed to update_corp_wallets: #{inspect(error)}&quot;)
        {:error, error}
    end
  end

  defp update_corp_wallets(_character), do: {:error, :skipped}

  defp maybe_update_total_balance(
         %{character: character, total_balance: total_balance} =
           state,
         wallets
       ) do
    new_total_balance =
      Enum.reduce(wallets, 0, fn %{&quot;balance&quot; =&gt; balance}, acc -&gt;
        acc + balance
      end)

    if new_total_balance != total_balance do
      Phoenix.PubSub.broadcast(
        WandererApp.PubSub,
        &quot;corporation&quot;,
        {:total_balance_changed, character.corporation_id, new_total_balance}
      )

      %{state | wallets: wallets, total_balance: new_total_balance}
    else
      %{state | wallets: wallets}
    end
  end

  defp maybe_update_transactions(
         %{character: character, transactions: transactions} =
           state,
         new_transactions
       ) do
    new_transactions =
      new_transactions
      |&gt; Enum.map(&amp;map_transaction/1)

    maybe_save_transactions(new_transactions)

    new_transactions = filter_new_transactions(transactions, new_transactions)

    new_transactions
    |&gt; Enum.each(fn transaction -&gt;
      maybe_update_user_balance(transaction)
    end)

    {:ok, transactions} = WandererApp.Api.CorpWalletTransaction.latest()

    if not (new_transactions |&gt; Enum.empty?()) do
      Phoenix.PubSub.broadcast(
        WandererApp.PubSub,
        &quot;corporation&quot;,
        {:transactions, character.corporation_id, transactions |&gt; Enum.sort_by(&amp; &amp;1.date, :desc)}
      )
    end

    %{state | transactions: transactions}
  end

  def maybe_update_user_balance(
        %{first_party_id: first_party_id, amount_encoded: amount} =
          _transaction
      ) do
    case WandererApp.Api.Character.by_eve_id(&quot;#{first_party_id}&quot;) |&gt; Ash.load(:user) do
      {:ok, character} -&gt;
        {:ok, user} =
          character.user
          |&gt; Ash.load([:balance])

        {:ok, user} =
          user
          |&gt; WandererApp.Api.User.update_balance(%{
            balance: (user.balance || 0.0) + amount
          })

        Phoenix.PubSub.broadcast(
          WandererApp.PubSub,
          &quot;user:#{user.id}&quot;,
          :wanderer_balance_changed
        )

        :telemetry.execute([:wanderer_app, :user, :wallet_balance, :changed], %{count: 1})
        :ok

      _ -&gt;
        :ok
    end
  end

  def maybe_save_transactions(transactions) do
    if not (transactions |&gt; Enum.empty?()) do
      transactions
      |&gt; Ash.bulk_create(WandererApp.Api.CorpWalletTransaction, :new)
    end
  end

  def filter_new_transactions(old_transactions, new_transactions) do
    new_transactions
    |&gt; Enum.filter(fn new_transaction -&gt;
      old_transactions
      |&gt; Enum.find(fn old_transaction -&gt;
        old_transaction.eve_transaction_id == new_transaction.eve_transaction_id
      end)
      |&gt; is_nil()
    end)
  end

  defp map_transaction(%{
         &quot;id&quot; =&gt; id,
         &quot;amount&quot; =&gt; amount,
         &quot;balance&quot; =&gt; balance,
         &quot;date&quot; =&gt; date,
         &quot;description&quot; =&gt; description,
         &quot;first_party_id&quot; =&gt; first_party_id,
         &quot;reason&quot; =&gt; reason,
         &quot;ref_type&quot; =&gt; ref_type,
         &quot;second_party_id&quot; =&gt; second_party_id
       }) do
    {:ok, date, _} = DateTime.from_iso8601(date)

    %{
      eve_transaction_id: id,
      amount_encoded: amount,
      balance_encoded: balance,
      date: date,
      description: description,
      first_party_id: first_party_id,
      reason_encoded: reason,
      ref_type: ref_type,
      second_party_id: second_party_id
    }
  end

  defp load_character(nil), do: nil

  defp load_character(character_id) do
    case Character.by_id(character_id) do
      {:ok, character} -&gt; character
      {:error, _} -&gt; nil
    end
  end
end</file><file path="lib/wanderer_app/character/transactions_tracker_supervisor.ex">defmodule WandererApp.Character.TransactionsTrackerSupervisor do
  @moduledoc false
  use Supervisor, restart: :transient

  def start_link(args), do: Supervisor.start_link(__MODULE__, args)

  @impl true
  def init(args) do
    children = [
      {WandererApp.Character.TransactionsTracker, args}
    ]

    Supervisor.init(children, strategy: :one_for_one, auto_shutdown: :all_significant)
  end
end</file><file path="lib/wanderer_app/character/transactions_tracker.ex">defmodule WandererApp.Character.TransactionsTracker do
  @moduledoc false
  use GenServer, restart: :transient

  require Logger

  alias WandererApp.GenImpl
  alias WandererApp.Character.TransactionsTracker.Impl

  def start_link(args),
    do: GenServer.start_link(__MODULE__, args, name: via(args[:character_id]))

  def update(character_id),
    do: GenServer.cast(via(character_id), {&amp;Impl.update/1, []})

  def get_total_balance(character_id),
    do: GenServer.call(via(character_id), {&amp;Impl.get_total_balance/1, []})

  def get_transactions(character_id),
    do: GenServer.call(via(character_id), {&amp;Impl.get_transactions/1, []})

  def pid(character_id),
    do:
      character_id
      |&gt; via()
      |&gt; GenServer.whereis()

  @impl true
  def init(args) do
    Logger.info(&quot;#{__MODULE__} started for #{args[:character_id]}&quot;)

    {:ok, Impl.init(args), {:continue, :start}}
  end

  @impl true
  def handle_continue(:start, state) do
    {:noreply, state |&gt; Impl.start()}
  end

  @impl true
  def terminate(_reason, _state) do
    :ok
  end

  @impl true
  def handle_call(:error, _, state), do: {:stop, :error, :ok, state}

  @impl true
  def handle_call(:stop, _, state), do: {:stop, :normal, :ok, state}

  @impl true
  def handle_call(
        {impl_function, args},
        _from,
        state
      )
      when is_function(impl_function),
      do: GenImpl.apply_call(impl_function, state, args)

  @impl true
  def handle_cast({impl_function, args}, state)
      when is_function(impl_function) do
    case GenImpl.apply_call(impl_function, state, args) do
      {:reply, _return, updated_state} -&gt;
        {:noreply, updated_state}

      _ -&gt;
        {:noreply, state}
    end
  end

  @impl true
  def handle_info(:shutdown, %Impl{} = state) do
    Logger.debug(fn -&gt; &quot;Shutting down character transaction tracker: #{inspect(state.character_id)}&quot; end)
    {:stop, :normal, state}
  end

  @impl true
  def handle_info(event, state), do: {:noreply, Impl.handle_event(event, state)}

  defp via(character_id) do
    {:via, Registry, {WandererApp.Character.TrackerRegistry, &quot;transactions:#{character_id}&quot;}}
  end
end</file><file path="lib/wanderer_app/esi/api_client.ex">defmodule WandererApp.Esi.ApiClient do
  use Nebulex.Caching
  @moduledoc false

  require Logger
  alias WandererApp.Cache

  @ttl :timer.hours(1)
  @routes_ttl :timer.minutes(15)

  @base_url &quot;https://esi.evetech.net/latest&quot;
  @wanderrer_user_agent &quot;(wanderer-industries@proton.me; +https://github.com/wanderer-industries/wanderer)&quot;

  @get_link_pairs_advanced_params [
    :include_mass_crit,
    :include_eol,
    :include_frig
  ]

  @default_routes_settings %{
    path_type: &quot;shortest&quot;,
    include_mass_crit: true,
    include_eol: false,
    include_frig: true,
    include_cruise: true,
    avoid_wormholes: false,
    avoid_pochven: false,
    avoid_edencom: false,
    avoid_triglavian: false,
    include_thera: true,
    avoid: []
  }

  @zarzakh_system 30_100_000
  @default_avoid_systems [@zarzakh_system]

  @cache_opts [cache: true]
  @retry_opts [max_retries: 0, retry_log_level: :warning]
  @timeout_opts [pool_timeout: 15_000, receive_timeout: :timer.seconds(30)]
  @api_retry_count 1

  @logger Application.compile_env(:wanderer_app, :logger)

  def get_server_status, do: get(&quot;/status&quot;)

  def set_autopilot_waypoint(add_to_beginning, clear_other_waypoints, destination_id, opts \\ []),
    do:
      post_esi(
        &quot;/ui/autopilot/waypoint&quot;,
        opts
        |&gt; Keyword.merge(
          params: %{
            add_to_beginning: add_to_beginning,
            clear_other_waypoints: clear_other_waypoints,
            destination_id: destination_id
          }
        )
      )

  def post_characters_affiliation(character_eve_ids, _opts)
      when is_list(character_eve_ids),
      do:
        post(
          &quot;#{@base_url}/characters/affiliation/&quot;,
          json: character_eve_ids,
          params: %{
            datasource: &quot;tranquility&quot;
          }
        )

  def find_routes(map_id, origin, hubs, routes_settings) do
    origin = origin |&gt; String.to_integer()
    hubs = hubs |&gt; Enum.map(&amp;(&amp;1 |&gt; String.to_integer()))

    routes_settings = @default_routes_settings |&gt; Map.merge(routes_settings)

    connections =
      case routes_settings.avoid_wormholes do
        false -&gt;
          map_chains =
            routes_settings
            |&gt; Map.take(@get_link_pairs_advanced_params)
            |&gt; Map.put_new(:map_id, map_id)
            |&gt; WandererApp.Api.MapConnection.get_link_pairs_advanced!()
            |&gt; Enum.map(fn %{
                             solar_system_source: solar_system_source,
                             solar_system_target: solar_system_target
                           } -&gt;
              %{
                first: solar_system_source,
                second: solar_system_target
              }
            end)
            |&gt; Enum.uniq()

          {:ok, thera_chains} =
            case routes_settings.include_thera do
              true -&gt;
                WandererApp.Server.TheraDataFetcher.get_chain_pairs(routes_settings)

              false -&gt;
                {:ok, []}
            end

          chains = remove_intersection([map_chains | thera_chains] |&gt; List.flatten())

          chains =
            case routes_settings.include_cruise do
              false -&gt;
                {:ok, wh_class_a_systems} = WandererApp.CachedInfo.get_wh_class_a_systems()

                chains
                |&gt; Enum.filter(fn x -&gt;
                  not Enum.member?(wh_class_a_systems, x.first) and
                    not Enum.member?(wh_class_a_systems, x.second)
                end)

              _ -&gt;
                chains
            end

          chains
          |&gt; Enum.map(fn chain -&gt;
            [&quot;#{chain.first}|#{chain.second}&quot;, &quot;#{chain.second}|#{chain.first}&quot;]
          end)
          |&gt; List.flatten()

        true -&gt;
          []
      end

    {:ok, trig_systems} = WandererApp.CachedInfo.get_trig_systems()

    pochven_solar_systems =
      trig_systems
      |&gt; Enum.filter(fn s -&gt; s.triglavian_invasion_status == &quot;Final&quot; end)
      |&gt; Enum.map(&amp; &amp;1.solar_system_id)

    triglavian_solar_systems =
      trig_systems
      |&gt; Enum.filter(fn s -&gt; s.triglavian_invasion_status == &quot;Triglavian&quot; end)
      |&gt; Enum.map(&amp; &amp;1.solar_system_id)

    edencom_solar_systems =
      trig_systems
      |&gt; Enum.filter(fn s -&gt; s.triglavian_invasion_status == &quot;Edencom&quot; end)
      |&gt; Enum.map(&amp; &amp;1.solar_system_id)

    avoidance_list =
      case routes_settings.avoid_edencom do
        true -&gt;
          edencom_solar_systems

        false -&gt;
          []
      end

    avoidance_list =
      case routes_settings.avoid_triglavian do
        true -&gt;
          [avoidance_list | triglavian_solar_systems]

        false -&gt;
          avoidance_list
      end

    avoidance_list =
      case routes_settings.avoid_pochven do
        true -&gt;
          [avoidance_list | pochven_solar_systems]

        false -&gt;
          avoidance_list
      end

    avoidance_list =
      (@default_avoid_systems ++ [routes_settings.avoid | avoidance_list])
      |&gt; List.flatten()
      |&gt; Enum.uniq()

    params =
      %{
        datasource: &quot;tranquility&quot;,
        flag: routes_settings.path_type,
        connections: connections,
        avoid: avoidance_list
      }

    {:ok, all_routes} = get_all_routes(hubs, origin, params)

    routes =
      all_routes
      |&gt; Enum.map(fn route_info -&gt;
        map_route_info(route_info)
      end)
      |&gt; Enum.filter(fn route_info -&gt; not is_nil(route_info) end)

    {:ok, routes}
  end

  def get_all_routes(hubs, origin, params, opts \\ []) do
    cache_key =
      &quot;routes-#{origin}-#{hubs |&gt; Enum.join(&quot;-&quot;)}-#{:crypto.hash(:sha, :erlang.term_to_binary(params))}&quot;

    case WandererApp.Cache.lookup(cache_key) do
      {:ok, result} when not is_nil(result) -&gt;
        {:ok, result}

      _ -&gt;
        case get_all_routes_custom(hubs, origin, params) do
          {:ok, result} -&gt;
            WandererApp.Cache.insert(
              cache_key,
              result,
              ttl: @routes_ttl
            )

            {:ok, result}

          {:error, _error} -&gt;
            @logger.error(&quot;Error getting custom routes for #{inspect(origin)}: #{inspect(hubs)}&quot;)

            @logger.error(
              &quot;Error getting custom routes for #{inspect(origin)}: #{inspect(params)}&quot;
            )

            get_all_routes_eve(hubs, origin, params, opts)
        end
    end
  end

  defp get_all_routes_custom(hubs, origin, params),
    do:
      post(
        &quot;#{get_custom_route_base_url()}/route/multiple&quot;,
        [
          json: %{
            origin: origin,
            destinations: hubs,
            flag: params.flag,
            connections: params.connections,
            avoid: params.avoid
          }
        ]
        |&gt; Keyword.merge(@timeout_opts)
      )

  def get_all_routes_eve(hubs, origin, params, opts),
    do:
      {:ok,
       hubs
       |&gt; Task.async_stream(
         fn destination -&gt;
           get_routes(origin, destination, params, opts)
         end,
         max_concurrency: 20,
         timeout: :timer.seconds(30),
         on_timeout: :kill_task
       )
       |&gt; Enum.map(fn result -&gt;
         case result do
           {:ok, val} -&gt; val
           {:error, error} -&gt; {:error, error}
           _ -&gt; {:error, :failed}
         end
       end)}

  def get_routes(origin, destination, params, opts) do
    case _get_routes(origin, destination, params, opts) do
      {:ok, result} -&gt;
        %{
          &quot;origin&quot; =&gt; origin,
          &quot;destination&quot; =&gt; destination,
          &quot;systems&quot; =&gt; result,
          &quot;success&quot; =&gt; true
        }

      {:error, :not_found} -&gt;
        %{&quot;origin&quot; =&gt; origin, &quot;destination&quot; =&gt; destination, &quot;systems&quot; =&gt; [], &quot;success&quot; =&gt; false}

      {:error, error} -&gt;
        Logger.warning(&quot;Error getting routes: #{inspect(error)}&quot;)
        %{&quot;origin&quot; =&gt; origin, &quot;destination&quot; =&gt; destination, &quot;systems&quot; =&gt; [], &quot;success&quot; =&gt; false}
    end
  end

  @decorate cacheable(
              cache: Cache,
              key: &quot;info-#{eve_id}&quot;,
              opts: [ttl: @ttl]
            )
  def get_alliance_info(eve_id, opts \\ []) do
    case _get_alliance_info(eve_id, &quot;&quot;, opts) do
      {:ok, result} -&gt; {:ok, result |&gt; Map.put(&quot;eve_id&quot;, eve_id)}
      {:error, error} -&gt; {:error, error}
    end
  end

  @decorate cacheable(
              cache: Cache,
              key: &quot;killmail-#{killmail_id}-#{killmail_hash}&quot;,
              opts: [ttl: @ttl]
            )
  def get_killmail(killmail_id, killmail_hash, opts \\ []) do
    get(&quot;/killmails/#{killmail_id}/#{killmail_hash}/&quot;, opts, @cache_opts)
  end

  @decorate cacheable(
              cache: Cache,
              key: &quot;info-#{eve_id}&quot;,
              opts: [ttl: @ttl]
            )
  def get_corporation_info(eve_id, opts \\ []) do
    case _get_corporation_info(eve_id, &quot;&quot;, opts) do
      {:ok, result} -&gt; {:ok, result |&gt; Map.put(&quot;eve_id&quot;, eve_id)}
      {:error, error} -&gt; {:error, error}
    end
  end

  @decorate cacheable(
              cache: Cache,
              key: &quot;info-#{eve_id}&quot;,
              opts: [ttl: @ttl]
            )
  def get_character_info(eve_id, opts \\ []) do
    case get(
           &quot;/characters/#{eve_id}/&quot;,
           opts,
           @cache_opts
         ) do
      {:ok, result} -&gt; {:ok, result |&gt; Map.put(&quot;eve_id&quot;, eve_id)}
      {:error, error} -&gt; {:error, error}
    end
  end

  @decorate cacheable(
              cache: Cache,
              key: &quot;get_custom_route_base_url&quot;
            )
  def get_custom_route_base_url, do: WandererApp.Env.custom_route_base_url()

  def get_character_wallet(character_eve_id, opts \\ []),
    do: get_character_auth_data(character_eve_id, &quot;wallet&quot;, opts ++ @cache_opts)

  def get_corporation_wallets(corporation_id, opts \\ []),
    do: get_corporation_auth_data(corporation_id, &quot;wallets&quot;, opts)

  def get_corporation_wallet_journal(corporation_id, division, opts \\ []),
    do:
      get_corporation_auth_data(
        corporation_id,
        &quot;wallets/#{division}/journal&quot;,
        opts
      )

  def get_corporation_wallet_transactions(corporation_id, division, opts \\ []),
    do:
      get_corporation_auth_data(
        corporation_id,
        &quot;wallets/#{division}/transactions&quot;,
        opts
      )

  def get_character_location(character_eve_id, opts \\ []),
    do: get_character_auth_data(character_eve_id, &quot;location&quot;, opts ++ @cache_opts)

  def get_character_online(character_eve_id, opts \\ []),
    do: get_character_auth_data(character_eve_id, &quot;online&quot;, opts ++ @cache_opts)

  def get_character_ship(character_eve_id, opts \\ []),
    do: get_character_auth_data(character_eve_id, &quot;ship&quot;, opts ++ @cache_opts)

  def search(character_eve_id, opts \\ []) do
    search_val = to_string(opts[:params][:search] || &quot;&quot;)
    categories_val = to_string(opts[:params][:categories] || &quot;character,alliance,corporation&quot;)

    query_params = [
      {&quot;search&quot;, search_val},
      {&quot;categories&quot;, categories_val},
      {&quot;language&quot;, &quot;en-us&quot;},
      {&quot;strict&quot;, &quot;false&quot;},
      {&quot;datasource&quot;, &quot;tranquility&quot;}
    ]

    merged_opts = Keyword.put(opts, :params, query_params)
    get_search(character_eve_id, search_val, categories_val, merged_opts)
  end

  @decorate cacheable(
              cache: Cache,
              key: &quot;search-#{character_eve_id}-#{categories_val}-#{search_val |&gt; Slug.slugify()}&quot;,
              opts: [ttl: @ttl]
            )
  defp get_search(character_eve_id, search_val, categories_val, merged_opts) do
    get_character_auth_data(character_eve_id, &quot;search&quot;, merged_opts)
  end

  defp remove_intersection(pairs_arr) do
    tuples = pairs_arr |&gt; Enum.map(fn x -&gt; {x.first, x.second} end)

    tuples
    |&gt; Enum.reduce([], fn {first, second} = x, acc -&gt;
      if Enum.member?(tuples, {second, first}) do
        acc
      else
        [x | acc]
      end
    end)
    |&gt; Enum.uniq()
    |&gt; Enum.map(fn {first, second} -&gt;
      %{
        first: first,
        second: second
      }
    end)
  end

  defp _get_routes(origin, destination, params, opts),
    do: get_routes_eve(origin, destination, params, opts)

  defp get_routes_eve(origin, destination, params, opts) do
    esi_params =
      Map.merge(params, %{
        connections: params.connections |&gt; Enum.join(&quot;,&quot;),
        avoid: params.avoid |&gt; Enum.join(&quot;,&quot;)
      })

    get(
      &quot;/route/#{origin}/#{destination}/?#{esi_params |&gt; Plug.Conn.Query.encode()}&quot;,
      opts,
      @cache_opts
    )
  end

  defp get_auth_opts(opts), do: [auth: {:bearer, opts[:access_token]}]

  defp _get_alliance_info(alliance_eve_id, info_path, opts),
    do:
      get(
        &quot;/alliances/#{alliance_eve_id}/#{info_path}&quot;,
        opts,
        @cache_opts
      )

  defp _get_corporation_info(corporation_eve_id, info_path, opts),
    do:
      get(
        &quot;/corporations/#{corporation_eve_id}/#{info_path}&quot;,
        opts,
        @cache_opts
      )

  defp get_character_auth_data(character_eve_id, info_path, opts) do
    path = &quot;/characters/#{character_eve_id}/#{info_path}&quot;

    auth_opts =
      [params: opts[:params] || []] ++
        (opts |&gt; get_auth_opts())

    character_id = opts |&gt; Keyword.get(:character_id, nil)

    if not is_access_token_expired?(character_id) do
      get(
        path,
        auth_opts,
        opts
      )
    else
      get_retry(path, auth_opts, opts)
    end
  end

  defp is_access_token_expired?(character_id) do
    {:ok, %{expires_at: expires_at} = _character} =
      WandererApp.Character.get_character(character_id)

    now = DateTime.utc_now() |&gt; DateTime.to_unix()

    expires_at - now &lt;= 0
  end

  defp get_corporation_auth_data(corporation_eve_id, info_path, opts),
    do:
      get(
        &quot;/corporations/#{corporation_eve_id}/#{info_path}&quot;,
        [params: opts[:params] || []] ++
          (opts |&gt; get_auth_opts()),
        opts ++ @cache_opts
      )

  defp with_user_agent_opts(opts) do
    opts
    |&gt; Keyword.merge(
      headers: [{:user_agent, &quot;Wanderer/#{WandererApp.Env.vsn()} #{@wanderrer_user_agent}&quot;}]
    )
  end

  defp with_cache_opts(opts) do
    opts |&gt; Keyword.merge(@cache_opts) |&gt; Keyword.merge(cache_dir: System.tmp_dir!())
  end

  defp post_esi(path, opts),
    do:
      post(
        &quot;#{@base_url}#{path}&quot;,
        [params: opts[:params] || []] ++ (opts |&gt; get_auth_opts())
      )

  defp get(path, api_opts \\ [], opts \\ []) do
    case Cachex.get(:api_cache, path) do
      {:ok, cached_data} when not is_nil(cached_data) -&gt;
        {:ok, cached_data}

      _ -&gt;
        do_get_request(path, api_opts, opts)
    end
  end

  defp do_get_request(path, api_opts \\ [], opts \\ []) do
    try do
      case Req.get(
             &quot;#{@base_url}#{path}&quot;,
             api_opts
             |&gt; with_user_agent_opts()
             |&gt; with_cache_opts()
             |&gt; Keyword.merge(@retry_opts)
             |&gt; Keyword.merge(@timeout_opts)
           ) do
        {:ok, %{status: 200, body: body, headers: headers}} -&gt;
          maybe_cache_response(path, body, headers, opts)

          {:ok, body}

        {:ok, %{status: 504}} -&gt;
          {:error, :timeout}

        {:ok, %{status: 404}} -&gt;
          {:error, :not_found}

        {:ok, %{status: 403} = _error} -&gt;
          get_retry(path, api_opts, opts)

        {:ok, %{status: 420} = _error} -&gt;
          get_retry(path, api_opts, opts, :error_limited)

        {:ok, %{status: status}} -&gt;
          {:error, &quot;Unexpected status: #{status}&quot;}

        {:error, _reason} -&gt;
          {:error, &quot;Request failed&quot;}
      end
    rescue
      e -&gt;
        @logger.error(Exception.message(e))

        {:error, &quot;Request failed&quot;}
    end
  end

  defp maybe_cache_response(path, body, %{&quot;expires&quot; =&gt; [expires]}, opts)
       when is_binary(path) and not is_nil(expires) do
    try do
      if opts |&gt; Keyword.get(:cache, false) do
        cached_ttl =
          DateTime.diff(Timex.parse!(expires, &quot;{RFC1123}&quot;), DateTime.utc_now(), :millisecond)

        Cachex.put(
          :api_cache,
          path,
          body,
          ttl: cached_ttl
        )
      end
    rescue
      e -&gt;
        @logger.error(Exception.message(e))

        :ok
    end
  end

  defp maybe_cache_response(_path, _body, _headers, _opts), do: :ok

  defp post(url, opts) do
    try do
      case Req.post(&quot;#{url}&quot;, opts |&gt; with_user_agent_opts()) do
        {:ok, %{status: status, body: body}} when status in [200, 201] -&gt;
          {:ok, body}

        {:ok, %{status: 504}} -&gt;
          {:error, :timeout}

        {:ok, %{status: 403}} -&gt;
          {:error, :forbidden}

        {:ok, %{status: 420}} -&gt;
          {:error, :error_limited}

        {:ok, %{status: status}} -&gt;
          {:error, &quot;Unexpected status: #{status}&quot;}

        {:error, reason} -&gt;
          {:error, reason}
      end
    rescue
      e -&gt;
        @logger.error(Exception.message(e))

        {:error, &quot;Request failed&quot;}
    end
  end

  defp get_retry(path, api_opts, opts, status \\ :forbidden) do
    refresh_token? = opts |&gt; Keyword.get(:refresh_token?, false)
    retry_count = opts |&gt; Keyword.get(:retry_count, 0)
    character_id = opts |&gt; Keyword.get(:character_id, nil)

    if not refresh_token? or is_nil(character_id) or retry_count &gt;= @api_retry_count do
      {:error, status}
    else
      case refresh_token(character_id) do
        {:ok, token} -&gt;
          auth_opts = [access_token: token.access_token] |&gt; get_auth_opts()

          get(
            path,
            api_opts |&gt; Keyword.merge(auth_opts),
            opts |&gt; Keyword.merge(retry_count: retry_count + 1)
          )

        {:error, _error} -&gt;
          {:error, status}
      end
    end
  end

  defp refresh_token(character_id) do
    {:ok, %{expires_at: expires_at, refresh_token: refresh_token, scopes: scopes} = character} =
      WandererApp.Character.get_character(character_id)

    refresh_token_result =
      WandererApp.Ueberauth.Strategy.Eve.OAuth.get_refresh_token([],
        with_wallet: WandererApp.Character.can_track_wallet?(character),
        is_admin?: WandererApp.Character.can_track_corp_wallet?(character),
        token: %OAuth2.AccessToken{refresh_token: refresh_token}
      )

    handle_refresh_token_result(refresh_token_result, character, character_id, expires_at, scopes)
  end

  defp handle_refresh_token_result(
         {:ok, %OAuth2.AccessToken{} = token},
         character,
         character_id,
         _expires_at,
         scopes
       ) do
    {:ok, _character} =
      character
      |&gt; WandererApp.Api.Character.update(%{
        access_token: token.access_token,
        expires_at: token.expires_at,
        scopes: scopes
      })

    WandererApp.Character.update_character(character_id, %{
      access_token: token.access_token,
      expires_at: token.expires_at
    })

    Phoenix.PubSub.broadcast(
      WandererApp.PubSub,
      &quot;character:#{character_id}&quot;,
      :token_updated
    )

    {:ok, token}
  end

  defp handle_refresh_token_result(
         {:error, {&quot;invalid_grant&quot;, error_message}},
         character,
         character_id,
         expires_at,
         scopes
       ) do
    invalidate_character_tokens(character, character_id, expires_at, scopes)
    Logger.warning(&quot;Failed to refresh token for #{character_id}: #{error_message}&quot;)
    {:error, :invalid_grant}
  end

  defp handle_refresh_token_result(
         {:error, %OAuth2.Error{reason: :econnrefused} = error},
         character,
         character_id,
         expires_at,
         scopes
       ) do
    Logger.warning(&quot;Failed to refresh token for #{character_id}: #{inspect(error)}&quot;)
    {:error, :econnrefused}
  end

  defp handle_refresh_token_result(
         {:error, %OAuth2.Error{} = error},
         character,
         character_id,
         expires_at,
         scopes
       ) do
    invalidate_character_tokens(character, character_id, expires_at, scopes)
    Logger.warning(&quot;Failed to refresh token for #{character_id}: #{inspect(error)}&quot;)
    {:error, :invalid_grant}
  end

  defp handle_refresh_token_result(error, character, character_id, expires_at, scopes) do
    Logger.warning(&quot;Failed to refresh token for #{character_id}: #{inspect(error)}&quot;)
    invalidate_character_tokens(character, character_id, expires_at, scopes)
    {:error, :failed}
  end

  defp invalidate_character_tokens(character, character_id, expires_at, scopes) do
    attrs = %{access_token: nil, refresh_token: nil, expires_at: expires_at, scopes: scopes}

    with {:ok, _} &lt;- WandererApp.Api.Character.update(character, attrs) do
      WandererApp.Character.update_character(character_id, attrs)
      :ok
    else
      error -&gt;
        Logger.error(&quot;Failed to clear tokens for #{character_id}: #{inspect(error)}&quot;)
    end

    Phoenix.PubSub.broadcast(
      WandererApp.PubSub,
      &quot;character:#{character_id}&quot;,
      :character_token_invalid
    )
  end

  defp map_route_info(
         %{
           &quot;origin&quot; =&gt; origin,
           &quot;destination&quot; =&gt; destination,
           &quot;systems&quot; =&gt; result_systems,
           &quot;success&quot; =&gt; success
         } = _route_info
       ),
       do:
         map_route_info(%{
           origin: origin,
           destination: destination,
           systems: result_systems,
           success: success
         })

  defp map_route_info(
         %{origin: origin, destination: destination, systems: result_systems, success: success} =
           _route_info
       ) do
    systems =
      case result_systems do
        [] -&gt;
          []

        _ -&gt;
          result_systems |&gt; Enum.reject(fn system_id -&gt; system_id == origin end)
      end

    %{
      has_connection: result_systems != [],
      systems: systems,
      origin: origin,
      destination: destination,
      success: success
    }
  end

  defp map_route_info(_), do: nil
end</file><file path="lib/wanderer_app/helpers/config.ex">defmodule WandererApp.ConfigHelpers do
  def get_var_from_path_or_env(config_dir, var_name, default \\ nil) do
    var_path = Path.join(config_dir, var_name)

    if File.exists?(var_path) do
      File.read!(var_path) |&gt; String.trim()
    else
      System.get_env(var_name, default)
    end
  end

  def get_int_from_path_or_env(config_dir, var_name, default \\ nil) do
    var = get_var_from_path_or_env(config_dir, var_name)

    case var do
      nil -&gt;
        default

      var -&gt;
        case Integer.parse(var) do
          {int, &quot;&quot;} -&gt; int
          _ -&gt; raise &quot;Config variable #{var_name} must be an integer. Got #{var}&quot;
        end
    end
  end
end</file><file path="lib/wanderer_app/license/license_manager_client.ex">defmodule WandererApp.License.LicenseManagerClient do
  @moduledoc &quot;&quot;&quot;
  Client for interacting with the external License Manager API.

  This module provides functions to create, update, and validate licenses
  through the external License Manager API.
  &quot;&quot;&quot;

  require Logger

  @doc &quot;&quot;&quot;
  Creates a new license in the License Manager.

  ## Parameters

  - `license_params` - Map containing license details:
    - `name` (required) - Name of the license
    - `description` (optional) - Description of the license
    - `is_valid` (optional) - Boolean indicating if the license is valid
    - `valid_to` (optional) - Expiration date in YYYY-MM-DD format
    - `link` (required) - URL associated with the license
    - `contact_email` (optional) - Contact email for the license

  ## Returns

  - `{:ok, license}` - On successful creation
  - `{:error, reason}` - On failure
  &quot;&quot;&quot;
  def create_license(license_params) do
    url = &quot;#{api_url()}/api/manage/licenses&quot;

    auth_opts = [auth: {:bearer, auth_key()}]

    log_request(&quot;POST&quot;, url, license_params)

    with {:ok, %{status: status, body: license}} when status in 200..299 &lt;-
           Req.post(url, [json: license_params] ++ auth_opts) do
      log_response(status, license)
      {:ok, license}
    else
      {:ok, %{status: status, body: body}} -&gt;
        Logger.error(&quot;Failed to create license. Status: #{status}, Body: #{body}&quot;)
        parse_error_response(status, body)

      {:error, error} -&gt;
        Logger.error(&quot;HTTP request failed: #{inspect(error)}&quot;)
        {:error, :request_failed}
    end
  end

  @doc &quot;&quot;&quot;
  Updates an existing license in the License Manager.

  ## Parameters

  - `license_id` - ID of the license to update
  - `update_params` - Map containing fields to update:
    - `is_valid` (optional) - Boolean indicating if the license is valid
    - `valid_to` (optional) - Expiration date in YYYY-MM-DD format

  ## Returns

  - `{:ok, license}` - On successful update
  - `{:error, reason}` - On failure
  &quot;&quot;&quot;
  def update_license(license_id, update_params) do
    url = &quot;#{api_url()}/api/manage/licenses/#{license_id}&quot;

    auth_opts = [auth: {:bearer, auth_key()}]

    log_request(&quot;PUT&quot;, url, update_params)

    with {:ok, %{status: status, body: license}} when status in 200..299 &lt;-
           Req.put(url, [json: update_params] ++ auth_opts) do
      log_response(status, license)
      {:ok, license}
    else
      {:ok, %{status: status, body: body}} -&gt;
        Logger.error(&quot;Failed to update license. Status: #{status}, Body: #{inspect(body)}&quot;)
        parse_error_response(status, body)

      {:error, error} -&gt;
        Logger.error(&quot;HTTP request failed: #{inspect(error)}&quot;)
        {:error, :request_failed}
    end
  end

  @doc &quot;&quot;&quot;
  Validates a license key.

  ## Parameters

  - `license_key` - The license key to validate

  ## Returns

  - `{:ok, result}` - On successful validation, where result is a map containing:
    - `license_valid` - Boolean indicating if the license is valid
    - `valid_to` - Expiration date of the license
    - `license_id` - UUID of the license
    - `license_name` - Name of the license
    - `bots` - List of associated bots with their details
  - `{:error, reason}` - On failure
  &quot;&quot;&quot;
  def validate_license(license_key) do
    url = &quot;#{api_url()}/api/license/validate&quot;

    auth_opts = [auth: {:bearer, license_key}]

    log_request(&quot;GET&quot;, url, nil)

    with {:ok, %{status: 200, body: validation_result}} &lt;- Req.get(url, auth_opts) do
      log_response(200, validation_result)
      {:ok, validation_result}
    else
      {:ok, %{status: 401}} -&gt;
        {:error, :invalid_license}

      {:ok, %{status: status, body: body}} -&gt;
        Logger.error(&quot;Failed to validate license. Status: #{status}, Body: #{body}&quot;)
        parse_error_response(status, body)

      {:error, error} -&gt;
        Logger.error(&quot;HTTP request failed: #{inspect(error)}&quot;)
        {:error, :request_failed}
    end
  end

  # Private helper functions
  defp api_url do
    Application.get_env(:wanderer_app, :license_manager)[:api_url]
  end

  defp auth_key do
    Application.get_env(:wanderer_app, :license_manager)[:auth_key]
  end

  defp parse_error_response(status, %{&quot;error&quot; =&gt; error_message}) do
    {:error, error_message}
  end

  defp parse_error_response(status, error) do
    {:error, &quot;HTTP #{status}: #{inspect(error)}&quot;}
  end

  defp log_request(method, url, params) do
    Logger.info(&quot;License Manager API Request: #{method} #{url}&quot;)
    Logger.debug(&quot;License Manager API Params: #{inspect(params)}&quot;)
  end

  defp log_response(status, body) do
    Logger.info(&quot;License Manager API Response: Status #{status}&quot;)
    Logger.debug(&quot;License Manager API Response Body: #{inspect(body)}&quot;)
  end
end</file><file path="lib/wanderer_app/license/license_manager.ex">defmodule WandererApp.License.LicenseManager do
  @moduledoc &quot;&quot;&quot;
  Manages bot licenses, including creation, validation, and expiration.

  This module provides functions for:
  - Creating licenses for maps with active subscriptions
  - Validating license keys
  - Checking license expiration
  - Generating unique license keys
  &quot;&quot;&quot;

  require Logger

  alias WandererApp.Api.License
  alias WandererApp.Api.Map
  alias WandererApp.Map.SubscriptionManager
  alias WandererApp.License.LicenseManagerClient

  @doc &quot;&quot;&quot;
  Creates a new license for a map if it has an active subscription.
  Returns {:ok, license} if successful, {:error, reason} otherwise.
  &quot;&quot;&quot;
  def create_license_for_map(map_id) do
    with {:ok, map} &lt;- Map.by_id(map_id),
         {:ok, true} &lt;- WandererApp.Map.is_subscription_active?(map_id),
         {:ok, subscription} &lt;- SubscriptionManager.get_active_map_subscription(map_id) do
      # Create a license in the local database

      # Create a license in the external License Manager service
      license_params = %{
        &quot;name&quot; =&gt; &quot;#{map.name} License&quot;,
        &quot;description&quot; =&gt; &quot;License for #{map.name} map&quot;,
        &quot;is_valid&quot; =&gt; true,
        &quot;valid_to&quot; =&gt; format_date(subscription.active_till),
        &quot;link&quot; =&gt; generate_map_link(map.slug),
        &quot;contact_email&quot; =&gt; get_map_owner_email(map)
      }

      case LicenseManagerClient.create_license(license_params) do
        {:ok, external_license} -&gt;
          License.create(%{
            map_id: map_id,
            lm_id: external_license[&quot;id&quot;],
            license_key: external_license[&quot;key&quot;],
            is_valid: true,
            expire_at: subscription.active_till
          })

        {:error, reason} -&gt;
          # Log the error but don&apos;t fail the operation
          Logger.error(&quot;Failed to create license in external service: #{inspect(reason)}&quot;)
          {:error, reason}
      end
    else
      {:ok, false} -&gt; {:error, :no_active_subscription}
      error -&gt; error
    end
  end

  @doc &quot;&quot;&quot;
  Validates a license key.
  Returns {:ok, license} if valid, {:error, reason} otherwise.
  &quot;&quot;&quot;
  def validate_license(license_key) do
    # First check in our local database
    case License.by_key(license_key) do
      {:ok, license} -&gt;
        case LicenseManagerClient.validate_license(license_key) do
          {:ok, %{&quot;license_valid&quot; =&gt; is_valid}} -&gt;
            {:ok, %{license | is_valid: is_valid}}

          {:error, reason} -&gt;
            # External validation failed, but we&apos;ll still consider it valid
            # if it&apos;s valid in our local database
            {:error, reason}
        end

      error -&gt;
        error
    end
  end

  @doc &quot;&quot;&quot;
  Invalidates a license.
  &quot;&quot;&quot;
  def invalidate_license(license_id) do
    with {:ok, license} &lt;- License.by_id(license_id) do
      # Try to invalidate in external service
      case LicenseManagerClient.update_license(license.lm_id, %{
             &quot;is_valid&quot; =&gt; false
           }) do
        {:ok, _} -&gt;
          License.invalidate(license)

        error -&gt;
          error
      end
    end
  end

  @doc &quot;&quot;&quot;
  Updates the expiration date of a license.
  &quot;&quot;&quot;
  def update_expiration(license_id, expire_at) do
    with {:ok, license} &lt;- License.by_id(license_id) do
      # Update in local database

      # Try to update in external service
      LicenseManagerClient.update_license(license.lm_id, %{
        &quot;valid_to&quot; =&gt; format_date(expire_at)
      })
      |&gt; case do
        {:ok, _license} -&gt;
          License.update_expire_at(license, %{expire_at: expire_at})

        {:error, error} -&gt;
          {:error, error}
      end
    end
  end

  @doc &quot;&quot;&quot;
  Gets a license by map ID.
  Returns {:ok, license} if found, {:error, reason} otherwise.
  &quot;&quot;&quot;
  def get_license_by_map_id(map_id) do
    case License.by_map_id(%{map_id: map_id}) do
      {:ok, [license | _]} -&gt;
        {:ok, license}

      {:ok, []} -&gt;
        {:error, :license_not_found}

      error -&gt;
        error
    end
  end

  @doc &quot;&quot;&quot;
  Updates a license&apos;s expiration date based on the map&apos;s subscription.
  &quot;&quot;&quot;
  def update_license_expiration_from_subscription(map_id) do
    with {:ok, license} &lt;- get_license_by_map_id(map_id),
         {:ok, subscription} &lt;- SubscriptionManager.get_active_map_subscription(map_id) do
      update_expiration(license.id, subscription.active_till)
    end
  end

  @doc &quot;&quot;&quot;
  Checks if a license is expired.
  &quot;&quot;&quot;
  defp expired?(license) do
    case license.expire_at do
      nil -&gt; false
      expire_at -&gt; DateTime.compare(expire_at, DateTime.utc_now()) == :lt
    end
  end

  @doc &quot;&quot;&quot;
  Generates a random string of specified length.
  &quot;&quot;&quot;
  defp generate_random_string(length) do
    :crypto.strong_rand_bytes(length)
    |&gt; Base.encode16(case: :upper)
    |&gt; binary_part(0, length)
  end

  @doc &quot;&quot;&quot;
  Formats a datetime as YYYY-MM-DD.
  &quot;&quot;&quot;
  defp format_date(datetime) do
    Calendar.strftime(datetime, &quot;%Y-%m-%d&quot;)
  end

  @doc &quot;&quot;&quot;
  Generates a link to the map.
  &quot;&quot;&quot;
  defp generate_map_link(map_slug) do
    base_url = Application.get_env(:wanderer_app, :web_app_url)
    &quot;#{base_url}/#{map_slug}&quot;
  end

  @doc &quot;&quot;&quot;
  Gets the map owner&apos;s data.
  &quot;&quot;&quot;
  defp get_map_owner_email(map) do
    {:ok, %{owner: owner}} = map |&gt; Ash.load([:owner])
    &quot;#{owner.name}(#{owner.eve_id})&quot;
  end
end</file><file path="lib/wanderer_app/map/operations/connections.ex">defmodule WandererApp.Map.Operations.Connections do
  @moduledoc &quot;&quot;&quot;
  Operations for managing map connections, including creation, updates, and deletions.
  Handles special cases like C1 wormhole sizing rules and unique constraint handling.
  &quot;&quot;&quot;

  require Logger
  alias WandererApp.Map.Server.{ConnectionsImpl, Server}
  alias Ash.Error.Invalid
  alias WandererApp.MapConnectionRepo

  # Connection type constants
  @connection_type_wormhole 0
  @connection_type_stargate 1

  # Ship size constants
  @small_ship_size  0
  @medium_ship_size 1
  @large_ship_size  2
  @xlarge_ship_size 3

  # System class constants
  @c1_system_class &quot;C1&quot;

  @doc &quot;&quot;&quot;
  Creates a connection between two systems, applying special rules for C1 wormholes.
  Handles parsing of input parameters, validates system information, and manages
  unique constraint violations gracefully.
  &quot;&quot;&quot;
  def create(attrs, map_id, char_id) do
    do_create(attrs, map_id, char_id)
  end

  defp do_create(attrs, map_id, char_id) do
    with {:ok, source} &lt;- parse_int(attrs[&quot;solar_system_source&quot;], &quot;solar_system_source&quot;),
         {:ok, target} &lt;- parse_int(attrs[&quot;solar_system_target&quot;], &quot;solar_system_target&quot;),
         {:ok, src_info} &lt;- ConnectionsImpl.get_system_static_info(source),
         {:ok, tgt_info} &lt;- ConnectionsImpl.get_system_static_info(target) do
      build_and_add_connection(attrs, map_id, char_id, src_info, tgt_info)
    else
      {:error, reason} -&gt; handle_precondition_error(reason, attrs)
      {:ok, []}      -&gt; {:error, :inconsistent_state}
      other          -&gt; {:error, :unexpected_precondition_error, other}
    end
  end

  defp build_and_add_connection(attrs, map_id, char_id, src_info, tgt_info) do
    info = %{
      solar_system_source_id: src_info.solar_system_id,
      solar_system_target_id: tgt_info.solar_system_id,
      character_id: char_id,
      type: parse_type(attrs[&quot;type&quot;]),
      ship_size_type: resolve_ship_size(attrs, src_info, tgt_info)
    }

    case Server.add_connection(map_id, info) do
      :ok                 -&gt; {:ok, :created}
      {:ok, []}           -&gt; log_warn_and(:inconsistent_state, info)
      {:error, %Invalid{errors: errs}} = err -&gt;
        if Enum.any?(errs, &amp;is_unique_constraint_error?/1), do: {:skip, :exists}, else: err
      {:error, _} = err  -&gt; Logger.error(&quot;[add_connection] #{inspect(err)}&quot;); {:error, :server_error}
      other               -&gt; Logger.error(&quot;[add_connection] unexpected: #{inspect(other)}&quot;); {:error, :unexpected_error}
    end
  end

  defp resolve_ship_size(attrs, src_info, tgt_info) do
    type = parse_type(attrs[&quot;type&quot;])

    if type == @connection_type_wormhole and
       (src_info.system_class == @c1_system_class or
        tgt_info.system_class == @c1_system_class) do
      @medium_ship_size
    else
      parse_ship_size(attrs[&quot;ship_size_type&quot;], @large_ship_size)
    end
  end

  defp parse_ship_size(nil, default),     do: default
  defp parse_ship_size(val, _default) when is_integer(val), do: val
  defp parse_ship_size(val, default) when is_binary(val) do
    case Integer.parse(val) do
      {i, _} -&gt; i
      :error -&gt; default
    end
  end
  defp parse_ship_size(_, default),       do: default

  defp parse_type(nil), do: @connection_type_wormhole
  defp parse_type(val) when is_integer(val), do: val
  defp parse_type(val) when is_binary(val) do
    case Integer.parse(val) do
      {i, _} -&gt; i
      :error -&gt; @connection_type_wormhole
    end
  end
  defp parse_type(_), do: @connection_type_wormhole

  defp parse_int(nil, field), do: {:error, {:missing_field, field}}
  defp parse_int(val, _) when is_integer(val), do: {:ok, val}
  defp parse_int(val, _) when is_binary(val) do
    case Integer.parse(val) do
      {i, _} -&gt; {:ok, i}
      :error -&gt; {:error, :invalid_integer}
    end
  end
  defp parse_int(_, field), do: {:error, {:invalid_field, field}}

  defp handle_precondition_error(reason, attrs) do
    Logger.warning(&quot;[add_connection] precondition failed: #{inspect(reason)} for #{inspect(attrs)}&quot;)
    {:error, :precondition_failed, reason}
  end

  defp log_warn_and(return, info) do
    Logger.warning(&quot;[add_connection] inconsistent for #{inspect(info)}&quot;)
    {:error, return}
  end

  defp is_unique_constraint_error?(%{code: :unique_constraint}), do: true
  defp is_unique_constraint_error?(_), do: false

  @spec list_connections(String.t()) :: [map()] | {:error, atom()}
  def list_connections(map_id) do
    with {:ok, conns} &lt;- MapConnectionRepo.get_by_map(map_id) do
      conns
    else
      {:error, err} -&gt;
        Logger.warning(&quot;[list_connections] Repo error: #{inspect(err)}&quot;)
        {:error, :repo_error}
      other -&gt;
        Logger.error(&quot;[list_connections] Unexpected repo result: #{inspect(other)}&quot;)
        {:error, :unexpected_repo_result}
    end
  end

  @spec list_connections(String.t(), integer()) :: [map()]
  def list_connections(map_id, system_id) do
    list_connections(map_id)
    |&gt; Enum.filter(fn c -&gt;
      c.solar_system_source == system_id or c.solar_system_target == system_id
    end)
  end

  @spec get_connection(String.t(), String.t()) :: {:ok, map()} | {:error, String.t()}
  def get_connection(map_id, conn_id) do
    case MapConnectionRepo.get_by_id(map_id, conn_id) do
      {:ok, conn} -&gt; {:ok, conn}
      _ -&gt; {:error, &quot;Connection not found&quot;}
    end
  end

  @spec update_connection(Plug.Conn.t(), String.t(), map()) :: {:ok, map()} | {:error, atom()}
  def update_connection(%{assigns: %{map_id: map_id, owner_character_id: char_id}} = _conn, conn_id, attrs) do
    with {:ok, conn_struct} &lt;- MapConnectionRepo.get_by_id(map_id, conn_id),
         result &lt;- (
           try do
             _allowed_keys = [
               :mass_status,
               :ship_size_type,
               :type
             ]
             _update_map =
               attrs
               |&gt; Enum.filter(fn {k, _v} -&gt; k in [&quot;mass_status&quot;, &quot;ship_size_type&quot;, &quot;type&quot;] end)
               |&gt; Enum.map(fn {k, v} -&gt; {String.to_atom(k), v} end)
               |&gt; Enum.into(%{})
             res = apply_connection_updates(map_id, conn_struct, attrs, char_id)
             res
           rescue
             error -&gt;
               Logger.error(&quot;[update_connection] Exception: #{inspect(error)}&quot;)
               {:error, :exception}
           end
         ),
         :ok &lt;- result,
         {:ok, updated_conn} &lt;- MapConnectionRepo.get_by_id(map_id, conn_id) do
      {:ok, updated_conn}
    else
      {:error, err} -&gt; {:error, err}
      _ -&gt; {:error, :unexpected_error}
    end
  end
  def update_connection(_conn, _conn_id, _attrs), do: {:error, :missing_params}

  @spec delete_connection(Plug.Conn.t(), integer(), integer()) :: :ok | {:error, atom()}
  def delete_connection(%{assigns: %{map_id: map_id}} = _conn, src, tgt) do
    case Server.delete_connection(map_id, %{solar_system_source_id: src, solar_system_target_id: tgt}) do
      :ok -&gt; :ok
      {:error, :not_found} -&gt;
        Logger.warning(&quot;[delete_connection] Connection not found: source=#{inspect(src)}, target=#{inspect(tgt)}&quot;)
        {:error, :not_found}
      {:error, _} = err -&gt;
        Logger.error(&quot;[delete_connection] Server error: #{inspect(err)}&quot;)
        {:error, :server_error}
      _ -&gt;
        Logger.error(&quot;[delete_connection] Unknown error&quot;)
        {:error, :unknown}
    end
  end
  def delete_connection(_conn, _src, _tgt), do: {:error, :missing_params}

  @doc &quot;Batch upsert for connections&quot;
  @spec upsert_batch(Plug.Conn.t(), [map()]) :: %{created: integer(), updated: integer(), skipped: integer()}
  def upsert_batch(%{assigns: %{map_id: map_id, owner_character_id: char_id}} = conn, conns) do
    _assigns = %{map_id: map_id, char_id: char_id}
    Enum.reduce(conns, %{created: 0, updated: 0, skipped: 0}, fn conn_attrs, acc -&gt;
      case upsert_single(conn, conn_attrs) do
        {:ok, :created} -&gt; %{acc | created: acc.created + 1}
        {:ok, :updated} -&gt; %{acc | updated: acc.updated + 1}
        _ -&gt; %{acc | skipped: acc.skipped + 1}
      end
    end)
  end
  def upsert_batch(_conn, _conns), do: %{created: 0, updated: 0, skipped: 0}

  @doc &quot;Upsert a single connection&quot;
  @spec upsert_single(Plug.Conn.t(), map()) :: {:ok, :created | :updated} | {:error, atom()}
  def upsert_single(%{assigns: %{map_id: map_id, owner_character_id: char_id}} = conn, conn_data) do
    source = conn_data[&quot;solar_system_source&quot;] || conn_data[:solar_system_source]
    target = conn_data[&quot;solar_system_target&quot;] || conn_data[:solar_system_target]
    with {:ok, %{} = existing_conn} &lt;- get_connection_by_systems(map_id, source, target),
         {:ok, _} &lt;- update_connection(conn, existing_conn.id, conn_data) do
      {:ok, :updated}
    else
      {:ok, nil} -&gt;
        case create_connection(map_id, conn_data, char_id) do
          {:ok, _} -&gt; {:ok, :created}
          {:skip, :exists} -&gt; {:ok, :updated}
          err -&gt; {:error, err}
        end
      {:error, _} = err -&gt;
        Logger.warning(&quot;[upsert_single] Connection lookup error: #{inspect(err)}&quot;)
        {:error, :lookup_error}
      err -&gt;
        Logger.error(&quot;[upsert_single] Update failed: #{inspect(err)}&quot;)
        {:error, :unexpected_error}
    end
  end
  def upsert_single(_conn, _conn_data), do: {:error, :missing_params}

  @doc &quot;Get a connection by source and target system IDs&quot;
  @spec get_connection_by_systems(String.t(), integer(), integer()) :: {:ok, map()} | {:error, String.t()}
  def get_connection_by_systems(map_id, source, target) do
    with {:ok, conn} &lt;- WandererApp.Map.find_connection(map_id, source, target) do
      if conn, do: {:ok, conn}, else: WandererApp.Map.find_connection(map_id, target, source)
    else
      {:error, reason} -&gt; {:error, reason}
    end
  end

  # -- Helpers ---------------------------------------------------------------

  defp apply_connection_updates(map_id, conn, attrs, _char_id) do
    Enum.reduce_while(attrs, :ok, fn {key, val}, _acc -&gt;
      result =
        case key do
          &quot;mass_status&quot; -&gt; maybe_update_mass_status(map_id, conn, val)
          &quot;ship_size_type&quot; -&gt; maybe_update_ship_size_type(map_id, conn, val)
          &quot;type&quot; -&gt; maybe_update_type(map_id, conn, val)
          _ -&gt; :ok
        end
      if result == :ok do
        {:cont, :ok}
      else
        {:halt, result}
      end
    end)
    |&gt; case do
      :ok -&gt; :ok
      err -&gt; err
    end
  end

  defp maybe_update_mass_status(_map_id, _conn, nil), do: :ok
  defp maybe_update_mass_status(map_id, conn, value) do
    Server.update_connection_mass_status(map_id, %{
      solar_system_source_id: conn.solar_system_source,
      solar_system_target_id: conn.solar_system_target,
      mass_status: value
    })
  end

  defp maybe_update_ship_size_type(_map_id, _conn, nil), do: :ok
  defp maybe_update_ship_size_type(map_id, conn, value) do
    Server.update_connection_ship_size_type(map_id, %{
      solar_system_source_id: conn.solar_system_source,
      solar_system_target_id: conn.solar_system_target,
      ship_size_type: value
    })
  end

  defp maybe_update_type(_map_id, _conn, nil), do: :ok
  defp maybe_update_type(map_id, conn, value) do
    Server.update_connection_type(map_id, %{
      solar_system_source_id: conn.solar_system_source,
      solar_system_target_id: conn.solar_system_target,
      type: value
    })
  end

  @doc &quot;Creates a connection between two systems&quot;
  @spec create_connection(String.t(), map(), String.t()) :: {:ok, :created} | {:skip, :exists} | {:error, atom()}
  def create_connection(map_id, attrs, char_id) do
    do_create(attrs, map_id, char_id)
  end

  @doc &quot;Creates a connection between two systems from a Plug.Conn&quot;
  @spec create_connection(Plug.Conn.t(), map()) :: {:ok, :created} | {:skip, :exists} | {:error, atom()}
  def create_connection(%{assigns: %{map_id: map_id, owner_character_id: char_id}} = _conn, attrs) do
    do_create(attrs, map_id, char_id)
  end

end</file><file path="lib/wanderer_app/map/operations/owner.ex">defmodule WandererApp.Map.Operations.Owner do
  @moduledoc &quot;&quot;&quot;
  Handles fetching and caching of the main character info for a map owner.
  &quot;&quot;&quot;

  # Cache TTL in milliseconds (24 hours)
  @owner_info_cache_ttl 86_400_000

  alias WandererApp.{
    MapRepo,
    MapCharacterSettingsRepo,
    MapUserSettingsRepo,
    Cache
  }
  alias WandererApp.Character
  alias WandererApp.Character.TrackingUtils

  @spec get_owner_character_id(String.t()) :: {:ok, %{id: term(), user_id: term()}} | {:error, String.t()}
  def get_owner_character_id(map_id) do
    cache_key = &quot;map_#{map_id}:owner_info&quot;

    case Cache.lookup!(cache_key) do
      nil -&gt;
        with {:ok, owner} &lt;- fetch_map_owner(map_id),
             {:ok, char_ids} &lt;- fetch_character_ids(map_id),
             {:ok, characters} &lt;- load_characters(char_ids),
             {:ok, user_settings} &lt;- MapUserSettingsRepo.get(map_id, owner.id),
             {:ok, main} &lt;- TrackingUtils.get_main_character(user_settings, characters, characters) do
          result = %{id: main.id, user_id: main.user_id}
          Cache.insert(cache_key, result, ttl: @owner_info_cache_ttl)
          {:ok, result}
        else
          {:error, msg} -&gt; {:error, msg}
          _ -&gt; {:error, &quot;Failed to resolve main character&quot;}
        end

      cached -&gt;
        {:ok, cached}
    end
  end

  defp fetch_map_owner(map_id) do
    case MapRepo.get(map_id, [:owner]) do
      {:ok, %{owner: %_{} = owner}} -&gt; {:ok, owner}
      {:ok, %{owner: nil}} -&gt; {:error, &quot;Map has no owner&quot;}
      {:error, _} -&gt; {:error, &quot;Map not found&quot;}
    end
  end

  defp fetch_character_ids(map_id) do
    case MapCharacterSettingsRepo.get_all_by_map(map_id) do
      {:ok, settings} when is_list(settings) and settings != [] -&gt;
        {:ok, Enum.map(settings, &amp; &amp;1.character_id)}

      {:ok, []} -&gt;
        {:error, &quot;No character settings found&quot;}

      {:error, _} -&gt;
        {:error, &quot;Failed to fetch character settings&quot;}
    end
  end

  defp load_characters(ids) when is_list(ids) do
    ids
    |&gt; Enum.map(&amp;Character.get_character/1)
    |&gt; Enum.flat_map(fn
      {:ok, ch} -&gt; [ch]
      _ -&gt; []
    end)
    |&gt; case do
      [] -&gt; {:error, &quot;No valid characters found&quot;}
      chars -&gt; {:ok, chars}
    end
  end
end</file><file path="lib/wanderer_app/map/operations/signatures.ex">defmodule WandererApp.Map.Operations.Signatures do
  @moduledoc &quot;&quot;&quot;
  CRUD for map signatures.
  &quot;&quot;&quot;

  require Logger
  alias WandererApp.Map.Operations
  alias WandererApp.Api.{MapSystem, MapSystemSignature}
  alias WandererApp.Map.Server

  @spec list_signatures(String.t()) :: [map()]
  def list_signatures(map_id) do
    systems = Operations.list_systems(map_id)
    if systems != [] do
      systems
      |&gt; Enum.flat_map(fn sys -&gt;
        with {:ok, sigs} &lt;- MapSystemSignature.by_system_id(sys.id) do
          sigs
        else
          err -&gt;
            Logger.error(&quot;[list_signatures] error: #{inspect(err)}&quot;)
            []
        end
      end)
    else
      []
    end
  end

  @spec create_signature(Plug.Conn.t(), map()) :: {:ok, map()} | {:error, atom()}
  def create_signature(%{assigns: %{map_id: map_id, owner_character_id: char_id, owner_user_id: user_id}} = _conn, %{&quot;solar_system_id&quot; =&gt; _solar_system_id} = params) do
    attrs = Map.put(params, &quot;character_eve_id&quot;, char_id)
    case Server.update_signatures(map_id, %{
      added_signatures: [attrs],
      updated_signatures: [],
      removed_signatures: [],
      solar_system_id: params[&quot;solar_system_id&quot;],
      character_id: char_id,
      user_id: user_id,
      delete_connection_with_sigs: false
    }) do
      :ok -&gt; {:ok, attrs}
      err -&gt;
        Logger.error(&quot;[create_signature] Unexpected error: #{inspect(err)}&quot;)
        {:error, :unexpected_error}
    end
  end

  def create_signature(_conn, _params), do: {:error, :missing_params}

  @spec update_signature(Plug.Conn.t(), String.t(), map()) :: {:ok, map()} | {:error, atom()}
  def update_signature(%{assigns: %{map_id: map_id, owner_character_id: char_id, owner_user_id: user_id}} = _conn, sig_id, params) do
    with {:ok, sig} &lt;- MapSystemSignature.by_id(sig_id),
         {:ok, system} &lt;- MapSystem.by_id(sig.system_id) do
      base = %{
        &quot;eve_id&quot; =&gt; sig.eve_id,
        &quot;name&quot; =&gt; sig.name,
        &quot;kind&quot; =&gt; sig.kind,
        &quot;group&quot; =&gt; sig.group,
        &quot;type&quot; =&gt; sig.type,
        &quot;custom_info&quot; =&gt; sig.custom_info,
        &quot;character_eve_id&quot; =&gt; char_id,
        &quot;description&quot; =&gt; sig.description,
        &quot;linked_system_id&quot; =&gt; sig.linked_system_id
      }
      attrs = Map.merge(base, params)
      :ok = Server.update_signatures(map_id, %{
        added_signatures: [],
        updated_signatures: [attrs],
        removed_signatures: [],
        solar_system_id: system.solar_system_id,
        character_id: char_id,
        user_id: user_id,
        delete_connection_with_sigs: false
      })
      {:ok, attrs}
    else
      err -&gt;
        Logger.error(&quot;[update_signature] Unexpected error: #{inspect(err)}&quot;)
        {:error, :unexpected_error}
    end
  end

  def update_signature(_conn, _sig_id, _params), do: {:error, :missing_params}

  @spec delete_signature(Plug.Conn.t(), String.t()) :: :ok | {:error, atom()}
  def delete_signature(%{assigns: %{map_id: map_id, owner_character_id: char_id, owner_user_id: user_id}} = _conn, sig_id) do
    with {:ok, sig} &lt;- MapSystemSignature.by_id(sig_id),
         {:ok, system} &lt;- MapSystem.by_id(sig.system_id) do
      removed = [%{
        &quot;eve_id&quot; =&gt; sig.eve_id,
        &quot;name&quot; =&gt; sig.name,
        &quot;kind&quot; =&gt; sig.kind,
        &quot;group&quot; =&gt; sig.group
      }]
      :ok = Server.update_signatures(map_id, %{
        added_signatures: [],
        updated_signatures: [],
        removed_signatures: removed,
        solar_system_id: system.solar_system_id,
        character_id: char_id,
        user_id: user_id,
        delete_connection_with_sigs: false
      })
      :ok
    else
      err -&gt;
        Logger.error(&quot;[delete_signature] Unexpected error: #{inspect(err)}&quot;)
        {:error, :unexpected_error}
    end
  end

  def delete_signature(_conn, _sig_id), do: {:error, :missing_params}
end</file><file path="lib/wanderer_app/map/operations/structures.ex">defmodule WandererApp.Map.Operations.Structures do
  @moduledoc &quot;&quot;&quot;
  CRUD for map structures.
  &quot;&quot;&quot;

  alias WandererApp.Map.Operations
  alias WandererApp.Api.MapSystem
  alias WandererApp.Api.MapSystemStructure
  alias WandererApp.Structure
  require Logger

  @spec list_structures(String.t()) :: [map()]
  def list_structures(map_id) do
    with systems when is_list(systems) and systems != [] &lt;- (
           case Operations.list_systems(map_id) do
             {:ok, systems} -&gt; systems
             systems when is_list(systems) -&gt; systems
             _ -&gt; []
           end
         ) do
      systems
      |&gt; Enum.flat_map(fn sys -&gt;
        with {:ok, structs} &lt;- MapSystemStructure.by_system_id(sys.id) do
          structs
        else
          _other -&gt; []
        end
      end)
    else
      _ -&gt; []
    end
  end

  @spec create_structure(Plug.Conn.t(), map()) :: {:ok, map()} | {:error, atom()}
  def create_structure(%{assigns: %{map_id: map_id, owner_character_id: char_id, owner_user_id: user_id}} = _conn, %{&quot;solar_system_id&quot; =&gt; _solar_system_id} = params) do
    with {:ok, system} &lt;- MapSystem.read_by_map_and_solar_system(%{map_id: map_id, solar_system_id: params[&quot;solar_system_id&quot;]}),
         attrs &lt;- Map.put(prepare_attrs(params), &quot;system_id&quot;, system.id),
         :ok &lt;- Structure.update_structures(system, [attrs], [], [], char_id, user_id),
         name = Map.get(attrs, &quot;name&quot;),
         structure_type_id = Map.get(attrs, &quot;structureTypeId&quot;),
         struct when not is_nil(struct) &lt;-
           MapSystemStructure.by_system_id!(system.id)
           |&gt; Enum.find(fn s -&gt; s.name == name and s.structure_type_id == structure_type_id end) do
      {:ok, struct}
    else
      nil -&gt;
        Logger.warning(&quot;[create_structure] Structure not found after creation&quot;)
        {:error, :structure_not_found}
      err -&gt;
        Logger.error(&quot;[create_structure] Unexpected error: #{inspect(err)}&quot;)
        {:error, :unexpected_error}
    end
  end

  def create_structure(_conn, _params), do: {:error, &quot;missing params&quot;}

  @spec update_structure(Plug.Conn.t(), String.t(), map()) :: {:ok, map()} | {:error, atom()}
  def update_structure(%{assigns: %{map_id: map_id, owner_character_id: char_id, owner_user_id: user_id}} = _conn, struct_id, params) do
    with {:ok, struct} &lt;- MapSystemStructure.by_id(struct_id),
         {:ok, system} &lt;- MapSystem.read_by_map_and_solar_system(%{map_id: map_id, solar_system_id: struct.solar_system_id}) do
      attrs = Map.merge(prepare_attrs(params), %{&quot;id&quot; =&gt; struct_id})
      :ok = Structure.update_structures(system, [], [attrs], [], char_id, user_id)
      case MapSystemStructure.by_id(struct_id) do
        {:ok, updated} -&gt; {:ok, updated}
        err -&gt;
          Logger.error(&quot;[update_structure] Unexpected error: #{inspect(err)}&quot;)
          {:error, :unexpected_error}
      end
    else
      err -&gt;
        Logger.error(&quot;[update_structure] Unexpected error: #{inspect(err)}&quot;)
        {:error, :unexpected_error}
    end
  end

  def update_structure(_conn, _struct_id, _params), do: {:error, &quot;missing params&quot;}

  @spec delete_structure(Plug.Conn.t(), String.t()) :: :ok | {:error, atom()}
  def delete_structure(%{assigns: %{map_id: _map_id, owner_character_id: char_id, owner_user_id: user_id}} = _conn, struct_id) do
    with {:ok, struct} &lt;- MapSystemStructure.by_id(struct_id),
         {:ok, system} &lt;- MapSystem.by_id(struct.system_id) do
      :ok = Structure.update_structures(system, [], [], [%{&quot;id&quot; =&gt; struct_id}], char_id, user_id)
      :ok
    else
      err -&gt;
        Logger.error(&quot;[delete_structure] Unexpected error: #{inspect(err)}&quot;)
        {:error, :unexpected_error}
    end
  end

  def delete_structure(_conn, _struct_id), do: {:error, &quot;missing params&quot;}

  defp prepare_attrs(params) do
    params
    |&gt; Enum.map(fn
      {&quot;structure_type&quot;, v} -&gt; {&quot;structureType&quot;, v}
      {&quot;structure_type_id&quot;, v} -&gt; {&quot;structureTypeId&quot;, v}
      {&quot;end_time&quot;, v} -&gt; {&quot;endTime&quot;, v}
      {k, v} -&gt; {k, v}
    end)
    |&gt; Map.new()
    |&gt; Map.take([&quot;name&quot;, &quot;structureType&quot;, &quot;structureTypeId&quot;, &quot;status&quot;, &quot;notes&quot;, &quot;endTime&quot;])
  end
end</file><file path="lib/wanderer_app/map/operations/systems.ex">defmodule WandererApp.Map.Operations.Systems do
  @moduledoc &quot;&quot;&quot;
  CRUD and batch upsert for map systems.
  &quot;&quot;&quot;

  alias WandererApp.MapSystemRepo
  alias WandererApp.Map.Server
  alias WandererApp.Map.Operations.Connections
  require Logger

  @spec list_systems(String.t()) :: [map()]
  def list_systems(map_id) do
    with {:ok, systems} &lt;- MapSystemRepo.get_visible_by_map(map_id) do
      systems
    else
      _ -&gt; []
    end
  end

  @spec get_system(String.t(), integer()) :: {:ok, map()} | {:error, :not_found}
  def get_system(map_id, system_id) do
    MapSystemRepo.get_by_map_and_solar_system_id(map_id, system_id)
  end

  @spec create_system(Plug.Conn.t(), map()) :: {:ok, map()} | {:error, atom()}
  def create_system(%{assigns: %{map_id: map_id, owner_character_id: char_id, owner_user_id: user_id}} = _conn, params) do
    do_create_system(map_id, user_id, char_id, params)
  end
  def create_system(_conn, _params), do: {:error, :missing_params}

  # Private helper for batch upsert
  defp create_system_batch(%{map_id: map_id, user_id: user_id, char_id: char_id}, params) do
    do_create_system(map_id, user_id, char_id, params)
  end

  defp do_create_system(map_id, user_id, char_id, params) do
    with {:ok, system_id} &lt;- fetch_system_id(params),
         coords &lt;- normalize_coordinates(params),
         :ok &lt;- Server.add_system(map_id, %{solar_system_id: system_id, coordinates: coords}, user_id, char_id),
         {:ok, system} &lt;- MapSystemRepo.get_by_map_and_solar_system_id(map_id, system_id) do
      {:ok, system}
    else
      {:error, reason} when is_binary(reason) -&gt;
        Logger.warning(&quot;[do_create_system] Expected error: #{inspect(reason)}&quot;)
        {:error, :expected_error}
      _ -&gt;
        Logger.error(&quot;[do_create_system] Unexpected error&quot;)
        {:error, :unexpected_error}
    end
  end

  @spec update_system(Plug.Conn.t(), integer(), map()) :: {:ok, map()} | {:error, atom()}
  def update_system(%{assigns: %{map_id: map_id}} = _conn, system_id, attrs) do
    with {:ok, current} &lt;- MapSystemRepo.get_by_map_and_solar_system_id(map_id, system_id),
         x_raw &lt;- Map.get(attrs, &quot;position_x&quot;, Map.get(attrs, :position_x, current.position_x)),
         y_raw &lt;- Map.get(attrs, &quot;position_y&quot;, Map.get(attrs, :position_y, current.position_y)),
         {:ok, x} &lt;- parse_int(x_raw, &quot;position_x&quot;),
         {:ok, y} &lt;- parse_int(y_raw, &quot;position_y&quot;),
         coords = %{x: x, y: y},
         :ok &lt;- apply_system_updates(map_id, system_id, attrs, coords),
         {:ok, system} &lt;- MapSystemRepo.get_by_map_and_solar_system_id(map_id, system_id) do
      {:ok, system}
    else
      {:error, reason} when is_binary(reason) -&gt;
        Logger.warning(&quot;[update_system] Expected error: #{inspect(reason)}&quot;)
        {:error, :expected_error}
      _ -&gt;
        Logger.error(&quot;[update_system] Unexpected error&quot;)
        {:error, :unexpected_error}
    end
  end
  def update_system(_conn, _system_id, _attrs), do: {:error, :missing_params}

  @spec delete_system(Plug.Conn.t(), integer()) :: {:ok, integer()} | {:error, atom()}
  def delete_system(%{assigns: %{map_id: map_id, owner_character_id: char_id, owner_user_id: user_id}} = _conn, system_id) do
    with {:ok, _} &lt;- MapSystemRepo.get_by_map_and_solar_system_id(map_id, system_id),
         :ok &lt;- Server.delete_systems(map_id, [system_id], user_id, char_id) do
      {:ok, 1}
    else
      {:error, :not_found} -&gt;
        Logger.warning(&quot;[delete_system] System not found: #{inspect(system_id)}&quot;)
        {:error, :not_found}
      _ -&gt;
        Logger.error(&quot;[delete_system] Unexpected error&quot;)
        {:error, :unexpected_error}
    end
  end
  def delete_system(_conn, _system_id), do: {:error, :missing_params}

  @spec upsert_systems_and_connections(Plug.Conn.t(), [map()], [map()]) :: {:ok, map()} | {:error, atom()}
  def upsert_systems_and_connections(%{assigns: %{map_id: map_id, owner_character_id: char_id, owner_user_id: user_id}} = conn, systems, connections) do
    assigns = %{map_id: map_id, user_id: user_id, char_id: char_id}
    {created_s, updated_s, _skipped_s} = upsert_each(systems, fn sys -&gt; create_system_batch(assigns, sys) end, 0, 0, 0)
    conn_results =
      connections
      |&gt; Enum.reduce(%{created: 0, updated: 0, skipped: 0}, fn conn_data, acc -&gt;
        case Connections.upsert_single(conn, conn_data) do
          {:ok, :created} -&gt; %{acc | created: acc.created + 1}
          {:ok, :updated} -&gt; %{acc | updated: acc.updated + 1}
          _ -&gt; %{acc | skipped: acc.skipped + 1}
        end
      end)
    {:ok, %{
      systems: %{created: created_s, updated: updated_s},
      connections: %{created: conn_results.created, updated: conn_results.updated}
    }}
  end
  def upsert_systems_and_connections(_conn, _systems, _connections), do: {:error, :missing_params}

  # -- Internal Helpers -------------------------------------------------------

  defp fetch_system_id(%{&quot;solar_system_id&quot; =&gt; id}), do: parse_int(id, &quot;solar_system_id&quot;)
  defp fetch_system_id(%{solar_system_id: id}) when not is_nil(id), do: parse_int(id, &quot;solar_system_id&quot;)
  defp fetch_system_id(_), do: {:error, &quot;Missing system identifier (id)&quot;}

  defp parse_int(val, _field) when is_integer(val), do: {:ok, val}
  defp parse_int(val, field) when is_binary(val) do
    case Integer.parse(val) do
      {i, _} -&gt; {:ok, i}
      _ -&gt; {:error, &quot;Invalid #{field}: #{val}&quot;}
    end
  end
  defp parse_int(nil, field), do: {:error, &quot;Missing #{field}&quot;}
  defp parse_int(val, field), do: {:error, &quot;Invalid #{field} type: #{inspect(val)}&quot;}

  defp normalize_coordinates(%{&quot;coordinates&quot; =&gt; %{&quot;x&quot; =&gt; x, &quot;y&quot; =&gt; y}}) when is_number(x) and is_number(y),
    do: %{x: x, y: y}
  defp normalize_coordinates(%{coordinates: %{x: x, y: y}}) when is_number(x) and is_number(y),
    do: %{x: x, y: y}
  defp normalize_coordinates(params) do
    %{
      x: params |&gt; Map.get(&quot;position_x&quot;, Map.get(params, :position_x, 0)),
      y: params |&gt; Map.get(&quot;position_y&quot;, Map.get(params, :position_y, 0))
    }
  end

  defp apply_system_updates(map_id, system_id, attrs, %{x: x, y: y}) do
    with :ok &lt;- Server.update_system_position(map_id, %{solar_system_id: system_id, position_x: round(x), position_y: round(y)}) do
      attrs
      |&gt; Map.drop([:coordinates, :position_x, :position_y, :solar_system_id,
                   &quot;coordinates&quot;, &quot;position_x&quot;, &quot;position_y&quot;, &quot;solar_system_id&quot;])
      |&gt; Enum.reduce_while(:ok, fn {key, val}, _ -&gt;
        case update_system_field(map_id, system_id, to_string(key), val) do
          :ok -&gt; {:cont, :ok}
          err -&gt; {:halt, err}
        end
      end)
    end
  end

  defp update_system_field(map_id, system_id, field, val) do
    case field do
      &quot;status&quot; -&gt; Server.update_system_status(map_id, %{solar_system_id: system_id, status: convert_status(val)})
      &quot;description&quot; -&gt; Server.update_system_description(map_id, %{solar_system_id: system_id, description: val})
      &quot;tag&quot; -&gt; Server.update_system_tag(map_id, %{solar_system_id: system_id, tag: val})
      &quot;locked&quot; -&gt;
        bool = val in [true, &quot;true&quot;, 1, &quot;1&quot;]
        Server.update_system_locked(map_id, %{solar_system_id: system_id, locked: bool})
      f when f in [&quot;label&quot;, &quot;labels&quot;] -&gt;
        labels = cond do
          is_list(val) -&gt; val
          is_binary(val) -&gt; String.split(val, &quot;,&quot;, trim: true)
          true -&gt; []
        end
        Server.update_system_labels(map_id, %{solar_system_id: system_id, labels: Enum.join(labels, &quot;,&quot;)})
      &quot;temporary_name&quot; -&gt; Server.update_system_temporary_name(map_id, %{solar_system_id: system_id, temporary_name: val})
      _ -&gt; :ok
    end
  end

  defp convert_status(&quot;CLEAR&quot;), do: 0
  defp convert_status(&quot;DANGEROUS&quot;), do: 1
  defp convert_status(&quot;OCCUPIED&quot;), do: 2
  defp convert_status(&quot;MASS_CRITICAL&quot;), do: 3
  defp convert_status(&quot;TIME_CRITICAL&quot;), do: 4
  defp convert_status(&quot;REINFORCED&quot;), do: 5
  defp convert_status(i) when is_integer(i), do: i
  defp convert_status(s) when is_binary(s) do
    case Integer.parse(s) do
      {i, _} -&gt; i
      _ -&gt; 0
    end
  end
  defp convert_status(_), do: 0

  defp upsert_each([], _fun, c, u, d), do: {c, u, d}
  defp upsert_each([item | rest], fun, c, u, d) do
    case fun.(item) do
      {:ok, _} -&gt; upsert_each(rest, fun, c + 1, u, d)
      :ok -&gt; upsert_each(rest, fun, c + 1, u, d)
      {:skip, _} -&gt; upsert_each(rest, fun, c, u + 1, d)
      _ -&gt; upsert_each(rest, fun, c, u, d + 1)
    end
  end
end</file><file path="lib/wanderer_app/map/server/map_server_acls_impl.ex">defmodule WandererApp.Map.Server.AclsImpl do
  @moduledoc false

  require Logger

  @pubsub_client Application.compile_env(:wanderer_app, :pubsub_client)

  def handle_map_acl_updated(%{map_id: map_id, map: old_map} = state, added_acls, removed_acls) do
    {:ok, map} =
      WandererApp.MapRepo.get(map_id,
        acls: [
          :owner_id,
          members: [:role, :eve_character_id, :eve_corporation_id, :eve_alliance_id]
        ]
      )

    track_acls(added_acls)

    result =
      (added_acls ++ removed_acls)
      |&gt; Task.async_stream(
        fn acl_id -&gt;
          update_acl(acl_id)
        end,
        max_concurrency: 10,
        timeout: :timer.seconds(15)
      )
      |&gt; Enum.reduce(
        %{
          eve_alliance_ids: [],
          eve_character_ids: [],
          eve_corporation_ids: []
        },
        fn result, acc -&gt;
          case result do
            {:ok, val} -&gt;
              {:ok,
               %{
                 eve_alliance_ids: eve_alliance_ids,
                 eve_character_ids: eve_character_ids,
                 eve_corporation_ids: eve_corporation_ids
               }} = val

              %{
                acc
                | eve_alliance_ids: eve_alliance_ids ++ acc.eve_alliance_ids,
                  eve_character_ids: eve_character_ids ++ acc.eve_character_ids,
                  eve_corporation_ids: eve_corporation_ids ++ acc.eve_corporation_ids
              }

            error -&gt;
              Logger.error(&quot;Failed to update map #{map_id} acl: #{inspect(error, pretty: true)}&quot;)

              acc
          end
        end
      )

    map_update = %{acls: map.acls, scope: map.scope}

    WandererApp.Map.update_map(map_id, map_update)

    broadcast_acl_updates({:ok, result}, map_id)

    %{state | map: Map.merge(old_map, map_update)}
  end

  def handle_acl_updated(map_id, acl_id) do
    {:ok, map} =
      WandererApp.MapRepo.get(map_id,
        acls: [
          :owner_id,
          members: [:role, :eve_character_id, :eve_corporation_id, :eve_alliance_id]
        ]
      )

    if map.acls |&gt; Enum.map(&amp; &amp;1.id) |&gt; Enum.member?(acl_id) do
      WandererApp.Map.update_map(map_id, %{acls: map.acls})

      :ok =
        acl_id
        |&gt; update_acl()
        |&gt; broadcast_acl_updates(map_id)
    end
  end

  def handle_acl_deleted(map_id, _acl_id) do
    {:ok, map} =
      WandererApp.MapRepo.get(map_id,
        acls: [
          :owner_id,
          members: [:role, :eve_character_id, :eve_corporation_id, :eve_alliance_id]
        ]
      )

    WandererApp.Map.update_map(map_id, %{acls: map.acls})

    character_ids =
      map_id
      |&gt; WandererApp.Map.get_map!()
      |&gt; Map.get(:characters, [])

    WandererApp.Cache.insert(&quot;map_#{map_id}:invalidate_character_ids&quot;, character_ids)
  end

  def track_acls([]), do: :ok

  def track_acls([acl_id | rest]) do
    track_acl(acl_id)
    track_acls(rest)
  end

  defp track_acl(acl_id),
    do: @pubsub_client.subscribe(WandererApp.PubSub, &quot;acls:#{acl_id}&quot;)

  defp broadcast_acl_updates(
         {:ok,
          %{
            eve_character_ids: eve_character_ids,
            eve_corporation_ids: eve_corporation_ids,
            eve_alliance_ids: eve_alliance_ids
          }},
         map_id
       ) do
    eve_character_ids
    |&gt; Enum.uniq()
    |&gt; Enum.each(fn eve_character_id -&gt;
      @pubsub_client.broadcast(
        WandererApp.PubSub,
        &quot;character:#{eve_character_id}&quot;,
        :update_permissions
      )
    end)

    eve_corporation_ids
    |&gt; Enum.uniq()
    |&gt; Enum.each(fn eve_corporation_id -&gt;
      @pubsub_client.broadcast(
        WandererApp.PubSub,
        &quot;corporation:#{eve_corporation_id}&quot;,
        :update_permissions
      )
    end)

    eve_alliance_ids
    |&gt; Enum.uniq()
    |&gt; Enum.each(fn eve_alliance_id -&gt;
      @pubsub_client.broadcast(
        WandererApp.PubSub,
        &quot;alliance:#{eve_alliance_id}&quot;,
        :update_permissions
      )
    end)

    character_ids =
      map_id
      |&gt; WandererApp.Map.get_map!()
      |&gt; Map.get(:characters, [])

    WandererApp.Cache.insert(&quot;map_#{map_id}:invalidate_character_ids&quot;, character_ids)

    :ok
  end

  defp broadcast_acl_updates(_, _map_id), do: :ok

  defp update_acl(acl_id) do
    {:ok, %{owner: owner, members: members}} =
      WandererApp.AccessListRepo.get(acl_id, [:owner, :members])

    result =
      members
      |&gt; Enum.reduce(
        %{eve_character_ids: [owner.eve_id], eve_corporation_ids: [], eve_alliance_ids: []},
        fn member, acc -&gt;
          case member do
            %{eve_character_id: eve_character_id} when not is_nil(eve_character_id) -&gt;
              acc
              |&gt; Map.put(:eve_character_ids, [eve_character_id | acc.eve_character_ids])

            %{eve_corporation_id: eve_corporation_id} when not is_nil(eve_corporation_id) -&gt;
              acc
              |&gt; Map.put(:eve_corporation_ids, [eve_corporation_id | acc.eve_corporation_ids])

            %{eve_alliance_id: eve_alliance_id} when not is_nil(eve_alliance_id) -&gt;
              acc
              |&gt; Map.put(:eve_alliance_ids, [eve_alliance_id | acc.eve_alliance_ids])

            _ -&gt;
              acc
          end
        end
      )

    {:ok, result}
  end
end</file><file path="lib/wanderer_app/map/server/map_server_characters_impl.ex">defmodule WandererApp.Map.Server.CharactersImpl do
  @moduledoc false

  require Logger

  alias WandererApp.Map.Server.{Impl, ConnectionsImpl, SystemsImpl}

  def add_character(%{map_id: map_id} = state, %{id: character_id} = character, track_character) do
    Task.start_link(fn -&gt;
      with :ok &lt;- map_id |&gt; WandererApp.Map.add_character(character),
           {:ok, _settings} &lt;-
             WandererApp.MapCharacterSettingsRepo.create(%{
               character_id: character_id,
               map_id: map_id,
               tracked: track_character
             }),
           {:ok, character} &lt;- WandererApp.Character.get_map_character(map_id, character_id) do
        Impl.broadcast!(map_id, :character_added, character)
        :telemetry.execute([:wanderer_app, :map, :character, :added], %{count: 1})
        :ok
      else
        _error -&gt;
          {:ok, character} = WandererApp.Character.get_map_character(map_id, character_id)
          Impl.broadcast!(map_id, :character_added, character)
          :ok
      end
    end)

    state
  end

  def remove_character(map_id, character_id) do
    Task.start_link(fn -&gt;
      with :ok &lt;- WandererApp.Map.remove_character(map_id, character_id),
           {:ok, character} &lt;- WandererApp.Character.get_map_character(map_id, character_id) do
        Impl.broadcast!(map_id, :character_removed, character)

        :telemetry.execute([:wanderer_app, :map, :character, :removed], %{count: 1})

        :ok
      else
        {:error, _error} -&gt;
          :ok
      end
    end)
  end

  def update_tracked_characters(map_id) do
    Task.start_link(fn -&gt;
      {:ok, map_tracked_character_ids} =
        map_id
        |&gt; WandererApp.MapCharacterSettingsRepo.get_tracked_by_map_all()
        |&gt; case do
          {:ok, settings} -&gt; {:ok, settings |&gt; Enum.map(&amp;Map.get(&amp;1, :character_id))}
          _ -&gt; {:ok, []}
        end

      {:ok, tracked_characters} = WandererApp.Cache.lookup(&quot;tracked_characters&quot;, [])

      map_active_tracked_characters =
        map_tracked_character_ids
        |&gt; Enum.filter(fn character -&gt; character in tracked_characters end)

      {:ok, old_map_tracked_characters} =
        WandererApp.Cache.lookup(&quot;maps:#{map_id}:tracked_characters&quot;, [])

      characters_to_remove = old_map_tracked_characters -- map_active_tracked_characters

      {:ok, invalidate_character_ids} =
        WandererApp.Cache.lookup(
          &quot;map_#{map_id}:invalidate_character_ids&quot;,
          []
        )

      WandererApp.Cache.insert(
        &quot;map_#{map_id}:invalidate_character_ids&quot;,
        (invalidate_character_ids ++ characters_to_remove) |&gt; Enum.uniq()
      )

      WandererApp.Cache.insert(&quot;maps:#{map_id}:tracked_characters&quot;, map_active_tracked_characters)

      :ok
    end)
  end

  def untrack_characters(map_id, character_ids),
    do:
      character_ids
      |&gt; Enum.each(fn character_id -&gt;
        if is_character_map_active?(map_id, character_id) do
          WandererApp.Character.TrackerManager.update_track_settings(character_id, %{
            map_id: map_id,
            track: false
          })

          Impl.broadcast!(map_id, :untrack_character, character_id)
        end
      end)

  def is_character_map_active?(map_id, character_id) do
    case WandererApp.Character.get_character_state(character_id) do
      {:ok, %{active_maps: active_maps}} -&gt;
        map_id in active_maps

      _ -&gt;
        false
    end
  end

  def cleanup_characters(map_id, owner_id) do
    {:ok, invalidate_character_ids} =
      WandererApp.Cache.lookup(
        &quot;map_#{map_id}:invalidate_character_ids&quot;,
        []
      )

    acls =
      map_id
      |&gt; WandererApp.Map.get_map!()
      |&gt; Map.get(:acls, [])

    invalidate_character_ids
    |&gt; Task.async_stream(
      fn character_id -&gt;
        character_id
        |&gt; WandererApp.Character.get_character()
        |&gt; case do
          {:ok, %{user_id: nil}} -&gt;
            {:remove_character, character_id}

          {:ok, character} -&gt;
            [character_permissions] =
              WandererApp.Permissions.check_characters_access([character], acls)

            map_permissions =
              WandererApp.Permissions.get_map_permissions(
                character_permissions,
                owner_id,
                [character_id]
              )

            case map_permissions do
              %{view_system: false} -&gt;
                {:remove_character, character_id}

              %{track_character: false} -&gt;
                {:remove_character, character_id}

              _ -&gt;
                :ok
            end

          _ -&gt;
            :ok
        end
      end,
      timeout: :timer.seconds(60),
      max_concurrency: System.schedulers_online(),
      on_timeout: :kill_task
    )
    |&gt; Enum.each(fn
      {:ok, {:remove_character, character_id}} -&gt;
        remove_and_untrack_characters(map_id, [character_id])
        :ok

      {:ok, _result} -&gt;
        :ok

      {:error, reason} -&gt;
        Logger.error(&quot;Error in cleanup_characters: #{inspect(reason)}&quot;)
    end)

    WandererApp.Cache.insert(
      &quot;map_#{map_id}:invalidate_character_ids&quot;,
      []
    )
  end

  defp remove_and_untrack_characters(map_id, character_ids) do
    Logger.debug(fn -&gt;
      &quot;Map #{map_id} - remove and untrack characters #{inspect(character_ids)}&quot;
    end)

    map_id
    |&gt; untrack_characters(character_ids)

    map_id
    |&gt; WandererApp.MapCharacterSettingsRepo.get_by_map_filtered(character_ids)
    |&gt; case do
      {:ok, settings} -&gt;
        settings
        |&gt; Enum.each(fn s -&gt;
          WandererApp.MapCharacterSettingsRepo.destroy!(s)
          remove_character(map_id, s.character_id)
        end)

      _ -&gt;
        :ok
    end
  end

  def track_characters(_map_id, []), do: :ok

  def track_characters(map_id, [character_id | rest]) do
    track_character(map_id, character_id)
    track_characters(map_id, rest)
  end

  def update_characters(%{map_id: map_id} = state) do
    WandererApp.Cache.lookup!(&quot;maps:#{map_id}:tracked_characters&quot;, [])
    |&gt; Enum.map(fn character_id -&gt;
      Task.start_link(fn -&gt;
        character_updates =
          maybe_update_online(map_id, character_id) ++
            maybe_update_location(map_id, character_id) ++
            maybe_update_ship(map_id, character_id) ++
            maybe_update_alliance(map_id, character_id) ++
            maybe_update_corporation(map_id, character_id)

        character_updates
        |&gt; Enum.filter(fn update -&gt; update != :skip end)
        |&gt; Enum.map(fn update -&gt;
          update
          |&gt; case do
            {:character_location, location_info, old_location_info} -&gt;
              update_location(
                character_id,
                location_info,
                old_location_info,
                state
              )

              :broadcast

            {:character_ship, _info} -&gt;
              :broadcast

            {:character_online, _info} -&gt;
              :broadcast

            {:character_alliance, _info} -&gt;
              WandererApp.Cache.insert_or_update(
                &quot;map_#{map_id}:invalidate_character_ids&quot;,
                [character_id],
                fn ids -&gt;
                  [character_id | ids]
                end
              )

              :broadcast

            {:character_corporation, _info} -&gt;
              WandererApp.Cache.insert_or_update(
                &quot;map_#{map_id}:invalidate_character_ids&quot;,
                [character_id],
                fn ids -&gt;
                  [character_id | ids]
                end
              )

              :broadcast

            _ -&gt;
              :skip
          end
        end)
        |&gt; Enum.filter(fn update -&gt; update != :skip end)
        |&gt; Enum.uniq()
        |&gt; Enum.each(fn update -&gt;
          case update do
            :broadcast -&gt;
              update_character(map_id, character_id)

            _ -&gt;
              :ok
          end
        end)

        :ok
      end)
    end)
  end

  defp update_character(map_id, character_id) do
    {:ok, character} = WandererApp.Character.get_map_character(map_id, character_id)
    Impl.broadcast!(map_id, :character_updated, character)
  end

  defp update_location(
         character_id,
         location,
         old_location,
         %{map: map, map_id: map_id, rtree_name: rtree_name, map_opts: map_opts} = _state
       ) do
    case is_nil(old_location.solar_system_id) and
           ConnectionsImpl.can_add_location(map.scope, location.solar_system_id) do
      true -&gt;
        :ok = SystemsImpl.maybe_add_system(map_id, location, nil, rtree_name, map_opts)

      _ -&gt;
        ConnectionsImpl.is_connection_valid(
          map.scope,
          old_location.solar_system_id,
          location.solar_system_id
        )
        |&gt; case do
          true -&gt;
            :ok =
              SystemsImpl.maybe_add_system(map_id, location, old_location, rtree_name, map_opts)

            :ok =
              SystemsImpl.maybe_add_system(map_id, old_location, location, rtree_name, map_opts)

            if is_character_in_space?(location) do
              :ok =
                ConnectionsImpl.maybe_add_connection(
                  map_id,
                  location,
                  old_location,
                  character_id,
                  false
                )
            end

          _ -&gt;
            :ok
        end
    end
  end

  defp is_character_in_space?(%{station_id: station_id, structure_id: structure_id} = location) do
    is_nil(structure_id) and is_nil(station_id)
  end

  defp track_character(map_id, character_id) do
    {:ok, character} = WandererApp.Character.get_character(character_id)
    add_character(%{map_id: map_id}, character, true)

    WandererApp.Character.TrackerManager.update_track_settings(character_id, %{
      map_id: map_id,
      track: true,
      track_online: true,
      track_location: true,
      track_ship: true
    })
  end

  defp maybe_update_online(map_id, character_id) do
    with {:ok, old_online} &lt;-
           WandererApp.Cache.lookup(&quot;map:#{map_id}:character:#{character_id}:online&quot;),
         {:ok, %{online: online}} &lt;-
           WandererApp.Character.get_character(character_id) do
      case old_online != online do
        true -&gt;
          WandererApp.Cache.insert(
            &quot;map:#{map_id}:character:#{character_id}:online&quot;,
            online
          )

          [{:character_online, %{online: online}}]

        _ -&gt;
          [:skip]
      end
    else
      error -&gt;
        Logger.error(&quot;Failed to update online: #{inspect(error, pretty: true)}&quot;)
        [:skip]
    end
  end

  defp maybe_update_ship(map_id, character_id) do
    with {:ok, old_ship_type_id} &lt;-
           WandererApp.Cache.lookup(&quot;map:#{map_id}:character:#{character_id}:ship_type_id&quot;),
         {:ok, old_ship_name} &lt;-
           WandererApp.Cache.lookup(&quot;map:#{map_id}:character:#{character_id}:ship_name&quot;),
         {:ok, %{ship: ship_type_id, ship_name: ship_name, ship_item_id: ship_item_id}} &lt;-
           WandererApp.Character.get_character(character_id) do
      case old_ship_type_id != ship_type_id or
             old_ship_name != ship_name do
        true -&gt;
          WandererApp.Cache.insert(
            &quot;map:#{map_id}:character:#{character_id}:ship_type_id&quot;,
            ship_type_id
          )

          WandererApp.Cache.insert(
            &quot;map:#{map_id}:character:#{character_id}:ship_name&quot;,
            ship_name
          )

          [
            {:character_ship,
             %{ship: ship_type_id, ship_name: ship_name, ship_item_id: ship_item_id}}
          ]

        _ -&gt;
          [:skip]
      end
    else
      error -&gt;
        Logger.error(&quot;Failed to update ship: #{inspect(error, pretty: true)}&quot;)
        [:skip]
    end
  end

  defp maybe_update_location(map_id, character_id) do
    {:ok, old_solar_system_id} =
      WandererApp.Cache.lookup(&quot;map:#{map_id}:character:#{character_id}:solar_system_id&quot;)

    {:ok, old_station_id} =
      WandererApp.Cache.lookup(&quot;map:#{map_id}:character:#{character_id}:station_id&quot;)

    {:ok, old_structure_id} =
      WandererApp.Cache.lookup(&quot;map:#{map_id}:character:#{character_id}:structure_id&quot;)

    {:ok, %{solar_system_id: solar_system_id, structure_id: structure_id, station_id: station_id}} =
      WandererApp.Character.get_character(character_id)

    WandererApp.Cache.insert(
      &quot;map:#{map_id}:character:#{character_id}:solar_system_id&quot;,
      solar_system_id
    )

    WandererApp.Cache.insert(
      &quot;map:#{map_id}:character:#{character_id}:station_id&quot;,
      station_id
    )

    WandererApp.Cache.insert(
      &quot;map:#{map_id}:character:#{character_id}:structure_id&quot;,
      structure_id
    )

    if solar_system_id != old_solar_system_id || structure_id != old_structure_id ||
         station_id != old_station_id do
      [
        {:character_location,
         %{
           solar_system_id: solar_system_id,
           structure_id: structure_id,
           station_id: station_id
         }, %{solar_system_id: old_solar_system_id}}
      ]
    else
      [:skip]
    end
  end

  defp maybe_update_alliance(map_id, character_id) do
    with {:ok, old_alliance_id} &lt;-
           WandererApp.Cache.lookup(&quot;map:#{map_id}:character:#{character_id}:alliance_id&quot;),
         {:ok, %{alliance_id: alliance_id}} &lt;-
           WandererApp.Character.get_character(character_id) do
      case old_alliance_id != alliance_id do
        true -&gt;
          WandererApp.Cache.insert(
            &quot;map:#{map_id}:character:#{character_id}:alliance_id&quot;,
            alliance_id
          )

          [{:character_alliance, %{alliance_id: alliance_id}}]

        _ -&gt;
          [:skip]
      end
    else
      error -&gt;
        Logger.error(&quot;Failed to update alliance: #{inspect(error, pretty: true)}&quot;)
        [:skip]
    end
  end

  defp maybe_update_corporation(map_id, character_id) do
    with {:ok, old_corporation_id} &lt;-
           WandererApp.Cache.lookup(&quot;map:#{map_id}:character:#{character_id}:corporation_id&quot;),
         {:ok, %{corporation_id: corporation_id}} &lt;-
           WandererApp.Character.get_character(character_id) do
      case old_corporation_id != corporation_id do
        true -&gt;
          WandererApp.Cache.insert(
            &quot;map:#{map_id}:character:#{character_id}:corporation_id&quot;,
            corporation_id
          )

          [{:character_corporation, %{corporation_id: corporation_id}}]

        _ -&gt;
          [:skip]
      end
    else
      error -&gt;
        Logger.error(&quot;Failed to update corporation: #{inspect(error, pretty: true)}&quot;)
        [:skip]
    end
  end
end</file><file path="lib/wanderer_app/map/server/map_server_connections_impl.ex">defmodule WandererApp.Map.Server.ConnectionsImpl do
  @moduledoc false

  require Logger

  alias WandererApp.Map.Server.Impl

  # @ccp1 -1
  @c1 1
  @c2 2
  @c3 3
  @c4 4
  @c5 5
  @c6 6
  @hs 7
  @ls 8
  @ns 9
  # @ccp2 10
  # @ccp3 11
  @thera 12
  @c13 13
  @sentinel 14
  @barbican 15
  @vidette 16
  @conflux 17
  @redoubt 18
  @a1 19
  @a2 20
  @a3 21
  @a4 22
  @a5 23
  @ccp4 24
  # @pochven 25
  # @zarzakh 10100

  @jita 30_000_142

  @wh_space [
    @c1,
    @c2,
    @c3,
    @c4,
    @c5,
    @c6,
    @c13,
    @thera,
    @sentinel,
    @barbican,
    @vidette,
    @conflux,
    @redoubt
  ]

  @known_space [@hs, @ls, @ns]

  @prohibited_systems [@jita]
  @prohibited_system_classes [
    @a1,
    @a2,
    @a3,
    @a4,
    @a5,
    @ccp4
  ]

  # this class of systems will guaranty that no one real class will take that place
  # @unknown 100_100
  #
  @connection_time_status_eol 1
  @connection_type_wormhole 0
  @connection_type_stargate 1
  @medium_ship_size 1

  def get_connection_auto_expire_hours(), do: WandererApp.Env.map_connection_auto_expire_hours()

  def get_connection_auto_eol_hours(), do: WandererApp.Env.map_connection_auto_eol_hours()

  def get_eol_expire_timeout_mins(), do: WandererApp.Env.map_connection_eol_expire_timeout_mins()

  def get_eol_expire_timeout(),
    do:
      :timer.hours(get_connection_auto_expire_hours() - get_connection_auto_eol_hours()) +
        :timer.minutes(get_eol_expire_timeout_mins())

  def get_connection_expire_timeout(),
    do:
      :timer.hours(get_connection_auto_expire_hours()) +
        :timer.minutes(get_eol_expire_timeout_mins())

  def init_eol_cache(map_id, connections_eol_time) do
    connections_eol_time
    |&gt; Enum.each(fn {connection_id, connection_eol_time} -&gt;
      WandererApp.Cache.put(
        &quot;map_#{map_id}:conn_#{connection_id}:mark_eol_time&quot;,
        connection_eol_time
      )
    end)
  end

  def init_start_cache(map_id, connections_start_time) when not is_nil(connections_start_time) do
    connections_start_time
    |&gt; Enum.each(fn {connection_id, start_time} -&gt;
      set_start_time(map_id, connection_id, start_time)
    end)
  end

  def init_start_cache(_map_id, _connections_start_time), do: :ok

  def add_connection(
        %{map_id: map_id} = state,
        %{
          solar_system_source_id: solar_system_source_id,
          solar_system_target_id: solar_system_target_id,
          character_id: character_id
        } = _connection_info
      ) do
    :ok =
      maybe_add_connection(
        map_id,
        %{solar_system_id: solar_system_target_id},
        %{
          solar_system_id: solar_system_source_id
        },
        character_id,
        true
      )

    state
  end

  def delete_connection(
        %{map_id: map_id} = state,
        %{
          solar_system_source_id: solar_system_source_id,
          solar_system_target_id: solar_system_target_id
        } = _connection_info
      ) do
    :ok =
      maybe_remove_connection(map_id, %{solar_system_id: solar_system_target_id}, %{
        solar_system_id: solar_system_source_id
      })

    state
  end

  def get_connection_info(
        %{map_id: map_id} = _state,
        %{
          solar_system_source_id: solar_system_source_id,
          solar_system_target_id: solar_system_target_id
        } = _connection_info
      ) do
    WandererApp.Map.find_connection(
      map_id,
      solar_system_source_id,
      solar_system_target_id
    )
    |&gt; case do
      {:ok, %{id: connection_id}} -&gt;
        connection_mark_eol_time = get_connection_mark_eol_time(map_id, connection_id, nil)
        {:ok, %{marl_eol_time: connection_mark_eol_time}}

      _ -&gt;
        {:error, :not_found}
    end
  end

  def update_connection_time_status(
        %{map_id: map_id} = state,
        connection_update
      ),
      do:
        update_connection(state, :update_time_status, [:time_status], connection_update, fn
          %{time_status: old_time_status}, %{id: connection_id, time_status: time_status} -&gt;
            case time_status == @connection_time_status_eol do
              true -&gt;
                if old_time_status != @connection_time_status_eol do
                  WandererApp.Cache.put(
                    &quot;map_#{map_id}:conn_#{connection_id}:mark_eol_time&quot;,
                    DateTime.utc_now()
                  )
                end

              _ -&gt;
                if old_time_status == @connection_time_status_eol do
                  WandererApp.Cache.delete(&quot;map_#{map_id}:conn_#{connection_id}:mark_eol_time&quot;)
                  set_start_time(map_id, connection_id, DateTime.utc_now())
                end
            end
        end)

  def update_connection_type(
        state,
        connection_update
      ),
      do: update_connection(state, :update_type, [:type], connection_update)

  def update_connection_mass_status(
        state,
        connection_update
      ),
      do: update_connection(state, :update_mass_status, [:mass_status], connection_update)

  def update_connection_ship_size_type(
        state,
        connection_update
      ),
      do: update_connection(state, :update_ship_size_type, [:ship_size_type], connection_update)

  def update_connection_locked(
        state,
        connection_update
      ),
      do: update_connection(state, :update_locked, [:locked], connection_update)

  def update_connection_custom_info(
        state,
        connection_update
      ),
      do: update_connection(state, :update_custom_info, [:custom_info], connection_update)

  def cleanup_connections(%{map_id: map_id} = state) do
    connection_auto_expire_hours = get_connection_auto_expire_hours()
    connection_auto_eol_hours = get_connection_auto_eol_hours()
    connection_eol_expire_timeout_hours = get_eol_expire_timeout_mins() / 60

    state =
      map_id
      |&gt; WandererApp.Map.list_connections!()
      |&gt; Enum.filter(fn %{
                          id: connection_id,
                          inserted_at: inserted_at,
                          solar_system_source: solar_system_source_id,
                          solar_system_target: solar_system_target_id,
                          type: type
                        } -&gt;
        connection_start_time = get_start_time(map_id, connection_id)

        type != @connection_type_stargate &amp;&amp;
          DateTime.diff(DateTime.utc_now(), connection_start_time, :hour) &gt;=
            connection_auto_eol_hours &amp;&amp;
          is_connection_valid(
            :wormholes,
            solar_system_source_id,
            solar_system_target_id
          )
      end)
      |&gt; Enum.reduce(state, fn %{
                                 solar_system_source: solar_system_source_id,
                                 solar_system_target: solar_system_target_id
                               },
                               state -&gt;
        state
        |&gt; update_connection_time_status(%{
          solar_system_source_id: solar_system_source_id,
          solar_system_target_id: solar_system_target_id,
          time_status: @connection_time_status_eol
        })
      end)

    state =
      map_id
      |&gt; WandererApp.Map.list_connections!()
      |&gt; Enum.filter(fn %{
                          id: connection_id,
                          solar_system_source: solar_system_source_id,
                          solar_system_target: solar_system_target_id,
                          type: type
                        } -&gt;
        connection_mark_eol_time =
          get_connection_mark_eol_time(map_id, connection_id)

        reverse_connection =
          WandererApp.Map.get_connection(
            map_id,
            solar_system_target_id,
            solar_system_source_id
          )

        is_connection_exist =
          is_connection_exist(
            map_id,
            solar_system_source_id,
            solar_system_target_id
          ) || not is_nil(reverse_connection)

        is_connection_valid =
          is_connection_valid(
            :wormholes,
            solar_system_source_id,
            solar_system_target_id
          )

        not is_connection_exist ||
          (type != @connection_type_stargate &amp;&amp; is_connection_valid &amp;&amp;
             DateTime.diff(DateTime.utc_now(), connection_mark_eol_time, :hour) &gt;=
               connection_auto_expire_hours - connection_auto_eol_hours +
                 +connection_eol_expire_timeout_hours)
      end)
      |&gt; Enum.reduce(state, fn %{
                                 solar_system_source: solar_system_source_id,
                                 solar_system_target: solar_system_target_id
                               },
                               state -&gt;
        state
        |&gt; delete_connection(%{
          solar_system_source_id: solar_system_source_id,
          solar_system_target_id: solar_system_target_id
        })
      end)

    state
  end

  def maybe_add_connection(map_id, location, old_location, character_id, is_manual)
      when not is_nil(location) and not is_nil(old_location) and
             not is_nil(old_location.solar_system_id) and
             location.solar_system_id != old_location.solar_system_id do
    if not is_manual do
      character_id
      |&gt; WandererApp.Character.get_character!()
      |&gt; case do
        nil -&gt;
          :ok

        character -&gt;
          :telemetry.execute([:wanderer_app, :map, :character, :jump], %{count: 1}, %{})

          {:ok, _} =
            WandererApp.Api.MapChainPassages.new(%{
              map_id: map_id,
              character_id: character_id,
              ship_type_id: character.ship,
              ship_name: character.ship_name,
              solar_system_source_id: old_location.solar_system_id,
              solar_system_target_id: location.solar_system_id
            })
      end
    end

    case WandererApp.Map.check_connection(map_id, location, old_location) do
      :ok -&gt;
        connection_type =
          is_connection_valid(
            :stargates,
            old_location.solar_system_id,
            location.solar_system_id
          )
          |&gt; case do
            true -&gt;
              @connection_type_stargate

            _ -&gt;
              @connection_type_wormhole
          end

        # Check if either system is C1 before creating the connection
        {:ok, source_system_info} = get_system_static_info(old_location.solar_system_id)
        {:ok, target_system_info} = get_system_static_info(location.solar_system_id)

        # Set ship size type to medium only for wormhole connections involving C1 systems
        ship_size_type = if connection_type == @connection_type_wormhole and
                             (source_system_info.system_class == @c1 or
                              target_system_info.system_class == @c1) do
          @medium_ship_size
        else
          2  # Default to large for non-wormhole or non-C1 connections
        end

        {:ok, connection} =
          WandererApp.MapConnectionRepo.create(%{
            map_id: map_id,
            solar_system_source: old_location.solar_system_id,
            solar_system_target: location.solar_system_id,
            type: connection_type,
            ship_size_type: ship_size_type
          })

        if connection_type == @connection_type_wormhole do
          set_start_time(map_id, connection.id, DateTime.utc_now())
        end

        WandererApp.Map.add_connection(map_id, connection)

        Impl.broadcast!(map_id, :maybe_select_system, %{
          character_id: character_id,
          solar_system_id: location.solar_system_id
        })

        Impl.broadcast!(map_id, :add_connection, connection)

        {:ok, character} = WandererApp.Character.get_character(character_id)

        {:ok, _} =
          WandererApp.User.ActivityTracker.track_map_event(:map_connection_added, %{
            character_id: character_id,
            user_id: character.user_id,
            map_id: map_id,
            solar_system_source_id: old_location.solar_system_id,
            solar_system_target_id: location.solar_system_id
          })

        Impl.broadcast!(map_id, :maybe_link_signature, %{
          character_id: character_id,
          solar_system_source: old_location.solar_system_id,
          solar_system_target: location.solar_system_id
        })

        :ok

      {:error, :already_exists} -&gt;
        # Still broadcast location change in case of followed character
        Impl.broadcast!(map_id, :maybe_select_system, %{
          character_id: character_id,
          solar_system_id: location.solar_system_id
        })

        :ok

      {:error, error} -&gt;
        Logger.debug(fn -&gt; &quot;Failed to add connection: #{inspect(error, pretty: true)}&quot; end)

        :ok
    end
  end

  def maybe_add_connection(_map_id, _location, _old_location, _character_id, _is_manual), do: :ok

  def get_start_time(map_id, connection_id) do
    case WandererApp.Cache.get(&quot;map_#{map_id}:conn_#{connection_id}:start_time&quot;) do
      nil -&gt;
        set_start_time(map_id, connection_id, DateTime.utc_now())
        DateTime.utc_now()

      value -&gt;
        value
    end
  end

  def set_start_time(map_id, connection_id, start_time) do
    WandererApp.Cache.put(
      &quot;map_#{map_id}:conn_#{connection_id}:start_time&quot;,
      start_time
    )
  end

  def can_add_location(_scope, nil), do: false

  def can_add_location(:none, _solar_system_id), do: false

  def can_add_location(scope, solar_system_id) do
    {:ok, system_static_info} = get_system_static_info(solar_system_id)

    case scope do
      :wormholes -&gt;
        not is_prohibited_system_class?(system_static_info.system_class) and
          not (@prohibited_systems |&gt; Enum.member?(solar_system_id)) and
          @wh_space |&gt; Enum.member?(system_static_info.system_class)

      :stargates -&gt;
        not is_prohibited_system_class?(system_static_info.system_class) and
          @known_space |&gt; Enum.member?(system_static_info.system_class)

      :all -&gt;
        not is_prohibited_system_class?(system_static_info.system_class)

      _ -&gt;
        false
    end
  end

  def is_prohibited_system_class?(system_class) do
    @prohibited_system_classes |&gt; Enum.member?(system_class)
  end

  def is_connection_exist(map_id, from_solar_system_id, to_solar_system_id),
    do:
      not is_nil(
        WandererApp.Map.find_system_by_location(
          map_id,
          %{solar_system_id: from_solar_system_id}
        )
      ) &amp;&amp;
        not is_nil(
          WandererApp.Map.find_system_by_location(
            map_id,
            %{solar_system_id: to_solar_system_id}
          )
        )

  def is_connection_valid(:all, _from_solar_system_id, _to_solar_system_id), do: true

  def is_connection_valid(:none, _from_solar_system_id, _to_solar_system_id), do: false

  def is_connection_valid(scope, from_solar_system_id, to_solar_system_id)
      when not is_nil(from_solar_system_id) and not is_nil(to_solar_system_id) do
    {:ok, known_jumps} =
      WandererApp.Api.MapSolarSystemJumps.find(%{
        before_system_id: from_solar_system_id,
        current_system_id: to_solar_system_id
      })

    {:ok, from_system_static_info} = get_system_static_info(from_solar_system_id)
    {:ok, to_system_static_info} = get_system_static_info(to_solar_system_id)

    case scope do
      :wormholes -&gt;
        not is_prohibited_system_class?(from_system_static_info.system_class) and
          not is_prohibited_system_class?(to_system_static_info.system_class) and
          not (@prohibited_systems |&gt; Enum.member?(from_solar_system_id)) and
          not (@prohibited_systems |&gt; Enum.member?(to_solar_system_id)) and
          known_jumps |&gt; Enum.empty?()

      :stargates -&gt;
        # For stargates, we need to check:
        # 1. Both systems are in known space (HS, LS, NS)
        # 2. There is a known jump between them
        # 3. Neither system is prohibited
        from_system_static_info.system_class in @known_space and
          to_system_static_info.system_class in @known_space and
          not is_prohibited_system_class?(from_system_static_info.system_class) and
          not is_prohibited_system_class?(to_system_static_info.system_class) and
          not (known_jumps |&gt; Enum.empty?())
    end
  end

  def is_connection_valid(_scope, _from_solar_system_id, _to_solar_system_id), do: false

  def get_connection_mark_eol_time(map_id, connection_id, default \\ DateTime.utc_now()) do
    WandererApp.Cache.get(&quot;map_#{map_id}:conn_#{connection_id}:mark_eol_time&quot;)
    |&gt; case do
      nil -&gt;
        default

      value -&gt;
        value
    end
  end

  defp get_system_static_info(solar_system_id) do
    case WandererApp.CachedInfo.get_system_static_info(solar_system_id) do
      {:ok, system_static_info} when not is_nil(system_static_info) -&gt;
        {:ok, system_static_info}

      _ -&gt;
        {:ok, %{system_class: nil}}
    end
  end

  defp maybe_remove_connection(map_id, location, old_location)
       when not is_nil(location) and not is_nil(old_location) and
              location.solar_system_id != old_location.solar_system_id do
    case WandererApp.Map.find_connection(
           map_id,
           location.solar_system_id,
           old_location.solar_system_id
         ) do
      {:ok, connection} when not is_nil(connection) -&gt;
        :ok = WandererApp.MapConnectionRepo.destroy(map_id, connection)

        Impl.broadcast!(map_id, :remove_connections, [connection])
        map_id |&gt; WandererApp.Map.remove_connection(connection)

        WandererApp.Cache.delete(&quot;map_#{map_id}:conn_#{connection.id}:start_time&quot;)

      _error -&gt;
        :ok
    end
  end

  defp maybe_remove_connection(_map_id, _location, _old_location), do: :ok

  defp update_connection(
         %{map_id: map_id} = state,
         update_method,
         attributes,
         %{
           solar_system_source_id: solar_system_source_id,
           solar_system_target_id: solar_system_target_id
         } = update,
         callback_fn \\ nil
       ) do
    with {:ok, connection} &lt;-
           WandererApp.Map.find_connection(
             map_id,
             solar_system_source_id,
             solar_system_target_id
           ),
         {:ok, update_map} &lt;- Impl.get_update_map(update, attributes),
         {:ok, updated_connection} &lt;-
           apply(WandererApp.MapConnectionRepo, update_method, [
             connection,
             update_map
           ]),
         :ok &lt;-
           WandererApp.Map.update_connection(
             map_id,
             connection |&gt; Map.merge(update_map)
           ) do
      if not is_nil(callback_fn) do
        callback_fn.(connection, updated_connection)
      end

      Impl.broadcast!(map_id, :update_connection, updated_connection)

      state
    else
      {:error, error} -&gt;
        Logger.error(&quot;Failed to update connection: #{inspect(error, pretty: true)}&quot;)

        state
    end
  end
end</file><file path="lib/wanderer_app/map/server/map_server_impl.ex">defmodule WandererApp.Map.Server.Impl do
  @moduledoc &quot;&quot;&quot;
  Holds state for a map and exposes an interface to managing the map instance
  &quot;&quot;&quot;
  require Logger

  alias WandererApp.Map.Server.{
    AclsImpl,
    CharactersImpl,
    ConnectionsImpl,
    SystemsImpl,
    SignaturesImpl
  }

  @enforce_keys [
    :map_id
  ]

  defstruct [
    :map_id,
    :rtree_name,
    map: nil,
    map_opts: []
  ]

  @systems_cleanup_timeout :timer.minutes(30)
  @characters_cleanup_timeout :timer.minutes(1)
  @connections_cleanup_timeout :timer.minutes(2)

  @pubsub_client Application.compile_env(:wanderer_app, :pubsub_client)
  @backup_state_timeout :timer.minutes(1)
  @update_presence_timeout :timer.seconds(1)
  @update_characters_timeout :timer.seconds(1)
  @update_tracked_characters_timeout :timer.seconds(1)

  def new(), do: __struct__()
  def new(args), do: __struct__(args)

  def init(args) do
    map_id = args[:map_id]
    Logger.info(&quot;Starting map server for #{map_id}&quot;)

    ErrorTracker.set_context(%{map_id: map_id})
    WandererApp.Cache.insert(&quot;map_#{map_id}:started&quot;, false)

    %{
      map_id: map_id,
      rtree_name: Module.concat([map_id, DDRT.DynamicRtree])
    }
    |&gt; new()
  end

  def load_state(%__MODULE__{map_id: map_id} = state) do
    with {:ok, map} &lt;-
           WandererApp.MapRepo.get(map_id, [
             :owner,
             :characters,
             acls: [
               :owner_id,
               members: [:role, :eve_character_id, :eve_corporation_id, :eve_alliance_id]
             ]
           ]),
         {:ok, systems} &lt;- WandererApp.MapSystemRepo.get_visible_by_map(map_id),
         {:ok, connections} &lt;- WandererApp.MapConnectionRepo.get_by_map(map_id),
         {:ok, subscription_settings} &lt;-
           WandererApp.Map.SubscriptionManager.get_active_map_subscription(map_id) do
      state
      |&gt; init_map(
        map,
        subscription_settings,
        systems,
        connections
      )
      |&gt; SystemsImpl.init_map_systems(systems)
      |&gt; init_map_cache()
    else
      error -&gt;
        Logger.error(&quot;Failed to load map state: #{inspect(error, pretty: true)}&quot;)
        state
    end
  end

  def start_map(%__MODULE__{map: map, map_id: map_id} = state) do
    with :ok &lt;- AclsImpl.track_acls(map.acls |&gt; Enum.map(&amp; &amp;1.id)) do
      @pubsub_client.subscribe(
        WandererApp.PubSub,
        &quot;maps:#{map_id}&quot;
      )

      Process.send_after(self(), :update_characters, @update_characters_timeout)
      Process.send_after(self(), :update_tracked_characters, 100)
      Process.send_after(self(), :update_presence, @update_presence_timeout)
      Process.send_after(self(), :cleanup_connections, 5_000)
      Process.send_after(self(), :cleanup_systems, 10_000)
      Process.send_after(self(), :cleanup_characters, :timer.minutes(5))
      Process.send_after(self(), :backup_state, @backup_state_timeout)

      WandererApp.Cache.insert(&quot;map_#{map_id}:started&quot;, true)

      broadcast!(map_id, :map_server_started)

      :telemetry.execute([:wanderer_app, :map, :started], %{count: 1})

      state
    else
      error -&gt;
        Logger.error(&quot;Failed to start map: #{inspect(error, pretty: true)}&quot;)
        state
    end
  end

  def stop_map(%{map_id: map_id} = state) do
    Logger.debug(fn -&gt; &quot;Stopping map server for #{map_id}&quot; end)

    WandererApp.Cache.delete(&quot;map_#{map_id}:started&quot;)

    :telemetry.execute([:wanderer_app, :map, :stopped], %{count: 1})

    state
    |&gt; maybe_stop_rtree()
  end

  def get_map(%{map: map} = _state), do: {:ok, map}

  defdelegate get_characters(state), to: CharactersImpl

  defdelegate add_character(state, character, track_character), to: CharactersImpl

  def remove_character(%{map_id: map_id} = state, character_id) do
    CharactersImpl.remove_character(map_id, character_id)

    state
  end

  def untrack_characters(%{map_id: map_id} = state, characters_ids) do
    CharactersImpl.untrack_characters(map_id, characters_ids)

    state
  end

  defdelegate add_system(state, system_info, user_id, character_id), to: SystemsImpl

  defdelegate add_system_comment(state, comment_info, user_id, character_id), to: SystemsImpl

  defdelegate remove_system_comment(state, comment_id, user_id, character_id), to: SystemsImpl

  defdelegate delete_systems(
                state,
                removed_ids,
                user_id,
                character_id
              ),
              to: SystemsImpl

  defdelegate update_system_name(state, update), to: SystemsImpl

  defdelegate update_system_description(state, update), to: SystemsImpl

  defdelegate update_system_status(state, update), to: SystemsImpl

  defdelegate update_system_tag(state, update), to: SystemsImpl

  defdelegate update_system_temporary_name(state, update), to: SystemsImpl

  defdelegate update_system_locked(state, update), to: SystemsImpl

  defdelegate update_system_labels(state, update), to: SystemsImpl

  defdelegate update_system_linked_sig_eve_id(state, update), to: SystemsImpl

  defdelegate update_system_position(state, update), to: SystemsImpl

  defdelegate add_hub(state, hub_info), to: SystemsImpl

  defdelegate remove_hub(state, hub_info), to: SystemsImpl

  defdelegate add_connection(state, connection_info), to: ConnectionsImpl

  defdelegate delete_connection(state, connection_info), to: ConnectionsImpl

  defdelegate get_connection_info(state, connection_info), to: ConnectionsImpl

  defdelegate update_connection_time_status(state, connection_update), to: ConnectionsImpl

  defdelegate update_connection_type(state, connection_update), to: ConnectionsImpl

  defdelegate update_connection_mass_status(state, connection_update), to: ConnectionsImpl

  defdelegate update_connection_ship_size_type(state, connection_update), to: ConnectionsImpl

  defdelegate update_connection_locked(state, connection_update), to: ConnectionsImpl

  defdelegate update_connection_custom_info(state, signatures_update), to: ConnectionsImpl

  defdelegate update_signatures(state, signatures_update), to: SignaturesImpl

  def import_settings(%{map_id: map_id} = state, settings, user_id) do
    WandererApp.Cache.put(
      &quot;map_#{map_id}:importing&quot;,
      true
    )

    state =
      state
      |&gt; maybe_import_systems(settings, user_id, nil)
      |&gt; maybe_import_connections(settings, user_id)
      |&gt; maybe_import_hubs(settings, user_id)

    WandererApp.Cache.take(&quot;map_#{map_id}:importing&quot;)

    state
  end

  def update_subscription_settings(%{map: map} = state, subscription_settings),
    do: %{
      state
      | map: map |&gt; WandererApp.Map.update_subscription_settings!(subscription_settings)
    }

  def handle_event(:update_characters, state) do
    Process.send_after(self(), :update_characters, @update_characters_timeout)

    CharactersImpl.update_characters(state)

    state
  end

  def handle_event(:update_tracked_characters, %{map_id: map_id} = state) do
    Process.send_after(self(), :update_tracked_characters, @update_tracked_characters_timeout)

    CharactersImpl.update_tracked_characters(map_id)

    state
  end

  def handle_event(:update_presence, %{map_id: map_id} = state) do
    Process.send_after(self(), :update_presence, @update_presence_timeout)

    update_presence(map_id)

    state
  end

  def handle_event(:backup_state, state) do
    Process.send_after(self(), :backup_state, @backup_state_timeout)
    {:ok, _map_state} = state |&gt; save_map_state()

    state
  end

  def handle_event(
        {:map_acl_updated, added_acls, removed_acls},
        state
      ) do
    state |&gt; AclsImpl.handle_map_acl_updated(added_acls, removed_acls)
  end

  def handle_event({:acl_updated, %{acl_id: acl_id}}, %{map_id: map_id} = state) do
    AclsImpl.handle_acl_updated(map_id, acl_id)

    state
  end

  def handle_event({:acl_deleted, %{acl_id: acl_id}}, %{map_id: map_id} = state) do
    AclsImpl.handle_acl_updated(map_id, acl_id)

    state
  end

  def handle_event(:cleanup_connections, state) do
    Process.send_after(self(), :cleanup_connections, @connections_cleanup_timeout)

    state |&gt; ConnectionsImpl.cleanup_connections()
  end

  def handle_event(:cleanup_characters, %{map_id: map_id, map: %{owner_id: owner_id}} = state) do
    Process.send_after(self(), :cleanup_characters, @characters_cleanup_timeout)

    CharactersImpl.cleanup_characters(map_id, owner_id)

    state
  end

  def handle_event(:cleanup_systems, state) do
    Process.send_after(self(), :cleanup_systems, @systems_cleanup_timeout)

    state |&gt; SystemsImpl.cleanup_systems()
  end

  def handle_event(:subscription_settings_updated, %{map: map, map_id: map_id} = state) do
    {:ok, subscription_settings} =
      WandererApp.Map.SubscriptionManager.get_active_map_subscription(map_id)

    %{
      state
      | map:
          map
          |&gt; WandererApp.Map.update_subscription_settings!(subscription_settings)
    }
  end

  def handle_event({:options_updated, options}, %{map: map} = state) do
    map |&gt; WandererApp.Map.update_options!(options)

    %{state | map_opts: map_options(options)}
  end

  def handle_event({ref, _result}, %{map_id: _map_id} = state) when is_reference(ref) do
    Process.demonitor(ref, [:flush])

    state
  end

  def handle_event(msg, state) do
    Logger.warning(&quot;Unhandled event: #{inspect(msg)}&quot;)

    state
  end

  def broadcast!(map_id, event, payload \\ nil) do
    if can_broadcast?(map_id) do
      @pubsub_client.broadcast!(WandererApp.PubSub, map_id, %{
        event: event,
        payload: payload,
        timestamp: DateTime.utc_now()
      })
    end

    :ok
  end

  defp can_broadcast?(map_id),
    do:
      not WandererApp.Cache.lookup!(&quot;map_#{map_id}:importing&quot;, false) and
        WandererApp.Cache.lookup!(&quot;map_#{map_id}:started&quot;, false)

  def get_update_map(update, attributes),
    do:
      {:ok,
       Enum.reduce(attributes, Map.new(), fn attribute, map -&gt;
         map |&gt; Map.put_new(attribute, get_in(update, [Access.key(attribute)]))
       end)}

  defp map_options(options) do
    [
      layout: options |&gt; Map.get(&quot;layout&quot;, &quot;left_to_right&quot;),
      store_custom_labels:
        options |&gt; Map.get(&quot;store_custom_labels&quot;, &quot;false&quot;) |&gt; String.to_existing_atom(),
      show_linked_signature_id:
        options |&gt; Map.get(&quot;show_linked_signature_id&quot;, &quot;false&quot;) |&gt; String.to_existing_atom(),
      show_linked_signature_id_temp_name:
        options
        |&gt; Map.get(&quot;show_linked_signature_id_temp_name&quot;, &quot;false&quot;)
        |&gt; String.to_existing_atom(),
      show_temp_system_name:
        options |&gt; Map.get(&quot;show_temp_system_name&quot;, &quot;false&quot;) |&gt; String.to_existing_atom(),
      restrict_offline_showing:
        options |&gt; Map.get(&quot;restrict_offline_showing&quot;, &quot;false&quot;) |&gt; String.to_existing_atom()
    ]
  end

  defp save_map_state(%{map_id: map_id} = _state) do
    systems_last_activity =
      map_id
      |&gt; WandererApp.Map.list_systems!()
      |&gt; Enum.reduce(%{}, fn %{id: system_id} = _system, acc -&gt;
        case WandererApp.Cache.get(&quot;map_#{map_id}:system_#{system_id}:last_activity&quot;) do
          nil -&gt;
            acc

          value -&gt;
            acc |&gt; Map.put_new(system_id, value)
        end
      end)

    connections =
      map_id
      |&gt; WandererApp.Map.list_connections!()

    connections_eol_time =
      connections
      |&gt; Enum.reduce(%{}, fn %{id: connection_id} = _connection, acc -&gt;
        case WandererApp.Cache.get(&quot;map_#{map_id}:conn_#{connection_id}:mark_eol_time&quot;) do
          nil -&gt;
            acc

          value -&gt;
            acc |&gt; Map.put_new(connection_id, value)
        end
      end)

    connections_start_time =
      connections
      |&gt; Enum.reduce(%{}, fn %{id: connection_id} = _connection, acc -&gt;
        connection_start_time = ConnectionsImpl.get_start_time(map_id, connection_id)
        acc |&gt; Map.put_new(connection_id, connection_start_time)
      end)

    WandererApp.Api.MapState.create(%{
      map_id: map_id,
      systems_last_activity: systems_last_activity,
      connections_eol_time: connections_eol_time,
      connections_start_time: connections_start_time
    })
  end

  defp maybe_stop_rtree(%{rtree_name: rtree_name} = state) do
    case Process.whereis(rtree_name) do
      nil -&gt;
        :ok

      pid when is_pid(pid) -&gt;
        GenServer.stop(pid, :normal)
    end

    state
  end

  defp init_map_cache(%__MODULE__{map_id: map_id} = state) do
    case WandererApp.Api.MapState.by_map_id(map_id) do
      {:ok,
       %{
         systems_last_activity: systems_last_activity,
         connections_eol_time: connections_eol_time,
         connections_start_time: connections_start_time
       }} -&gt;
        SystemsImpl.init_last_activity_cache(map_id, systems_last_activity)
        ConnectionsImpl.init_eol_cache(map_id, connections_eol_time)
        ConnectionsImpl.init_start_cache(map_id, connections_start_time)

        state

      _ -&gt;
        state
    end
  end

  defp init_map(
         state,
         %{id: map_id, characters: characters} = initial_map,
         subscription_settings,
         systems,
         connections
       ) do
    {:ok, options} = WandererApp.MapRepo.options_to_form_data(initial_map)

    map =
      initial_map
      |&gt; WandererApp.Map.new()
      |&gt; WandererApp.Map.update_options!(options)
      |&gt; WandererApp.Map.update_subscription_settings!(subscription_settings)
      |&gt; WandererApp.Map.add_systems!(systems)
      |&gt; WandererApp.Map.add_connections!(connections)
      |&gt; WandererApp.Map.add_characters!(characters)

    character_ids =
      map_id
      |&gt; WandererApp.Map.get_map!()
      |&gt; Map.get(:characters, [])

    WandererApp.Cache.insert(&quot;map_#{map_id}:invalidate_character_ids&quot;, character_ids)

    %{state | map: map, map_opts: map_options(options)}
  end

  def maybe_import_systems(state, %{&quot;systems&quot; =&gt; systems} = _settings, user_id, character_id) do
    state =
      systems
      |&gt; Enum.reduce(state, fn %{
                                 &quot;description&quot; =&gt; description,
                                 &quot;id&quot; =&gt; id,
                                 &quot;labels&quot; =&gt; labels,
                                 &quot;locked&quot; =&gt; locked,
                                 &quot;name&quot; =&gt; name,
                                 &quot;position&quot; =&gt; %{&quot;x&quot; =&gt; x, &quot;y&quot; =&gt; y},
                                 &quot;status&quot; =&gt; status,
                                 &quot;tag&quot; =&gt; tag,
                                 &quot;temporary_name&quot; =&gt; temporary_name
                               } = _system,
                               acc -&gt;
        acc
        |&gt; add_system(
          %{
            solar_system_id: id |&gt; String.to_integer(),
            coordinates: %{&quot;x&quot; =&gt; round(x), &quot;y&quot; =&gt; round(y)}
          },
          user_id,
          character_id
        )
        |&gt; update_system_name(%{solar_system_id: id |&gt; String.to_integer(), name: name})
        |&gt; update_system_description(%{
          solar_system_id: id |&gt; String.to_integer(),
          description: description
        })
        |&gt; update_system_status(%{solar_system_id: id |&gt; String.to_integer(), status: status})
        |&gt; update_system_tag(%{solar_system_id: id |&gt; String.to_integer(), tag: tag})
        |&gt; update_system_temporary_name(%{
          solar_system_id: id |&gt; String.to_integer(),
          temporary_name: temporary_name
        })
        |&gt; update_system_locked(%{solar_system_id: id |&gt; String.to_integer(), locked: locked})
        |&gt; update_system_labels(%{solar_system_id: id |&gt; String.to_integer(), labels: labels})
      end)

    removed_system_ids =
      systems
      |&gt; Enum.filter(fn system -&gt; not system[&quot;visible&quot;] end)
      |&gt; Enum.map(fn system -&gt; system[&quot;id&quot;] end)
      |&gt; Enum.map(&amp;String.to_integer/1)

    state
    |&gt; delete_systems(removed_system_ids, user_id, character_id)
  end

  def maybe_import_connections(state, %{&quot;connections&quot; =&gt; connections} = _settings, _user_id) do
    connections
    |&gt; Enum.reduce(state, fn %{
                               &quot;source&quot; =&gt; source,
                               &quot;target&quot; =&gt; target,
                               &quot;mass_status&quot; =&gt; mass_status,
                               &quot;time_status&quot; =&gt; time_status,
                               &quot;ship_size_type&quot; =&gt; ship_size_type
                             } = _system,
                             acc -&gt;
      source_id = source |&gt; String.to_integer()
      target_id = target |&gt; String.to_integer()

      acc
      |&gt; add_connection(%{
        solar_system_source_id: source_id,
        solar_system_target_id: target_id
      })
      |&gt; update_connection_time_status(%{
        solar_system_source_id: source_id,
        solar_system_target_id: target_id,
        time_status: time_status
      })
      |&gt; update_connection_mass_status(%{
        solar_system_source_id: source_id,
        solar_system_target_id: target_id,
        mass_status: mass_status
      })
      |&gt; update_connection_ship_size_type(%{
        solar_system_source_id: source_id,
        solar_system_target_id: target_id,
        ship_size_type: ship_size_type
      })
    end)
  end

  def maybe_import_hubs(state, %{&quot;hubs&quot; =&gt; hubs} = _settings, _user_id) do
    hubs
    |&gt; Enum.reduce(state, fn hub, acc -&gt;
      solar_system_id = hub |&gt; String.to_integer()

      acc
      |&gt; add_hub(%{solar_system_id: solar_system_id})
    end)
  end

  defp update_presence(map_id) do
    case WandererApp.Cache.lookup!(&quot;map_#{map_id}:started&quot;, false) and
           WandererApp.Cache.get_and_remove!(&quot;map_#{map_id}:presence_updated&quot;, false) do
      true -&gt;
        {:ok, presence_character_ids} =
          WandererApp.Cache.lookup(&quot;map_#{map_id}:presence_character_ids&quot;, [])

        characters_ids =
          map_id
          |&gt; WandererApp.Map.get_map!()
          |&gt; Map.get(:characters, [])

        not_present_character_ids =
          characters_ids
          |&gt; Enum.filter(fn character_id -&gt;
            not Enum.member?(presence_character_ids, character_id)
          end)

        CharactersImpl.track_characters(map_id, presence_character_ids)
        CharactersImpl.untrack_characters(map_id, not_present_character_ids)

        broadcast!(
          map_id,
          :present_characters_updated,
          presence_character_ids
          |&gt; WandererApp.Character.get_character_eve_ids!()
        )

        :ok

      _ -&gt;
        :ok
    end
  end
end</file><file path="lib/wanderer_app/map/server/map_server_signatures_impl.ex">defmodule WandererApp.Map.Server.SignaturesImpl do
  @moduledoc false

  require Logger

  alias WandererApp.Api.{MapSystem, MapSystemSignature}
  alias WandererApp.Character
  alias WandererApp.User.ActivityTracker
  alias WandererApp.Map.Server.{Impl, ConnectionsImpl, SystemsImpl}

  @doc &quot;&quot;&quot;
  Public entrypoint for updating signatures on a map system.
  &quot;&quot;&quot;
  def update_signatures(
        %{map_id: map_id} = state,
        %{
          solar_system_id: system_solar_id,
          character_id: char_id,
          user_id: user_id,
          delete_connection_with_sigs: delete_conn?,
          added_signatures: added_params,
          updated_signatures: updated_params,
          removed_signatures: removed_params
        }
      )
      when not is_nil(char_id) do
    with {:ok, system} &lt;-
           MapSystem.read_by_map_and_solar_system(%{
             map_id: map_id,
             solar_system_id: system_solar_id
           }),
         {:ok, %{eve_id: char_eve_id}} &lt;- Character.get_character(char_id) do
      do_update_signatures(
        state,
        system,
        char_eve_id,
        user_id,
        delete_conn?,
        added_params,
        updated_params,
        removed_params
      )
    else
      error -&gt;
        Logger.warning(&quot;Skipping signature update: #{inspect(error)}&quot;)
        state
    end
  end

  def update_signatures(state, _), do: state

  defp do_update_signatures(
         state,
         system,
         character_eve_id,
         user_id,
         delete_conn?,
         added_params,
         updated_params,
         removed_params
       ) do
    # parse incoming DTOs
    added_sigs = parse_signatures(added_params, character_eve_id, system.id)
    updated_sigs = parse_signatures(updated_params, character_eve_id, system.id)
    removed_sigs = parse_signatures(removed_params, character_eve_id, system.id)

    # fetch both current &amp; all (including deleted) signatures once
    existing_current = MapSystemSignature.by_system_id!(system.id)
    existing_all = MapSystemSignature.by_system_id_all!(system.id)

    removed_ids = Enum.map(removed_sigs, &amp; &amp;1.eve_id)
    updated_ids = Enum.map(updated_sigs, &amp; &amp;1.eve_id)
    added_ids = Enum.map(added_sigs, &amp; &amp;1.eve_id)

    # 1. Removals
    existing_current
    |&gt; Enum.filter(&amp;(&amp;1.eve_id in removed_ids))
    |&gt; Enum.each(&amp;remove_signature(&amp;1, state, system, delete_conn?))

    # 2. Updates
    existing_current
    |&gt; Enum.filter(&amp;(&amp;1.eve_id in updated_ids))
    |&gt; Enum.each(fn existing -&gt;
      update = Enum.find(updated_sigs, &amp;(&amp;1.eve_id == existing.eve_id))
      apply_update_signature(existing, update)
    end)

    # 3. Additions &amp; restorations
    added_eve_ids = Enum.map(added_sigs, &amp; &amp;1.eve_id)

    existing_index =
      MapSystemSignature.by_system_id_all!(system.id)
      |&gt; Enum.filter(&amp;(&amp;1.eve_id in added_eve_ids))
      |&gt; Map.new(&amp;{&amp;1.eve_id, &amp;1})

    added_sigs
    |&gt; Enum.each(fn sig -&gt;
      case existing_index[sig.eve_id] do
        nil -&gt;
          MapSystemSignature.create!(sig)

        %MapSystemSignature{deleted: true} = deleted_sig -&gt;
          MapSystemSignature.update!(
            deleted_sig,
            Map.take(sig, [
              :name,
              :description,
              :kind,
              :group,
              :type,
              :character_eve_id,
              :custom_info,
              :deleted,
              :update_forced_at
            ])
          )

        _ -&gt;
          :noop
      end
    end)

    # 4. Activity tracking
    if added_ids != [] do
      track_activity(
        :signatures_added,
        state.map_id,
        system.solar_system_id,
        user_id,
        character_eve_id,
        added_ids
      )
    end

    if removed_ids != [] do
      track_activity(
        :signatures_removed,
        state.map_id,
        system.solar_system_id,
        user_id,
        character_eve_id,
        removed_ids
      )
    end

    # 5. Broadcast to any live subscribers
    Impl.broadcast!(state.map_id, :signatures_updated, system.solar_system_id)

    state
  end

  defp remove_signature(sig, state, system, delete_conn?) do
    # optionally remove the linked connection
    if delete_conn? &amp;&amp; sig.linked_system_id do
      ConnectionsImpl.delete_connection(state, %{
        solar_system_source_id: system.solar_system_id,
        solar_system_target_id: sig.linked_system_id
      })
    end

    # clear any linked_sig_eve_id on the target system
    if sig.linked_system_id do
      SystemsImpl.update_system_linked_sig_eve_id(state, %{
        solar_system_id: sig.linked_system_id,
        linked_sig_eve_id: nil
      })
    end

    # mark as deleted
    MapSystemSignature.update!(sig, %{deleted: true})
  end

  defp apply_update_signature(%MapSystemSignature{} = existing, update_params)
       when not is_nil(update_params) do
    case MapSystemSignature.update(
           existing,
           update_params |&gt; Map.put(:update_forced_at, DateTime.utc_now())
         ) do
      {:ok, _updated} -&gt;
        :ok

      {:error, reason} -&gt;
        Logger.error(&quot;Failed to update signature #{existing.id}: #{inspect(reason)}&quot;)
    end
  end

  defp track_activity(event, map_id, solar_system_id, user_id, character_id, signatures) do
    ActivityTracker.track_map_event(event, %{
      map_id: map_id,
      solar_system_id: solar_system_id,
      user_id: user_id,
      character_id: character_id,
      signatures: signatures
    })
  end

  @doc false
  defp parse_signatures(signatures, character_eve_id, system_id) do
    Enum.map(signatures, fn sig -&gt;
      %{
        system_id: system_id,
        eve_id: sig[&quot;eve_id&quot;],
        name: sig[&quot;name&quot;],
        description: Map.get(sig, &quot;description&quot;),
        kind: sig[&quot;kind&quot;],
        group: sig[&quot;group&quot;],
        type: Map.get(sig, &quot;type&quot;),
        custom_info: Map.get(sig, &quot;custom_info&quot;),
        character_eve_id: character_eve_id,
        deleted: false
      }
    end)
  end
end</file><file path="lib/wanderer_app/map/server/map_server_supervisor.ex">defmodule WandererApp.Map.ServerSupervisor do
  @moduledoc false
  use Supervisor, restart: :transient

  alias WandererApp.Map.Server

  def start_link(args), do: Supervisor.start_link(__MODULE__, args)

  @impl true
  def init(args) do
    children = [
      {Server, args},
      {DDRT.DynamicRtree,
       [
         conf: [name: &quot;rtree_#{args[:map_id]}&quot;, width: 150, verbose: false, seed: 0],
         name: Module.concat([args[:map_id], DDRT.DynamicRtree])
       ]}
    ]

    Supervisor.init(children, strategy: :one_for_one, auto_shutdown: :any_significant)
  end
end</file><file path="lib/wanderer_app/map/server/map_server_systems_impl.ex">defmodule WandererApp.Map.Server.SystemsImpl do
  @moduledoc false

  require Logger

  alias WandererApp.Map.Server.Impl

  @ddrt Application.compile_env(:wanderer_app, :ddrt)
  @system_auto_expire_minutes 15
  @system_inactive_timeout :timer.minutes(15)

  def init_last_activity_cache(map_id, systems_last_activity) do
    systems_last_activity
    |&gt; Enum.each(fn {system_id, last_activity} -&gt;
      WandererApp.Cache.put(
        &quot;map_#{map_id}:system_#{system_id}:last_activity&quot;,
        last_activity,
        ttl: @system_inactive_timeout
      )
    end)
  end

  def init_map_systems(state, [] = _systems), do: state

  def init_map_systems(%{map_id: map_id, rtree_name: rtree_name} = state, systems) do
    systems
    |&gt; Enum.each(fn %{id: system_id, solar_system_id: solar_system_id} = system -&gt;
      @ddrt.insert(
        {solar_system_id, WandererApp.Map.PositionCalculator.get_system_bounding_rect(system)},
        rtree_name
      )

      WandererApp.Cache.put(
        &quot;map_#{map_id}:system_#{system_id}:last_activity&quot;,
        DateTime.utc_now(),
        ttl: @system_inactive_timeout
      )
    end)

    state
  end

  def add_system(
        %{map_id: map_id} = state,
        %{
          solar_system_id: solar_system_id
        } = system_info,
        user_id,
        character_id
      ) do
    case map_id |&gt; WandererApp.Map.check_location(%{solar_system_id: solar_system_id}) do
      {:ok, _location} -&gt;
        state |&gt; _add_system(system_info, user_id, character_id)

      {:error, :already_exists} -&gt;
        state
    end
  end

  def add_system_comment(
        %{map_id: map_id} = state,
        %{
          solar_system_id: solar_system_id,
          text: text
        } = comment_info,
        user_id,
        character_id
      ) do
    system =
      WandererApp.Map.find_system_by_location(map_id, %{
        solar_system_id: solar_system_id |&gt; String.to_integer()
      })

    {:ok, comment} =
      WandererApp.MapSystemCommentRepo.create(%{
        system_id: system.id,
        character_id: character_id,
        text: text
      })

    comment =
      comment
      |&gt; Ash.load!([:character, :system])

    Impl.broadcast!(map_id, :system_comment_added, %{
      solar_system_id: solar_system_id,
      comment: comment
    })

    state
  end

  def remove_system_comment(
        %{map_id: map_id} = state,
        comment_id,
        user_id,
        character_id
      ) do
    {:ok, %{system: system} = comment} =
      WandererApp.MapSystemCommentRepo.get_by_id(comment_id)

    :ok = WandererApp.MapSystemCommentRepo.destroy(comment)

    Impl.broadcast!(map_id, :system_comment_removed, %{
      solar_system_id: system.solar_system_id,
      comment_id: comment_id
    })

    state
  end

  def cleanup_systems(%{map_id: map_id} = state) do
    expired_systems =
      map_id
      |&gt; WandererApp.Map.list_systems!()
      |&gt; Enum.filter(fn %{
                          id: system_id,
                          visible: system_visible,
                          locked: system_locked,
                          solar_system_id: solar_system_id
                        } = _system -&gt;
        last_updated_time =
          WandererApp.Cache.get(&quot;map_#{map_id}:system_#{system_id}:last_activity&quot;)

        if system_visible and not system_locked and
             (is_nil(last_updated_time) or
                DateTime.diff(DateTime.utc_now(), last_updated_time, :minute) &gt;=
                  @system_auto_expire_minutes) do
          no_active_connections? =
            map_id
            |&gt; WandererApp.Map.find_connections(solar_system_id)
            |&gt; Enum.empty?()

          no_active_characters? =
            map_id |&gt; WandererApp.Map.get_system_characters(solar_system_id) |&gt; Enum.empty?()

          no_active_connections? and no_active_characters?
        else
          false
        end
      end)
      |&gt; Enum.map(&amp; &amp;1.solar_system_id)

    case expired_systems |&gt; Enum.empty?() do
      false -&gt;
        state |&gt; delete_systems(expired_systems, nil, nil)

      _ -&gt;
        state
    end
  end

  def update_system_name(
        state,
        update
      ),
      do: state |&gt; update_system(:update_name, [:name], update)

  def update_system_description(
        state,
        update
      ),
      do: state |&gt; update_system(:update_description, [:description], update)

  def update_system_status(
        state,
        update
      ),
      do: state |&gt; update_system(:update_status, [:status], update)

  def update_system_tag(
        state,
        update
      ),
      do: state |&gt; update_system(:update_tag, [:tag], update)

  def update_system_temporary_name(
        state,
        update
      ) do
    state |&gt; update_system(:update_temporary_name, [:temporary_name], update)
  end

  def update_system_locked(
        state,
        update
      ),
      do: state |&gt; update_system(:update_locked, [:locked], update)

  def update_system_labels(
        state,
        update
      ),
      do: state |&gt; update_system(:update_labels, [:labels], update)

  def update_system_linked_sig_eve_id(
        state,
        update
      ),
      do: state |&gt; update_system(:update_linked_sig_eve_id, [:linked_sig_eve_id], update)

  def update_system_position(
        %{rtree_name: rtree_name} = state,
        update
      ),
      do:
        state
        |&gt; update_system(
          :update_position,
          [:position_x, :position_y],
          update,
          fn updated_system -&gt;
            @ddrt.update(
              updated_system.solar_system_id,
              WandererApp.Map.PositionCalculator.get_system_bounding_rect(updated_system),
              rtree_name
            )
          end
        )

  def add_hub(
        %{map_id: map_id} = state,
        hub_info
      ) do
    with :ok &lt;- WandererApp.Map.add_hub(map_id, hub_info),
         {:ok, hubs} = map_id |&gt; WandererApp.Map.list_hubs(),
         {:ok, _} &lt;-
           WandererApp.MapRepo.update_hubs(map_id, hubs) do
      Impl.broadcast!(map_id, :update_map, %{hubs: hubs})
      state
    else
      error -&gt;
        Logger.error(&quot;Failed to add hub: #{inspect(error, pretty: true)}&quot;)
        state
    end
  end

  def remove_hub(
        %{map_id: map_id} = state,
        hub_info
      ) do
    with :ok &lt;- WandererApp.Map.remove_hub(map_id, hub_info),
         {:ok, hubs} = map_id |&gt; WandererApp.Map.list_hubs(),
         {:ok, _} &lt;-
           WandererApp.MapRepo.update_hubs(map_id, hubs) do
      Impl.broadcast!(map_id, :update_map, %{hubs: hubs})
      state
    else
      error -&gt;
        Logger.error(&quot;Failed to remove hub: #{inspect(error, pretty: true)}&quot;)
        state
    end
  end

  def delete_systems(
        %{map_id: map_id, rtree_name: rtree_name} = state,
        removed_ids,
        user_id,
        character_id
      ) do
    filtered_ids =
      removed_ids
      |&gt; Enum.map(fn solar_system_id -&gt;
        WandererApp.Map.find_system_by_location(map_id, %{solar_system_id: solar_system_id})
      end)
      |&gt; Enum.filter(fn system -&gt; not is_nil(system) &amp;&amp; not system.locked end)
      |&gt; Enum.map(&amp;{&amp;1.solar_system_id, &amp;1.id})

    filtered_ids
    |&gt; Enum.each(fn {solar_system_id, system_id} -&gt;
      map_id
      |&gt; WandererApp.MapSystemRepo.remove_from_map(solar_system_id)
      |&gt; case do
        {:ok, _} -&gt;
          :ok = WandererApp.Map.remove_system(map_id, solar_system_id)
          @ddrt.delete([solar_system_id], rtree_name)
          Impl.broadcast!(map_id, :systems_removed, [solar_system_id])
          track_systems_removed(map_id, user_id, character_id, [solar_system_id])
          remove_system_connections(map_id, [solar_system_id])

          try do
            cleanup_linked_signatures(map_id, [solar_system_id])
          rescue
            e -&gt;
              Logger.error(&quot;Failed to cleanup linked signature: #{inspect(e)}&quot;)
          end

          try do
            cleanup_linked_system_sig_eve_ids(state, [system_id])
          rescue
            e -&gt;
              Logger.error(&quot;Failed to cleanup system linked sig eve ids: #{inspect(e)}&quot;)
          end

          :ok

        {:error, error} -&gt;
          Logger.error(&quot;Failed to remove system from map: #{inspect(error, pretty: true)}&quot;)
          :ok
      end
    end)

    state
  end

  defp track_systems_removed(map_id, user_id, character_id, removed_solar_system_ids)
       when not is_nil(user_id) and not is_nil(character_id) do
    WandererApp.User.ActivityTracker.track_map_event(:systems_removed, %{
      character_id: character_id,
      user_id: user_id,
      map_id: map_id,
      solar_system_ids: removed_solar_system_ids
    })
    |&gt; case do
      {:ok, _} -&gt; :ok
      error -&gt; Logger.error(&quot;Failed to track systems removed: #{inspect(error)}&quot;)
    end
  end

  defp track_systems_removed(_map_id, _user_id, _character_id, _removed_solar_system_ids), do: :ok

  defp remove_system_connections(map_id, solar_system_ids_to_remove) do
    connections_to_remove =
      solar_system_ids_to_remove
      |&gt; Enum.map(fn solar_system_id -&gt;
        WandererApp.Map.find_connections(map_id, solar_system_id)
      end)
      |&gt; List.flatten()
      |&gt; Enum.uniq_by(&amp; &amp;1.id)

    connections_to_remove
    |&gt; Enum.each(fn connection -&gt;
      try do
        Logger.debug(fn -&gt; &quot;Removing connection from map: #{inspect(connection)}&quot; end)
        :ok = WandererApp.MapConnectionRepo.destroy(map_id, connection)
        :ok = WandererApp.Map.remove_connection(map_id, connection)
        Impl.broadcast!(map_id, :remove_connections, [connection])
      rescue
        e -&gt;
          Logger.error(&quot;Failed to remove connection: #{inspect(e)}&quot;)
      end
    end)
  end

  defp cleanup_linked_signatures(map_id, removed_solar_system_ids) do
    removed_solar_system_ids
    |&gt; Enum.map(fn solar_system_id -&gt;
      WandererApp.Api.MapSystemSignature.by_linked_system_id!(solar_system_id)
    end)
    |&gt; List.flatten()
    |&gt; Enum.uniq_by(&amp; &amp;1.system_id)
    |&gt; Enum.each(fn s -&gt;
      try do
        {:ok, %{system: system}} = s |&gt; Ash.load([:system])
        :ok = Ash.destroy!(s)
        Impl.broadcast!(map_id, :signatures_updated, system.solar_system_id)
      rescue
        e -&gt;
          Logger.error(&quot;Failed to cleanup linked signature: #{inspect(e)}&quot;)
      end
    end)
  end

  defp cleanup_linked_system_sig_eve_ids(state, system_ids_to_remove) do
    linked_system_ids =
      system_ids_to_remove
      |&gt; Enum.map(fn system_id -&gt;
        WandererApp.Api.MapSystemSignature.by_system_id!(system_id)
        |&gt; Enum.filter(fn s -&gt; not is_nil(s.linked_system_id) end)
        |&gt; Enum.map(fn s -&gt; s.linked_system_id end)
      end)
      |&gt; List.flatten()
      |&gt; Enum.uniq()

    linked_system_ids
    |&gt; Enum.each(fn linked_system_id -&gt;
      update_system_linked_sig_eve_id(state, %{
        solar_system_id: linked_system_id,
        linked_sig_eve_id: nil
      })
    end)
  end

  def maybe_add_system(map_id, location, old_location, rtree_name, map_opts)
      when not is_nil(location) do
    case WandererApp.Map.check_location(map_id, location) do
      {:ok, location} -&gt;
        {:ok, position} = calc_new_system_position(map_id, old_location, rtree_name, map_opts)

        case WandererApp.MapSystemRepo.get_by_map_and_solar_system_id(
               map_id,
               location.solar_system_id
             ) do
          {:ok, existing_system} when not is_nil(existing_system) -&gt;
            updated_system =
              existing_system
              |&gt; WandererApp.MapSystemRepo.update_position!(%{
                position_x: position.x,
                position_y: position.y
              })
              |&gt; WandererApp.MapSystemRepo.cleanup_labels!(map_opts)
              |&gt; WandererApp.MapSystemRepo.update_visible!(%{visible: true})
              |&gt; WandererApp.MapSystemRepo.cleanup_tags!()
              |&gt; WandererApp.MapSystemRepo.cleanup_temporary_name!()
              |&gt; WandererApp.MapSystemRepo.cleanup_linked_sig_eve_id!()

            @ddrt.insert(
              {existing_system.solar_system_id,
               WandererApp.Map.PositionCalculator.get_system_bounding_rect(%{
                 position_x: position.x,
                 position_y: position.y
               })},
              rtree_name
            )

            WandererApp.Cache.put(
              &quot;map_#{map_id}:system_#{updated_system.id}:last_activity&quot;,
              DateTime.utc_now(),
              ttl: @system_inactive_timeout
            )

            WandererApp.Map.add_system(map_id, updated_system)

            Impl.broadcast!(map_id, :add_system, updated_system)
            :ok

          _ -&gt;
            {:ok, solar_system_info} =
              WandererApp.CachedInfo.get_system_static_info(location.solar_system_id)

            WandererApp.MapSystemRepo.create(%{
              map_id: map_id,
              solar_system_id: location.solar_system_id,
              name: solar_system_info.solar_system_name,
              position_x: position.x,
              position_y: position.y
            })
            |&gt; case do
              {:ok, new_system} -&gt;
                @ddrt.insert(
                  {new_system.solar_system_id,
                   WandererApp.Map.PositionCalculator.get_system_bounding_rect(new_system)},
                  rtree_name
                )

                WandererApp.Cache.put(
                  &quot;map_#{map_id}:system_#{new_system.id}:last_activity&quot;,
                  DateTime.utc_now(),
                  ttl: @system_inactive_timeout
                )

                WandererApp.Map.add_system(map_id, new_system)
                Impl.broadcast!(map_id, :add_system, new_system)

                :ok

              error -&gt;
                Logger.warning(&quot;Failed to create system: #{inspect(error, pretty: true)}&quot;)
                :ok
            end
        end

      error -&gt;
        Logger.debug(fn -&gt; &quot;Skip adding system: #{inspect(error, pretty: true)}&quot; end)
        :ok
    end
  end

  def maybe_add_system(_map_id, _location, _old_location, _rtree_name, _map_opts), do: :ok

  defp _add_system(
         %{map_id: map_id, map_opts: map_opts, rtree_name: rtree_name} = state,
         %{
           solar_system_id: solar_system_id,
           coordinates: coordinates
         } = system_info,
         user_id,
         character_id
       ) do
    %{&quot;x&quot; =&gt; x, &quot;y&quot; =&gt; y} =
      coordinates
      |&gt; case do
        %{&quot;x&quot; =&gt; x, &quot;y&quot; =&gt; y} -&gt;
          %{&quot;x&quot; =&gt; x, &quot;y&quot; =&gt; y}

        _ -&gt;
          %{x: x, y: y} =
            WandererApp.Map.PositionCalculator.get_new_system_position(nil, rtree_name, map_opts)

          %{&quot;x&quot; =&gt; x, &quot;y&quot; =&gt; y}
      end

    {:ok, system} =
      case WandererApp.MapSystemRepo.get_by_map_and_solar_system_id(map_id, solar_system_id) do
        {:ok, existing_system} when not is_nil(existing_system) -&gt;
          use_old_coordinates = Map.get(system_info, :use_old_coordinates, false)

          if use_old_coordinates do
            @ddrt.insert(
              {solar_system_id,
               WandererApp.Map.PositionCalculator.get_system_bounding_rect(%{
                 position_x: existing_system.position_x,
                 position_y: existing_system.position_y
               })},
              rtree_name
            )

            existing_system
            |&gt; WandererApp.MapSystemRepo.update_visible(%{visible: true})
          else
            @ddrt.insert(
              {solar_system_id,
               WandererApp.Map.PositionCalculator.get_system_bounding_rect(%{
                 position_x: x,
                 position_y: y
               })},
              rtree_name
            )

            existing_system
            |&gt; WandererApp.MapSystemRepo.update_position!(%{position_x: x, position_y: y})
            |&gt; WandererApp.MapSystemRepo.cleanup_labels!(map_opts)
            |&gt; WandererApp.MapSystemRepo.cleanup_tags!()
            |&gt; WandererApp.MapSystemRepo.cleanup_temporary_name!()
            |&gt; WandererApp.MapSystemRepo.cleanup_linked_sig_eve_id!()
            |&gt; WandererApp.MapSystemRepo.update_visible(%{visible: true})
          end

        _ -&gt;
          {:ok, solar_system_info} =
            WandererApp.CachedInfo.get_system_static_info(solar_system_id)

          @ddrt.insert(
            {solar_system_id,
             WandererApp.Map.PositionCalculator.get_system_bounding_rect(%{
               position_x: x,
               position_y: y
             })},
            rtree_name
          )

          WandererApp.MapSystemRepo.create(%{
            map_id: map_id,
            solar_system_id: solar_system_id,
            name: solar_system_info.solar_system_name,
            position_x: x,
            position_y: y
          })
      end

    :ok = map_id |&gt; WandererApp.Map.add_system(system)

    WandererApp.Cache.put(
      &quot;map_#{map_id}:system_#{system.id}:last_activity&quot;,
      DateTime.utc_now(),
      ttl: @system_inactive_timeout
    )

    Impl.broadcast!(map_id, :add_system, system)

    {:ok, _} =
      WandererApp.User.ActivityTracker.track_map_event(:system_added, %{
        character_id: character_id,
        user_id: user_id,
        map_id: map_id,
        solar_system_id: solar_system_id
      })

    state
  end

  defp calc_new_system_position(map_id, old_location, rtree_name, opts),
    do:
      {:ok,
       map_id
       |&gt; WandererApp.Map.find_system_by_location(old_location)
       |&gt; WandererApp.Map.PositionCalculator.get_new_system_position(rtree_name, opts)}

  defp update_system(
         %{map_id: map_id} = state,
         update_method,
         attributes,
         update,
         callback_fn \\ nil
       ) do
    with :ok &lt;- WandererApp.Map.update_system_by_solar_system_id(map_id, update),
         {:ok, system} &lt;-
           WandererApp.MapSystemRepo.get_by_map_and_solar_system_id(
             map_id,
             update.solar_system_id
           ),
         {:ok, update_map} &lt;- Impl.get_update_map(update, attributes) do
      {:ok, updated_system} =
        apply(WandererApp.MapSystemRepo, update_method, [
          system,
          update_map
        ])

      if not is_nil(callback_fn) do
        callback_fn.(updated_system)
      end

      update_map_system_last_activity(map_id, updated_system)

      state
    else
      error -&gt;
        Logger.error(&quot;Failed to update system: #{inspect(error, pretty: true)}&quot;)
        state
    end
  end

  defp update_map_system_last_activity(
         map_id,
         updated_system
       ) do
    WandererApp.Cache.put(
      &quot;map_#{map_id}:system_#{updated_system.id}:last_activity&quot;,
      DateTime.utc_now(),
      ttl: @system_inactive_timeout
    )

    Impl.broadcast!(map_id, :update_system, updated_system)
  end
end</file><file path="lib/wanderer_app/map/map_audit.ex">defmodule WandererApp.Map.Audit do
  @moduledoc &quot;&quot;&quot;
  Manager map subscription plans
  &quot;&quot;&quot;

  require Ash.Query
  require Logger

  @logger Application.compile_env(:wanderer_app, :logger)

  @week_seconds :timer.hours(24 * 7)
  @month_seconds @week_seconds * 4
  @audit_expired_seconds @month_seconds * 3

  def track_map_subscription_event(event_type, metadata) do
    case event_type do
      &quot;subscription.created&quot; -&gt;
        track_map_event(event_type, metadata)

      &quot;subscription.updated&quot; -&gt;
        track_map_event(event_type, metadata)

      &quot;subscription.deleted&quot; -&gt;
        track_map_event(event_type, metadata)

      _ -&gt;
        {:ok, nil}
    end
  end

  def archive() do
    Logger.info(&quot;Start map audit arhiving...&quot;)

    WandererApp.Api.UserActivity
    |&gt; Ash.Query.filter(inserted_at: [less_than: get_expired_at()])
    |&gt; Ash.bulk_destroy!(:archive, %{}, batch_size: 100)

    Logger.info(fn -&gt; &quot;Audit arhived&quot; end)
    :ok
  end

  def get_activity_query(map_id, period, activity) do
    {from, to} = period |&gt; get_period()

    query =
      WandererApp.Api.UserActivity
      |&gt; Ash.Query.filter(
        and: [
          [entity_id: map_id],
          [inserted_at: [greater_than_or_equal: from]],
          [inserted_at: [less_than_or_equal: to]]
        ]
      )

    query =
      activity
      |&gt; case do
        &quot;all&quot; -&gt;
          query

        activity -&gt;
          query
          |&gt; Ash.Query.filter(event_type: activity)
      end

    query
    |&gt; Ash.Query.sort(inserted_at: :desc)
  end

  def track_acl_event(
        event_type,
        %{user_id: user_id, acl_id: acl_id} = metadata
      ) when not is_nil(user_id) and not is_nil(acl_id),
      do:
        WandererApp.Api.UserActivity.new(%{
          user_id: user_id,
          entity_type: :access_list,
          entity_id: acl_id,
          event_type: event_type,
          event_data: metadata |&gt; Map.drop([:user_id, :acl_id]) |&gt; Jason.encode!()
        })

  def track_acl_event(_event_type, _metadata), do: {:ok, nil}

  def track_map_event(
        event_type,
        %{character_id: character_id, user_id: user_id, map_id: map_id} = metadata
      ) when not is_nil(character_id) and not is_nil(user_id) and not is_nil(map_id),
      do:
        WandererApp.Api.UserActivity.new(%{
          character_id: character_id,
          user_id: user_id,
          entity_type: :map,
          entity_id: map_id,
          event_type: event_type,
          event_data: metadata |&gt; Map.drop([:character_id, :user_id, :map_id]) |&gt; Jason.encode!()
        })

  def track_map_event(_event_type, _metadata), do: {:ok, nil}

  defp get_period(&quot;1H&quot;) do
    now = DateTime.utc_now()
    start_date = now |&gt; DateTime.add(-1 * 3600, :second)
    {start_date, now}
  end

  defp get_period(&quot;1D&quot;) do
    now = DateTime.utc_now()
    start_date = now |&gt; DateTime.add(-24 * 3600, :second)
    {start_date, now}
  end

  defp get_period(&quot;1W&quot;) do
    now = DateTime.utc_now()
    start_date = now |&gt; DateTime.add(-24 * 3600 * 7, :second)
    {start_date, now}
  end

  defp get_period(&quot;1M&quot;) do
    now = DateTime.utc_now()
    start_date = now |&gt; DateTime.add(-24 * 3600 * 31, :second)
    {start_date, now}
  end

  defp get_period(&quot;2M&quot;) do
    now = DateTime.utc_now()
    start_date = now |&gt; DateTime.add(-24 * 3600 * 31 * 2, :second)
    {start_date, now}
  end

  defp get_period(&quot;3M&quot;) do
    now = DateTime.utc_now()
    start_date = now |&gt; DateTime.add(-24 * 3600 * 31 * 3, :second)
    {start_date, now}
  end

  defp get_period(_), do: get_period(&quot;1H&quot;)

  defp get_expired_at(), do: DateTime.utc_now() |&gt; DateTime.add(-@audit_expired_seconds, :second)
end</file><file path="lib/wanderer_app/map/map_dynamic_supervisor.ex">defmodule WandererApp.Map.DynamicSupervisor do
  @moduledoc &quot;&quot;&quot;
  Dynamically starts a map server
  &quot;&quot;&quot;

  use DynamicSupervisor

  require Logger

  alias WandererApp.Map.Server

  def start_link(_arg) do
    DynamicSupervisor.start_link(__MODULE__, nil, name: __MODULE__)
  end

  def init(nil) do
    DynamicSupervisor.init(strategy: :one_for_one)
  end

  def _start_child(map_id) do
    child_spec = %{
      id: Server,
      start: {Server, :start_link, [map_id]},
      restart: :transient
    }

    case DynamicSupervisor.start_child(__MODULE__, child_spec) do
      {:ok, _} -&gt;
        :ok

      {:error, {:already_started, _}} -&gt;
        :ok

      {:error, reason} -&gt;
        {:error, reason}
    end
  end

  def which_children do
    Supervisor.which_children(__MODULE__)
  end
end</file><file path="lib/wanderer_app/map/map_manager.ex">defmodule WandererApp.Map.Manager do
  @moduledoc &quot;&quot;&quot;
  Manager maps with no active characters and bulk start
  &quot;&quot;&quot;

  use GenServer

  require Logger

  alias WandererApp.Map.Server
  alias WandererApp.Map.ServerSupervisor
  alias WandererApp.Api.MapSystemSignature

  @maps_start_per_second 5
  @maps_start_interval 1000
  @maps_queue :maps_queue
  @garbage_collection_interval :timer.hours(1)
  @check_maps_queue_interval :timer.seconds(1)
  @signatures_cleanup_interval :timer.minutes(30)
  @delete_after_minutes 30

  def start_map(map_id) when is_binary(map_id),
    do: WandererApp.Queue.push_uniq(@maps_queue, map_id)

  def stop_map(map_id) when is_binary(map_id) do
    case Server.map_pid(map_id) do
      pid when is_pid(pid) -&gt;
        GenServer.cast(
          pid,
          :stop
        )

      nil -&gt;
        :ok
    end
  end

  def start_link(_), do: GenServer.start(__MODULE__, [], name: __MODULE__)

  @impl true
  def init([]) do
    WandererApp.Queue.new(@maps_queue, [])

    {:ok, check_maps_queue_timer} =
      :timer.send_interval(@check_maps_queue_interval, :check_maps_queue)

    {:ok, garbage_collector_timer} =
      :timer.send_interval(@garbage_collection_interval, :garbage_collect)

    {:ok, signatures_cleanup_timer} =
      :timer.send_interval(@signatures_cleanup_interval, :cleanup_signatures)

    try do
      Task.async(fn -&gt;
        start_last_active_maps()
      end)
    rescue
      e -&gt;
        Logger.error(Exception.message(e))
    end

    {:ok,
     %{
       garbage_collector_timer: garbage_collector_timer,
       check_maps_queue_timer: check_maps_queue_timer,
       signatures_cleanup_timer: signatures_cleanup_timer
     }}
  end

  def handle_info({ref, _result}, state) do
    Process.demonitor(ref, [:flush])

    {:noreply, state}
  end

  @impl true
  def handle_info(:check_maps_queue, state) do
    try do
      case not WandererApp.Queue.empty?(@maps_queue) do
        true -&gt;
          Task.async(fn -&gt;
            start_maps()
          end)

        _ -&gt;
          :ok
      end

      {:noreply, state}
    rescue
      e -&gt;
        Logger.error(Exception.message(e))

        {:noreply, state}
    end
  end

  @impl true
  def handle_info(:garbage_collect, state) do
    try do
      WandererApp.Map.RegistryHelper.list_all_maps()
      |&gt; Enum.each(fn %{id: map_id, pid: server_pid} -&gt;
        case Process.alive?(server_pid) do
          true -&gt;
            presence_character_ids =
              WandererApp.Cache.lookup!(&quot;map_#{map_id}:presence_character_ids&quot;, [])

            if presence_character_ids |&gt; Enum.empty?() do
              Logger.info(&quot;No more characters present on: #{map_id}, shutting down map server...&quot;)
              stop_map(map_id)
            end

          false -&gt;
            Logger.warning(&quot;Server not alive: #{inspect(server_pid)}&quot;)
            :ok
        end
      end)

      {:noreply, state}
    rescue
      e -&gt;
        Logger.error(Exception.message(e))

        {:noreply, state}
    end
  end

  @impl true
  def handle_info(:cleanup_signatures, state) do
    try do
      cleanup_deleted_signatures()
      {:noreply, state}
    rescue
      e -&gt;
        Logger.error(&quot;Failed to cleanup signatures: #{inspect(e)}&quot;)
        {:noreply, state}
    end
  end

  def cleanup_deleted_signatures() do
    delete_after_date = DateTime.utc_now() |&gt; DateTime.add(-1 * @delete_after_minutes, :minute)

    case MapSystemSignature.by_deleted_and_updated_before!(true, delete_after_date) do
      {:ok, deleted_signatures} -&gt;

        Enum.each(deleted_signatures, fn sig -&gt;
          Ash.destroy!(sig)
        end)

        :ok

      {:error, error} -&gt;
        Logger.error(&quot;Failed to fetch deleted signatures: #{inspect(error)}&quot;)
        {:error, error}
    end
  end

  defp start_last_active_maps() do
    {:ok, last_map_states} =
      WandererApp.Api.MapState.get_last_active(
        DateTime.utc_now()
        |&gt; DateTime.add(-30, :minute)
      )

    last_map_states
    |&gt; Enum.map(fn %{map_id: map_id} -&gt; map_id end)
    |&gt; Enum.each(fn map_id -&gt; start_map(map_id) end)

    :ok
  end

  defp start_maps() do
    chunks =
      @maps_queue
      |&gt; WandererApp.Queue.to_list!()
      |&gt; Enum.uniq()
      |&gt; Enum.chunk_every(@maps_start_per_second)

    WandererApp.Queue.clear(@maps_queue)

    tasks =
      for chunk &lt;- chunks do
        task =
          Task.async(fn -&gt;
            chunk
            |&gt; Enum.map(&amp;start_map_server/1)
          end)

        :timer.sleep(@maps_start_interval)

        task
      end

    Logger.debug(fn -&gt; &quot;Waiting for maps to start&quot; end)
    Task.await_many(tasks)
    Logger.debug(fn -&gt; &quot;All maps started&quot; end)
  end

  defp start_map_server(map_id) do
    case DynamicSupervisor.start_child(
           {:via, PartitionSupervisor, {WandererApp.Map.DynamicSupervisors, self()}},
           {ServerSupervisor, map_id: map_id}
         ) do
      {:ok, pid} -&gt;
        {:ok, pid}

      {:error, {:already_started, pid}} -&gt;
        {:ok, pid}

      {:error, {:shutdown, {:failed_to_start_child, Server, {:already_started, pid}}}} -&gt;
        {:ok, pid}

      {:error, reason} -&gt;
        {:error, reason}
    end
  end
end</file><file path="lib/wanderer_app/map/map_operations.ex"># File: lib/wanderer_app/map/operations.ex
defmodule WandererApp.Map.Operations do
  @moduledoc &quot;&quot;&quot;
  Central entrypoint for map operations. Delegates responsibilities to specialized submodules:
    - Owner: Fetching and caching owner character info
    - Systems: CRUD and batch upsert for systems
    - Connections: CRUD and batch upsert for connections
    - Structures: CRUD for structures
    - Signatures: CRUD for signatures
  &quot;&quot;&quot;

  alias WandererApp.Map.Operations.{
    Owner,
    Systems,
    Connections,
    Structures,
    Signatures
  }

  # -- Owner Info -------------------------------------------------------------

  @doc &quot;Fetch cached main character info for a map owner&quot;
  @spec get_owner_character_id(String.t()) ::
          {:ok, %{id: term(), user_id: term()}} | {:error, String.t()}
  defdelegate get_owner_character_id(map_id), to: Owner

  # -- Systems ----------------------------------------------------------------

  @doc &quot;List visible systems&quot;
  @spec list_systems(String.t()) :: [map()]
  defdelegate list_systems(map_id), to: Systems

  @doc &quot;Get a specific system&quot;
  @spec get_system(String.t(), integer()) :: {:ok, map()} | {:error, :not_found}
  defdelegate get_system(map_id, system_id), to: Systems

  @doc &quot;Create a system&quot;
  @spec create_system(String.t(), map()) :: {:ok, map()} | {:error, String.t()}
  defdelegate create_system(map_id, params), to: Systems

  @doc &quot;Update a system&quot;
  @spec update_system(String.t(), integer(), map()) ::
          {:ok, map()} | {:error, String.t()}
  defdelegate update_system(map_id, system_id, attrs), to: Systems

  @doc &quot;Delete a system&quot;
  @spec delete_system(String.t(), integer()) :: {:ok, integer()} | {:error, term()}
  defdelegate delete_system(map_id, system_id), to: Systems

  @doc &quot;Upsert systems and connections in batch&quot;
  @spec upsert_systems_and_connections(String.t(), [map()], [map()]) ::
          {:ok, map()} | {:error, String.t()}
  defdelegate upsert_systems_and_connections(map_id, systems, connections), to: Systems

  # -- Connections -----------------------------------------------------------

  @doc &quot;List all connections&quot;
  @spec list_connections(String.t()) :: [map()]
  defdelegate list_connections(map_id), to: Connections

  @doc &quot;List connections for a specific system&quot;
  @spec list_connections(String.t(), integer()) :: [map()]
  defdelegate list_connections(map_id, system_id), to: Connections

  @doc &quot;Get a connection&quot;
  @spec get_connection(String.t(), String.t()) :: {:ok, map()} | {:error, String.t()}
  defdelegate get_connection(map_id, connection_id), to: Connections

  @doc &quot;Create a connection&quot;
  @spec create_connection(String.t(), map()) ::
          {:ok, map()} | {:skip, :exists} | {:error, String.t()}
  defdelegate create_connection(map_id, attrs), to: Connections

  @doc &quot;Force-create a connection with explicit character ID&quot;
  @spec create_connection(String.t(), map(), integer()) ::
          {:ok, map()} | {:skip, :exists} | {:error, String.t()}
  defdelegate create_connection(map_id, attrs, char_id), to: Connections

  @doc &quot;Update a connection&quot;
  @spec update_connection(String.t(), String.t(), map()) ::
          {:ok, map()} | {:error, String.t()}
  defdelegate update_connection(map_id, connection_id, attrs), to: Connections

  @doc &quot;Delete a connection&quot;
  @spec delete_connection(String.t(), integer(), integer()) :: :ok | {:error, term()}
  defdelegate delete_connection(map_id, src_id, tgt_id), to: Connections

  @doc &quot;Get a connection by source and target system IDs&quot;
  @spec get_connection_by_systems(String.t(), integer(), integer()) :: {:ok, map()} | {:error, String.t()}
  defdelegate get_connection_by_systems(map_id, source, target), to: Connections

  # -- Structures ------------------------------------------------------------

  @doc &quot;List all structures&quot;
  @spec list_structures(String.t()) :: [map()]
  defdelegate list_structures(map_id), to: Structures

  @doc &quot;Create a structure&quot;
  @spec create_structure(String.t(), map()) :: {:ok, map()} | {:error, String.t()}
  defdelegate create_structure(map_id, params), to: Structures

  @doc &quot;Update a structure&quot;
  @spec update_structure(String.t(), String.t(), map()) :: {:ok, map()} | {:error, String.t()}
  defdelegate update_structure(map_id, struct_id, params), to: Structures

  @doc &quot;Delete a structure&quot;
  @spec delete_structure(String.t(), String.t()) :: :ok | {:error, String.t()}
  defdelegate delete_structure(map_id, struct_id), to: Structures

  # -- Signatures ------------------------------------------------------------

  @doc &quot;List all signatures&quot;
  @spec list_signatures(String.t()) :: [map()]
  defdelegate list_signatures(map_id), to: Signatures

  @doc &quot;Create a signature&quot;
  @spec create_signature(String.t(), map()) :: {:ok, map()} | {:error, String.t()}
  defdelegate create_signature(map_id, params), to: Signatures

  @doc &quot;Update a signature&quot;
  @spec update_signature(String.t(), String.t(), map()) ::
          {:ok, map()} | {:error, String.t()}
  defdelegate update_signature(map_id, sig_id, params), to: Signatures

  @doc &quot;Delete a signature in a map&quot;
  @spec delete_signature(String.t(), String.t()) :: :ok | {:error, String.t()}
  defdelegate delete_signature(map_id, sig_id), to: Signatures
end</file><file path="lib/wanderer_app/map/map_position_calculator.ex">defmodule WandererApp.Map.PositionCalculator do
  @moduledoc false
  require Logger

  # Node height
  @h 34
  # Node weight
  @w 130
  # Nodes margin
  @m_x 50
  @m_y 41

  @start_x 0
  @start_y 0

  def get_system_bounding_rect(%{position_x: x, position_y: y} = _system) do
    [{x, x + @w}, {y, y + @h}]
  end

  def get_system_bounding_rect(_system), do: [{0, 0}, {0, 0}]

  def get_new_system_position(nil, rtree_name, opts) do
    {:ok, {x, y}} = rtree_name |&gt; check_system_available_positions(@start_x, @start_y, 1, opts)
    %{x: x, y: y}
  end

  def get_new_system_position(
        %{position_x: start_x, position_y: start_y} = _old_system,
        rtree_name,
        opts
      ) do
    {:ok, {x, y}} = rtree_name |&gt; check_system_available_positions(start_x, start_y, 1, opts)

    %{x: x, y: y}
  end

  defp check_system_available_positions(_rtree_name, _start_x, _start_y, 100, _opts),
    do: {:ok, {@start_x, @start_y}}

  defp check_system_available_positions(rtree_name, start_x, start_y, level, opts) do
    possible_positions = get_available_positions(level, start_x, start_y, opts)

    case get_available_position(possible_positions, rtree_name) do
      {:ok, nil} -&gt;
        rtree_name |&gt; check_system_available_positions(start_x, start_y, level + 1, opts)

      {:ok, position} -&gt;
        {:ok, position}
    end
  end

  defp get_available_position([], _rtree_name), do: {:ok, nil}

  defp get_available_position([position | rest], rtree_name) do
    if is_available_position(position, rtree_name) do
      {:ok, position}
    else
      get_available_position(rest, rtree_name)
    end
  end

  defp is_available_position({x, y} = _position, rtree_name) do
    case DDRT.query(get_system_bounding_rect(%{position_x: x, position_y: y}), rtree_name) do
      {:ok, []} -&gt;
        true

      {:ok, _} -&gt;
        false

      _ -&gt;
        true
    end
  end

  def get_available_positions(level, x, y, opts),
    do: adjusted_coordinates(1 + level * 2, x, y, opts)

  defp edge_coordinates(n, _opts) when n &gt; 1 do
    min = -div(n, 2)
    max = div(n, 2)
    # Top edge
    top_edge = for x &lt;- min..max, do: {x, min}
    # Right edge
    right_edge = for y &lt;- min..max, do: {max, y}
    # Bottom edge
    bottom_edge = for x &lt;- max..min, do: {x, max}
    # Left edge
    left_edge = for y &lt;- max..min, do: {min, y}

    # Combine all edges in clockwise order
    (right_edge ++ bottom_edge ++ left_edge ++ top_edge)
    |&gt; Enum.uniq()
  end

  defp sorted_edge_coordinates(n, opts) when n &gt; 1 do
    coordinates = edge_coordinates(n, opts)
    start_index = get_start_index(n, opts[:layout])

    Enum.slice(coordinates, start_index, length(coordinates) - start_index) ++
      Enum.slice(coordinates, 0, start_index)
  end

  defp get_start_index(n, &quot;left_to_right&quot;), do: div(n, 2)

  defp get_start_index(n, &quot;top_to_bottom&quot;), do: div(n, 2) + n - 1

  defp adjusted_coordinates(n, start_x, start_y, opts) when n &gt; 1 do
    sorted_coords = sorted_edge_coordinates(n, opts)

    Enum.map(sorted_coords, fn {x, y} -&gt;
      {
        start_x + x * (@w + @m_x),
        start_y + y * (@h + @m_y)
      }
    end)
  end
end</file><file path="lib/wanderer_app/map/map_registry_helper.ex">defmodule WandererApp.Map.RegistryHelper do
  @moduledoc false

  alias WandererApp.MapRegistry

  def list_all_maps(),
    do: Registry.select(MapRegistry, [{{:&quot;$1&quot;, :&quot;$2&quot;, :_}, [], [%{id: :&quot;$1&quot;, pid: :&quot;$2&quot;}]}])

  def list_all_maps_by_map_id(map_id) do
    match_all = {:&quot;$1&quot;, :&quot;$2&quot;, :&quot;$3&quot;}
    guards = [{:==, :&quot;$1&quot;, map_id}]
    map_result = [%{id: :&quot;$1&quot;, pid: :&quot;$2&quot;}]
    Registry.select(MapRegistry, [{match_all, guards, map_result}])
  end
end</file><file path="lib/wanderer_app/map/map_rtree_dynamic_supervisor.ex">defmodule WandererApp.Map.RtreeDynamicSupervisor do
  @moduledoc &quot;&quot;&quot;
  Dynamically starts a map server
  &quot;&quot;&quot;

  use DynamicSupervisor

  def start_link(_arg) do
    DynamicSupervisor.start_link(__MODULE__, nil, name: __MODULE__)
  end

  def init(nil) do
    DynamicSupervisor.init(strategy: :one_for_one)
  end

  def start(map_id) do
    case DynamicSupervisor.start_child(
           __MODULE__,
           {DDRT.DynamicRtree,
            [
              conf: [name: &quot;rtree_#{map_id}&quot;, width: 150, verbose: false, seed: 0],
              name: Module.concat([map_id, DDRT.DynamicRtree])
            ]}
         ) do
      {:ok, pid} -&gt; {:ok, pid}
      {:error, {:already_started, pid}} -&gt; {:ok, pid}
      {:error, reason} -&gt; {:error, reason}
    end
  end

  def stop(map_id) do
    case Process.whereis(Module.concat([map_id, DDRT.DynamicRtree])) do
      nil -&gt; :ok
      pid when is_pid(pid) -&gt; DynamicSupervisor.terminate_child(__MODULE__, pid)
    end
  end

  def which_children do
    Supervisor.which_children(__MODULE__)
  end
end</file><file path="lib/wanderer_app/map/map_server.ex">defmodule WandererApp.Map.Server do
  @moduledoc &quot;&quot;&quot;
  Holds state for a map and exposes an interface to managing the map instance
  &quot;&quot;&quot;
  use GenServer, restart: :transient, significant: true

  require Logger

  alias WandererApp.Map.Server.Impl

  @logger Application.compile_env(:wanderer_app, :logger)

  @spec start_link(keyword()) :: GenServer.on_start()
  def start_link(args) when is_list(args) do
    GenServer.start_link(__MODULE__, args, name: _via(args[:map_id]))
  end

  @impl true
  def init(args), do: {:ok, Impl.init(args), {:continue, :load_state}}

  def map_pid(map_id),
    do:
      map_id
      |&gt; _via()
      |&gt; GenServer.whereis()

  def map_pid!(map_id) do
    map_id
    |&gt; map_pid()
    |&gt; case do
      map_id when is_pid(map_id) -&gt;
        map_id

      nil -&gt;
        WandererApp.Cache.insert(&quot;map_#{map_id}:started&quot;, false)
        throw(&quot;Map server not started&quot;)
    end
  end

  def get_map(pid) when is_pid(pid),
    do:
      pid
      |&gt; GenServer.call({&amp;Impl.get_map/1, []}, :timer.minutes(5))

  def get_map(map_id) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; get_map()

  def get_export_settings(%{id: map_id, hubs: hubs} = _map) do
    with {:ok, all_systems} &lt;- WandererApp.MapSystemRepo.get_all_by_map(map_id),
         {:ok, connections} &lt;- WandererApp.MapConnectionRepo.get_by_map(map_id) do
      {:ok,
       %{
         systems: all_systems,
         hubs: hubs,
         connections: connections
       }}
    else
      error -&gt;
        @logger.error(&quot;Failed to get export settings: #{inspect(error, pretty: true)}&quot;)

        {:ok,
         %{
           systems: [],
           hubs: [],
           connections: []
         }}
    end
  end

  def get_characters(map_id) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.call({&amp;Impl.get_characters/1, []}, :timer.minutes(1))

  def add_character(map_id, character, track_character \\ false) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.add_character/3, [character, track_character]})

  def remove_character(map_id, character_id) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.remove_character/2, [character_id]})

  def untrack_characters(map_id, character_ids) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.untrack_characters/2, [character_ids]})

  def add_system(map_id, system_info, user_id, character_id) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.add_system/4, [system_info, user_id, character_id]})

  def add_system_comment(map_id, comment_info, user_id, character_id) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.add_system_comment/4, [comment_info, user_id, character_id]})

  def remove_system_comment(map_id, comment_id, user_id, character_id) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.remove_system_comment/4, [comment_id, user_id, character_id]})

  def update_system_position(map_id, update) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_system_position/2, [update]})

  def update_system_linked_sig_eve_id(map_id, update) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_system_linked_sig_eve_id/2, [update]})

  def update_system_name(map_id, update) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_system_name/2, [update]})

  def update_system_description(map_id, update) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_system_description/2, [update]})

  def update_system_status(map_id, update) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_system_status/2, [update]})

  def update_system_tag(map_id, update) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_system_tag/2, [update]})

  def update_system_temporary_name(map_id, update) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_system_temporary_name/2, [update]})

  def update_system_locked(map_id, update) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_system_locked/2, [update]})

  def update_system_labels(map_id, update) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_system_labels/2, [update]})

  def add_hub(map_id, hub_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.add_hub/2, [hub_info]})

  def remove_hub(map_id, hub_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.remove_hub/2, [hub_info]})

  def delete_systems(map_id, solar_system_ids, user_id, character_id) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.delete_systems/4, [solar_system_ids, user_id, character_id]})

  def add_connection(map_id, connection_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.add_connection/2, [connection_info]})

  def import_settings(map_id, settings, user_id) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.call({&amp;Impl.import_settings/3, [settings, user_id]}, :timer.minutes(30))

  def update_subscription_settings(map_id, settings) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.call({&amp;Impl.update_subscription_settings/2, [settings]})

  def delete_connection(map_id, connection_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.delete_connection/2, [connection_info]})

  def get_connection_info(map_id, connection_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.call({&amp;Impl.get_connection_info/2, [connection_info]}, :timer.minutes(1))

  def update_connection_time_status(map_id, connection_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_connection_time_status/2, [connection_info]})

  def update_connection_type(map_id, connection_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_connection_type/2, [connection_info]})

  def update_connection_mass_status(map_id, connection_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_connection_mass_status/2, [connection_info]})

  def update_connection_ship_size_type(map_id, connection_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_connection_ship_size_type/2, [connection_info]})

  def update_connection_locked(map_id, connection_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_connection_locked/2, [connection_info]})

  def update_connection_custom_info(map_id, connection_info) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_connection_custom_info/2, [connection_info]})

  def update_signatures(map_id, signatures_update) when is_binary(map_id),
    do:
      map_id
      |&gt; map_pid!
      |&gt; GenServer.cast({&amp;Impl.update_signatures/2, [signatures_update]})

  @impl true
  def handle_continue(:load_state, state),
    do: {:noreply, state |&gt; Impl.load_state(), {:continue, :start_map}}

  @impl true
  def handle_continue(:start_map, state), do: {:noreply, state |&gt; Impl.start_map()}

  @impl true
  def handle_call(
        {impl_function, args},
        _from,
        state
      )
      when is_function(impl_function),
      do: WandererApp.GenImpl.apply_call(impl_function, state, args)

  @impl true
  def handle_cast(:stop, state), do: {:stop, :normal, state |&gt; Impl.stop_map()}

  @impl true
  def handle_cast({impl_function, args}, state)
      when is_function(impl_function) do
    case WandererApp.GenImpl.apply_call(impl_function, state, args) do
      {:reply, _return, updated_state} -&gt;
        {:noreply, updated_state}

      _ -&gt;
        {:noreply, state}
    end
  end

  @impl true
  def handle_info(event, state), do: {:noreply, Impl.handle_event(event, state)}

  defp _via(map_id), do: {:via, Registry, {WandererApp.MapRegistry, map_id}}
end</file><file path="lib/wanderer_app/map/map_subscription_manager.ex">defmodule WandererApp.Map.SubscriptionManager do
  @moduledoc &quot;&quot;&quot;
  Manager map subscription plans
  &quot;&quot;&quot;

  require Logger

  @logger Application.compile_env(:wanderer_app, :logger)
  @pubsub_client Application.compile_env(:wanderer_app, :pubsub_client)

  def get_default_subscription_plan() do
    %{plans: plans} = WandererApp.Env.subscription_settings()

    %{
      characters_limit: plan_characters_limit,
      hubs_limit: plan_hubs_limit
    } = plans |&gt; Enum.find(fn p -&gt; p.id == &quot;alpha&quot; end)

    %{
      id: &quot;alpha&quot;,
      status: :active,
      plan: :alpha,
      characters_limit: plan_characters_limit,
      hubs_limit: plan_hubs_limit,
      auto_renew?: false,
      active_till: nil
    }
  end

  def get_map_subscriptions(map_id) do
    case WandererApp.MapSubscriptionRepo.get_all_by_map(map_id) do
      {:ok, subscriptions} when subscriptions != [] -&gt;
        case subscriptions |&gt; Enum.any?(fn s -&gt; s.status == :active end) do
          true -&gt;
            {:ok, subscriptions}

          _ -&gt;
            {:ok, [get_default_subscription_plan() | subscriptions] |&gt; List.flatten()}
        end

      _ -&gt;
        {:ok, [get_default_subscription_plan()]}
    end
  end

  def get_active_map_subscription(map_id) do
    case WandererApp.MapSubscriptionRepo.get_active_by_map(map_id) do
      {:ok, [subscription]} when not is_nil(subscription) -&gt;
        {:ok, subscription}

      _ -&gt;
        {:ok, get_default_subscription_plan()}
    end
  end

  def process() do
    Logger.info(&quot;Start map subscriptions processing...&quot;)

    {:ok, active_map_subscriptions} =
      WandererApp.MapSubscriptionRepo.get_all_active()

    tasks =
      for map_subscription &lt;- active_map_subscriptions do
        Task.async(fn -&gt;
          map_subscription |&gt; process_subscription()
        end)
      end

    Task.await_many(tasks)
    @logger.info(fn -&gt; &quot;All subscriptions processed&quot; end)

    :ok
  end

  def estimate_price(
        %{
          &quot;period&quot; =&gt; period,
          &quot;characters_limit&quot; =&gt; characters_limit,
          &quot;hubs_limit&quot; =&gt; hubs_limit
        },
        renew?
      )
      when is_binary(characters_limit),
      do:
        estimate_price(
          %{
            period: period |&gt; String.to_integer(),
            characters_limit: characters_limit |&gt; String.to_integer(),
            hubs_limit: hubs_limit |&gt; String.to_integer()
          },
          renew?
        )

  def estimate_price(
        %{characters_limit: characters_limit, hubs_limit: hubs_limit} = params,
        renew?
      ) do
    %{
      plans: plans,
      extra_characters_100: extra_characters_100,
      extra_hubs_10: extra_hubs_10
    } = WandererApp.Env.subscription_settings()

    %{
      characters_limit: plan_characters_limit,
      hubs_limit: plan_hubs_limit,
      base_price: plan_base_price
    } = current_plan = plans |&gt; Enum.find(fn p -&gt; p.id == &quot;omega&quot; end)

    estimated_price = plan_base_price

    estimated_price =
      case characters_limit &gt; plan_characters_limit do
        true -&gt;
          estimated_price +
            (characters_limit - plan_characters_limit) / 100 * extra_characters_100

        _ -&gt;
          estimated_price
      end

    estimated_price =
      case hubs_limit &gt; plan_hubs_limit do
        true -&gt;
          estimated_price + (hubs_limit - plan_hubs_limit) / 10 * extra_hubs_10

        _ -&gt;
          estimated_price
      end

    period =
      case renew? do
        true -&gt; 1
        false -&gt; params[:period]
      end

    total_price = estimated_price * period

    {:ok, discount} =
      calc_discount(
        period,
        total_price,
        current_plan,
        renew?
      )

    {:ok, total_price, discount}
  end

  def calc_additional_price(
        %{&quot;characters_limit&quot; =&gt; characters_limit, &quot;hubs_limit&quot; =&gt; hubs_limit},
        selected_subscription
      ) do
    %{
      plans: plans,
      extra_characters_100: extra_characters_100,
      extra_hubs_10: extra_hubs_10
    } = WandererApp.Env.subscription_settings()

    current_plan = plans |&gt; Enum.find(fn p -&gt; p.id == &quot;omega&quot; end)

    additional_price = 0

    characters_limit = characters_limit |&gt; String.to_integer()
    hubs_limit = hubs_limit |&gt; String.to_integer()
    sub_characters_limit = selected_subscription.characters_limit
    sub_hubs_limit = selected_subscription.hubs_limit

    additional_price =
      case characters_limit &gt; sub_characters_limit do
        true -&gt;
          additional_price +
            (characters_limit - sub_characters_limit) / 100 * extra_characters_100

        _ -&gt;
          additional_price
      end

    additional_price =
      case hubs_limit &gt; sub_hubs_limit do
        true -&gt;
          additional_price + (hubs_limit - sub_hubs_limit) / 10 * extra_hubs_10

        _ -&gt;
          additional_price
      end

    period = get_active_months(selected_subscription)
    total_price = additional_price * period

    {:ok, discount} =
      calc_discount(
        period,
        total_price,
        current_plan,
        false
      )

    {:ok, total_price, discount}
  end

  defp get_active_months(subscription) do
    subscription.active_till
    |&gt; Timex.shift(days: 5)
    |&gt; Timex.diff(Timex.now(), :months)
  end

  defp calc_discount(
         period,
         _total_price,
         _current_plan,
         renew?
       )
       when period &lt;= 1 or renew?,
       do: {:ok, 0.0}

  defp calc_discount(
         period,
         total_price,
         %{
           month_12_discount: month_12_discount
         },
         _renew?
       )
       when period &gt;= 12,
       do: {:ok, round(total_price * month_12_discount)}

  defp calc_discount(
         period,
         total_price,
         %{
           month_6_discount: month_6_discount
         },
         _renew?
       )
       when period &gt;= 6,
       do: {:ok, round(total_price * month_6_discount)}

  defp calc_discount(
         period,
         total_price,
         %{
           month_3_discount: month_3_discount
         },
         _renew?
       )
       when period &gt;= 3,
       do: {:ok, round(total_price * month_3_discount)}

  def get_balance(map) do
    map
    |&gt; WandererApp.MapRepo.load_relationships([
      :transactions_amount_in,
      :transactions_amount_out
    ])
    |&gt; case do
      {:ok,
       %{
         transactions_amount_in: transactions_amount_in,
         transactions_amount_out: transactions_amount_out
       }} -&gt;
        {:ok, transactions_amount_in - transactions_amount_out}

      _ -&gt;
        @logger.error(&quot;Error getting balance for map #{map.id}&quot;)
        {:ok, 0}
    end
  end

  def convert_date_to_datetime(%DateTime{} = date), do: date

  def convert_date_to_datetime(%Date{} = date) do
    date
    |&gt; Date.to_gregorian_days()
    |&gt; Kernel.*(86400)
    |&gt; Kernel.+(86399)
    |&gt; DateTime.from_gregorian_seconds()
  end

  defp process_subscription(subscription) when is_map(subscription) do
    subscription
    |&gt; is_expired()
    |&gt; case do
      true -&gt;
        renew_subscription(subscription)

      _ -&gt;
        :ok
    end
  end

  defp is_expired(subscription) when is_map(subscription),
    do: DateTime.compare(DateTime.utc_now(), subscription.active_till) == :gt

  defp renew_subscription(%{auto_renew?: true} = subscription) when is_map(subscription) do
    with {:ok, %{map: map}} &lt;-
           subscription |&gt; WandererApp.MapSubscriptionRepo.load_relationships([:map]),
         {:ok, estimated_price, discount} &lt;- estimate_price(subscription, true),
         {:ok, map_balance} &lt;- get_balance(map) do
      case map_balance &gt;= estimated_price do
        true -&gt;
          {:ok, _t} =
            WandererApp.MapTransactionRepo.create(%{
              map_id: map.id,
              user_id: nil,
              amount: estimated_price - discount,
              type: :out
            })

          active_till =
            DateTime.utc_now()
            |&gt; DateTime.to_date()
            |&gt; Date.add(30)
            |&gt; convert_date_to_datetime()

          {:ok, _} =
            subscription
            |&gt; WandererApp.MapSubscriptionRepo.update_active_till(active_till)

          @pubsub_client.broadcast(
            WandererApp.PubSub,
            &quot;maps:#{map.id}&quot;,
            :subscription_settings_updated
          )

          :telemetry.execute([:wanderer_app, :map, :subscription, :renew], %{count: 1}, %{
            map_id: map.id,
            amount: estimated_price - discount
          })

          # Check if a license already exists, if not create one
          case WandererApp.License.LicenseManager.get_license_by_map_id(map.id) do
            {:error, :license_not_found} -&gt;
              # No license found, create one
              # The License Manager service will verify the subscription is active
              case WandererApp.License.LicenseManager.create_license_for_map(map.id) do
                {:ok, license} -&gt;
                  Logger.debug(fn -&gt;
                    &quot;Automatically created license #{license.license_key} for map #{map.id} during renewal&quot;
                  end)

                {:error, :no_active_subscription} -&gt;
                  Logger.warning(
                    &quot;Cannot create license for map #{map.id}: No active subscription found&quot;
                  )

                {:error, reason} -&gt;
                  Logger.error(
                    &quot;Failed to create license for map #{map.id} during renewal: #{inspect(reason)}&quot;
                  )
              end

            {:ok, _license} -&gt;
              # License exists, update its expiration date
              case WandererApp.License.LicenseManager.update_license_expiration_from_subscription(
                     map.id
                   ) do
                {:ok, updated_license} -&gt;
                  Logger.info(
                    &quot;Updated license expiration for map #{map.id} to #{updated_license.expire_at}&quot;
                  )

                {:error, reason} -&gt;
                  Logger.error(
                    &quot;Failed to update license expiration for map #{map.id}: #{inspect(reason)}&quot;
                  )
              end

            _ -&gt;
              # Error occurred, do nothing
              :ok
          end

          :ok

        _ -&gt;
          subscription
          |&gt; WandererApp.MapSubscriptionRepo.cancel()

          @pubsub_client.broadcast(
            WandererApp.PubSub,
            &quot;maps:#{map.id}&quot;,
            :subscription_settings_updated
          )

          case WandererApp.License.LicenseManager.get_license_by_map_id(map.id) do
            {:ok, license} -&gt;
              WandererApp.License.LicenseManager.invalidate_license(license.id)
              Logger.info(&quot;Cancelled license for map #{map.id}&quot;)

            {:error, reason} -&gt;
              Logger.error(&quot;Failed to cancel license for map #{map.id}: #{inspect(reason)}&quot;)
          end

          :telemetry.execute([:wanderer_app, :map, :subscription, :cancel], %{count: 1}, %{
            map_id: map.id
          })

          :ok
      end
    else
      error -&gt;
        @logger.error(
          &quot;Error renewing subscription for map #{subscription.map_id} #{inspect(error)}&quot;
        )

        :ok
    end
  end

  defp renew_subscription(%{auto_renew?: false} = subscription) when is_map(subscription) do
    subscription
    |&gt; WandererApp.MapSubscriptionRepo.expire()

    @pubsub_client.broadcast(
      WandererApp.PubSub,
      &quot;maps:#{subscription.map_id}&quot;,
      :subscription_settings_updated
    )

    case WandererApp.License.LicenseManager.get_license_by_map_id(subscription.map_id) do
      {:ok, license} -&gt;
        WandererApp.License.LicenseManager.invalidate_license(license.id)
        Logger.info(&quot;Cancelled license for map #{subscription.map_id}&quot;)

      {:error, reason} -&gt;
        Logger.error(
          &quot;Failed to cancel license for map #{subscription.map_id}: #{inspect(reason)}&quot;
        )
    end

    :telemetry.execute([:wanderer_app, :map, :subscription, :expired], %{count: 1}, %{
      map_id: subscription.map_id
    })

    :ok
  end
end</file><file path="lib/wanderer_app/map/map_zkb_data_fetcher.ex">defmodule WandererApp.Map.ZkbDataFetcher do
  @moduledoc &quot;&quot;&quot;
  Refreshes the map zKillboard data every 15 seconds.
  &quot;&quot;&quot;
  use GenServer

  require Logger

  alias WandererApp.Zkb.KillsProvider.KillsCache

  @interval :timer.seconds(15)
  @store_map_kills_timeout :timer.hours(1)
  @logger Application.compile_env(:wanderer_app, :logger)

  # This means 120 ‚Äúticks‚Äù of 15s each ‚Üí ~30 minutes
  @preload_cycle_ticks 120

  def start_link(_) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  @impl true
  def init(_arg) do
    {:ok, _timer_ref} = :timer.send_interval(@interval, :fetch_data)
    {:ok, %{iteration: 0}}
  end

  @impl true
  def handle_info(:fetch_data, %{iteration: iteration} = state) do
    zkill_preload_disabled = WandererApp.Env.zkill_preload_disabled?()

    WandererApp.Map.RegistryHelper.list_all_maps()
    |&gt; Task.async_stream(
      fn %{id: map_id, pid: _server_pid} -&gt;
        try do
          if WandererApp.Map.Server.map_pid(map_id) do
            update_map_kills(map_id)

            {:ok, is_subscription_active} = map_id |&gt; WandererApp.Map.is_subscription_active?()

            can_preload_zkill = not zkill_preload_disabled &amp;&amp; is_subscription_active

            if can_preload_zkill do
              update_detailed_map_kills(map_id)
            end
          end
        rescue
          e -&gt;
            @logger.error(Exception.message(e))
        end
      end,
      max_concurrency: 10,
      on_timeout: :kill_task
    )
    |&gt; Enum.each(fn _ -&gt; :ok end)

    new_iteration = iteration + 1

    cond do
      zkill_preload_disabled -&gt;
        # If preload is disabled, just update iteration
        {:noreply, %{state | iteration: new_iteration}}

      new_iteration &gt;= @preload_cycle_ticks -&gt;
        Logger.info(&quot;[ZkbDataFetcher] Triggering a fresh kill preload pass ...&quot;)
        WandererApp.Zkb.KillsPreloader.run_preload_now()
        {:noreply, %{state | iteration: 0}}

      true -&gt;
        {:noreply, %{state | iteration: new_iteration}}
    end
  end

  # Catch any async task results we aren&apos;t explicitly pattern-matching
  @impl true
  def handle_info({ref, _result}, state) do
    Process.demonitor(ref, [:flush])
    {:noreply, state}
  end

  defp update_map_kills(map_id) do
    with_started_map(map_id, &quot;basic kills update&quot;, fn -&gt;
      map_id
      |&gt; WandererApp.Map.get_map!()
      |&gt; Map.get(:systems, %{})
      |&gt; Enum.into(%{}, fn {solar_system_id, _system} -&gt;
        kills_count = WandererApp.Cache.get(&quot;zkb_kills_#{solar_system_id}&quot;) || 0
        {solar_system_id, kills_count}
      end)
      |&gt; maybe_broadcast_map_kills(map_id)
    end)
  end

  defp update_detailed_map_kills(map_id) do
    with_started_map(map_id, &quot;detailed kills update&quot;, fn -&gt;
      systems =
        map_id
        |&gt; WandererApp.Map.get_map!()
        |&gt; Map.get(:systems, %{})

      # Old cache data
      old_ids_map = WandererApp.Cache.get(&quot;map_#{map_id}:zkb_ids&quot;) || %{}
      old_details_map = WandererApp.Cache.get(&quot;map_#{map_id}:zkb_detailed_kills&quot;) || %{}

      new_ids_map =
        Enum.into(systems, %{}, fn {solar_system_id, _} -&gt;
          ids = KillsCache.get_system_killmail_ids(solar_system_id) |&gt; MapSet.new()
          {solar_system_id, ids}
        end)

      changed_systems =
        new_ids_map
        |&gt; Enum.filter(fn {system_id, new_ids_set} -&gt;
          old_set = MapSet.new(Map.get(old_ids_map, system_id, []))
          not MapSet.equal?(new_ids_set, old_set)
        end)
        |&gt; Enum.map(&amp;elem(&amp;1, 0))

      if changed_systems == [] do
        Logger.debug(fn -&gt;
          &quot;[ZkbDataFetcher] No changes in detailed kills for map_id=#{map_id}&quot;
        end)

        :ok
      else
        # Build new details for each changed system
        updated_details_map =
          Enum.reduce(changed_systems, old_details_map, fn system_id, acc -&gt;
            kill_ids =
              new_ids_map
              |&gt; Map.fetch!(system_id)
              |&gt; MapSet.to_list()

            kill_details =
              kill_ids
              |&gt; Enum.map(&amp;KillsCache.get_killmail/1)
              |&gt; Enum.reject(&amp;is_nil/1)

            Map.put(acc, system_id, kill_details)
          end)

        updated_ids_map =
          Enum.reduce(changed_systems, old_ids_map, fn system_id, acc -&gt;
            new_ids_list = new_ids_map[system_id] |&gt; MapSet.to_list()
            Map.put(acc, system_id, new_ids_list)
          end)

        WandererApp.Cache.put(&quot;map_#{map_id}:zkb_ids&quot;, updated_ids_map,
          ttl: :timer.hours(KillsCache.killmail_ttl())
        )

        WandererApp.Cache.put(&quot;map_#{map_id}:zkb_detailed_kills&quot;, updated_details_map,
          ttl: :timer.hours(KillsCache.killmail_ttl())
        )

        changed_data = Map.take(updated_details_map, changed_systems)

        WandererApp.Map.Server.Impl.broadcast!(map_id, :detailed_kills_updated, changed_data)

        :ok
      end
    end)
  end

  defp maybe_broadcast_map_kills(new_kills_map, map_id) do
    {:ok, old_kills_map} = WandererApp.Cache.lookup(&quot;map_#{map_id}:zkb_kills&quot;, %{})

    # Use the union of keys from both the new and old maps
    all_system_ids = Map.keys(Map.merge(new_kills_map, old_kills_map))

    changed_system_ids =
      Enum.filter(all_system_ids, fn system_id -&gt;
        new_kills_count = Map.get(new_kills_map, system_id, 0)
        old_kills_count = Map.get(old_kills_map, system_id, 0)

        new_kills_count != old_kills_count and
          (new_kills_count &gt; 0 or (old_kills_count &gt; 0 and new_kills_count == 0))
      end)

    if changed_system_ids == [] do
      :ok
    else
      :ok =
        WandererApp.Cache.put(&quot;map_#{map_id}:zkb_kills&quot;, new_kills_map,
          ttl: @store_map_kills_timeout
        )

      payload = Map.take(new_kills_map, changed_system_ids)

      WandererApp.Map.Server.Impl.broadcast!(map_id, :kills_updated, payload)

      :ok
    end
  end

  defp with_started_map(map_id, label, fun) when is_function(fun, 0) do
    if WandererApp.Cache.lookup!(&quot;map_#{map_id}:started&quot;, false) do
      fun.()
    else
      Logger.debug(fn -&gt; &quot;[ZkbDataFetcher] Map #{map_id} not started =&gt; skipping #{label}&quot; end)
      :ok
    end
  end
end</file><file path="lib/wanderer_app/metrics/prom_ex_plugin.ex">defmodule WandererApp.Metrics.PromExPlugin do
  use PromEx.Plugin

  @character_tracker_event [:wanderer_app, :character, :tracker]
  @character_tracker_started_event [:wanderer_app, :character, :tracker, :started]
  @character_tracker_stopped_event [:wanderer_app, :character, :tracker, :stopped]
  @user_registered_event [:wanderer_app, :user, :registered]
  @user_character_registered_event [:wanderer_app, :user, :character, :registered]
  @map_character_added_event [:wanderer_app, :map, :character, :added]
  @map_character_jump_event [:wanderer_app, :map, :character, :jump]
  @map_created_event [:wanderer_app, :map, :created]
  @map_started_event [:wanderer_app, :map, :started]
  @map_stopped_event [:wanderer_app, :map, :stopped]
  @map_subscription_new_event [:wanderer_app, :map, :subscription, :new]
  @map_subscription_renew_event [:wanderer_app, :map, :subscription, :renew]
  @map_subscription_update_event [:wanderer_app, :map, :subscription, :update]
  @map_subscription_cancel_event [:wanderer_app, :map, :subscription, :cancel]
  @map_subscription_expired_event [:wanderer_app, :map, :subscription, :expired]

  @impl true
  def event_metrics(_opts) do
    [
      user_event_metrics(),
      character_event_metrics(),
      map_event_metrics(),
      map_subscription_metrics(),
      characters_distribution_event_metrics()
    ]
  end

  defp user_event_metrics do
    Event.build(
      :wanderer_app_user_event_metrics,
      [
        counter(
          @user_registered_event ++ [:count],
          event_name: @user_registered_event,
          description: &quot;The number of users registered events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        ),
        counter(
          @user_character_registered_event ++ [:count],
          event_name: @user_character_registered_event,
          description: &quot;The number of users character registered events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        )
      ]
    )
  end

  defp character_event_metrics do
    Event.build(
      :wanderer_app_character_event_metrics,
      [
        counter(
          @character_tracker_started_event ++ [:count],
          event_name: @character_tracker_started_event,
          description: &quot;The number of character tracker started events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        ),
        counter(
          @character_tracker_stopped_event ++ [:count],
          event_name: @character_tracker_stopped_event,
          description: &quot;The number of character tracker stopped events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        )
      ]
    )
  end

  defp map_event_metrics do
    Event.build(
      :wanderer_app_map_event_metrics,
      [
        counter(
          @map_created_event ++ [:count],
          event_name: @map_created_event,
          description: &quot;The number of map created events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        ),
        counter(
          @map_started_event ++ [:count],
          event_name: @map_started_event,
          description: &quot;The number of map started events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        ),
        counter(
          @map_stopped_event ++ [:count],
          event_name: @map_stopped_event,
          description: &quot;The number of map stopped events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        ),
        counter(
          @map_character_added_event ++ [:count],
          event_name: @map_character_added_event,
          description: &quot;The number of map character added events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        ),
        counter(
          @map_character_jump_event ++ [:count],
          event_name: @map_character_jump_event,
          description: &quot;The number of map character jump events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        )
      ]
    )
  end

  defp map_subscription_metrics do
    Event.build(
      :wanderer_app_map_subscription_metrics,
      [
        counter(
          @map_subscription_new_event ++ [:count],
          event_name: @map_subscription_new_event,
          description: &quot;The number of new map subscription events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        ),
        counter(
          @map_subscription_renew_event ++ [:count],
          event_name: @map_subscription_renew_event,
          description: &quot;The number of map subscription renew events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        ),
        counter(
          @map_subscription_update_event ++ [:count],
          event_name: @map_subscription_update_event,
          description: &quot;The number of map subscription update events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        ),
        counter(
          @map_subscription_cancel_event ++ [:count],
          event_name: @map_subscription_cancel_event,
          description:
            &quot;The number of map character subscription cancel events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        ),
        counter(
          @map_subscription_expired_event ++ [:count],
          event_name: @map_subscription_expired_event,
          description:
            &quot;The number of map character subscription expired events that have occurred&quot;,
          tags: [],
          tag_values: &amp;get_empty_tag_values/1
        )
      ]
    )
  end

  defp characters_distribution_event_metrics do
    Event.build(
      :wanderer_app_characters_distribution_event_metrics,
      [
        distribution(
          @character_tracker_event ++ [:duration],
          event_name: @character_tracker_event,
          description: &quot;The time spent in hours before disconnecting from the mapper.&quot;,
          reporter_options: [buckets: [1, 2, 4, 8, 16, 32]]
        )
      ]
    )
  end

  defp get_empty_tag_values(_) do
    %{}
  end
end</file><file path="lib/wanderer_app/repositories/access_list_repo.ex">defmodule WandererApp.AccessListRepo do
  use WandererApp, :repository

  def get(acl_id, relationships \\ []) do
    acl_id
    |&gt; WandererApp.Api.AccessList.by_id()
    |&gt; case do
      {:ok, acl} -&gt;
        acl |&gt; load_relationships(relationships)

      _ -&gt;
        {:error, :not_found}
    end
  end

  def load_relationships(acl, []), do: {:ok, acl}

  def load_relationships(acl, relationships), do: acl |&gt; Ash.load(relationships)
end</file><file path="lib/wanderer_app/repositories/map_chain_passages_repo.ex">defmodule WandererApp.MapChainPassagesRepo do
  use WandererApp, :repository

  def by_connection(map_id, from, to) do
    map_id
    |&gt; WandererApp.Map.find_connection(
      from,
      to
    )
    |&gt; case do
      {:ok, connection} -&gt;
        {:ok, from_passages} =
          WandererApp.Api.MapChainPassages.by_connection(%{
            map_id: map_id,
            from: from,
            to: to,
            after: connection.inserted_at
          })

        {:ok, to_passages} =
          WandererApp.Api.MapChainPassages.by_connection(%{
            map_id: map_id,
            from: to,
            to: from,
            after: connection.inserted_at
          })

        from_passages =
          from_passages
          |&gt; Enum.map(fn passage -&gt; passage |&gt; Map.put_new(:from, true) end)

        to_passages =
          to_passages
          |&gt; Enum.map(fn passage -&gt; passage |&gt; Map.put_new(:from, false) end)

        passages =
          [from_passages | to_passages]
          |&gt; List.flatten()

        {:ok, passages}

      {:error, _error} -&gt;
        {:ok, []}
    end
  end
end</file><file path="lib/wanderer_app/repositories/map_character_settings_repo.ex">defmodule WandererApp.MapCharacterSettingsRepo do
  use WandererApp, :repository

  def get(map_id, character_id) do
    case WandererApp.Api.MapCharacterSettings.read_by_map_and_character(%{
           map_id: map_id,
           character_id: character_id
         }) do
      {:ok, settings} when not is_nil(settings) -&gt;
        {:ok, settings}

      _ -&gt;
        WandererApp.Api.MapCharacterSettings.create(%{
          character_id: character_id,
          map_id: map_id,
          tracked: false
        })
    end
  end

  def create(settings) do
    WandererApp.Api.MapCharacterSettings.create(settings)
  end

  def update(map_id, character_id, updated_settings) do
    case get(map_id, character_id) do
      {:ok, settings} when not is_nil(settings) -&gt;
        settings
        |&gt; WandererApp.Api.MapCharacterSettings.update(updated_settings)

      _ -&gt;
        {:ok, nil}
    end
  end

  def get_tracked_by_map_filtered(map_id, character_ids),
    do:
      WandererApp.Api.MapCharacterSettings.tracked_by_map_filtered(%{
        map_id: map_id,
        character_ids: character_ids
      })

  def get_by_map_filtered(map_id, character_ids),
    do:
      WandererApp.Api.MapCharacterSettings.by_map_filtered(%{
        map_id: map_id,
        character_ids: character_ids
      })

  def get_all_by_map(map_id),
    do: WandererApp.Api.MapCharacterSettings.read_by_map(%{map_id: map_id})

  def get_tracked_by_map_all(map_id),
    do: WandererApp.Api.MapCharacterSettings.tracked_by_map_all(%{map_id: map_id})

  def get_by_map(map_id, character_id) do
    case get_by_map_filtered(map_id, [character_id]) do
      {:ok, [setting | _]} -&gt;
        {:ok, setting}

      {:ok, []} -&gt;
        {:error, :not_found}

      {:error, reason} -&gt;
        {:error, reason}
    end
  end

  def track(settings) do
    # Only update the tracked field, preserving other fields
    WandererApp.Api.MapCharacterSettings.track(%{
      map_id: settings.map_id,
      character_id: settings.character_id
    })
  end

  def untrack(settings) do
    # Only update the tracked field, preserving other fields
    WandererApp.Api.MapCharacterSettings.untrack(%{
      map_id: settings.map_id,
      character_id: settings.character_id
    })
  end

  def track!(settings),
    do:
      WandererApp.Api.MapCharacterSettings.track!(%{
        map_id: settings.map_id,
        character_id: settings.character_id
      })

  def untrack!(settings),
    do:
      WandererApp.Api.MapCharacterSettings.untrack!(%{
        map_id: settings.map_id,
        character_id: settings.character_id
      })

  def follow(settings) do
    WandererApp.Api.MapCharacterSettings.follow(%{
      map_id: settings.map_id,
      character_id: settings.character_id
    })
  end

  def unfollow(settings) do
    WandererApp.Api.MapCharacterSettings.unfollow(%{
      map_id: settings.map_id,
      character_id: settings.character_id
    })
  end

  def follow!(settings),
    do:
      WandererApp.Api.MapCharacterSettings.follow!(%{
        map_id: settings.map_id,
        character_id: settings.character_id
      })

  def unfollow!(settings),
    do:
      WandererApp.Api.MapCharacterSettings.unfollow!(%{
        map_id: settings.map_id,
        character_id: settings.character_id
      })

  def destroy!(settings), do: settings |&gt; WandererApp.Api.MapCharacterSettings.destroy!()
end</file><file path="lib/wanderer_app/repositories/map_connection_repo.ex">defmodule WandererApp.MapConnectionRepo do
  use WandererApp, :repository

  require Logger

  @logger Application.compile_env(:wanderer_app, :logger)

  def get_by_map(map_id),
    do: WandererApp.Api.MapConnection.read_by_map(%{map_id: map_id})

  def get_by_locations(map_id, solar_system_source, solar_system_target) do
    WandererApp.Api.MapConnection.by_locations(%{
      map_id: map_id,
      solar_system_source: solar_system_source,
      solar_system_target: solar_system_target
    })
    |&gt; case do
      {:ok, connections} -&gt;
        {:ok, connections}

      {:error, %Ash.Error.Query.NotFound{}} -&gt;
        {:ok, []}

      {:error, error} -&gt;
        @logger.error(&quot;Failed to get connections: #{inspect(error, pretty: true)}&quot;)
        {:error, error}
    end
  end

  def create(connection), do: connection |&gt; WandererApp.Api.MapConnection.create()
  def create!(connection), do: connection |&gt; WandererApp.Api.MapConnection.create!()

  def destroy(map_id, connection) when not is_nil(connection) do
    {:ok, from_connections} =
      get_by_locations(map_id, connection.solar_system_source, connection.solar_system_target)

    {:ok, to_connections} =
      get_by_locations(map_id, connection.solar_system_target, connection.solar_system_source)

    [from_connections ++ to_connections]
    |&gt; List.flatten()
    |&gt; bulk_destroy!()
    |&gt; case do
      :ok -&gt;
        :ok

      error -&gt;
        @logger.error(&quot;Failed to remove connections from map: #{inspect(error, pretty: true)}&quot;)
        :ok
    end
  end

  def destroy(_map_id, _connection), do: :ok

  def destroy!(connection), do: connection |&gt; WandererApp.Api.MapConnection.destroy!()

  def bulk_destroy!(connections) do
    connections
    |&gt; WandererApp.Api.MapConnection.destroy!()
    |&gt; case do
      %Ash.BulkResult{status: :success} -&gt;
        :ok

      error -&gt;
        error
    end
  end

  def update_time_status(connection, update),
    do:
      connection
      |&gt; WandererApp.Api.MapConnection.update_time_status(update)

  def update_type(connection, update),
    do:
      connection
      |&gt; WandererApp.Api.MapConnection.update_type(update)

  def update_mass_status(connection, update),
    do:
      connection
      |&gt; WandererApp.Api.MapConnection.update_mass_status(update)

  def update_ship_size_type(connection, update),
    do:
      connection
      |&gt; WandererApp.Api.MapConnection.update_ship_size_type(update)

  def update_locked(connection, update),
    do:
      connection
      |&gt; WandererApp.Api.MapConnection.update_locked(update)

  def update_custom_info(connection, update),
    do:
      connection
      |&gt; WandererApp.Api.MapConnection.update_custom_info(update)

  def get_by_id(map_id, id) do
    case WandererApp.Api.MapConnection.by_id(id) do
      {:ok, conn} when conn.map_id == map_id -&gt; {:ok, conn}
      {:ok, _} -&gt; {:error, :not_found}
      {:error, _} -&gt; {:error, :not_found}
    end
  end
end</file><file path="lib/wanderer_app/repositories/map_repo.ex">defmodule WandererApp.MapRepo do
  use WandererApp, :repository

  @default_map_options %{
    &quot;layout&quot; =&gt; &quot;left_to_right&quot;,
    &quot;store_custom_labels&quot; =&gt; &quot;false&quot;,
    &quot;show_linked_signature_id&quot; =&gt; &quot;false&quot;,
    &quot;show_linked_signature_id_temp_name&quot; =&gt; &quot;false&quot;,
    &quot;show_temp_system_name&quot; =&gt; &quot;false&quot;,
    &quot;restrict_offline_showing&quot; =&gt; &quot;false&quot;
  }

  def get(map_id, relationships \\ []) do
    map_id
    |&gt; WandererApp.Api.Map.by_id()
    |&gt; case do
      {:ok, map} -&gt;
        map |&gt; load_relationships(relationships)

      _ -&gt;
        {:error, :not_found}
    end
  end

  def get_by_slug_with_permissions(map_slug, current_user),
    do:
      map_slug
      |&gt; WandererApp.Api.Map.get_map_by_slug()
      |&gt; load_user_permissions(current_user)

  def load_relationships(map, []), do: {:ok, map}

  def load_relationships(map, relationships), do: map |&gt; Ash.load(relationships)

  defp load_user_permissions({:ok, map}, current_user),
    do:
      map
      |&gt; Ash.load([:acls, :user_permissions], actor: current_user)

  defp load_user_permissions(error, _current_user), do: error

  def update_hubs(map_id, hubs) do
    map_id
    |&gt; WandererApp.Api.Map.by_id()
    |&gt; case do
      {:ok, map} -&gt;
        map |&gt; WandererApp.Api.Map.update_hubs(%{hubs: hubs})

      _ -&gt;
        {:error, :map_not_found}
    end
  end

  def update_options(map, options),
    do:
      map
      |&gt; WandererApp.Api.Map.update_options(%{options: Jason.encode!(options)})

  def options_to_form_data(%{options: options} = _map_options) when not is_nil(options),
    do: {:ok, Jason.decode!(options)}

  def options_to_form_data(_), do: {:ok, @default_map_options}

  def options_to_form_data!(options) do
    {:ok, data} = options_to_form_data(options)
    data
  end
end</file><file path="lib/wanderer_app/repositories/map_subscription_repo.ex">defmodule WandererApp.MapSubscriptionRepo do
  use WandererApp, :repository

  def cancel(sub), do: sub |&gt; WandererApp.Api.MapSubscription.cancel()

  def expire(sub), do: sub |&gt; WandererApp.Api.MapSubscription.expire()

  def get_all_active(),
    do: WandererApp.Api.MapSubscription.all_active()

  def get_all_by_map(map_id),
    do: WandererApp.Api.MapSubscription.all_by_map(%{map_id: map_id})

  def get_active_by_map(map_id),
    do: WandererApp.Api.MapSubscription.active_by_map(%{map_id: map_id})

  def load_relationships(sub, []), do: {:ok, sub}

  def load_relationships(sub, relationships), do: sub |&gt; Ash.load(relationships)

  def update_active_till(sub, active_till),
    do:
      sub
      |&gt; WandererApp.Api.MapSubscription.update_active_till(%{active_till: active_till})
end</file><file path="lib/wanderer_app/repositories/map_system_comment_repo.ex">defmodule WandererApp.MapSystemCommentRepo do
  use WandererApp, :repository

  require Logger

  def get_by_id(comment_id),
    do: WandererApp.Api.MapSystemComment.by_id!(comment_id) |&gt; Ash.load([:system])

  def get_by_system(system_id),
    do: WandererApp.Api.MapSystemComment.by_system_id(system_id)

  def create(comment), do: comment |&gt; WandererApp.Api.MapSystemComment.create()
  def create!(comment), do: comment |&gt; WandererApp.Api.MapSystemComment.create!()

  def destroy(comment) when not is_nil(comment),
    do:
      comment
      |&gt; WandererApp.Api.MapSystemComment.destroy!()

  def destroy(_comment), do: :ok
end</file><file path="lib/wanderer_app/repositories/map_system_repo.ex">defmodule WandererApp.MapSystemRepo do
  use WandererApp, :repository

  def create(system) do
    system |&gt; WandererApp.Api.MapSystem.create()
  end

  def get_by_map_and_solar_system_id(map_id, solar_system_id) do
    WandererApp.Api.MapSystem.by_map_id_and_solar_system_id(map_id, solar_system_id)
    |&gt; case do
      {:ok, system} -&gt;
        {:ok, system}

      _ -&gt;
        {:error, :not_found}
    end
  end

  def get_all_by_map(map_id) do
    WandererApp.Api.MapSystem.read_all_by_map(%{map_id: map_id})
  end

  def get_visible_by_map(map_id) do
    WandererApp.Api.MapSystem.read_visible_by_map(%{map_id: map_id})
  end

  def remove_from_map(map_id, solar_system_id) do
    WandererApp.Api.MapSystem.read_by_map_and_solar_system!(%{
      map_id: map_id,
      solar_system_id: solar_system_id
    })
    |&gt; WandererApp.Api.MapSystem.update_visible(%{visible: false})
  rescue
    error -&gt;
      {:error, error}
  end

  def cleanup_labels!(%{labels: labels} = system, opts) do
    store_custom_labels? =
      Keyword.get(opts, :store_custom_labels)

    labels = get_filtered_labels(labels, store_custom_labels?)

    system
    |&gt; update_labels!(%{
      labels: labels
    })
  end

  def cleanup_tags(system) do
    system
    |&gt; WandererApp.Api.MapSystem.update_tag(%{
      tag: nil
    })
  end

  def cleanup_tags!(system) do
    system
    |&gt; WandererApp.Api.MapSystem.update_tag!(%{
      tag: nil
    })
  end

  def cleanup_temporary_name(system) do
    system
    |&gt; WandererApp.Api.MapSystem.update_temporary_name(%{
      temporary_name: nil
    })
  end

  def cleanup_temporary_name!(system) do
    system
    |&gt; WandererApp.Api.MapSystem.update_temporary_name!(%{
      temporary_name: nil
    })
  end

  def cleanup_linked_sig_eve_id!(system) do
    system
    |&gt; WandererApp.Api.MapSystem.update_linked_sig_eve_id!(%{
      linked_sig_eve_id: nil
    })
  end

  def get_filtered_labels(labels, true) when is_binary(labels) do
    labels
    |&gt; Jason.decode!()
    |&gt; case do
      %{&quot;customLabel&quot; =&gt; customLabel} when is_binary(customLabel) -&gt;
        %{&quot;customLabel&quot; =&gt; customLabel, &quot;labels&quot; =&gt; []}
        |&gt; Jason.encode!()

      _ -&gt;
        nil
    end
  end

  def get_filtered_labels(_, _store_custom_labels), do: nil

  def update_name(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_name(update)

  def update_description(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_description(update)

  def update_locked(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_locked(update)

  def update_status(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_status(update)

  def update_tag(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_tag(update)

  def update_temporary_name(system, update) do
    system
    |&gt; WandererApp.Api.MapSystem.update_temporary_name(update)
  end

  def update_labels(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_labels(update)

  def update_labels!(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_labels!(update)

  def update_linked_sig_eve_id(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_linked_sig_eve_id(update)

  def update_linked_sig_eve_id!(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_linked_sig_eve_id!(update)

  def update_position(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_position(update)

  def update_position!(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_position!(update)

  def update_visible(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_visible(update)

  def update_visible!(system, update),
    do:
      system
      |&gt; WandererApp.Api.MapSystem.update_visible!(update)
end</file><file path="lib/wanderer_app/repositories/map_transaction_repo.ex">defmodule WandererApp.MapTransactionRepo do
  use WandererApp, :repository

  def create(transaction),
    do: WandererApp.Api.MapTransaction.create(transaction)
end</file><file path="lib/wanderer_app/repositories/map_user_settings_repo.ex">defmodule WandererApp.MapUserSettingsRepo do
  use WandererApp, :repository

  @default_form_data %{
    &quot;select_on_spash&quot; =&gt; false,
    &quot;link_signature_on_splash&quot; =&gt; false,
    &quot;delete_connection_with_sigs&quot; =&gt; false,
    &quot;primary_character_id&quot; =&gt; nil
  }

  def get(map_id, user_id) do
    map_id
    |&gt; WandererApp.Api.MapUserSettings.by_user_id(user_id)
    |&gt; case do
      {:ok, settings} -&gt;
        {:ok, settings}

      _ -&gt;
        {:ok, nil}
    end
  end

  def get!(map_id, user_id) do
    WandererApp.Api.MapUserSettings.by_user_id(map_id, user_id)
    |&gt; case do
      {:ok, user_settings} -&gt; user_settings
      _ -&gt; nil
    end
  end

  def create_or_update(map_id, user_id, nil) do
    create_or_update(map_id, user_id, @default_form_data |&gt; Jason.encode!())
  end

  def create_or_update(map_id, user_id, settings) do
    get!(map_id, user_id)
    |&gt; case do
      user_settings when not is_nil(user_settings) -&gt;
        user_settings
        |&gt; WandererApp.Api.MapUserSettings.update_settings(%{settings: settings})

      _ -&gt;
        WandererApp.Api.MapUserSettings.create(%{
          map_id: map_id,
          user_id: user_id,
          settings: settings
        })
    end
  end

  def get_hubs(map_id, user_id) do
    case WandererApp.MapUserSettingsRepo.get(map_id, user_id) do
      {:ok, user_settings} when not is_nil(user_settings) -&gt;
        {:ok, Map.get(user_settings, :hubs, [])}

      _ -&gt;
        {:ok, []}
    end
  end

  def update_hubs(map_id, user_id, hubs) do
    get!(map_id, user_id)
    |&gt; case do
      user_settings when not is_nil(user_settings) -&gt;
        user_settings
        |&gt; WandererApp.Api.MapUserSettings.update_hubs(%{hubs: hubs})

      _ -&gt;
        WandererApp.Api.MapUserSettings.create!(%{
          map_id: map_id,
          user_id: user_id,
          settings: @default_form_data |&gt; Jason.encode!()
        })
        |&gt; WandererApp.Api.MapUserSettings.update_hubs(%{hubs: hubs})
    end
  end

  def to_form_data(nil), do: {:ok, @default_form_data}
  def to_form_data(%{settings: settings} = _user_settings), do: {:ok, Jason.decode!(settings)}

  def to_form_data!(user_settings) do
    {:ok, data} = to_form_data(user_settings)
    data
  end

  def get_boolean_setting(settings, key, default \\ false) do
    settings
    |&gt; Map.get(key, default)
    |&gt; to_boolean()
  end

  def to_boolean(value) when is_binary(value), do: value |&gt; String.to_existing_atom()
  def to_boolean(value) when is_boolean(value), do: value
end</file><file path="lib/wanderer_app/schema/ash_erlang_binary.ex">defmodule WandererApp.Schema.AshErlangBinary do
  use Ash.Type

  @impl Ash.Type
  def storage_type, do: :binary

  @impl Ash.Type
  def cast_input(value, _) do
    {:ok, value}
  end

  @impl Ash.Type
  def cast_stored(value, _) when not is_nil(value),
    do: {:ok, :erlang.binary_to_term(value)}

  @impl Ash.Type
  def cast_stored(value, _), do: {:ok, value}

  @impl Ash.Type
  def dump_to_native(value, _) when not is_nil(value), do: {:ok, :erlang.term_to_binary(value)}

  @impl Ash.Type
  def dump_to_native(value, _), do: {:ok, value}
end</file><file path="lib/wanderer_app/server/server_status_tracker.ex">defmodule WandererApp.Server.ServerStatusTracker do
  @moduledoc false
  use GenServer

  require Logger

  @name :server_status_tracker

  defstruct [
    :players,
    :server_version,
    :start_time,
    :vip,
    :retries
  ]

  @retries_count 3

  @initial_state %{
    players: 0,
    retries: @retries_count,
    server_version: &quot;0&quot;,
    start_time: &quot;0&quot;,
    vip: true
  }

  @refresh_interval :timer.minutes(1)

  @logger Application.compile_env(:wanderer_app, :logger)

  def get_status(), do: GenServer.call(@name, :get_status)

  def start_link(opts \\ []), do: GenServer.start(__MODULE__, opts, name: @name)

  @impl true
  def init(_opts) do
    @logger.info(&quot;#{__MODULE__} started&quot;)

    {:ok, @initial_state, {:continue, :start}}
  end

  @impl true
  def terminate(_reason, _state), do: :ok

  @impl true
  def handle_call(:get_status, _from, state), do: {:reply, {:ok, state}, state}

  @impl true
  def handle_call(:stop, _, state), do: {:stop, :normal, :ok, state}

  @impl true
  def handle_call(:error, _, state), do: {:stop, :error, :ok, state}

  @impl true
  def handle_continue(:start, state) do
    Process.send_after(self(), :refresh_status, 100)

    {:noreply, state}
  end

  @impl true
  def handle_info(
        :refresh_status,
        %{
          retries: retries
        } = state
      ) do
    Process.send_after(self(), :refresh_status, @refresh_interval)
    Task.async(fn -&gt; _get_server_status(retries) end)

    {:noreply, state}
  end

  @impl true
  def handle_info(
        {ref, result},
        %{
          retries: retries
        } = state
      ) do
    Process.demonitor(ref, [:flush])

    case result do
      {:status, status} -&gt;
        Phoenix.PubSub.broadcast(
          WandererApp.PubSub,
          &quot;server_status&quot;,
          {:server_status, status}
        )

        {:noreply, state |&gt; Map.merge(status)}

      :retry -&gt;
        {:noreply, %{state | retries: retries - 1}}

      {:error, _error} -&gt;
        {:noreply, state}

      _ -&gt;
        {:noreply, state}
    end
  end

  def handle_info(_action, state),
    do: {:noreply, state}

  defp _get_server_status(retries) do
    case WandererApp.Esi.get_server_status() do
      {:ok, result} -&gt;
        {:status, _get_status(result)}

      {:error, :timeout} -&gt;
        if retries &gt; 0 do
          :retry
        else
          @logger.warning(&quot;#{__MODULE__} failed to refresh server status: :timeout&quot;)
          {:status, @initial_state}
        end

      {:error, error} -&gt;
        if retries &gt; 0 do
          :retry
        else
          @logger.warning(&quot;#{__MODULE__} failed to refresh server status: #{inspect(error)}&quot;)
          {:status, @initial_state}
        end
    end
  end

  defp _get_status(%{
         &quot;players&quot; =&gt; 0,
         &quot;server_version&quot; =&gt; server_version,
         &quot;start_time&quot; =&gt; start_time,
         &quot;vip&quot; =&gt; _vip
       }) do
    %{players: 0, server_version: server_version, start_time: start_time, vip: true}
  end

  defp _get_status(%{
         &quot;players&quot; =&gt; players,
         &quot;server_version&quot; =&gt; server_version,
         &quot;start_time&quot; =&gt; start_time,
         &quot;vip&quot; =&gt; vip
       }) do
    %{players: players, server_version: server_version, start_time: start_time, vip: vip}
  end

  defp _get_status(%{
         &quot;players&quot; =&gt; players,
         &quot;server_version&quot; =&gt; server_version,
         &quot;start_time&quot; =&gt; start_time
       }) do
    %{
      players: players,
      server_version: server_version,
      start_time: start_time,
      vip: false
    }
  end
end</file><file path="lib/wanderer_app/server/thera_data_fetcher.ex">defmodule WandererApp.Server.TheraDataFetcher do
  @moduledoc false
  use GenServer

  require Logger

  @name :thera_data_fetcher

  defstruct [
    :retries_count,
    :restart_timeout
  ]

  @eve_scout_base_url &quot;https://api.eve-scout.com/v2/public&quot;
  @refresh_timeout :timer.minutes(1)

  @initial_state %{
    retries_count: 5,
    restart_timeout: @refresh_timeout
  }

  def get_chain_pairs(params) do
    case WandererApp.Cache.get(@name) do
      nil -&gt;
        {:ok, []}

      data -&gt;
        {:ok,
         data
         |&gt; Enum.filter(fn item -&gt; _is_filtered(item, params) end)
         |&gt; Enum.map(fn item -&gt;
           %{
             first: item.source_solar_system_id,
             second: item.destination_solar_system_id
           }
         end)}
    end
  end

  defp _is_filtered(%{ship_size_type: 0}, %{
         include_frig: false
       }),
       do: false

  defp _is_filtered(%{time_status: 1}, %{
         include_eol: false
       }),
       do: false

  defp _is_filtered(%{time_status: 2}, %{
         include_mass_crit: false
       }),
       do: false

  defp _is_filtered(_, _), do: true

  def start_link(opts \\ []) do
    GenServer.start(__MODULE__, opts, name: @name)
  end

  @impl true
  def init(_opts) do
    Logger.info(&quot;#{__MODULE__} started&quot;)

    {:ok, @initial_state, {:continue, :start}}
  end

  @impl true
  def terminate(_reason, _state) do
    :ok
  end

  @impl true
  def handle_call(:stop, _, state), do: {:stop, :normal, :ok, state}

  @impl true
  def handle_call(:error, _, state), do: {:stop, :error, :ok, state}

  @impl true
  def handle_continue(:start, state) do
    Process.send_after(self(), :refresh_data, 500)

    {:noreply, state}
  end

  @impl true
  def handle_info(
        :refresh_data,
        state
      ) do
    Task.async(fn -&gt; load_data() end)
    Process.send_after(self(), :refresh_data, @refresh_timeout)

    {:noreply, state}
  end

  @impl true
  def handle_info({ref, result}, state) do
    Process.demonitor(ref, [:flush])

    case result do
      {:ok, data} -&gt;
        _cache_items(data)
        {:noreply, state}

      _ -&gt;
        Logger.error(&quot;#{__MODULE__} failed to load data&quot;)
        {:noreply, state}
    end
  end

  def handle_info(_action, state),
    do: {:noreply, state}

  defp load_data() do
    case Req.get(&quot;#{@eve_scout_base_url}/signatures&quot;, params: [system_name: &quot;thera&quot;]) do
      {:ok, %{status: 200, body: body}} -&gt;
        {:ok, body |&gt; _get_infos()}

      {:error, reason} -&gt;
        {:error, reason}

      _ -&gt;
        {:error, &quot;Request failed&quot;}
    end
  end

  defp _get_infos(data) do
    data
    |&gt; Enum.map(&amp;_get_info/1)
  end

  defp _get_info(%{
         &quot;in_system_id&quot; =&gt; in_system_id,
         &quot;max_ship_size&quot; =&gt; max_ship_size,
         &quot;out_system_id&quot; =&gt; out_system_id,
         &quot;remaining_hours&quot; =&gt; remaining_hours
       }) do
    %{
      source_solar_system_id: in_system_id,
      destination_solar_system_id: out_system_id,
      mass_status: 0,
      time_status: _get_time_status(remaining_hours),
      ship_size_type: _get_ship_size(max_ship_size)
    }
  end

  defp _get_ship_size(&quot;small&quot;), do: 0
  defp _get_ship_size(&quot;medium&quot;), do: 1
  defp _get_ship_size(&quot;large&quot;), do: 1
  defp _get_ship_size(&quot;xlarge&quot;), do: 2
  defp _get_ship_size(_), do: 1

  defp _get_time_status(remaining_hours) when remaining_hours &lt; 2, do: 0
  defp _get_time_status(_), do: 1

  defp _cache_items([]), do: WandererApp.Cache.put(@name, [])

  defp _cache_items(items), do: WandererApp.Cache.put(@name, items)
end</file><file path="lib/wanderer_app/ueberauth/strategy/eve/oauth.ex">defmodule WandererApp.Ueberauth.Strategy.Eve.OAuth do
  @moduledoc &quot;&quot;&quot;
  OAuth2 for Eve.

  Add `client_id` and `client_secret` to your configuration:

      config :wanderer_app, WandererApp.Ueberauth.Strategy.Eve.OAuth,
        client_id: System.get_env(&quot;EVE_APP_ID&quot;),
        client_secret: System.get_env(&quot;EVE_APP_SECRET&quot;)

  &quot;&quot;&quot;
  use OAuth2.Strategy

  @defaults [
    strategy: __MODULE__,
    site: &quot;https://login.eveonline.com&quot;,
    authorize_url: &quot;/v2/oauth/authorize/&quot;,
    token_url: &quot;https://login.eveonline.com/v2/oauth/token&quot;
  ]

  @doc &quot;&quot;&quot;
  Construct a client for requests to Eve.

  This will be setup automatically for you in `Ueberauth.Strategy.Eve`.

  These options are only useful for usage outside the normal callback phase of Ueberauth.
  &quot;&quot;&quot;
  def client(opts \\ []) do
    config = Application.get_env(:ueberauth, __MODULE__, [])

    json_library = Ueberauth.json_library()

    @defaults
    |&gt; Keyword.merge(config)
    |&gt; Keyword.merge(opts)
    |&gt; resolve_values()
    |&gt; generate_client_id()
    |&gt; generate_client_secret()
    |&gt; OAuth2.Client.new()
    |&gt; OAuth2.Client.put_serializer(&quot;application/json&quot;, json_library)
  end

  @doc &quot;&quot;&quot;
  Provides the authorize url for the request phase of Ueberauth. No need to call this usually.
  &quot;&quot;&quot;
  def authorize_url!(params \\ [], opts \\ []) do
    opts
    |&gt; client
    |&gt; OAuth2.Client.authorize_url!(params)
  end

  def get(token, url, headers \\ [], opts \\ []) do
    [token: token]
    |&gt; client
    |&gt; put_param(&quot;response_type&quot;, &quot;code&quot;)
    |&gt; put_param(&quot;client_id&quot;, client().client_id)
    |&gt; put_param(&quot;state&quot;, &quot;ccp_auth_response&quot;)
    |&gt; put_param(&quot;redirect_uri&quot;, &quot;#{WandererApp.Env.base_url()}/auth/eve/callback&quot;)
    |&gt; OAuth2.Client.get(url, headers, opts)
  end

  def get_access_token(params \\ [], opts \\ []) do
    case opts
         |&gt; client
         |&gt; OAuth2.Client.get_token(params ++ [grant_type: &quot;authorization_code&quot;], []) do
      {:ok, %OAuth2.Client{token: token}} -&gt;
        case Map.get(token, :access_token) do
          nil -&gt;
            %{&quot;error&quot; =&gt; error, &quot;error_description&quot; =&gt; description} = token.other_params
            {:error, {error, description}}

          _ -&gt;
            {:ok, token}
        end

      {:error, %OAuth2.Response{body: %{&quot;error&quot; =&gt; error}} = response} -&gt;
        description = Map.get(response.body, &quot;error_description&quot;, &quot;&quot;)
        {:error, {error, description}}

      {:error, %OAuth2.Error{reason: reason}} -&gt;
        {:error, {&quot;error&quot;, to_string(reason)}}
    end
  end

  def get_refresh_token(params \\ [], opts \\ []) do
    case opts
         |&gt; client
         |&gt; refresh_token(params) do
      {:ok, %OAuth2.Client{token: token} = _response} -&gt;
        case Map.get(token, :access_token) do
          nil -&gt;
            %{&quot;error&quot; =&gt; error, &quot;error_description&quot; =&gt; description} = token.other_params
            {:error, {error, description}}

          _ -&gt;
            {:ok, token}
        end

      {:error, %OAuth2.Response{body: %{&quot;error&quot; =&gt; error}} = response} -&gt;
        description = Map.get(response.body, &quot;error_description&quot;, &quot;&quot;)
        {:error, {error, description}}

      {:error, %OAuth2.Response{body: body}} -&gt;
        {:error, to_string(body)}

      {:error, error} -&gt;
        {:error, error}
    end
  end

  # Strategy Callbacks

  def authorize_url(client, params) do
    OAuth2.Strategy.AuthCode.authorize_url(client, params)
  end

  def get_token(client, params, headers) do
    client
    |&gt; put_header(&quot;Accept&quot;, &quot;application/x-www-form-urlencoded&quot;)
    |&gt; put_header(&quot;Host&quot;, &quot;login.eveonline.com&quot;)
    |&gt; merge_params(params)
    |&gt; basic_auth()
    |&gt; put_headers(headers)
  end

  defp resolve_values(list) do
    for {key, value} &lt;- list do
      {key, resolve_value(value)}
    end
  end

  defp resolve_value({m, f, a}) when is_atom(m) and is_atom(f), do: apply(m, f, a)
  defp resolve_value(v), do: v

  defp generate_client_secret(opts) do
    if is_tuple(opts[:client_secret]) do
      {module, fun} = opts[:client_secret]
      secret = apply(module, fun, [opts])
      Keyword.put(opts, :client_secret, secret)
    else
      opts
    end
  end

  defp generate_client_id(opts) do
    if is_tuple(opts[:client_id]) do
      {module, fun} = opts[:client_id]
      secret = apply(module, fun, [opts])
      Keyword.put(opts, :client_id, secret)
    else
      opts
    end
  end
end</file><file path="lib/wanderer_app/ueberauth/strategy/eve.ex">defmodule WandererApp.Ueberauth.Strategy.Eve do
  @moduledoc &quot;&quot;&quot;
  Eve Strategy for √úberauth.
  &quot;&quot;&quot;

  use Ueberauth.Strategy,
    uid_field: &quot;CharacterId&quot;,
    default_scope: &quot;email&quot;,
    hd: nil,
    userinfo_endpoint: &quot;https://login.eveonline.com/oauth/verify&quot;

  alias Ueberauth.Auth.Credentials
  alias Ueberauth.Auth.Extra

  @doc &quot;&quot;&quot;
  Handles initial request for Eve authentication.
  &quot;&quot;&quot;
  def handle_request!(%{params: params} = conn) do
    with_wallet = Map.get(params, &quot;w&quot;, &quot;false&quot;) in ~w(true 1)
    is_admin? = Map.get(params, &quot;admin&quot;, &quot;false&quot;) in ~w(true 1)
    invite_token = Map.get(params, &quot;invite&quot;, nil)

    invite_token_valid =
      case WandererApp.Env.invites() do
        true -&gt;
          case invite_token do
            nil -&gt; false
            token -&gt; WandererApp.Cache.lookup!(&quot;invite_#{token}&quot;, false)
          end

        _ -&gt;
          true
      end

    case invite_token_valid do
      true -&gt;
        scopes =
          cond do
            is_admin? -&gt; option(conn, :admin_scope) || params[&quot;scope&quot;]
            with_wallet -&gt; option(conn, :wallet_scope) || params[&quot;scope&quot;]
            true -&gt; option(conn, :default_scope) || params[&quot;scope&quot;]
          end

        params =
          [scope: scopes]
          |&gt; with_optional(:hd, conn)
          |&gt; with_optional(:prompt, conn)
          |&gt; with_optional(:access_type, conn)
          |&gt; with_optional(:login_hint, conn)
          |&gt; with_optional(:include_granted_scopes, conn)
          |&gt; with_param(:access_type, conn)
          |&gt; with_param(:prompt, conn)
          |&gt; with_param(:login_hint, conn)
          |&gt; with_param(:hl, conn)
          |&gt; with_state_param(conn)

        WandererApp.Cache.put(
          &quot;eve_auth_#{params[:state]}&quot;,
          [with_wallet: with_wallet, is_admin?: is_admin?],
          ttl: :timer.minutes(15)
        )

        opts = oauth_client_options_from_conn(conn, with_wallet, is_admin?)

        redirect!(conn, WandererApp.Ueberauth.Strategy.Eve.OAuth.authorize_url!(params, opts))

      false -&gt;
        conn
        |&gt; redirect!(&quot;/welcome&quot;)
    end
  end

  @doc &quot;&quot;&quot;
  Handles the callback from Eve.
  &quot;&quot;&quot;
  def handle_callback!(%Plug.Conn{params: %{&quot;code&quot; =&gt; code, &quot;state&quot; =&gt; state}} = conn) do
    opts =
      WandererApp.Cache.get(&quot;eve_auth_#{state}&quot;)

    params = [code: code]

    case WandererApp.Ueberauth.Strategy.Eve.OAuth.get_access_token(params, opts) do
      {:ok, token} -&gt;
        fetch_user(conn, token)

      {:error, {error_code, error_description}} -&gt;
        set_errors!(conn, [error(error_code, error_description)])
    end
  end

  @doc false
  def handle_callback!(conn) do
    set_errors!(conn, [error(&quot;missing_code&quot;, &quot;No code received&quot;)])
  end

  @doc false
  def handle_cleanup!(conn) do
    conn
    |&gt; put_private(:eve_user, nil)
    |&gt; put_private(:eve_token, nil)
  end

  @doc &quot;&quot;&quot;
  Fetches the uid field from the response.
  &quot;&quot;&quot;
  def uid(conn) do
    uid_field =
      conn
      |&gt; option(:uid_field)
      |&gt; to_string

    conn.private.eve_user[uid_field]
  end

  @doc &quot;&quot;&quot;
  Includes the credentials from the eve response.
  &quot;&quot;&quot;
  def credentials(conn) do
    token = conn.private.eve_token
    user = conn.private.eve_user

    %Credentials{
      expires: !!token.expires_at,
      expires_at: token.expires_at,
      scopes: user[&quot;Scopes&quot;] || &quot;&quot;,
      token_type: Map.get(token, :token_type),
      refresh_token: token.refresh_token,
      token: token.access_token
    }
  end

  @doc &quot;&quot;&quot;
  Fetches the fields to populate the info section of the `Ueberauth.Auth` struct.
  &quot;&quot;&quot;
  def info(
        %{
          private: %{
            eve_user: %{&quot;CharacterID&quot; =&gt; character_id, &quot;CharacterName&quot; =&gt; character_name}
          }
        } = _conn
      )
      when is_integer(character_id) and is_binary(character_name) do
    %Ueberauth.Auth.Info{
      email: &quot;#{character_id}&quot;,
      name: character_name,
      urls: %{profile: &quot;https://login.eveonline.com/Character/#{character_id}&quot;}
    }
  end

  @doc &quot;&quot;&quot;
  Stores the raw information (including the token) obtained from the google callback.
  &quot;&quot;&quot;
  def extra(conn) do
    %Extra{
      raw_info: %{
        token: conn.private.eve_token,
        user: conn.private.eve_user
      }
    }
  end

  defp fetch_user(conn, token) do
    conn = put_private(conn, :eve_token, token)

    case WandererApp.Ueberauth.Strategy.Eve.OAuth.get(token, get_userinfo_endpoint(conn)) do
      {:ok, %OAuth2.Response{status_code: 401, body: body}} -&gt;
        set_errors!(conn, [error(&quot;token&quot;, &quot;unauthorized&quot; &lt;&gt; body)])

      {:ok, %OAuth2.Response{status_code: status_code, body: user}}
      when status_code in 200..399 -&gt;
        put_private(conn, :eve_user, user)

      {:error, %OAuth2.Response{status_code: status_code}} -&gt;
        set_errors!(conn, [error(&quot;OAuth2&quot;, &quot;#{status_code}&quot;)])

      {:error, %OAuth2.Error{reason: reason}} -&gt;
        set_errors!(conn, [error(&quot;OAuth2&quot;, reason)])
    end
  end

  defp get_userinfo_endpoint(conn) do
    case option(conn, :userinfo_endpoint) do
      {:system, varname, default} -&gt;
        System.get_env(varname) || default

      {:system, varname} -&gt;
        System.get_env(varname) || Keyword.get(default_options(), :userinfo_endpoint)

      other -&gt;
        other
    end
  end

  defp with_param(opts, key, conn) do
    if value = conn.params[to_string(key)], do: Keyword.put(opts, key, value), else: opts
  end

  defp with_optional(opts, key, conn) do
    if option(conn, key), do: Keyword.put(opts, key, option(conn, key)), else: opts
  end

  defp oauth_client_options_from_conn(conn, with_wallet, is_admin?) do
    base_options = [
      redirect_uri: callback_url(conn),
      with_wallet: with_wallet,
      is_admin?: is_admin?
    ]

    request_options = conn.private[:ueberauth_request_options].options

    case {request_options[:client_id], request_options[:client_secret]} do
      {nil, _} -&gt; base_options
      {_, nil} -&gt; base_options
      {id, secret} -&gt; [client_id: id, client_secret: secret] ++ base_options
    end
  end

  defp option(conn, key) do
    Keyword.get(options(conn), key, Keyword.get(default_options(), key))
  end
end</file><file path="lib/wanderer_app/ueberauth/uberauth.ex">defmodule WandererApp.Ueberauth do
  @moduledoc false

  def client_id(opts \\ []) do
    config = _get_config()

    cond do
      Keyword.get(opts, :is_admin?) -&gt; config[:client_id_with_corp_wallet]
      Keyword.get(opts, :with_wallet) -&gt; config[:client_id_with_wallet]
      true -&gt; config[:client_id_default]
    end
  end

  def client_secret(opts \\ []) do
    config = _get_config()

    cond do
      Keyword.get(opts, :is_admin?) -&gt; config[:client_secret_with_corp_wallet]
      Keyword.get(opts, :with_wallet) -&gt; config[:client_secret_with_wallet]
      true -&gt; config[:client_secret_default]
    end
  end

  defp _get_config() do
    Application.get_env(:ueberauth, WandererApp.Ueberauth.Strategy.Eve.OAuth, [])
  end
end</file><file path="lib/wanderer_app/user/user_activity_tracker.ex">defmodule WandererApp.User.ActivityTracker do
  @moduledoc false
  require Logger

  def track_map_event(
        event_type,
        metadata
      ),
      do: WandererApp.Map.Audit.track_map_event(event_type, metadata)

  def track_acl_event(
        event_type,
        metadata
      ),
      do: WandererApp.Map.Audit.track_acl_event(event_type, metadata)
end</file><file path="lib/wanderer_app/utils/cache.ex">defmodule WandererApp.Utils.Cache do
  @moduledoc false

  defmacro __using__(ops) do
    name =
      case Keyword.fetch(ops, :name) do
        {:ok, n} -&gt; n
        _ -&gt; raise &quot;name parameter is mandatory&quot;
      end

    quote location: :keep do
      # quote do
      require Logger

      def name(), do: unquote(name)

      def lookup(key, default \\ nil)

      def lookup({id, key}, default) when is_binary(id) and is_binary(key),
        do: lookup(&quot;#{id}:#{key}&quot;, default)

      def lookup(key, default) when is_binary(key) do
        case Cachex.get(name(), key) do
          {:ok, nil} -&gt; {:ok, default}
          {:ok, value} -&gt; {:ok, value}
        end
      end

      def lookup!(key, default \\ nil)

      def lookup!({id, key}, default) when is_binary(id) and is_binary(key),
        do: lookup!(&quot;#{id}:#{key}&quot;, default)

      def lookup!(key, default) when is_binary(key) do
        {:ok, result} = lookup(key, default)
        result
      end

      def insert(key, value, options \\ [])

      def insert({id, key}, value, options) when is_binary(id) and is_binary(key),
        do: insert(&quot;#{id}:#{key}&quot;, value, options)

      def insert(key, value, options) when is_binary(key) do
        Cachex.put(name(), key, value, options)
        :ok
      end

      def insert_or_update(key, value, update_fn, options \\ [])

      def insert_or_update({id, key}, value, update_fn, options)
          when is_binary(id) and is_binary(key),
          do: insert_or_update(&quot;#{id}:#{key}&quot;, value, update_fn, options)

      def insert_or_update(key, value, update_fn, options) when is_binary(key) do
        case lookup(key) do
          {:ok, nil} -&gt;
            insert(key, value, options)

          {:ok, data} -&gt;
            insert(key, update_fn.(data), options)
        end
      end

      def exists?({id, key}) when is_binary(id) and is_binary(key), do: exists?(&quot;#{id}:#{key}&quot;)

      def exists?(key) when is_binary(key), do: Cachex.exists?(name(), key)

      def delete(key, options \\ [])

      def delete({id, key}, options) when is_binary(id) and is_binary(key),
        do: delete(&quot;#{id}:#{key}&quot;, options)

      def delete(key, options) when is_binary(key), do: Cachex.del(name(), key, options)
    end
  end
end</file><file path="lib/wanderer_app/utils/CSVUtil.ex">defmodule WandererApp.Utils.CSVUtil do
  @moduledoc false

  alias NimbleCSV.RFC4180, as: CSV

  def get_column_names(file) do
    file
    |&gt; File.stream!()
    |&gt; CSV.parse_stream(skip_headers: false)
    |&gt; Enum.fetch!(0)
    |&gt; Enum.with_index()
    |&gt; Map.new(fn {val, num} -&gt; {num, val} end)
  end

  def csv_row_to_table_record(file, mapper) do
    column_names = get_column_names(file)

    file
    |&gt; File.stream!()
    |&gt; CSV.parse_stream(skip_headers: true)
    |&gt; Enum.map(fn row -&gt;
      row
      |&gt; Enum.with_index()
      |&gt; Map.new(fn {val, num} -&gt; {column_names[num], val} end)
      |&gt; mapper.()
    end)
  end
end</file><file path="lib/wanderer_app/utils/eve_util.ex">defmodule WandererApp.Utils.EVEUtil do
  @moduledoc &quot;&quot;&quot;
  Utility functions for EVE Online related operations.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Generates a URL for a character portrait.

  ## Parameters
    * `eve_id` - The EVE Online character ID
    * `size` - The size of the portrait (default: 64)

  ## Examples
      iex&gt; WandererApp.Utils.EVEUtil.get_portrait_url(12345678)
      &quot;https://images.evetech.net/characters/12345678/portrait?size=64&quot;

      iex&gt; WandererApp.Utils.EVEUtil.get_portrait_url(12345678, 128)
      &quot;https://images.evetech.net/characters/12345678/portrait?size=128&quot;
  &quot;&quot;&quot;
  def get_portrait_url(eve_id, size \\ 64)
  def get_portrait_url(nil, size), do: &quot;https://images.evetech.net/characters/0/portrait?size=#{size}&quot;
  def get_portrait_url(&quot;&quot;, size), do: &quot;https://images.evetech.net/characters/0/portrait?size=#{size}&quot;
  def get_portrait_url(eve_id, size) do
    &quot;https://images.evetech.net/characters/#{eve_id}/portrait?size=#{size}&quot;
  end
end</file><file path="lib/wanderer_app/utils/http_util.ex">defmodule WandererApp.Utils.HttpUtil do
  @moduledoc &quot;&quot;&quot;
  Utility functions for HTTP operations and error handling.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Determines if an HTTP error is retriable.

  Returns `true` for common transient errors like timeouts and server errors (500, 502, 503, 504).
  &quot;&quot;&quot;
  def retriable_error?(:timeout), do: true
  def retriable_error?(&quot;Unexpected status: 500&quot;), do: true
  def retriable_error?(&quot;Unexpected status: 502&quot;), do: true
  def retriable_error?(&quot;Unexpected status: 503&quot;), do: true
  def retriable_error?(&quot;Unexpected status: 504&quot;), do: true
  def retriable_error?(&quot;Request failed&quot;), do: true
  def retriable_error?(_), do: false
end</file><file path="lib/wanderer_app/utils/JSONUtil.ex">defmodule WandererApp.Utils.JSONUtil do
  @moduledoc false

  def read_json(filename) do
    {:ok, body} = File.read(filename)
    Jason.decode(body)
  end

  def read_json!(filename),
    do:
      filename
      |&gt; File.read!()
      |&gt; Jason.decode!()
end</file><file path="lib/wanderer_app/zkb/zkills_provider/cache.ex">defmodule WandererApp.Zkb.KillsProvider.KillsCache do
  @moduledoc &quot;&quot;&quot;
  Provides helper functions for putting/fetching kill data
  &quot;&quot;&quot;

  require Logger
  alias WandererApp.Cache

  @killmail_ttl :timer.hours(24)
  @system_kills_ttl :timer.hours(1)

  # Base (average) expiry of 15 minutes for &quot;recently fetched&quot; systems
  @base_full_fetch_expiry_ms 900_000
  @jitter_percent 0.1

  def killmail_ttl, do: @killmail_ttl
  def system_kills_ttl, do: @system_kills_ttl

  @doc &quot;&quot;&quot;
  Store the killmail data, keyed by killmail_id, with a 24h TTL.
  &quot;&quot;&quot;
  def put_killmail(killmail_id, kill_data) do
    Logger.debug(fn -&gt; &quot;[KillsCache] Storing killmail =&gt; killmail_id=#{killmail_id}&quot; end)
    Cache.put(killmail_key(killmail_id), kill_data, ttl: @killmail_ttl)
  end

  @doc &quot;&quot;&quot;
  Fetch kills for `system_id` from the local cache only.
  Returns a list of killmail maps (could be empty).
  &quot;&quot;&quot;
  def fetch_cached_kills(system_id) do
    killmail_ids = get_system_killmail_ids(system_id)
    Logger.debug(fn -&gt; &quot;[KillsCache] fetch_cached_kills =&gt; system_id=#{system_id}, count=#{length(killmail_ids)}&quot; end)

    killmail_ids
    |&gt; Enum.map(&amp;get_killmail/1)
    |&gt; Enum.reject(&amp;is_nil/1)
  end

  @doc &quot;&quot;&quot;
  Fetch cached kills for multiple solar system IDs.
  Returns a map of `%{ solar_system_id =&gt; list_of_kills }`.
  &quot;&quot;&quot;
  def fetch_cached_kills_for_systems(system_ids) when is_list(system_ids) do
    Enum.reduce(system_ids, %{}, fn sid, acc -&gt;
      kills_list = fetch_cached_kills(sid)
      Map.put(acc, sid, kills_list)
    end)
  end

  @doc &quot;&quot;&quot;
  Fetch the killmail data (if any) from the cache, by killmail_id.
  &quot;&quot;&quot;
  def get_killmail(killmail_id) do
    Cache.get(killmail_key(killmail_id))
  end

  @doc &quot;&quot;&quot;
  Adds `killmail_id` to the list of killmail IDs for the system
  if it‚Äôs not already present. The TTL is 24 hours.
  &quot;&quot;&quot;
  def add_killmail_id_to_system_list(solar_system_id, killmail_id) do
    Cache.update(
      system_kills_list_key(solar_system_id),
      [],
      fn existing_list -&gt;
        existing_list = existing_list || []
        if killmail_id in existing_list do
          existing_list
        else
          existing_list ++ [killmail_id]
        end
      end,
      ttl: @killmail_ttl
    )
  end

  @doc &quot;&quot;&quot;
  Returns a list of killmail IDs for the given system, or [] if none.
  &quot;&quot;&quot;
  def get_system_killmail_ids(solar_system_id) do
    Cache.get(system_kills_list_key(solar_system_id)) || []
  end

  @doc &quot;&quot;&quot;
  Increments the kill count for a system by `amount`. The TTL is 1 hour.
  &quot;&quot;&quot;
  def incr_system_kill_count(solar_system_id, amount \\ 1) do
    Cache.incr(
      system_kills_key(solar_system_id),
      amount,
      default: 0,
      ttl: @system_kills_ttl
    )
  end

  @doc &quot;&quot;&quot;
  Returns the integer count of kills for this system in the last hour, or 0.
  &quot;&quot;&quot;
  def get_system_kill_count(solar_system_id) do
    Cache.get(system_kills_key(solar_system_id)) || 0
  end

  @doc &quot;&quot;&quot;
  Check if the system is still in its &quot;recently fetched&quot; window.
  We store an `expires_at` timestamp (in ms). If `now &lt; expires_at`,
  this system is still considered &quot;recently fetched&quot;.
  &quot;&quot;&quot;
  def recently_fetched?(system_id) do
    case Cache.lookup(fetched_timestamp_key(system_id)) do
      {:ok, expires_at_ms} when is_integer(expires_at_ms) -&gt;
        now_ms = current_time_ms()
        now_ms &lt; expires_at_ms

      _ -&gt;
        false
    end
  end

  @doc &quot;&quot;&quot;
  Puts a jittered `expires_at` in the cache for `system_id`,
  marking it as fully fetched for ~15 minutes (+/- 10%).
  &quot;&quot;&quot;
  def put_full_fetched_timestamp(system_id) do
    now_ms = current_time_ms()
    max_jitter = round(@base_full_fetch_expiry_ms * @jitter_percent)
    # random offset in range [-max_jitter..+max_jitter]
    offset = :rand.uniform(2 * max_jitter + 1) - (max_jitter + 1)
    final_expiry_ms = max(@base_full_fetch_expiry_ms + offset, 60_000)
    expires_at_ms = now_ms + final_expiry_ms

    Logger.debug(fn -&gt; &quot;[KillsCache] Marking system=#{system_id} recently_fetched? until #{expires_at_ms} (ms)&quot; end)
    Cache.put(fetched_timestamp_key(system_id), expires_at_ms)
  end

  @doc &quot;&quot;&quot;
  Returns how many ms remain until this system&apos;s &quot;recently fetched&quot; window ends.
  If it&apos;s already expired (or doesn&apos;t exist), returns -1.
  &quot;&quot;&quot;
  def fetch_age_ms(system_id) do
    now_ms = current_time_ms()

    case Cache.lookup(fetched_timestamp_key(system_id)) do
      {:ok, expires_at_ms} when is_integer(expires_at_ms) -&gt;
        if now_ms &lt; expires_at_ms do
          expires_at_ms - now_ms
        else
          -1
        end

      _ -&gt;
        -1
    end
  end

  defp killmail_key(killmail_id), do: &quot;zkb_killmail_#{killmail_id}&quot;
  defp system_kills_key(solar_system_id), do: &quot;zkb_kills_#{solar_system_id}&quot;
  defp system_kills_list_key(solar_system_id), do: &quot;zkb_kills_list_#{solar_system_id}&quot;
  defp fetched_timestamp_key(system_id), do: &quot;zkb_system_fetched_at_#{system_id}&quot;

  defp current_time_ms() do
    DateTime.utc_now() |&gt; DateTime.to_unix(:millisecond)
  end
end</file><file path="lib/wanderer_app/zkb/zkills_provider/fetcher.ex">defmodule WandererApp.Zkb.KillsProvider.Fetcher do
  @moduledoc &quot;&quot;&quot;
  Low-level API for fetching killmails from zKillboard + ESI.
  &quot;&quot;&quot;

  require Logger
  use Retry

  alias WandererApp.Zkb.KillsProvider.{Parser, KillsCache, ZkbApi}
  alias WandererApp.Utils.HttpUtil

  @page_size 200
  @max_pages 2

  @doc &quot;&quot;&quot;
  Fetch killmails for multiple systems, returning a map of system_id =&gt; kills.
  &quot;&quot;&quot;
  def fetch_kills_for_systems(system_ids, since_hours, state, _opts \\ []) when is_list(system_ids) do
    try do
      {final_map, final_state} =
        Enum.reduce(system_ids, {%{}, state}, fn sid, {acc_map, acc_st} -&gt;
          case fetch_kills_for_system(sid, since_hours, acc_st) do
            {:ok, kills, new_st} -&gt;
              {Map.put(acc_map, sid, kills), new_st}

            {:error, reason, new_st} -&gt;
              Logger.debug(fn -&gt; &quot;[Fetcher] system=#{sid} =&gt; error=#{inspect(reason)}&quot; end)
              {Map.put(acc_map, sid, {:error, reason}), new_st}
          end
        end)

      Logger.debug(fn -&gt; &quot;[Fetcher] fetch_kills_for_systems =&gt; done, final_map_size=#{map_size(final_map)} calls=#{final_state.calls_count}&quot; end)
      {:ok, final_map}
    rescue
      e -&gt;
        Logger.error(&quot;[Fetcher] EXCEPTION in fetch_kills_for_systems =&gt; #{Exception.message(e)}&quot;)
        {:error, e}
    end
  end

  @doc &quot;&quot;&quot;
  Fetch killmails for a single system within `since_hours` cutoff.

  Options:
    - `:limit` =&gt; integer limit on how many kills to fetch (optional).
      If `limit` is nil (or not set), we fetch until we exhaust pages or older kills.
    - `:force` =&gt; if true, ignore the &quot;recently fetched&quot; check and forcibly refetch.

  Returns `{:ok, kills, updated_state}` on success, or `{:error, reason, updated_state}`.
  &quot;&quot;&quot;
  def fetch_kills_for_system(system_id, since_hours, state, opts \\ []) do
    limit = Keyword.get(opts, :limit, nil)
    force? = Keyword.get(opts, :force, false)

    log_prefix = &quot;[Fetcher] fetch_kills_for_system =&gt; system=#{system_id}&quot;

    # Check the &quot;recently fetched&quot; cache if not forced
    if not force? and KillsCache.recently_fetched?(system_id) do
      cached_kills = KillsCache.fetch_cached_kills(system_id)
      final = maybe_take(cached_kills, limit)
      Logger.debug(fn -&gt; &quot;#{log_prefix}, recently_fetched?=true =&gt; returning #{length(final)} cached kills&quot; end)
      {:ok, final, state}
    else
      Logger.debug(fn -&gt; &quot;#{log_prefix}, hours=#{since_hours}, limit=#{inspect(limit)}, force=#{force?}&quot; end)

      cutoff_dt = hours_ago(since_hours)

      result =
        retry with: exponential_backoff(300)
               |&gt; randomize()
               |&gt; cap(5_000)
               |&gt; expiry(120_000) do
          case do_multi_page_fetch(system_id, cutoff_dt, 1, 0, limit, state) do
            {:ok, new_st, total_fetched} -&gt;
              # Mark system as fully fetched (to prevent repeated calls).
              KillsCache.put_full_fetched_timestamp(system_id)
              final_kills = KillsCache.fetch_cached_kills(system_id) |&gt; maybe_take(limit)

              Logger.debug(fn -&gt;
                &quot;#{log_prefix}, total_fetched=#{total_fetched}, final_cached=#{length(final_kills)}, calls_count=#{new_st.calls_count}&quot;
              end)

              {:ok, final_kills, new_st}

            {:error, :rate_limited, _new_st} -&gt;
              raise &quot;:rate_limited&quot;

            {:error, reason, _new_st} -&gt;
              raise &quot;#{log_prefix}, reason=#{inspect(reason)}&quot;
          end
        end

      case result do
        {:ok, kills, new_st} -&gt;
          {:ok, kills, new_st}

        error -&gt;
          Logger.error(&quot;#{log_prefix}, EXHAUSTED =&gt; error=#{inspect(error)}&quot;)
          {:error, error, state}
      end
    end
  rescue
    e -&gt;
      Logger.error(&quot;[Fetcher] EXCEPTION in fetch_kills_for_system =&gt; #{Exception.message(e)}&quot;)
      {:error, e, state}
  end

  defp do_multi_page_fetch(_system_id, _cutoff_dt, page, total_so_far, _limit, state)
       when page &gt; @max_pages do
    # No more pages
    {:ok, state, total_so_far}
  end

  defp do_multi_page_fetch(system_id, cutoff_dt, page, total_so_far, limit, state) do
    Logger.debug(
      &quot;[Fetcher] do_multi_page_fetch =&gt; system=#{system_id}, page=#{page}, total_so_far=#{total_so_far}, limit=#{inspect(limit)}&quot;
    )

    with {:ok, st1} &lt;- increment_calls_count(state),
         {:ok, st2, partials} &lt;- ZkbApi.fetch_and_parse_page(system_id, page, st1) do
      Logger.debug(fn -&gt; &quot;[Fetcher] system=#{system_id}, page=#{page}, partials_count=#{length(partials)}&quot; end)

      {_count_stored, older_found?, total_now} =
        Enum.reduce_while(partials, {0, false, total_so_far}, fn partial, {acc_count, had_older, acc_total} -&gt;
          # If we have a limit and reached it, stop immediately
          if reached_limit?(limit, acc_total) do
            {:halt, {acc_count, had_older, acc_total}}
          else
            case parse_partial(partial, cutoff_dt) do
              :older -&gt;
                # Found an older kill =&gt; we can halt the entire multi-page fetch
                {:halt, {acc_count, true, acc_total}}

              :ok -&gt;
                {:cont, {acc_count + 1, false, acc_total + 1}}

              :skip -&gt;
                {:cont, {acc_count, had_older, acc_total}}
            end
          end
        end)

      cond do
        # If we found older kills, stop now
        older_found? -&gt;
          {:ok, st2, total_now}

        # If we have a limit and just reached or exceeded it
        reached_limit?(limit, total_now) -&gt;
          {:ok, st2, total_now}

        # If partials &lt; @page_size, no more kills are left
        length(partials) &lt; @page_size -&gt;
          {:ok, st2, total_now}

        # Otherwise, keep going to next page
        true -&gt;
          do_multi_page_fetch(system_id, cutoff_dt, page + 1, total_now, limit, st2)
      end
    else
      {:error, :rate_limited, stx} -&gt;
        {:error, :rate_limited, stx}

      {:error, reason, stx} -&gt;
        {:error, reason, stx}

      other -&gt;
        Logger.warning(&quot;[Fetcher] Unexpected result =&gt; #{inspect(other)}&quot;)
        {:error, :unexpected, state}
    end
  end

  defp parse_partial(%{&quot;killmail_id&quot; =&gt; kill_id, &quot;zkb&quot; =&gt; %{&quot;hash&quot; =&gt; kill_hash}} = partial, cutoff_dt) do
    # If we&apos;ve already cached this kill, skip
    if KillsCache.get_killmail(kill_id) do
      :skip
    else
      # Actually fetch the full kill from ESI
      case fetch_full_killmail(kill_id, kill_hash) do
        {:ok, full_km} -&gt;
          # Delegate the time check &amp; storing to Parser
          Parser.parse_full_and_store(full_km, partial, cutoff_dt)

        {:error, reason} -&gt;
          Logger.warning(&quot;[Fetcher] ESI fail =&gt; kill_id=#{kill_id}, reason=#{inspect(reason)}&quot;)
          :skip
      end
    end
  end

  defp parse_partial(_other, _cutoff_dt), do: :skip

  defp fetch_full_killmail(k_id, k_hash) do
    retry with: exponential_backoff(300) |&gt; randomize() |&gt; cap(5_000) |&gt; expiry(30_000), rescue_only: [RuntimeError] do
      case WandererApp.Esi.get_killmail(k_id, k_hash) do
        {:ok, full_km} -&gt;
          {:ok, full_km}

        {:error, :timeout} -&gt;
          Logger.warning(&quot;[Fetcher] ESI get_killmail timeout =&gt; kill_id=#{k_id}, retrying...&quot;)
          raise &quot;ESI timeout, will retry&quot;

        {:error, :not_found} -&gt;
          Logger.warning(&quot;[Fetcher] ESI get_killmail not_found =&gt; kill_id=#{k_id}&quot;)
          {:error, :not_found}

        {:error, reason} -&gt;
          if HttpUtil.retriable_error?(reason) do
            Logger.warning(&quot;[Fetcher] ESI get_killmail retriable error =&gt; kill_id=#{k_id}, reason=#{inspect(reason)}&quot;)
            raise &quot;ESI error: #{inspect(reason)}, will retry&quot;
          else
            Logger.warning(&quot;[Fetcher] ESI get_killmail failed =&gt; kill_id=#{k_id}, reason=#{inspect(reason)}&quot;)
            {:error, reason}
          end
      end
    end
  end

  defp hours_ago(h),
    do: DateTime.utc_now() |&gt; DateTime.add(-h * 3600, :second)

  defp increment_calls_count(%{calls_count: c} = st),
    do: {:ok, %{st | calls_count: c + 1}}

  defp reached_limit?(nil, _count_so_far), do: false
  defp reached_limit?(limit, count_so_far) when is_integer(limit),
    do: count_so_far &gt;= limit

  defp maybe_take(kills, nil), do: kills
  defp maybe_take(kills, limit), do: Enum.take(kills, limit)
end</file><file path="lib/wanderer_app/zkb/zkills_provider/parser.ex">defmodule WandererApp.Zkb.KillsProvider.Parser do
  @moduledoc &quot;&quot;&quot;
  Helper for parsing &amp; storing a killmail from the ESI data (plus zKB partial).
  Responsible for:
    - Parsing the raw JSON structures,
    - Combining partial &amp; full kill data,
    - Checking whether kills are &apos;too old&apos;,
    - Storing in KillsCache, etc.
  &quot;&quot;&quot;

  require Logger
  alias WandererApp.Zkb.KillsProvider.KillsCache
  alias WandererApp.Utils.HttpUtil
  use Retry

  # Maximum retries for enrichment calls

  @doc &quot;&quot;&quot;
  Merges the &apos;partial&apos; from zKB and the &apos;full&apos; killmail from ESI, checks its time
  vs. `cutoff_dt`.

  Returns:
    - `:ok` if we parsed &amp; stored successfully,
    - `:older` if killmail time is older than `cutoff_dt`,
    - `:skip` if we cannot parse or store for some reason.
  &quot;&quot;&quot;
  def parse_full_and_store(full_km, partial_zkb, cutoff_dt) when is_map(full_km) do
    # Attempt to parse the killmail_time
    case parse_killmail_time(full_km) do
      {:ok, km_dt} -&gt;
        if older_than_cutoff?(km_dt, cutoff_dt) do
          :older
        else
          # Merge the &quot;zkb&quot; portion from the partial into the full killmail
          enriched = Map.merge(full_km, %{&quot;zkb&quot; =&gt; partial_zkb[&quot;zkb&quot;]})
          parse_and_store_killmail(enriched)
        end

      _ -&gt;
        :skip
    end
  end

  def parse_full_and_store(_full_km, _partial_zkb, _cutoff_dt),
    do: :skip

  @doc &quot;&quot;&quot;
  Parse a raw killmail (`full_km`) and store it if valid.
  Returns:
    - `:ok` if successfully parsed &amp; stored,
    - `:skip` otherwise
  &quot;&quot;&quot;
  def parse_and_store_killmail(%{&quot;killmail_id&quot; =&gt; _kill_id} = full_km) do
    parsed_map = do_parse(full_km)

    if is_nil(parsed_map) or is_nil(parsed_map[&quot;kill_time&quot;]) do
      :skip
    else
      store_killmail(parsed_map)
      :ok
    end
  end

  def parse_and_store_killmail(_),
    do: :skip

  defp do_parse(%{&quot;killmail_id&quot; =&gt; kill_id} = km) do
    victim = Map.get(km, &quot;victim&quot;, %{})
    attackers = Map.get(km, &quot;attackers&quot;, [])

    kill_time_dt =
      case DateTime.from_iso8601(&quot;#{Map.get(km, &quot;killmail_time&quot;, &quot;&quot;)}&quot;) do
        {:ok, dt, _off} -&gt; dt
        _ -&gt; nil
      end

    npc_flag = get_in(km, [&quot;zkb&quot;, &quot;npc&quot;]) || false

    %{
      &quot;killmail_id&quot; =&gt; kill_id,
      &quot;kill_time&quot; =&gt; kill_time_dt,
      &quot;solar_system_id&quot; =&gt; km[&quot;solar_system_id&quot;],
      &quot;zkb&quot; =&gt; Map.get(km, &quot;zkb&quot;, %{}),
      &quot;attacker_count&quot; =&gt; length(attackers),
      &quot;total_value&quot; =&gt; get_in(km, [&quot;zkb&quot;, &quot;totalValue&quot;]) || 0,
      &quot;victim&quot; =&gt; victim,
      &quot;attackers&quot; =&gt; attackers,
      &quot;npc&quot; =&gt; npc_flag
    }
  end

  defp do_parse(_),
    do: nil

  @doc &quot;&quot;&quot;
  Extracts &amp; returns {:ok, DateTime} from the &quot;killmail_time&quot; field, or :skip on failure.
  &quot;&quot;&quot;
  def parse_killmail_time(full_km) do
    killmail_time_str = Map.get(full_km, &quot;killmail_time&quot;, &quot;&quot;)

    case DateTime.from_iso8601(killmail_time_str) do
      {:ok, dt, _offset} -&gt;
        {:ok, dt}

      _ -&gt;
        :skip
    end
  end

  defp older_than_cutoff?(%DateTime{} = dt, %DateTime{} = cutoff_dt),
    do: DateTime.compare(dt, cutoff_dt) == :lt

  defp store_killmail(%{&quot;killmail_id&quot; =&gt; nil}), do: :ok

  defp store_killmail(%{&quot;killmail_id&quot; =&gt; kill_id} = parsed) do
    final = build_kill_data(parsed)

    if final do
      enriched = maybe_enrich_killmail(final)
      KillsCache.put_killmail(kill_id, enriched)

      system_id = enriched[&quot;solar_system_id&quot;]
      KillsCache.add_killmail_id_to_system_list(system_id, kill_id)

      if within_last_hour?(enriched[&quot;kill_time&quot;]) do
        KillsCache.incr_system_kill_count(system_id)
      end
    else
      Logger.warning(&quot;[Parser] store_killmail =&gt; build_kill_data returned nil for kill_id=#{kill_id}&quot;)
    end
  end

  defp store_killmail(_),
    do: :ok

  defp build_kill_data(%{
         &quot;killmail_id&quot; =&gt; kill_id,
         &quot;kill_time&quot; =&gt; kill_time_dt,
         &quot;solar_system_id&quot; =&gt; sys_id,
         &quot;zkb&quot; =&gt; zkb,
         &quot;victim&quot; =&gt; victim,
         &quot;attackers&quot; =&gt; attackers,
         &quot;attacker_count&quot; =&gt; attacker_count,
         &quot;total_value&quot; =&gt; total_value,
         &quot;npc&quot; =&gt; npc
       }) do

    victim_map = extract_victim_fields(victim)
    final_blow_map = extract_final_blow_fields(attackers)

    %{
      &quot;killmail_id&quot; =&gt; kill_id,
      &quot;kill_time&quot; =&gt; kill_time_dt,
      &quot;solar_system_id&quot; =&gt; sys_id,
      &quot;zkb&quot; =&gt; zkb,

      &quot;victim_char_id&quot; =&gt; victim_map.char_id,
      &quot;victim_corp_id&quot; =&gt; victim_map.corp_id,
      &quot;victim_alliance_id&quot; =&gt; victim_map.alliance_id,
      &quot;victim_ship_type_id&quot; =&gt; victim_map.ship_type_id,

      &quot;final_blow_char_id&quot; =&gt; final_blow_map.char_id,
      &quot;final_blow_corp_id&quot; =&gt; final_blow_map.corp_id,
      &quot;final_blow_alliance_id&quot; =&gt; final_blow_map.alliance_id,
      &quot;final_blow_ship_type_id&quot; =&gt; final_blow_map.ship_type_id,

      &quot;attacker_count&quot; =&gt; attacker_count,
      &quot;total_value&quot; =&gt; total_value,
      &quot;npc&quot; =&gt; npc
    }
  end

  defp build_kill_data(_),
    do: nil

  defp extract_victim_fields(%{
         &quot;character_id&quot; =&gt; cid,
         &quot;corporation_id&quot; =&gt; corp,
         &quot;alliance_id&quot; =&gt; alli,
         &quot;ship_type_id&quot; =&gt; st_id
       }),
    do: %{char_id: cid, corp_id: corp, alliance_id: alli, ship_type_id: st_id}

  defp extract_victim_fields(%{
         &quot;character_id&quot; =&gt; cid,
         &quot;corporation_id&quot; =&gt; corp,
         &quot;ship_type_id&quot; =&gt; st_id
       }),
    do: %{char_id: cid, corp_id: corp, alliance_id: nil, ship_type_id: st_id}

  defp extract_victim_fields(_),
    do: %{char_id: nil, corp_id: nil, alliance_id: nil, ship_type_id: nil}

  defp extract_final_blow_fields(attackers) when is_list(attackers) do
    final = Enum.find(attackers, fn a -&gt; a[&quot;final_blow&quot;] == true end)
    extract_attacker_fields(final)
  end

  defp extract_final_blow_fields(_),
    do: %{char_id: nil, corp_id: nil, alliance_id: nil, ship_type_id: nil}

  defp extract_attacker_fields(nil),
    do: %{char_id: nil, corp_id: nil, alliance_id: nil, ship_type_id: nil}

  defp extract_attacker_fields(%{
         &quot;character_id&quot; =&gt; cid,
         &quot;corporation_id&quot; =&gt; corp,
         &quot;alliance_id&quot; =&gt; alli,
         &quot;ship_type_id&quot; =&gt; st_id
       }),
    do: %{char_id: cid, corp_id: corp, alliance_id: alli, ship_type_id: st_id}

  defp extract_attacker_fields(%{
         &quot;character_id&quot; =&gt; cid,
         &quot;corporation_id&quot; =&gt; corp,
         &quot;ship_type_id&quot; =&gt; st_id
       }),
    do: %{char_id: cid, corp_id: corp, alliance_id: nil, ship_type_id: st_id}

  defp extract_attacker_fields(%{&quot;ship_type_id&quot; =&gt; st_id} = attacker) do
    %{
      char_id: Map.get(attacker, &quot;character_id&quot;),
      corp_id: Map.get(attacker, &quot;corporation_id&quot;),
      alliance_id: Map.get(attacker, &quot;alliance_id&quot;),
      ship_type_id: st_id
    }
  end

  defp extract_attacker_fields(_),
    do: %{char_id: nil, corp_id: nil, alliance_id: nil, ship_type_id: nil}

  defp maybe_enrich_killmail(km) do
    km
    |&gt; enrich_victim()
    |&gt; enrich_final_blow()
  end


  defp enrich_victim(km) do
    km
    |&gt; maybe_put_character_name(&quot;victim_char_id&quot;, &quot;victim_char_name&quot;)
    |&gt; maybe_put_corp_info(&quot;victim_corp_id&quot;, &quot;victim_corp_ticker&quot;, &quot;victim_corp_name&quot;)
    |&gt; maybe_put_alliance_info(&quot;victim_alliance_id&quot;, &quot;victim_alliance_ticker&quot;, &quot;victim_alliance_name&quot;)
    |&gt; maybe_put_ship_name(&quot;victim_ship_type_id&quot;, &quot;victim_ship_name&quot;)
  end


  defp enrich_final_blow(km) do
    km
    |&gt; maybe_put_character_name(&quot;final_blow_char_id&quot;, &quot;final_blow_char_name&quot;)
    |&gt; maybe_put_corp_info(&quot;final_blow_corp_id&quot;, &quot;final_blow_corp_ticker&quot;, &quot;final_blow_corp_name&quot;)
    |&gt; maybe_put_alliance_info(&quot;final_blow_alliance_id&quot;, &quot;final_blow_alliance_ticker&quot;, &quot;final_blow_alliance_name&quot;)
    |&gt; maybe_put_ship_name(&quot;final_blow_ship_type_id&quot;, &quot;final_blow_ship_name&quot;)
  end

  defp maybe_put_character_name(km, id_key, name_key) do
    case Map.get(km, id_key) do
      nil -&gt; km
      0 -&gt; km
      eve_id -&gt;
        result = retry with: exponential_backoff(200) |&gt; randomize() |&gt; cap(2_000) |&gt; expiry(10_000), rescue_only: [RuntimeError] do
          case WandererApp.Esi.get_character_info(eve_id) do
            {:ok, %{&quot;name&quot; =&gt; char_name}} -&gt;
              {:ok, char_name}

            {:error, :timeout} -&gt;
              Logger.debug(fn -&gt; &quot;[Parser] Character info timeout, retrying =&gt; id=#{eve_id}&quot; end)
              raise &quot;Character info timeout, will retry&quot;

            {:error, :not_found} -&gt;
              Logger.debug(fn -&gt; &quot;[Parser] Character not found =&gt; id=#{eve_id}&quot; end)
              :skip

            {:error, reason} -&gt;
              if HttpUtil.retriable_error?(reason) do
                Logger.debug(fn -&gt; &quot;[Parser] Character info retriable error =&gt; id=#{eve_id}, reason=#{inspect(reason)}&quot; end)
                raise &quot;Character info error: #{inspect(reason)}, will retry&quot;
              else
                Logger.debug(fn -&gt; &quot;[Parser] Character info failed =&gt; id=#{eve_id}, reason=#{inspect(reason)}&quot; end)
                :skip
              end
          end
        end

        case result do
          {:ok, char_name} -&gt; Map.put(km, name_key, char_name)
          _ -&gt; km
        end
    end
  end

  defp maybe_put_corp_info(km, id_key, ticker_key, name_key) do
    case Map.get(km, id_key) do
      nil -&gt; km
      0 -&gt; km
      corp_id -&gt;
        result = retry with: exponential_backoff(200) |&gt; randomize() |&gt; cap(2_000) |&gt; expiry(10_000), rescue_only: [RuntimeError] do
          case WandererApp.Esi.get_corporation_info(corp_id) do
            {:ok, %{&quot;ticker&quot; =&gt; ticker, &quot;name&quot; =&gt; corp_name}} -&gt;
              {:ok, {ticker, corp_name}}

            {:error, :timeout} -&gt;
              Logger.debug(fn -&gt; &quot;[Parser] Corporation info timeout, retrying =&gt; id=#{corp_id}&quot; end)
              raise &quot;Corporation info timeout, will retry&quot;

            {:error, :not_found} -&gt;
              Logger.debug(fn -&gt; &quot;[Parser] Corporation not found =&gt; id=#{corp_id}&quot; end)
              :skip

            {:error, reason} -&gt;
              if HttpUtil.retriable_error?(reason) do
                Logger.debug(fn -&gt; &quot;[Parser] Corporation info retriable error =&gt; id=#{corp_id}, reason=#{inspect(reason)}&quot; end)
                raise &quot;Corporation info error: #{inspect(reason)}, will retry&quot;
              else
                Logger.warning(&quot;[Parser] Failed to fetch corp info: ID=#{corp_id}, reason=#{inspect(reason)}&quot;)
                :skip
              end
          end
        end

        case result do
          {:ok, {ticker, corp_name}} -&gt;
            km
            |&gt; Map.put(ticker_key, ticker)
            |&gt; Map.put(name_key, corp_name)
          _ -&gt; km
        end
    end
  end

  defp maybe_put_alliance_info(km, id_key, ticker_key, name_key) do
    case Map.get(km, id_key) do
      nil -&gt; km
      0 -&gt; km
      alliance_id -&gt;
        result = retry with: exponential_backoff(200) |&gt; randomize() |&gt; cap(2_000) |&gt; expiry(10_000), rescue_only: [RuntimeError] do
          case WandererApp.Esi.get_alliance_info(alliance_id) do
            {:ok, %{&quot;ticker&quot; =&gt; alliance_ticker, &quot;name&quot; =&gt; alliance_name}} -&gt;
              {:ok, {alliance_ticker, alliance_name}}

            {:error, :timeout} -&gt;
              Logger.debug(fn -&gt; &quot;[Parser] Alliance info timeout, retrying =&gt; id=#{alliance_id}&quot; end)
              raise &quot;Alliance info timeout, will retry&quot;

            {:error, :not_found} -&gt;
              Logger.debug(fn -&gt; &quot;[Parser] Alliance not found =&gt; id=#{alliance_id}&quot; end)
              :skip

            {:error, reason} -&gt;
              if HttpUtil.retriable_error?(reason) do
                Logger.debug(fn -&gt; &quot;[Parser] Alliance info retriable error =&gt; id=#{alliance_id}, reason=#{inspect(reason)}&quot; end)
                raise &quot;Alliance info error: #{inspect(reason)}, will retry&quot;
              else
                Logger.debug(fn -&gt; &quot;[Parser] Alliance info failed =&gt; id=#{alliance_id}, reason=#{inspect(reason)}&quot; end)
                :skip
              end
          end
        end

        case result do
          {:ok, {alliance_ticker, alliance_name}} -&gt;
            km
            |&gt; Map.put(ticker_key, alliance_ticker)
            |&gt; Map.put(name_key, alliance_name)
          _ -&gt; km
        end
    end
  end

  defp maybe_put_ship_name(km, id_key, name_key) do
    case Map.get(km, id_key) do
      nil -&gt; km
      0 -&gt; km
      type_id -&gt;
        result = retry with: exponential_backoff(200) |&gt; randomize() |&gt; cap(2_000) |&gt; expiry(10_000), rescue_only: [RuntimeError] do
          case WandererApp.CachedInfo.get_ship_type(type_id) do
            {:ok, nil} -&gt; :skip
            {:ok, %{name: ship_name}} -&gt; {:ok, ship_name}
            {:error, :timeout} -&gt;
              Logger.debug(fn -&gt; &quot;[Parser] Ship type timeout, retrying =&gt; id=#{type_id}&quot; end)
              raise &quot;Ship type timeout, will retry&quot;

            {:error, :not_found} -&gt;
              Logger.debug(fn -&gt; &quot;[Parser] Ship type not found =&gt; id=#{type_id}&quot; end)
              :skip

            {:error, reason} -&gt;
              if HttpUtil.retriable_error?(reason) do
                Logger.debug(fn -&gt; &quot;[Parser] Ship type retriable error =&gt; id=#{type_id}, reason=#{inspect(reason)}&quot; end)
                raise &quot;Ship type error: #{inspect(reason)}, will retry&quot;
              else
                Logger.warning(&quot;[Parser] Failed to fetch ship type: ID=#{type_id}, reason=#{inspect(reason)}&quot;)
                :skip
              end
          end
        end

        case result do
          {:ok, ship_name} -&gt; Map.put(km, name_key, ship_name)
          _ -&gt; km
        end
    end
  end

  # Utility
  defp within_last_hour?(nil), do: false

  defp within_last_hour?(%DateTime{} = dt),
    do: DateTime.diff(DateTime.utc_now(), dt, :minute) &lt; 60
end</file><file path="lib/wanderer_app/zkb/zkills_provider/redisq.ex">defmodule WandererApp.Zkb.KillsProvider.RedisQ do
  @moduledoc &quot;&quot;&quot;
  Handles real-time kills from zKillboard RedisQ.
  The RedisQ response includes the full killmail data, so no additional ESI calls are needed.
  &quot;&quot;&quot;

  require Logger
  alias WandererApp.Zkb.KillsProvider.Parser
  use Retry

  @poll_interval 1_000
  @redisq_url &quot;https://redisq.zkillboard.com/listen.php&quot;
  @queue_id &quot;wanderer&quot;

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: Keyword.get(opts, :name))
  end

  def init(_opts) do
    schedule_poll()
    {:ok, %{connected: true}}
  end

  def handle_info(:poll, state) do
    schedule_poll()
    poll_redisq(state)
    {:noreply, state}
  end

  defp schedule_poll do
    Process.send_after(self(), :poll, @poll_interval)
  end

  defp poll_redisq(_state) do
    url = &quot;#{@redisq_url}?queueID=#{@queue_id}&quot;

    case Req.get(url, decode_body: :json) do
      {:ok, %{status: 200, body: %{&quot;package&quot; =&gt; nil}}} -&gt;
        # No new kills, this is normal
        :ok

      {:ok, %{status: 200, body: %{&quot;package&quot; =&gt; package}}} when is_map(package) -&gt;
        # We got a killmail, process it
        parse_and_store_zkb_package(package)

      {:error, reason} -&gt;
        Logger.warning(&quot;[KillsProvider.RedisQ] Poll failed =&gt; #{inspect(reason)}&quot;)
        :error
    end
  end

  defp parse_and_store_zkb_package(%{&quot;killID&quot; =&gt; kill_id, &quot;killmail&quot; =&gt; killmail, &quot;zkb&quot; =&gt; zkb}) do
    Logger.debug(fn -&gt; &quot;[KillsProvider.RedisQ] Received killmail =&gt; kill_id=#{kill_id}&quot; end)

    # The RedisQ response already includes the full killmail data
    enriched = Map.merge(killmail, %{&quot;zkb&quot; =&gt; zkb})
    Parser.parse_and_store_killmail(enriched)
    :ok
  end

  defp parse_and_store_zkb_package(_),
    do: :skip
end</file><file path="lib/wanderer_app/zkb/zkills_provider/zkb_api.ex">defmodule WandererApp.Zkb.KillsProvider.ZkbApi do
  @moduledoc &quot;&quot;&quot;
  A small module for making HTTP requests to zKillboard and
  parsing JSON responses, separate from the multi-page logic.
  &quot;&quot;&quot;

  require Logger
  alias ExRated

  # 5 calls per second allowed
  @exrated_bucket :zkb_preloader_provider
  @exrated_interval_ms 1_000
  @exrated_max_requests 5

  @zkillboard_api &quot;https://zkillboard.com/api&quot;

  @doc &quot;&quot;&quot;
  Perform rate-limit check before fetching a single page from zKillboard and parse the response.

  Returns:
    - `{:ok, updated_state, partials_list}` on success
    - `{:error, reason, updated_state}` if error
  &quot;&quot;&quot;
  def fetch_and_parse_page(system_id, page, %{calls_count: _} = state) do
    with :ok &lt;- check_rate(),
         {:ok, resp} &lt;- do_req_get(system_id, page),
         partials when is_list(partials) &lt;- parse_response_body(resp) do
      {:ok, state, partials}
    else
      {:error, :rate_limited} -&gt;
        {:error, :rate_limited, state}

      {:error, reason} -&gt;
        {:error, reason, state}

      _other -&gt;
        {:error, :unexpected, state}
    end
  end

  defp do_req_get(system_id, page) do
    url = &quot;#{@zkillboard_api}/kills/systemID/#{system_id}/page/#{page}/&quot;
    Logger.debug(fn -&gt; &quot;[ZkbApi] GET =&gt; system=#{system_id}, page=#{page}, url=#{url}&quot; end)

    try do
      resp = Req.get!(url, decode_body: :json)

      if resp.status == 200 do
        {:ok, resp}
      else
        {:error, {:http_status, resp.status}}
      end
    rescue
      e -&gt;
        Logger.error(&quot;&quot;&quot;
        [ZkbApi] do_req_get =&gt; exception: #{Exception.message(e)}
        #{Exception.format_stacktrace(__STACKTRACE__)}
        &quot;&quot;&quot;)

        {:error, :exception}
    end
  end

  defp parse_response_body(%{status: 200, body: body}) when is_list(body),
    do: body

  defp parse_response_body(_),
    do: :not_list

  defp check_rate do
    case ExRated.check_rate(@exrated_bucket, @exrated_interval_ms, @exrated_max_requests) do
      {:ok, _count} -&gt;
        :ok

      {:error, limit} -&gt;
        Logger.debug(fn -&gt; &quot;[ZkbApi] RATE_LIMIT =&gt; limit=#{inspect(limit)}&quot; end)
        {:error, :rate_limited}
    end
  end
end</file><file path="lib/wanderer_app/zkb/zkb_kills_preloader.ex">defmodule WandererApp.Zkb.KillsPreloader do
  @moduledoc &quot;&quot;&quot;
  On startup, kicks off two passes (quick and expanded) to preload kills data.

  There is also a `run_preload_now/0` function for manual triggering of the same logic.
  &quot;&quot;&quot;

  use GenServer
  require Logger

  alias WandererApp.Zkb.KillsProvider
  alias WandererApp.Zkb.KillsProvider.KillsCache

  # ----------------
  # Configuration
  # ----------------

  # (1) Quick pass
  @quick_limit 1
  @quick_hours 1

  # (2) Expanded pass
  @expanded_limit 25
  @expanded_hours 24

  # How many minutes back we look for ‚Äúlast active‚Äù maps
  @last_active_cutoff 30

  # Default concurrency if not provided
  @default_max_concurrency 2

  @doc &quot;&quot;&quot;
  Starts the GenServer with optional opts (like `max_concurrency`).
  &quot;&quot;&quot;
  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @doc &quot;&quot;&quot;
  Public helper to explicitly request a fresh preload pass (both quick &amp; expanded).
  &quot;&quot;&quot;
  def run_preload_now() do
    send(__MODULE__, :start_preload)
  end

  @impl true
  def init(opts) do
    state = %{
      phase: :idle,
      calls_count: 0,
      max_concurrency: Keyword.get(opts, :max_concurrency, @default_max_concurrency)
    }

    # Kick off the preload passes once at startup
    send(self(), :start_preload)
    {:ok, state}
  end

  @impl true
  def handle_info(:start_preload, state) do
    # Gather last-active maps (or fallback).
    cutoff_time =
      DateTime.utc_now()
      |&gt; DateTime.add(-@last_active_cutoff, :minute)

    last_active_maps_result = WandererApp.Api.MapState.get_last_active(cutoff_time)
    last_active_maps = resolve_last_active_maps(last_active_maps_result)
    active_maps_with_subscription = get_active_maps_with_subscription(last_active_maps)

    # Gather systems from those maps
    system_tuples = gather_visible_systems(active_maps_with_subscription)
    unique_systems = Enum.uniq(system_tuples)

    Logger.debug(fn -&gt; &quot;
    [KillsPreloader] Found #{length(unique_systems)} unique systems \
    across #{length(last_active_maps)} map(s)
    &quot; end)

    # ---- QUICK PASS ----
    state_quick = %{state | phase: :quick_pass}

    {time_quick_ms, state_after_quick} =
      measure_execution_time(fn -&gt;
        do_pass(unique_systems, :quick, @quick_hours, @quick_limit, state_quick)
      end)

    Logger.info(
      &quot;[KillsPreloader] Phase 1 (quick) done =&gt; calls_count=#{state_after_quick.calls_count}, elapsed=#{time_quick_ms}ms&quot;
    )

    # ---- EXPANDED PASS ----
    state_expanded = %{state_after_quick | phase: :expanded_pass}

    {time_expanded_ms, final_state} =
      measure_execution_time(fn -&gt;
        do_pass(unique_systems, :expanded, @quick_hours, @expanded_limit, state_expanded)
      end)

    Logger.info(
      &quot;[KillsPreloader] Phase 2 (expanded) done =&gt; calls_count=#{final_state.calls_count}, elapsed=#{time_expanded_ms}ms&quot;
    )

    # Reset phase to :idle
    {:noreply, %{final_state | phase: :idle}}
  end

  @impl true
  def handle_info(_other, state), do: {:noreply, state}

  defp resolve_last_active_maps({:ok, []}) do
    Logger.warning(&quot;[KillsPreloader] No last-active maps found. Using fallback logic...&quot;)

    case WandererApp.Maps.get_available_maps() do
      {:ok, []} -&gt;
        Logger.error(&quot;[KillsPreloader] Fallback: get_available_maps returned zero maps!&quot;)
        []

      {:ok, maps} -&gt;
        # pick the newest map by updated_at
        fallback_map = Enum.max_by(maps, &amp; &amp;1.updated_at, fn -&gt; nil end)
        if fallback_map, do: [fallback_map], else: []
    end
  end

  defp resolve_last_active_maps({:ok, maps}) when is_list(maps),
    do: maps

  defp resolve_last_active_maps({:error, reason}) do
    Logger.error(&quot;[KillsPreloader] Could not load last-active maps =&gt; #{inspect(reason)}&quot;)
    []
  end

  defp get_active_maps_with_subscription(maps) do
    maps
    |&gt; Enum.filter(fn map -&gt;
      {:ok, is_subscription_active} = map.id |&gt; WandererApp.Map.is_subscription_active?()
      is_subscription_active
    end)
  end

  defp gather_visible_systems(maps) do
    maps
    |&gt; Enum.flat_map(fn map_record -&gt;
      the_map_id = Map.get(map_record, :map_id) || Map.get(map_record, :id)

      case WandererApp.MapSystemRepo.get_visible_by_map(the_map_id) do
        {:ok, systems} -&gt;
          Enum.map(systems, fn sys -&gt; {the_map_id, sys.solar_system_id} end)

        {:error, reason} -&gt;
          Logger.warning(
            &quot;[KillsPreloader] get_visible_by_map failed =&gt; map_id=#{inspect(the_map_id)}, reason=#{inspect(reason)}&quot;
          )

          []
      end
    end)
  end

  defp do_pass(unique_systems, pass_type, hours, limit, state) do
    Logger.info(
      &quot;[KillsPreloader] Starting #{pass_type} pass =&gt; #{length(unique_systems)} systems&quot;
    )

    {final_state, _kills_map} =
      unique_systems
      |&gt; Task.async_stream(
        fn {_map_id, system_id} -&gt;
          fetch_kills_for_system(system_id, pass_type, hours, limit, state)
        end,
        max_concurrency: state.max_concurrency,
        timeout: pass_timeout_ms(pass_type)
      )
      |&gt; Enum.reduce({state, %{}}, fn task_result, {acc_state, acc_map} -&gt;
        reduce_task_result(pass_type, task_result, acc_state, acc_map)
      end)

    final_state
  end

  defp fetch_kills_for_system(system_id, :quick, hours, limit, state) do
    Logger.debug(fn -&gt; &quot;[KillsPreloader] Quick fetch =&gt; system=#{system_id}, hours=#{hours}, limit=#{limit}&quot; end)

    case KillsProvider.Fetcher.fetch_kills_for_system(system_id, hours, state,
           limit: limit,
           force: false
         ) do
      {:ok, kills, updated_state} -&gt;
        {:ok, system_id, kills, updated_state}

      {:error, reason, updated_state} -&gt;
        Logger.warning(
          &quot;[KillsPreloader] Quick fetch failed =&gt; system=#{system_id}, reason=#{inspect(reason)}&quot;
        )

        {:error, reason, updated_state}
    end
  end

  defp fetch_kills_for_system(system_id, :expanded, hours, limit, state) do
    Logger.debug(fn -&gt; &quot;[KillsPreloader] Expanded fetch =&gt; system=#{system_id}, hours=#{hours}, limit=#{limit} (forcing refresh)&quot; end)

    with {:ok, kills_1h, updated_state} &lt;-
           KillsProvider.Fetcher.fetch_kills_for_system(system_id, hours, state,
             limit: limit,
             force: true
           ),
         {:ok, final_kills, final_state} &lt;-
           maybe_fetch_more_if_needed(system_id, kills_1h, limit, updated_state) do
      {:ok, system_id, final_kills, final_state}
    else
      {:error, reason, updated_state} -&gt;
        Logger.warning(
          &quot;[KillsPreloader] Expanded fetch (#{hours}h) failed =&gt; system=#{system_id}, reason=#{inspect(reason)}&quot;
        )

        {:error, reason, updated_state}
    end
  end

  # If we got fewer kills than `limit` from the 1h fetch, top up from 24h
  defp maybe_fetch_more_if_needed(system_id, kills_1h, limit, state) do
    if length(kills_1h) &lt; limit do
      needed = limit - length(kills_1h)
      Logger.debug(fn -&gt; &quot;[KillsPreloader] Expanding to #{@expanded_hours}h =&gt; system=#{system_id}, need=#{needed} more kills&quot; end)

      case KillsProvider.Fetcher.fetch_kills_for_system(system_id, @expanded_hours, state,
             limit: needed,
             force: true
           ) do
        {:ok, _kills_24h, updated_state2} -&gt;
          final_kills =
            KillsCache.fetch_cached_kills(system_id)
            |&gt; Enum.take(limit)

          {:ok, final_kills, updated_state2}

        {:error, reason2, updated_state2} -&gt;
          Logger.warning(
            &quot;[KillsPreloader] #{@expanded_hours}h fetch failed =&gt; system=#{system_id}, reason=#{inspect(reason2)}&quot;
          )

          {:error, reason2, updated_state2}
      end
    else
      {:ok, kills_1h, state}
    end
  end

  defp reduce_task_result(pass_type, task_result, acc_state, acc_map) do
    case task_result do
      {:ok, {:ok, sys_id, kills, updated_state}} -&gt;
        # Merge calls count from updated_state into acc_state
        new_state = merge_calls_count(acc_state, updated_state)
        new_map = Map.put(acc_map, sys_id, kills)
        {new_state, new_map}

      {:ok, {:error, reason, updated_state}} -&gt;
        log_failed_task(pass_type, reason)
        new_state = merge_calls_count(acc_state, updated_state)
        {new_state, acc_map}

      {:error, reason} -&gt;
        Logger.error(&quot;[KillsPreloader] #{pass_type} fetch task crashed =&gt; #{inspect(reason)}&quot;)
        {acc_state, acc_map}
    end
  end

  defp log_failed_task(:quick, reason),
    do: Logger.warning(&quot;[KillsPreloader] Quick fetch task failed =&gt; #{inspect(reason)}&quot;)

  defp log_failed_task(:expanded, reason),
    do: Logger.error(&quot;[KillsPreloader] Expanded fetch task failed =&gt; #{inspect(reason)}&quot;)

  defp merge_calls_count(%{calls_count: c1} = st1, %{calls_count: c2}),
    do: %{st1 | calls_count: c1 + c2}

  defp merge_calls_count(st1, _other),
    do: st1

  defp pass_timeout_ms(:quick), do: :timer.minutes(2)
  defp pass_timeout_ms(:expanded), do: :timer.minutes(5)

  defp measure_execution_time(fun) when is_function(fun, 0) do
    start = System.monotonic_time()
    result = fun.()
    finish = System.monotonic_time()
    ms = System.convert_time_unit(finish - start, :native, :millisecond)
    {ms, result}
  end
end</file><file path="lib/wanderer_app/zkb/zkb_supervisor.ex">defmodule WandererApp.Zkb.Supervisor do
  use Supervisor

  @name __MODULE__

  def start_link(opts \\ []) do
    Supervisor.start_link(@name, opts, name: @name)
  end

  def init(_init_args) do
    preloader_child =
      unless WandererApp.Env.zkill_preload_disabled?() do
        {WandererApp.Zkb.KillsPreloader, []}
      end

    children =
      [
        {
          WandererApp.Zkb.KillsProvider.RedisQ,
          name: {:local, :zkb_kills_provider}
        },
        preloader_child
      ]
      |&gt; Enum.reject(&amp;is_nil/1)

    Supervisor.init(children, strategy: :one_for_one)
  end
end</file><file path="lib/wanderer_app/acls.ex">defmodule WandererApp.Acls do
  @moduledoc false

  def get_available_acls() do
    case WandererApp.Api.AccessList.available() do
      {:ok, acls} -&gt; {:ok, acls}
      _ -&gt; {:ok, []}
    end
  end

  def get_available_acls(current_user) do
    case WandererApp.Api.AccessList.available(%{}, actor: current_user) do
      {:ok, acls} -&gt; {:ok, acls |&gt; Enum.sort_by(&amp; &amp;1.name, :asc)}
      _ -&gt; {:ok, []}
    end
  end
end</file><file path="lib/wanderer_app/api.ex">defmodule WandererApp.Api do
  @moduledoc false

  use Ash.Domain

  resources do
    resource WandererApp.Api.AccessList
    resource WandererApp.Api.AccessListMember
    resource WandererApp.Api.Character
    resource WandererApp.Api.Map
    resource WandererApp.Api.MapAccessList
    resource WandererApp.Api.MapSolarSystem
    resource WandererApp.Api.MapSolarSystemJumps
    resource WandererApp.Api.MapChainPassages
    resource WandererApp.Api.MapConnection
    resource WandererApp.Api.MapState
    resource WandererApp.Api.MapSystem
    resource WandererApp.Api.MapSystemComment
    resource WandererApp.Api.MapSystemSignature
    resource WandererApp.Api.MapSystemStructure
    resource WandererApp.Api.MapCharacterSettings
    resource WandererApp.Api.MapSubscription
    resource WandererApp.Api.MapTransaction
    resource WandererApp.Api.MapUserSettings
    resource WandererApp.Api.User
    resource WandererApp.Api.ShipTypeInfo
    resource WandererApp.Api.UserActivity
    resource WandererApp.Api.UserTransaction
    resource WandererApp.Api.CorpWalletTransaction
    resource WandererApp.Api.License
  end
end</file><file path="lib/wanderer_app/application.ex">defmodule WandererApp.Application do
  @moduledoc false

  use Application

  require Logger

  @impl true
  def start(_type, _args) do
    children =
      [
        WandererApp.PromEx,
        WandererAppWeb.Telemetry,
        WandererApp.Vault,
        WandererApp.Repo,
        {Phoenix.PubSub, name: WandererApp.PubSub, adapter_name: Phoenix.PubSub.PG2},
        {
          Finch,
          name: WandererApp.Finch,
          pools: %{
            default: [
              # number of connections per pool
              size: 25,
              # number of pools (so total 50 connections)
              count: 2
            ]
          }
        },
        WandererApp.Cache,
        Supervisor.child_spec({Cachex, name: :api_cache}, id: :api_cache_worker),
        Supervisor.child_spec({Cachex, name: :system_static_info_cache},
          id: :system_static_info_cache_worker
        ),
        Supervisor.child_spec({Cachex, name: :ship_types_cache}, id: :ship_types_cache_worker),
        Supervisor.child_spec({Cachex, name: :character_cache}, id: :character_cache_worker),
        Supervisor.child_spec({Cachex, name: :map_cache}, id: :map_cache_worker),
        Supervisor.child_spec({Cachex, name: :character_state_cache},
          id: :character_state_cache_worker
        ),
        Supervisor.child_spec({Cachex, name: :tracked_characters},
          id: :tracked_characters_cache_worker
        ),
        WandererApp.Scheduler,
        {Registry, keys: :unique, name: WandererApp.MapRegistry},
        {Registry, keys: :unique, name: WandererApp.Character.TrackerRegistry},
        {PartitionSupervisor,
         child_spec: DynamicSupervisor, name: WandererApp.Map.DynamicSupervisors},
        {PartitionSupervisor,
         child_spec: DynamicSupervisor, name: WandererApp.Character.DynamicSupervisors},
        WandererApp.Zkb.Supervisor,
        WandererApp.Server.ServerStatusTracker,
        WandererApp.Server.TheraDataFetcher,
        {WandererApp.Character.TrackerPoolSupervisor, []},
        WandererApp.Character.TrackerManager,
        WandererApp.Map.Manager,
        WandererApp.Map.ZkbDataFetcher,
        WandererAppWeb.Presence,
        WandererAppWeb.Endpoint
      ] ++
        maybe_start_corp_wallet_tracker(WandererApp.Env.map_subscriptions_enabled?())

    opts = [strategy: :one_for_one, name: WandererApp.Supervisor]

    Supervisor.start_link(children, opts)
    |&gt; case do
      {:ok, _pid} = ok -&gt;
        ok

      {:error, info} = e -&gt;
        Logger.error(&quot;Failed to start application: #{inspect(info)}&quot;)
        e
    end
  end

  @impl true
  def config_change(changed, _new, removed) do
    WandererAppWeb.Endpoint.config_change(changed, removed)
    :ok
  end

  defp maybe_start_corp_wallet_tracker(true),
    do: [
      WandererApp.StartCorpWalletTrackerTask
    ]

  defp maybe_start_corp_wallet_tracker(_),
    do: []
end</file><file path="lib/wanderer_app/cache.ex">defmodule WandererApp.Cache do
  @moduledoc false
  use Nebulex.Cache,
    otp_app: :wanderer_app,
    adapter: Nebulex.Adapters.Local

  require Logger

  def lookup(key, default \\ nil)

  def lookup({id, key}, default) when is_binary(id) and (is_binary(key) or is_atom(key)),
    do: lookup(&quot;#{id}:#{key}&quot;, default)

  def lookup(key, default) when is_binary(key) or is_atom(key) do
    case get(key) do
      nil -&gt; {:ok, default}
      value -&gt; {:ok, value}
    end
  end

  def lookup!(key, default \\ nil)

  def lookup!({id, key}, default) when is_binary(id) and (is_binary(key) or is_atom(key)),
    do: lookup!(&quot;#{id}:#{key}&quot;, default)

  def lookup!(key, default) when is_binary(key) or is_atom(key) do
    {:ok, result} = lookup(key, default)
    result
  end

  def get_and_remove(key, default) when is_binary(key) or is_atom(key) do
    case take(key) do
      nil -&gt; {:ok, default}
      value -&gt; {:ok, value}
    end
  end

  def get_and_remove!(key, default) when is_binary(key) or is_atom(key) do
    {:ok, result} = get_and_remove(key, default)
    result
  end

  def insert(key, value, opts \\ [])

  def insert({id, key}, value, opts) when is_binary(id) and (is_binary(key) or is_atom(key)),
    do: insert(&quot;#{id}:#{key}&quot;, value, opts)

  def insert(key, nil, opts) when is_binary(key) or is_atom(key), do: delete(key)
  def insert(key, value, opts) when is_binary(key) or is_atom(key), do: put(key, value, opts)

  def insert_or_update(key, value, update_fn, opts \\ [])

  def insert_or_update({id, key}, value, update_fn, opts)
      when is_binary(id) and (is_binary(key) or is_atom(key)),
      do: insert_or_update(&quot;#{id}:#{key}&quot;, value, update_fn, opts)

  def insert_or_update(key, value, update_fn, opts) when is_binary(key) or is_atom(key) do
    case lookup(key) do
      {:ok, nil} -&gt;
        insert(key, value, opts)

      {:ok, data} -&gt;
        insert(key, update_fn.(data), opts)
    end
  end

  def find_by_attrs(type, attrs, match \\ :any) do
    case type |&gt; get() |&gt; find(attrs, match: match) do
      %{} = item -&gt; {:ok, item}
      nil -&gt; {:error, :item_not_found}
    end
  end

  def filter_by_attr_in(type, attr, includes), do: type |&gt; get() |&gt; filter_in(attr, includes)

  defp find(list, %{} = attrs, match: match) do
    list
    |&gt; Enum.find(fn item -&gt;
      case match do
        :any -&gt; Enum.any?(attrs, &amp;has_equal_attribute?(item, &amp;1))
        :all -&gt; Enum.all?(attrs, &amp;has_equal_attribute?(item, &amp;1))
      end
    end)
  end

  defp filter_in(nil, _attr, _includes), do: []

  defp filter_in(list, attr, includes),
    do:
      list
      |&gt; Enum.filter(&amp;(&amp;1[attr] in includes))

  defp has_equal_attribute?(%{} = map, {key, {:case_insensitive, value}}) when is_binary(value) do
    String.downcase(Map.get(map, key, &quot;&quot;)) == String.downcase(value)
  end

  defp has_equal_attribute?(%{} = map, {key, value}), do: Map.get(map, key) == value
end</file><file path="lib/wanderer_app/cached_info.ex">defmodule WandererApp.CachedInfo do
  require Logger

  def run(_arg) do
    :ok = cache_trig_systems()
  end

  def get_ship_type(type_id) do
    case Cachex.get(:ship_types_cache, type_id) do
      {:ok, nil} -&gt;
        {:ok, ship_types} = WandererApp.Api.ShipTypeInfo.read()

        ship_types
        |&gt; Enum.each(fn ship_type -&gt;
          Cachex.put(
            :ship_types_cache,
            ship_type.type_id,
            ship_type
            |&gt; Map.take([
              :type_id,
              :group_id,
              :group_name,
              :name,
              :description,
              :mass,
              :capacity,
              :volume
            ])
          )
        end)

        Cachex.get(:ship_types_cache, type_id)

      {:ok, ship_type} -&gt;
        {:ok, ship_type}
    end
  end

  def get_system_static_info(solar_system_id) do
    case Cachex.get(:system_static_info_cache, solar_system_id) do
      {:ok, nil} -&gt;
        case WandererApp.Api.MapSolarSystem.read() do
          {:ok, systems} -&gt;
            systems
            |&gt; Enum.each(fn system -&gt;
              Cachex.put(
                :system_static_info_cache,
                system.solar_system_id,
                Map.take(system, [
                  :solar_system_id,
                  :region_id,
                  :constellation_id,
                  :solar_system_name,
                  :solar_system_name_lc,
                  :constellation_name,
                  :region_name,
                  :system_class,
                  :security,
                  :type_description,
                  :class_title,
                  :is_shattered,
                  :effect_name,
                  :effect_power,
                  :statics,
                  :wandering,
                  :triglavian_invasion_status,
                  :sun_type_id
                ])
              )
            end)

            Cachex.get(:system_static_info_cache, solar_system_id)

          {:error, reason} -&gt;
            Logger.error(&quot;Failed to read solar systems from API: #{inspect(reason)}&quot;)
            {:error, :api_error}
        end

      {:ok, system_static_info} -&gt;
        {:ok, system_static_info}

      {:error, reason} -&gt;
        Logger.error(&quot;Failed to get system static info from cache: #{inspect(reason)}&quot;)
        {:error, :cache_error}
    end
  end

  def get_system_static_info!(solar_system_id) do
    case get_system_static_info(solar_system_id) do
      {:ok, system_static_info} -&gt;
        system_static_info

      error -&gt;
        Logger.error(&quot;Error loading system static info: #{inspect(error)}&quot;)
        nil
    end
  end

  def get_wormhole_types() do
    case WandererApp.Cache.lookup(:wormhole_types) do
      {:ok, nil} -&gt;
        wormhole_types = WandererApp.EveDataService.load_wormhole_types()

        cache_items(wormhole_types, :wormhole_types)

        {:ok, wormhole_types}

      {:ok, wormhole_types} -&gt;
        {:ok, wormhole_types}
    end
  end

  def get_wormhole_types!() do
    case get_wormhole_types() do
      {:ok, wormhole_types} -&gt;
        wormhole_types

      error -&gt;
        Logger.error(&quot;Error loading wormhole types: #{inspect(error)}&quot;)
        error
    end
  end

  def get_wormhole_classes() do
    case WandererApp.Cache.lookup(:wormhole_classes) do
      {:ok, nil} -&gt;
        wormhole_classes = WandererApp.EveDataService.load_wormhole_classes()

        cache_items(wormhole_classes, :wormhole_classes)

        {:ok, wormhole_classes}

      {:ok, wormhole_classes} -&gt;
        {:ok, wormhole_classes}
    end
  end

  def get_wormhole_classes!() do
    case get_wormhole_classes() do
      {:ok, wormhole_classes} -&gt;
        wormhole_classes

      error -&gt;
        Logger.error(&quot;Error loading wormhole classes: #{inspect(error)}&quot;)
        error
    end
  end

  def get_effects() do
    case WandererApp.Cache.lookup(:effects) do
      {:ok, nil} -&gt;
        effects = WandererApp.EveDataService.load_effects()

        cache_items(effects, :effects)

        {:ok, effects}

      {:ok, effects} -&gt;
        {:ok, effects}
    end
  end

  def get_effects!() do
    case get_effects() do
      {:ok, effects} -&gt;
        effects

      error -&gt;
        Logger.error(&quot;Error loading effects: #{inspect(error)}&quot;)
        error
    end
  end

  def get_wh_class_a_systems() do
    case WandererApp.Cache.lookup(:wh_class_a_systems) do
      {:ok, nil} -&gt;
        {:ok, wh_class_a} = WandererApp.Api.MapSolarSystem.get_wh_class_a()

        wh_class_a_ids = wh_class_a |&gt; Enum.map(&amp; &amp;1.solar_system_id)

        cache_items(wh_class_a_ids, :wh_class_a_systems)

        {:ok, wh_class_a_ids}

      {:ok, wh_class_a_ids} -&gt;
        {:ok, wh_class_a_ids}
    end
  end

  def get_trig_systems() do
    case WandererApp.Cache.lookup(:trig_systems) do
      {:ok, nil} -&gt;
        {:ok, trig_systems} = WandererApp.Api.MapSolarSystem.get_trig_systems()

        cache_items(trig_systems, :trig_systems)

        {:ok, trig_systems}

      {:ok, trig_systems} -&gt;
        {:ok, trig_systems}
    end
  end

  defp cache_trig_systems() do
    trig_systems = WandererApp.Api.MapSolarSystem.get_trig_systems!()

    trig_systems
    |&gt; Enum.filter(fn s -&gt; s.triglavian_invasion_status == &quot;Final&quot; end)
    |&gt; Enum.map(&amp; &amp;1.solar_system_id)
    |&gt; cache_items(:pochven_solar_systems)

    trig_systems
    |&gt; Enum.filter(fn s -&gt; s.triglavian_invasion_status == &quot;Triglavian&quot; end)
    |&gt; Enum.map(&amp; &amp;1.solar_system_id)
    |&gt; cache_items(:triglavian_solar_systems)

    trig_systems
    |&gt; Enum.filter(fn s -&gt; s.triglavian_invasion_status == &quot;Edencom&quot; end)
    |&gt; Enum.map(&amp; &amp;1.solar_system_id)
    |&gt; cache_items(:edencom_solar_systems)
  end

  defp cache_items([], _list_name), do: :ok

  defp cache_items(items, list_name), do: WandererApp.Cache.put(list_name, items)
end</file><file path="lib/wanderer_app/character.ex">defmodule WandererApp.Character do
  @moduledoc false
  use Nebulex.Caching

  require Logger

  @read_character_wallet_scope &quot;esi-wallet.read_character_wallet.v1&quot;
  @read_corp_wallet_scope &quot;esi-wallet.read_corporation_wallets.v1&quot;

  @default_character_tracking_data %{
    solar_system_id: nil,
    structure_id: nil,
    station_id: nil,
    ship: nil,
    ship_name: nil,
    ship_item_id: nil
  }

  @decorate cacheable(
              cache: WandererApp.Cache,
              key: &quot;characters-#{character_eve_id}&quot;
            )
  def get_by_eve_id(character_eve_id) when is_binary(character_eve_id) do
    WandererApp.Api.Character.by_eve_id(character_eve_id)
  end

  def get_character(character_id) when not is_nil(character_id) do
    case Cachex.get(:character_cache, character_id) do
      {:ok, nil} -&gt;
        case WandererApp.Api.Character.by_id(character_id) do
          {:ok, character} -&gt;
            Cachex.put(:character_cache, character_id, character)
            {:ok, character}

          _ -&gt;
            {:error, :not_found}
        end

      {:ok, character} -&gt;
        {:ok, character}
    end
  end

  def get_character(_character_id), do: {:ok, nil}

  def get_character!(character_id) do
    case get_character(character_id) do
      {:ok, character} -&gt;
        character

      _ -&gt;
        Logger.error(&quot;Failed to get character #{character_id}&quot;)
        nil
    end
  end

  def get_map_character(map_id, character_id) do
    case get_character(character_id) do
      {:ok, character} -&gt;
        {:ok,
         character
         |&gt; maybe_merge_map_character_settings(
           map_id,
           WandererApp.Character.TrackerManager.Impl.character_is_present(map_id, character_id)
         )}

      _ -&gt;
        {:ok, nil}
    end
  end

  def get_map_character!(map_id, character_id) do
    case get_map_character(map_id, character_id) do
      {:ok, character} -&gt;
        character

      _ -&gt;
        Logger.error(&quot;Failed to get map character #{map_id} #{character_id}&quot;)
        nil
    end
  end

  def get_character_eve_ids!(character_ids),
    do:
      character_ids
      |&gt; Enum.map(fn character_id -&gt;
        character_id |&gt; get_character!() |&gt; Map.get(:eve_id)
      end)

  def update_character(character_id, character_update) do
    Cachex.get_and_update(:character_cache, character_id, fn character -&gt;
      case character do
        nil -&gt;
          case WandererApp.Api.Character.by_id(character_id) do
            {:ok, character} -&gt;
              {:commit, Map.merge(character, character_update)}

            _ -&gt;
              {:ignore, nil}
          end

        _ -&gt;
          {:commit, Map.merge(character, character_update)}
      end
    end)
  end

  def get_character_state(character_id, init_if_empty? \\ true) do
    case Cachex.get(:character_state_cache, character_id) do
      {:ok, nil} -&gt;
        case init_if_empty? do
          true -&gt;
            character_state = WandererApp.Character.Tracker.init(character_id: character_id)
            Cachex.put(:character_state_cache, character_id, character_state)
            {:ok, character_state}

          _ -&gt;
            {:ok, nil}
        end

      {:ok, character_state} -&gt;
        {:ok, character_state}
    end
  end

  def get_character_state!(character_id) do
    case get_character_state(character_id) do
      {:ok, character_state} -&gt;
        character_state

      _ -&gt;
        Logger.error(&quot;Failed to get character_state #{character_id}&quot;)
        throw(&quot;Failed to get character_state #{character_id}&quot;)
    end
  end

  def update_character_state(character_id, character_state_update) do
    Cachex.get_and_update(:character_state_cache, character_id, fn character_state -&gt;
      case character_state do
        nil -&gt;
          new_state = WandererApp.Character.Tracker.init(character_id: character_id)
          :telemetry.execute([:wanderer_app, :character, :tracker, :started], %{count: 1})

          {:commit, Map.merge(new_state, character_state_update)}

        _ -&gt;
          {:commit, Map.merge(character_state, character_state_update)}
      end
    end)
  end

  def delete_character_state(character_id) do
    Cachex.del(:character_state_cache, character_id)
  end

  def set_autopilot_waypoint(
        character_id,
        destination_id,
        opts
      ) do
    {:ok, %{access_token: access_token}} = WandererApp.Character.get_character(character_id)

    WandererApp.Esi.set_autopilot_waypoint(
      opts[:add_to_beginning],
      opts[:clear_other_waypoints],
      destination_id,
      access_token: access_token
    )

    :ok
  end

  def search(character_id, opts \\ []) do
    {:ok, %{access_token: access_token, eve_id: eve_id} = _character} =
      get_character(character_id)

    case WandererApp.Esi.search(eve_id |&gt; String.to_integer(),
           access_token: access_token,
           character_id: character_id,
           refresh_token?: true,
           params: opts[:params]
         ) do
      {:ok, result} -&gt;
        {:ok, result |&gt; prepare_search_results()}

      {:error, error} -&gt;
        Logger.warning(&quot;#{__MODULE__} failed search: #{inspect(error)}&quot;)
        {:ok, []}
    end
  end

  def can_track_wallet?(%{scopes: scopes} = _character) when not is_nil(scopes) do
    scopes |&gt; String.split(&quot; &quot;) |&gt; Enum.member?(@read_character_wallet_scope)
  end

  def can_track_wallet?(_), do: false

  def can_track_corp_wallet?(%{scopes: scopes} = _character) when not is_nil(scopes) do
    scopes |&gt; String.split(&quot; &quot;) |&gt; Enum.member?(@read_corp_wallet_scope)
  end

  def can_track_corp_wallet?(_), do: false

  def get_ship(%{ship: ship_type_id, ship_name: ship_name} = _character)
      when not is_nil(ship_type_id) and is_integer(ship_type_id) do
    ship_type_id
    |&gt; WandererApp.CachedInfo.get_ship_type()
    |&gt; case do
      {:ok, ship_type_info} when not is_nil(ship_type_info) -&gt;
        %{ship_type_id: ship_type_id, ship_name: ship_name, ship_type_info: ship_type_info}

      _ -&gt;
        %{ship_type_id: ship_type_id, ship_name: ship_name, ship_type_info: %{}}
    end
  end

  def get_ship(%{ship_name: ship_name} = _character) when is_binary(ship_name),
    do: %{ship_name: ship_name, ship_type_info: %{}}

  def get_ship(_),
    do: %{ship_name: nil, ship_type_info: %{}}

  def get_location(
        %{solar_system_id: solar_system_id, structure_id: structure_id, station_id: station_id} =
          _character
      ) do
    case WandererApp.CachedInfo.get_system_static_info(solar_system_id) do
      {:ok, system_static_info} when not is_nil(system_static_info) -&gt;
        %{
          solar_system_id: solar_system_id,
          structure_id: structure_id,
          station_id: station_id,
          solar_system_info: system_static_info
        }

      _ -&gt;
        %{
          solar_system_id: solar_system_id,
          structure_id: structure_id,
          station_id: station_id,
          solar_system_info: %{}
        }
    end
  end

  defp maybe_merge_map_character_settings(character, map_id, true), do: character

  defp maybe_merge_map_character_settings(
         %{id: character_id} = character,
         map_id,
         _character_is_present
       ) do
    WandererApp.MapCharacterSettingsRepo.get(map_id, character_id)
    |&gt; case do
      {:ok, settings} when not is_nil(settings) -&gt;
        character
        |&gt; Map.put(:online, false)
        |&gt; Map.merge(settings)

      _ -&gt;
        character
        |&gt; Map.put(:online, false)
        |&gt; Map.merge(@default_character_tracking_data)
    end
  end

  defp prepare_search_results(result) do
    {:ok, characters} =
      _load_eve_info(Map.get(result, &quot;character&quot;), :get_character_info, &amp;_map_character_info/1)

    {:ok, corporations} =
      _load_eve_info(
        Map.get(result, &quot;corporation&quot;),
        :get_corporation_info,
        &amp;_map_corporation_info/1
      )

    {:ok, alliances} =
      _load_eve_info(Map.get(result, &quot;alliance&quot;), :get_alliance_info, &amp;_map_alliance_info/1)

    [[characters | corporations] | alliances] |&gt; List.flatten()
  end

  defp _load_eve_info(nil, _, _), do: {:ok, []}

  defp _load_eve_info([], _, _), do: {:ok, []}

  defp _load_eve_info(eve_ids, method, map_function),
    do:
      {:ok,
       Enum.map(eve_ids, fn eve_id -&gt;
         Task.async(fn -&gt; apply(WandererApp.Esi.ApiClient, method, [eve_id]) end)
       end)
       # 145000 == Timeout in milliseconds
       |&gt; Enum.map(fn task -&gt; Task.await(task, 145_000) end)
       |&gt; Enum.map(fn result -&gt;
         case result do
           {:ok, result} -&gt; map_function.(result)
           _ -&gt; nil
         end
       end)
       |&gt; Enum.filter(fn result -&gt; not is_nil(result) end)}

  defp _map_alliance_info(info) do
    %{
      label: info[&quot;name&quot;],
      value: info[&quot;eve_id&quot;] |&gt; to_string(),
      alliance: true
    }
  end

  defp _map_character_info(info) do
    %{
      label: info[&quot;name&quot;],
      value: info[&quot;eve_id&quot;] |&gt; to_string(),
      character: true
    }
  end

  defp _map_corporation_info(info) do
    %{
      label: info[&quot;name&quot;],
      value: info[&quot;eve_id&quot;] |&gt; to_string(),
      corporation: true
    }
  end

  @doc &quot;&quot;&quot;
  Finds a character by EVE ID from a user&apos;s active characters.

  ## Parameters
  - `current_user_id`: The current user ID
  - `character_eve_id`: The EVE ID of the character to find

  ## Returns
  - `{:ok, character}` if the character is found
  - `{:error, :character_not_found}` if the character is not found
  &quot;&quot;&quot;
  def find_character_by_eve_id(current_user_id, character_eve_id) do
    {:ok, all_user_characters} =
      WandererApp.Api.Character.active_by_user(%{user_id: current_user_id})

    case Enum.find(all_user_characters, fn char -&gt;
           &quot;#{char.eve_id}&quot; == &quot;#{character_eve_id}&quot;
         end) do
      nil -&gt;
        {:error, :character_not_found}

      character -&gt;
        {:ok, character}
    end
  end

  @doc &quot;&quot;&quot;
  Finds a character by character ID from a user&apos;s characters.

  ## Parameters
  - `current_user`: The current user struct
  - `char_id`: The character ID to find

  ## Returns
  - `{:ok, character}` if the character is found
  - `{:error, :character_not_found}` if the character is not found
  &quot;&quot;&quot;
  def find_user_character(current_user, char_id) do
    case Enum.find(current_user.characters, &amp;(&quot;#{&amp;1.id}&quot; == &quot;#{char_id}&quot;)) do
      nil -&gt;
        {:error, :character_not_found}

      char -&gt;
        {:ok, char}
    end
  end
end</file><file path="lib/wanderer_app/env.ex">defmodule WandererApp.Env do
  @moduledoc false
  use Nebulex.Caching

  @app :wanderer_app

  @decorate cacheable(
              cache: WandererApp.Cache,
              key: &quot;vsn_version&quot;
            )
  def vsn(), do: Application.spec(@app)[:vsn]

  def git_sha(), do: get_key(:git_sha, &quot;&lt;GIT_SHA&gt;&quot;)
  def base_url, do: get_key(:web_app_url, &quot;&lt;BASE_URL&gt;&quot;)
  def custom_route_base_url, do: get_key(:custom_route_base_url, &quot;&lt;CUSTOM_ROUTE_BASE_URL&gt;&quot;)
  def invites, do: get_key(:invites, false)
  def map_subscriptions_enabled?, do: get_key(:map_subscriptions_enabled, false)
  def public_api_disabled?, do: get_key(:public_api_disabled, false)
  def character_api_disabled?, do: get_key(:character_api_disabled, false)
  def zkill_preload_disabled?, do: get_key(:zkill_preload_disabled, false)
  def wallet_tracking_enabled?, do: get_key(:wallet_tracking_enabled, false)
  def admins, do: get_key(:admins, [])
  def admin_username, do: get_key(:admin_username)
  def admin_password, do: get_key(:admin_password)
  def corp_wallet, do: get_key(:corp_wallet, &quot;&quot;)
  def corp_eve_id, do: get_key(:corp_id, -1)
  def subscription_settings, do: get_key(:subscription_settings)

  @decorate cacheable(
              cache: WandererApp.Cache,
              key: &quot;restrict_maps_creation&quot;
            )
  def restrict_maps_creation?, do: get_key(:restrict_maps_creation, false)

  @decorate cacheable(
              cache: WandererApp.Cache,
              key: &quot;map-connection-auto-expire-hours&quot;
            )
  def map_connection_auto_expire_hours, do: get_key(:map_connection_auto_expire_hours)

  @decorate cacheable(
              cache: WandererApp.Cache,
              key: &quot;map-connection-auto-eol-hours&quot;
            )
  def map_connection_auto_eol_hours, do: get_key(:map_connection_auto_eol_hours)

  @decorate cacheable(
              cache: WandererApp.Cache,
              key: &quot;map-connection-eol-expire-timeout-mins&quot;
            )
  def map_connection_eol_expire_timeout_mins,
    do: get_key(:map_connection_eol_expire_timeout_mins)

  def get_key(key, default \\ nil), do: Application.get_env(@app, key, default)

  @doc &quot;&quot;&quot;
  A single map containing environment variables
  made available to react
  &quot;&quot;&quot;
  def to_client_env do
    %{detailedKillsDisabled: zkill_preload_disabled?()}
  end
end</file><file path="lib/wanderer_app/esi.ex">defmodule WandererApp.Esi do
  @moduledoc group: :esi

  defdelegate get_server_status, to: WandererApp.Esi.ApiClient
  defdelegate get_alliance_info(eve_id, opts \\ []), to: WandererApp.Esi.ApiClient
  defdelegate get_corporation_info(eve_id, opts \\ []), to: WandererApp.Esi.ApiClient
  defdelegate get_character_info(eve_id, opts \\ []), to: WandererApp.Esi.ApiClient

  defdelegate post_characters_affiliation(character_eve_ids, opts \\ []),
    to: WandererApp.Esi.ApiClient

  defdelegate get_character_wallet(character_eve_id, opts \\ []), to: WandererApp.Esi.ApiClient
  defdelegate get_corporation_wallets(corporation_id, opts \\ []), to: WandererApp.Esi.ApiClient

  defdelegate get_corporation_wallet_journal(corporation_id, division, opts \\ []),
    to: WandererApp.Esi.ApiClient

  defdelegate get_corporation_wallet_transactions(corporation_id, division, opts \\ []),
    to: WandererApp.Esi.ApiClient

  defdelegate get_character_location(character_eve_id, opts \\ []), to: WandererApp.Esi.ApiClient
  defdelegate get_character_online(character_eve_id, opts \\ []), to: WandererApp.Esi.ApiClient
  defdelegate get_character_ship(character_eve_id, opts \\ []), to: WandererApp.Esi.ApiClient
  defdelegate find_routes(map_id, origin, hubs, routes_settings), to: WandererApp.Esi.ApiClient
  defdelegate search(character_eve_id, opts \\ []), to: WandererApp.Esi.ApiClient

  defdelegate get_killmail(killmail_id, killmail_hash, opts \\ []), to: WandererApp.Esi.ApiClient


  defdelegate set_autopilot_waypoint(
                add_to_beginning,
                clear_other_waypoints,
                destination_id,
                opts \\ []
              ),
              to: WandererApp.Esi.ApiClient
end</file><file path="lib/wanderer_app/eve_data_service.ex">defmodule WandererApp.EveDataService do
  @moduledoc &quot;&quot;&quot;
  Service for loading data from the EVE DB dumps &amp; JSON files
  &quot;&quot;&quot;

  require Logger

  alias WandererApp.Utils.JSONUtil

  @eve_db_dump_url &quot;https://www.fuzzwork.co.uk/dump/latest&quot;

  @dump_file_names [
    &quot;invGroups.csv&quot;,
    &quot;invTypes.csv&quot;,
    &quot;mapConstellations.csv&quot;,
    &quot;mapRegions.csv&quot;,
    &quot;mapLocationWormholeClasses.csv&quot;,
    &quot;mapSolarSystems.csv&quot;,
    &quot;mapSolarSystemJumps.csv&quot;
  ]

  def update_eve_data() do
    download_files()

    Logger.info(&quot;Downloading files finished!&quot;)

    get_db_data()
    |&gt; Ash.bulk_create(WandererApp.Api.MapSolarSystem, :create)

    Logger.info(&quot;MapSolarSystem updated!&quot;)

    get_ship_types_data()
    |&gt; Ash.bulk_create(WandererApp.Api.ShipTypeInfo, :create)

    Logger.info(&quot;ShipTypeInfo updated!&quot;)

    get_solar_system_jumps_data()
    |&gt; Ash.bulk_create(WandererApp.Api.MapSolarSystemJumps, :create)

    Logger.info(&quot;MapSolarSystemJumps updated!&quot;)
  end

  def download_files() do
    tasks =
      @dump_file_names
      |&gt; Enum.map(fn file_name -&gt;
        Task.async(fn -&gt;
          download_file(file_name)
        end)
      end)

    Task.await_many(tasks, :timer.minutes(30))
  end

  def download_file(file_name) do
    url = &quot;#{@eve_db_dump_url}/#{file_name}&quot;
    Logger.info(&quot;Downloading file from #{url}&quot;)

    download_path = Path.join([:code.priv_dir(:wanderer_app), &quot;repo&quot;, &quot;data&quot;, file_name])

    Req.get!(url, raw: true, into: File.stream!(download_path, [:write])).body
    |&gt; Stream.run()

    Logger.info(&quot;File downloaded successfully to #{download_path}&quot;)

    :ok
  end

  def load_wormhole_types() do
    JSONUtil.read_json!(&quot;#{:code.priv_dir(:wanderer_app)}/repo/data/wormholes.json&quot;)
    |&gt; Enum.map(fn row -&gt;
      %{
        id: row[&quot;typeID&quot;],
        name: row[&quot;name&quot;],
        src: row[&quot;src&quot;],
        dest: row[&quot;dest&quot;],
        total_mass: row[&quot;total_mass&quot;],
        lifetime: row[&quot;lifetime&quot;],
        max_mass_per_jump: row[&quot;max_mass_per_jump&quot;],
        static: row[&quot;static&quot;],
        mass_regen: row[&quot;mass_regen&quot;],
        sibling_groups: row[&quot;sibling_groups&quot;],
        respawn: row[&quot;respawn&quot;]
      }
    end)
  end

  def load_wormhole_classes() do
    JSONUtil.read_json!(&quot;#{:code.priv_dir(:wanderer_app)}/repo/data/wormholeClasses.json&quot;)
    |&gt; Enum.map(fn row -&gt;
      %{
        id: row[&quot;id&quot;],
        short_name: row[&quot;shortName&quot;],
        short_title: row[&quot;shortTitle&quot;],
        title: row[&quot;title&quot;],
        effect_power: row |&gt; Map.get(&quot;effectPower&quot;, 0),
        wormhole_class_id: row[&quot;wormholeClassID&quot;]
      }
    end)
  end

  def load_wormhole_systems() do
    JSONUtil.read_json!(&quot;#{:code.priv_dir(:wanderer_app)}/repo/data/wormholeSystems.json&quot;)
    |&gt; Enum.map(fn row -&gt;
      %{
        solar_system_id: row[&quot;solarSystemID&quot;],
        wanderers: row[&quot;wanderers&quot;],
        statics: row[&quot;statics&quot;],
        system_name: row[&quot;systemName&quot;],
        effect_name: row[&quot;effectName&quot;]
      }
    end)
  end

  def load_effects() do
    JSONUtil.read_json!(&quot;#{:code.priv_dir(:wanderer_app)}/repo/data/effects.json&quot;)
    |&gt; Enum.map(fn row -&gt;
      %{
        id: row[&quot;name&quot;] |&gt; Slug.slugify(),
        name: row[&quot;name&quot;],
        modifiers:
          row[&quot;modifiers&quot;]
          |&gt; Enum.map(fn m -&gt;
            %{
              name: m[&quot;name&quot;],
              positive: m[&quot;positive&quot;],
              power: m[&quot;power&quot;]
            }
          end)
      }
    end)
  end

  def load_triglavian_systems() do
    JSONUtil.read_json!(&quot;#{:code.priv_dir(:wanderer_app)}/repo/data/triglavianSystems.json&quot;)
    |&gt; Enum.map(fn row -&gt;
      %{
        solar_system_id: row[&quot;solarSystemID&quot;],
        solar_system_name: row[&quot;solarSystemName&quot;],
        effect_name: row[&quot;effectName&quot;],
        effect_power: row[&quot;effectPower&quot;],
        invasion_status: row[&quot;invasionStatus&quot;]
      }
    end)
  end

  def load_wormhole_classes_info() do
    {:ok, data} =
      JSONUtil.read_json(&quot;#{:code.priv_dir(:wanderer_app)}/repo/data/wormholeClassesInfo.json&quot;)

    %{
      names: data[&quot;names&quot;],
      classes: data[&quot;classes&quot;]
    }
  end

  def load_shattered_constellations() do
    {:ok, data} =
      JSONUtil.read_json(
        &quot;#{:code.priv_dir(:wanderer_app)}/repo/data/shatteredConstellations.json&quot;
      )

    data
  end

  def load_map_constellations() do
    WandererApp.Utils.CSVUtil.csv_row_to_table_record(
      &quot;#{:code.priv_dir(:wanderer_app)}/repo/data/mapConstellations.csv&quot;,
      fn row -&gt;
        %{
          constellation_id: row[&quot;constellationID&quot;] |&gt; Integer.parse() |&gt; elem(0),
          constellation_name: row[&quot;constellationName&quot;]
        }
      end
    )
  end

  def load_map_regions() do
    WandererApp.Utils.CSVUtil.csv_row_to_table_record(
      &quot;#{:code.priv_dir(:wanderer_app)}/repo/data/mapRegions.csv&quot;,
      fn row -&gt;
        %{
          region_id: row[&quot;regionID&quot;] |&gt; Integer.parse() |&gt; elem(0),
          region_name: row[&quot;regionName&quot;]
        }
      end
    )
  end

  def load_map_location_wormhole_classes() do
    WandererApp.Utils.CSVUtil.csv_row_to_table_record(
      &quot;#{:code.priv_dir(:wanderer_app)}/repo/data/mapLocationWormholeClasses.csv&quot;,
      fn row -&gt;
        %{
          location_id: row[&quot;locationID&quot;],
          wormhole_class_id: row[&quot;wormholeClassID&quot;]
        }
      end
    )
  end

  def load_inv_groups() do
    WandererApp.Utils.CSVUtil.csv_row_to_table_record(
      &quot;#{:code.priv_dir(:wanderer_app)}/repo/data/invGroups.csv&quot;,
      fn row -&gt;
        %{
          group_id: row[&quot;groupID&quot;] |&gt; Integer.parse() |&gt; elem(0),
          group_name: row[&quot;groupName&quot;],
          category_id: row[&quot;categoryID&quot;] |&gt; Integer.parse() |&gt; elem(0)
        }
      end
    )
  end

  def get_db_data() do
    map_constellations = load_map_constellations()
    map_regions = load_map_regions()
    map_location_wormhole_classes = load_map_location_wormhole_classes()
    wormhole_classes = load_wormhole_classes()
    wormhole_systems = load_wormhole_systems()

    triglavian_systems = load_triglavian_systems()
    wormhole_classes_info = load_wormhole_classes_info()
    shattered_constellations = load_shattered_constellations()

    WandererApp.Utils.CSVUtil.csv_row_to_table_record(
      &quot;#{:code.priv_dir(:wanderer_app)}/repo/data/mapSolarSystems.csv&quot;,
      fn row -&gt;
        solar_system_id = row[&quot;solarSystemID&quot;] |&gt; Integer.parse() |&gt; elem(0)
        region_id = row[&quot;regionID&quot;] |&gt; Integer.parse() |&gt; elem(0)
        constellation_id = row[&quot;constellationID&quot;] |&gt; Integer.parse() |&gt; elem(0)
        solar_system_name = row[&quot;solarSystemName&quot;]

        {:ok, wormhole_class_id} =
          get_wormhole_class_id(
            map_location_wormhole_classes,
            region_id,
            constellation_id,
            solar_system_id
          )

        {:ok, constellation_name} =
          get_constellation_name(map_constellations, constellation_id)

        {:ok, region_name} = get_region_name(map_regions, region_id)

        {:ok, wormhole_class} = get_wormhole_class(wormhole_classes, wormhole_class_id)

        {:ok, security} = get_security(row[&quot;security&quot;])

        {:ok, class_title} =
          get_class_title(
            wormhole_classes_info,
            wormhole_class_id,
            security,
            wormhole_class
          )

        {:ok, solar_system_name} =
          get_system_name(
            wormhole_classes_info,
            wormhole_class_id,
            solar_system_name,
            wormhole_class
          )

        is_shattered =
          case Map.get(shattered_constellations, constellation_id |&gt; Integer.to_string()) do
            nil -&gt; false
            _ -&gt; true
          end

        %{
          effect_power: 0,
          effect_name: &quot;&quot;,
          statics: [],
          wandering: [],
          triglavian_invasion_status: &quot;Normal&quot;,
          constellation_id: constellation_id,
          region_id: region_id,
          solar_system_id: solar_system_id,
          solar_system_name: solar_system_name,
          solar_system_name_lc: solar_system_name |&gt; String.downcase(),
          sun_type_id: get_sun_type_id(row[&quot;sunTypeID&quot;]),
          constellation_name: constellation_name,
          region_name: region_name,
          security: security,
          system_class: wormhole_class_id,
          class_title: class_title,
          type_description: wormhole_class.title,
          is_shattered: is_shattered
        }
        |&gt; get_wormhole_data(wormhole_systems, solar_system_id, wormhole_class)
        |&gt; get_triglavian_data(triglavian_systems, solar_system_id)
      end
    )
  end

  def get_ship_types_data() do
    inv_groups = load_inv_groups()

    ship_type_groups =
      inv_groups
      |&gt; Enum.filter(fn g -&gt; g.category_id == 6 end)
      |&gt; Enum.map(fn g -&gt; g.group_id end)

    WandererApp.Utils.CSVUtil.csv_row_to_table_record(
      &quot;#{:code.priv_dir(:wanderer_app)}/repo/data/invTypes.csv&quot;,
      fn row -&gt;
        group_id = row[&quot;groupID&quot;] |&gt; Integer.parse() |&gt; elem(0)

        inv_group =
          case Enum.find(inv_groups, fn group -&gt;
                 group.group_id == group_id
               end) do
            nil -&gt; %{}
            group -&gt; group
          end

        %{
          type_id: row[&quot;typeID&quot;] |&gt; Integer.parse() |&gt; elem(0),
          group_id: group_id,
          name: row[&quot;typeName&quot;],
          mass: row[&quot;mass&quot;],
          volume: row[&quot;volume&quot;],
          capacity: row[&quot;capacity&quot;],
          group_name: inv_group.group_name
        }
      end
    )
    |&gt; Enum.filter(fn t -&gt; t.group_id in ship_type_groups end)
  end

  def get_solar_system_jumps_data() do
    WandererApp.Utils.CSVUtil.csv_row_to_table_record(
      &quot;#{:code.priv_dir(:wanderer_app)}/repo/data/mapSolarSystemJumps.csv&quot;,
      fn row -&gt;
        %{
          from_solar_system_id: row[&quot;fromSolarSystemID&quot;] |&gt; Integer.parse() |&gt; elem(0),
          to_solar_system_id: row[&quot;toSolarSystemID&quot;] |&gt; Integer.parse() |&gt; elem(0)
        }
      end
    )
  end

  defp get_sun_type_id(sun_type_id) do
    case sun_type_id do
      &quot;None&quot; -&gt; 0
      _ -&gt; sun_type_id |&gt; Integer.parse() |&gt; elem(0)
    end
  end

  defp get_wormhole_data(default_data, wormhole_systems, solar_system_id, wormhole_class) do
    case Enum.find(wormhole_systems, fn system -&gt; system.solar_system_id == solar_system_id end) do
      nil -&gt;
        default_data

      wormhole_data -&gt;
        %{
          default_data
          | effect_power: wormhole_class.effect_power,
            effect_name: wormhole_data.effect_name,
            statics: wormhole_data.statics,
            wandering: wormhole_data.wanderers
        }
    end
  end

  defp get_solar_system_name(solar_system_name, wormhole_class) do
  end

  defp get_triglavian_data(default_data, triglavian_systems, solar_system_id) do
    case Enum.find(triglavian_systems, fn system -&gt; system.solar_system_id == solar_system_id end) do
      nil -&gt;
        default_data

      triglavian_data -&gt;
        %{
          default_data
          | triglavian_invasion_status: triglavian_data.invasion_status,
            effect_name: triglavian_data.effect_name,
            effect_power: triglavian_data.effect_power
        }
    end
  end

  defp get_security(security) do
    case security do
      nil -&gt; {:ok, &quot;&quot;}
      _ -&gt; {:ok, String.to_float(security) |&gt; get_true_security() |&gt; Float.to_string(decimals: 1)}
    end
  end

  defp truncate_to_two_digits(value) when is_float(value), do: Float.floor(value * 100) / 100

  defp get_true_security(security) when is_float(security) and security &gt; 0.0 and security &lt; 0.05,
    do: security |&gt; Float.ceil(1)

  defp get_true_security(security) when is_float(security) do
    truncated_value = security |&gt; truncate_to_two_digits()
    floor_value = truncated_value |&gt; Float.floor(1)

    if Float.round(truncated_value - floor_value, 2) &lt; 0.05 do
      floor_value
    else
      Float.ceil(truncated_value, 1)
    end
  end

  defp get_system_name(
         wormhole_classes_info,
         wormhole_class_id,
         solar_system_name,
         wormhole_class
       ) do
    case wormhole_class_id in [
           wormhole_classes_info.names[&quot;sentinel&quot;],
           wormhole_classes_info.names[&quot;barbican&quot;],
           wormhole_classes_info.names[&quot;vidette&quot;],
           wormhole_classes_info.names[&quot;conflux&quot;],
           wormhole_classes_info.names[&quot;redoubt&quot;]
         ] do
      true -&gt;
        {:ok, wormhole_class.short_title}

      _ -&gt;
        {:ok, solar_system_name}
    end
  end

  defp get_class_title(wormhole_classes_info, wormhole_class_id, security, wormhole_class) do
    case wormhole_class_id in [
           wormhole_classes_info.names[&quot;hs&quot;],
           wormhole_classes_info.names[&quot;ls&quot;],
           wormhole_classes_info.names[&quot;ns&quot;]
         ] do
      true -&gt;
        {:ok, security}

      _ -&gt;
        {:ok, wormhole_class.short_name}
    end
  end

  defp get_constellation_name(constellations, constellation_id) do
    case Enum.find(constellations, fn constellation -&gt;
           constellation.constellation_id == constellation_id
         end) do
      nil -&gt; {:ok, &quot;&quot;}
      constellation -&gt; {:ok, constellation.constellation_name}
    end
  end

  defp get_region_name(regions, region_id) do
    case Enum.find(regions, fn region -&gt; region.region_id == region_id end) do
      nil -&gt; {:ok, &quot;&quot;}
      region -&gt; {:ok, region.region_name}
    end
  end

  defp get_wormhole_class(wormhole_classes, wormhole_class_id) do
    {:ok,
     Enum.find(wormhole_classes, fn wormhole_class -&gt;
       wormhole_class.wormhole_class_id == wormhole_class_id
     end)}
  end

  defp get_wormhole_class_id(_systems, _region_id, _constellation_id, 30_100_000),
    do: {:ok, 10_100}

  defp get_wormhole_class_id(systems, region_id, constellation_id, solar_system_id) do
    with region &lt;-
           Enum.find(systems, fn system -&gt;
             system.location_id |&gt; Integer.parse() |&gt; elem(0) == region_id
           end),
         constellation &lt;-
           Enum.find(systems, fn system -&gt;
             system.location_id |&gt; Integer.parse() |&gt; elem(0) == constellation_id
           end),
         solar_system &lt;-
           Enum.find(systems, fn system -&gt;
             system.location_id |&gt; Integer.parse() |&gt; elem(0) == solar_system_id
           end),
         wormhole_class_id &lt;- get_wormhole_class_id(region, constellation, solar_system) do
      {:ok, wormhole_class_id}
    else
      _ -&gt; {:ok, -1}
    end
  end

  defp get_wormhole_class_id(_region, _constellation, solar_system)
       when not is_nil(solar_system),
       do: solar_system.wormhole_class_id |&gt; Integer.parse() |&gt; elem(0)

  defp get_wormhole_class_id(_region, constellation, _solar_system)
       when not is_nil(constellation),
       do: constellation.wormhole_class_id |&gt; Integer.parse() |&gt; elem(0)

  defp get_wormhole_class_id(region, _constellation, _solar_system) when not is_nil(region),
    do: region.wormhole_class_id |&gt; Integer.parse() |&gt; elem(0)

  defp get_wormhole_class_id(_region, _constellation, _solar_system), do: -1
end</file><file path="lib/wanderer_app/gen_impl.ex">defmodule WandererApp.GenImpl do
  @moduledoc &quot;Simple utility for avoiding boilerplate in a GenServer implementation.&quot;

  @doc &quot;&quot;&quot;
  If your GenServer is a thin wrapper around a struct, you can make its handle_call/3 and/or
  handle_cast/2 implementations be &quot;just this.&quot;

  Use it like this:

      GenImpl.apply_call(&amp;MyGenServer.Impl.update/3, %MyGenServer.Impl{}, [arg2, arg3])

  This will result in a call that looks like:

      MyGenServer.Impl.update(%MyGenServer.Impl{}, arg2, arg3)

  Supports operations that:

  - Update the state struct
  - Return a result tuple, or even just :error
  - Query the state and return a value

  ...but not operations that both modify the state *and* query something.
  &quot;&quot;&quot;
  def apply_call(impl_function, state, additional_args)
      when is_function(impl_function) and is_struct(state) and is_list(additional_args) do
    result = apply(impl_function, [state | additional_args])
    handle_call_result(state, result)
  end

  def apply_call(impl_function_name, %struct_module{} = state, additional_args)
      when is_atom(impl_function_name) and is_list(additional_args) do
    result = apply(struct_module, impl_function_name, [state | additional_args])
    handle_call_result(state, result)
  end

  defp handle_call_result(%struct_type{}, %struct_type{} = updated_state),
    do: {:reply, :ok, updated_state}

  defp handle_call_result(%struct_type{}, {:ok, %struct_type{} = updated_state}),
    do: {:reply, :ok, updated_state}

  defp handle_call_result(%struct_type{}, {result, %struct_type{} = updated_state}),
    do: {:reply, result, updated_state}

  defp handle_call_result(%_struct_type{} = state, :error), do: {:reply, :error, state}
  defp handle_call_result(%_struct_type{} = state, result), do: {:reply, result, state}
end</file><file path="lib/wanderer_app/init_corp_wallet_tracker_task.ex">defmodule WandererApp.StartCorpWalletTrackerTask do
  use Task

  require Logger

  def start_link(arg) do
    Task.start_link(__MODULE__, :run, [arg])
  end

  def run(_arg) do
    Logger.info(&quot;Starting corp wallet tracker task&quot;)

    case WandererApp.Env.corp_wallet() do
      &quot;&quot; -&gt;
        :ok

      user_hash -&gt;
        user_hash
        |&gt; _get_user_characters()
        |&gt; maybe_start_corp_wallet_tracker()
    end
  end

  def maybe_start_corp_wallet_tracker({:ok, user_characters}) do
    admin_character =
      user_characters
      |&gt; Enum.find(fn character -&gt;
        WandererApp.Character.can_track_corp_wallet?(character)
      end)

    if not is_nil(admin_character) do
      :ok =
        WandererApp.Character.TrackerManager.start_tracking(admin_character.id, keep_alive: true)

      {:ok, _pid} =
        WandererApp.Character.TrackerManager.start_transaction_tracker(admin_character.id)
    end

    :ok
  end

  def maybe_start_corp_wallet_tracker(_), do: :ok

  defp _get_user_characters(user_hash) when not is_nil(user_hash) and is_binary(user_hash) do
    case WandererApp.Api.User.by_hash(user_hash, load: :characters) do
      {:ok, user} -&gt; {:ok, user.characters}
      {:error, _} -&gt; {:ok, []}
    end
  end

  defp _get_user_characters(_), do: {:ok, []}
end</file><file path="lib/wanderer_app/mailer.ex">defmodule WandererApp.Mailer do
  use Swoosh.Mailer, otp_app: :wanderer_app
end</file><file path="lib/wanderer_app/map.ex">defmodule WandererApp.Map do
  @moduledoc &quot;&quot;&quot;
  Represents the map structure and exposes actions that can be taken to update
  it
  &quot;&quot;&quot;
  import Ecto.Query

  require Logger

  defstruct map_id: nil,
            name: nil,
            scope: :none,
            owner_id: nil,
            characters: [],
            systems: Map.new(),
            hubs: [],
            connections: Map.new(),
            acls: [],
            options: Map.new(),
            characters_limit: nil,
            hubs_limit: nil

  def new(%{id: map_id, name: name, scope: scope, owner_id: owner_id, acls: acls, hubs: hubs}) do
    map =
      struct!(__MODULE__,
        map_id: map_id,
        scope: scope,
        owner_id: owner_id,
        name: name,
        acls: acls,
        hubs: hubs
      )

    update_map(map_id, map)

    map
  end

  def get_map(map_id) do
    case Cachex.get(:map_cache, map_id) do
      {:ok, nil} -&gt;
        {:error, :not_found}

      {:ok, map} -&gt;
        {:ok, map}
    end
  end

  def get_map!(map_id) do
    case get_map(map_id) do
      {:ok, map} -&gt;
        map

      _ -&gt;
        Logger.error(fn -&gt; &quot;Failed to get map #{map_id}&quot; end)
        %{}
    end
  end

  def update_map(map_id, map_update) do
    Cachex.get_and_update(:map_cache, map_id, fn map -&gt;
      case map do
        nil -&gt;
          {:commit, map_update}

        _ -&gt;
          {:commit, Map.merge(map, map_update)}
      end
    end)
  end

  def get_characters_limit(map_id),
    do: {:ok, map_id |&gt; get_map!() |&gt; Map.get(:characters_limit, 50)}

  def get_hubs_limit(map_id),
    do: {:ok, map_id |&gt; get_map!() |&gt; Map.get(:hubs_limit, 20)}

  def is_subscription_active?(map_id),
    do: is_subscription_active?(map_id, WandererApp.Env.map_subscriptions_enabled?())

  def is_subscription_active?(_map_id, false), do: {:ok, true}

  def is_subscription_active?(map_id, _map_subscriptions_enabled) do
    {:ok, %{plan: plan}} = WandererApp.Map.SubscriptionManager.get_active_map_subscription(map_id)
    {:ok, plan != :alpha}
  end

  def get_options(map_id),
    do: {:ok, map_id |&gt; get_map!() |&gt; Map.get(:options, Map.new())}

  @doc &quot;&quot;&quot;
  Returns a full list of characters in the map
  &quot;&quot;&quot;
  def list_characters(map_id),
    do:
      map_id
      |&gt; get_map!()
      |&gt; Map.get(:characters, [])
      |&gt; Enum.map(fn character_id -&gt; WandererApp.Character.get_map_character!(map_id, character_id) end)

  def list_systems(map_id),
    do: {:ok, map_id |&gt; get_map!() |&gt; Map.get(:systems, Map.new()) |&gt; Map.values()}

  def list_systems!(map_id) do
    {:ok, systems} = list_systems(map_id)
    systems
  end

  def list_hubs(map_id) do
    {:ok, map} = map_id |&gt; get_map()

    {:ok, map |&gt; Map.get(:hubs, [])}
  end

  def list_hubs(map_id, hubs) do
    {:ok, map} = map_id |&gt; get_map()

    {:ok, hubs}
  end

  def list_connections(map_id),
    do: {:ok, map_id |&gt; get_map!() |&gt; Map.get(:connections, Map.new()) |&gt; Map.values()}

  def list_connections!(map_id) do
    {:ok, connections} = list_connections(map_id)
    connections
  end

  def get_connection(map_id, solar_system_source, solar_system_target),
    do:
      map_id
      |&gt; get_map!()
      |&gt; Map.get(:connections, Map.new())
      |&gt; Map.get(&quot;#{solar_system_source}_#{solar_system_target}&quot;)

  def add_characters!(map, []), do: map

  def add_characters!(%{map_id: map_id} = map, [character | rest]) do
    case add_character(map_id, character) do
      :ok -&gt;
        add_characters!(map, rest)

      {:error, :already_exists} -&gt;
        add_characters!(map, rest)
    end
  end

  def add_character(
        map_id,
        %{
          id: character_id
        } = _character
      ) do
    characters = map_id |&gt; get_map!() |&gt; Map.get(:characters, [])

    case not (characters |&gt; Enum.member?(character_id)) do
      true -&gt;
        {:ok,
         %{
           alliance_id: alliance_id,
           corporation_id: corporation_id,
           solar_system_id: solar_system_id,
           structure_id: structure_id,
           station_id: station_id,
           ship: ship_type_id,
           ship_name: ship_name
         }} = WandererApp.Character.get_character(character_id)

        map_id
        |&gt; update_map(%{characters: [character_id | characters]})

        WandererApp.Cache.insert(
          &quot;map:#{map_id}:character:#{character_id}:alliance_id&quot;,
          alliance_id
        )

        WandererApp.Cache.insert(
          &quot;map:#{map_id}:character:#{character_id}:corporation_id&quot;,
          corporation_id
        )

        WandererApp.Cache.insert(
          &quot;map:#{map_id}:character:#{character_id}:solar_system_id&quot;,
          solar_system_id
        )

        WandererApp.Cache.insert(
          &quot;map:#{map_id}:character:#{character_id}:structure_id&quot;,
          structure_id
        )

        WandererApp.Cache.insert(
          &quot;map:#{map_id}:character:#{character_id}:station_id&quot;,
          station_id
        )

        WandererApp.Cache.insert(
          &quot;map:#{map_id}:character:#{character_id}:ship_type_id&quot;,
          ship_type_id
        )

        WandererApp.Cache.insert(
          &quot;map:#{map_id}:character:#{character_id}:ship_name&quot;,
          ship_name
        )

        :ok

      _ -&gt;
        {:error, :already_exists}
    end
  end

  def get_system_characters(map_id, solar_system_id),
    do:
      map_id
      |&gt; list_characters()
      |&gt; filter(%{solar_system_id: solar_system_id}, match: :any)

  @doc &quot;&quot;&quot;
  Removes a character with a given id
  &quot;&quot;&quot;
  def remove_character(map_id, character_id) do
    characters = map_id |&gt; get_map!() |&gt; Map.get(:characters, [])

    case characters |&gt; Enum.member?(character_id) do
      true -&gt;
        map_id
        |&gt; update_map(%{characters: characters |&gt; Enum.reject(fn id -&gt; id == character_id end)})

        :ok

      _ -&gt;
        :ok
    end
  end

  def check_location(map_id, location) do
    case find_system_by_location(map_id, location) do
      nil -&gt;
        {:ok, location}

      %{} -&gt;
        {:error, :already_exists}
    end
  end

  def find_system_by_location(_map_id, nil), do: nil

  def find_system_by_location(map_id, %{solar_system_id: solar_system_id} = _location) do
    case map_id |&gt; get_map!() |&gt; Map.get(:systems, Map.new()) |&gt; Map.get(solar_system_id) do
      nil -&gt;
        nil

      %{visible: true} = system -&gt;
        system

      _system -&gt;
        nil
    end
  end

  def check_connection(
        map_id,
        %{solar_system_id: solar_system_id} = _location,
        %{solar_system_id: old_solar_system_id} = _old_location
      ) do
    case map_id
         |&gt; get_map!()
         |&gt; Map.get(:connections, Map.new())
         |&gt; is_connection_exist?(%{
           solar_system_source: solar_system_id,
           solar_system_target: old_solar_system_id
         }) do
      true -&gt;
        {:error, :already_exists}

      _ -&gt;
        :ok
    end
  end

  def update_subscription_settings!(%{map_id: map_id} = map, %{
        characters_limit: characters_limit,
        hubs_limit: hubs_limit
      }) do
    map_id
    |&gt; update_map(%{characters_limit: characters_limit, hubs_limit: hubs_limit})

    map
  end

  def update_options!(%{map_id: map_id} = map, options) do
    map_id
    |&gt; update_map(%{options: options})

    map
  end

  def add_systems!(map, []), do: map

  def add_systems!(%{map_id: map_id} = map, [system | rest]) do
    :ok = add_system(map_id, system)
    add_systems!(map, rest)
  end

  def add_system(map_id, %{solar_system_id: solar_system_id} = system) do
    systems = map_id |&gt; get_map!() |&gt; Map.get(:systems, Map.new())

    case not Map.has_key?(systems, solar_system_id) do
      true -&gt;
        map_id
        |&gt; update_map(%{systems: Map.put(systems, solar_system_id, system)})

        :ok

      _ -&gt;
        :ok
    end
  end

  def update_system_by_solar_system_id(
        map_id,
        update
      ) do
    updated_systems =
      map_id |&gt; get_map!() |&gt; Map.get(:systems, Map.new()) |&gt; update_by_solar_system_id(update)

    map_id
    |&gt; update_map(%{systems: updated_systems})

    :ok
  end

  def remove_system(map_id, solar_system_id) do
    systems = map_id |&gt; get_map!() |&gt; Map.get(:systems, Map.new())

    case systems |&gt; Map.get(solar_system_id) do
      nil -&gt;
        :ok

      _system -&gt;
        map_id
        |&gt; update_map(%{systems: Map.drop(systems, [solar_system_id])})

        :ok
    end
  end

  def remove_systems(_map_id, []), do: :ok

  def remove_systems(map_id, [solar_system_id | rest]) do
    :ok = remove_system(map_id, solar_system_id)
    remove_systems(map_id, rest)
  end

  def add_hub(map_id, %{solar_system_id: solar_system_id} = _hub_info) do
    hubs = map_id |&gt; get_map!() |&gt; Map.get(:hubs, [])

    case hubs |&gt; Enum.member?(&quot;#{solar_system_id}&quot;) do
      false -&gt;
        map_id
        |&gt; update_map(%{hubs: [&quot;#{solar_system_id}&quot; | hubs]})

        :ok

      _ -&gt;
        :ok
    end
  end

  def remove_hub(map_id, %{solar_system_id: solar_system_id} = _hub_info) do
    hubs = map_id |&gt; get_map!() |&gt; Map.get(:hubs, [])

    case hubs |&gt; Enum.member?(&quot;#{solar_system_id}&quot;) do
      true -&gt;
        map_id
        |&gt; update_map(%{hubs: Enum.reject(hubs, fn hub -&gt; hub == &quot;#{solar_system_id}&quot; end)})

        :ok

      _ -&gt;
        :ok
    end
  end

  def add_connections!(map, []), do: map

  def add_connections!(%{map_id: map_id} = map, [connection | rest]) do
    case add_connection(map_id, connection) do
      :ok -&gt;
        add_connections!(map, rest)

      {:error, :already_exists} -&gt;
        connection
        |&gt; WandererApp.MapConnectionRepo.destroy!()

        add_connections!(map, rest)
    end
  end

  def add_connection(
        map_id,
        %{solar_system_source: solar_system_source, solar_system_target: solar_system_target} =
          connection
      ) do
    connections = map_id |&gt; get_map!() |&gt; Map.get(:connections, Map.new())

    case not (connections |&gt; is_connection_exist?(connection)) do
      true -&gt;
        map_id
        |&gt; update_map(%{
          connections:
            Map.put_new(connections, &quot;#{solar_system_source}_#{solar_system_target}&quot;, connection)
        })

        :ok

      _ -&gt;
        :ok
    end
  end

  def is_connection_exist?(
        connections,
        %{solar_system_source: solar_system_source, solar_system_target: solar_system_target} =
          _connection
      ) do
    connections |&gt; Map.has_key?(&quot;#{solar_system_source}_#{solar_system_target}&quot;) or
      connections |&gt; Map.has_key?(&quot;#{solar_system_target}_#{solar_system_source}&quot;)
  end

  def update_connection(
        map_id,
        %{solar_system_source: solar_system_source, solar_system_target: solar_system_target} =
          connection
      ) do
    connections = map_id |&gt; get_map!() |&gt; Map.get(:connections, Map.new())

    map_id
    |&gt; update_map(%{
      connections:
        Map.put(connections, &quot;#{solar_system_source}_#{solar_system_target}&quot;, connection)
    })

    :ok
  end

  def remove_connection(
        map_id,
        %{solar_system_source: solar_system_source, solar_system_target: solar_system_target} =
          _connection
      ) do
    connections = map_id |&gt; get_map!() |&gt; Map.get(:connections, Map.new())

    map_id
    |&gt; update_map(%{
      connections: Map.drop(connections, [&quot;#{solar_system_source}_#{solar_system_target}&quot;])
    })

    :ok
  end

  def remove_connections(_map_id, []), do: :ok

  def remove_connections(map_id, [connection | rest]) do
    :ok = remove_connection(map_id, connection)
    remove_connections(map_id, rest)
  end

  def find_connections(map_id, solar_system_id),
    do:
      map_id
      |&gt; list_connections!()
      |&gt; filter(
        %{solar_system_source: solar_system_id, solar_system_target: solar_system_id},
        match: :any
      )

  def find_connection(
        map_id,
        solar_system_source,
        solar_system_target
      ) do
    case map_id
         |&gt; get_map!()
         |&gt; Map.get(:connections, Map.new())
         |&gt; Map.get(&quot;#{solar_system_source}_#{solar_system_target}&quot;) do
      nil -&gt;
        {:ok,
         map_id
         |&gt; get_map!()
         |&gt; Map.get(:connections, Map.new())
         |&gt; Map.get(&quot;#{solar_system_target}_#{solar_system_source}&quot;)}

      connection -&gt;
        {:ok, connection}
    end
  end

  def get_by_id(list, id) do
    case find(list, %{id: id}, match: :any) do
      %{} = item -&gt; {:ok, item}
      nil -&gt; {:error, :item_not_found}
    end
  end

  def find(list, %{} = attrs, match: :any) do
    list
    |&gt; Enum.find(fn item -&gt;
      Enum.any?(attrs, &amp;has_equal_attribute?(item, &amp;1))
    end)
  end

  def find(list, %{} = attrs, match: :all) do
    list
    |&gt; Enum.find(fn item -&gt;
      Enum.all?(attrs, &amp;has_equal_attribute?(item, &amp;1))
    end)
  end

  def filter(list, %{} = attrs, match: :any) do
    list
    |&gt; Enum.filter(fn item -&gt;
      Enum.any?(attrs, &amp;has_equal_attribute?(item, &amp;1))
    end)
  end

  defp has_equal_attribute?(%{} = map, {key, {:case_insensitive, value}}) when is_binary(value) do
    String.downcase(Map.get(map, key, &quot;&quot;)) == String.downcase(value)
  end

  defp has_equal_attribute?(%{} = map, {key, value}) do
    Map.get(map, key) == value
  end

  defp update_by_solar_system_id(systems, %{solar_system_id: solar_system_id} = item) do
    case systems |&gt; Map.get(solar_system_id) do
      nil -&gt;
        systems

      system -&gt;
        systems |&gt; Map.put(solar_system_id, system |&gt; Map.merge(item))
    end
  end

  @doc &quot;&quot;&quot;
  Returns the raw activity data that can be processed by WandererApp.Character.Activity.
  Only includes characters that are on the map&apos;s ACL.
  If days parameter is provided, filters activity to that time period.
  &quot;&quot;&quot;
  def get_character_activity(map_id, days \\ nil) do
    {:ok, map} = WandererApp.Api.Map.by_id(map_id)
    _map_with_acls = Ash.load!(map, :acls)

    # Calculate cutoff date if days is provided
    cutoff_date =
      if days, do: DateTime.utc_now() |&gt; DateTime.add(-days * 24 * 3600, :second), else: nil

    # Get activity data
    passages_activity = get_passages_activity(map_id, cutoff_date)
    connections_activity = get_connections_activity(map_id, cutoff_date)
    signatures_activity = get_signatures_activity(map_id, cutoff_date)

    # Return activity data
    passages_activity
    |&gt; Enum.map(fn passage -&gt;
      %{
        character: passage.character,
        passages: passage.count,
        connections: Map.get(connections_activity, passage.character.id, 0),
        signatures: Map.get(signatures_activity, passage.character.id, 0),
        timestamp: DateTime.utc_now(),
        character_id: passage.character.id,
        user_id: passage.character.user_id
      }
    end)
  end

  defp get_passages_activity(map_id, nil) do
    # Query all map chain passages without time filter
    from(p in WandererApp.Api.MapChainPassages,
      join: c in assoc(p, :character),
      where: p.map_id == ^map_id,
      group_by: [c.id],
      select: {c, count(p.id)}
    )
    |&gt; WandererApp.Repo.all()
    |&gt; Enum.map(fn {character, count} -&gt; %{character: character, count: count} end)
  end

  defp get_passages_activity(map_id, cutoff_date) do
    # Query map chain passages with time filter
    from(p in WandererApp.Api.MapChainPassages,
      join: c in assoc(p, :character),
      where:
        p.map_id == ^map_id and
          p.inserted_at &gt; ^cutoff_date,
      group_by: [c.id],
      select: {c, count(p.id)}
    )
    |&gt; WandererApp.Repo.all()
    |&gt; Enum.map(fn {character, count} -&gt; %{character: character, count: count} end)
  end

  defp get_connections_activity(map_id, nil) do
    # Query all connection activity without time filter
    from(ua in WandererApp.Api.UserActivity,
      join: c in assoc(ua, :character),
      where:
        ua.entity_id == ^map_id and
          ua.entity_type == :map and
          ua.event_type == :map_connection_added,
      group_by: [c.id],
      select: {c.id, count(ua.id)}
    )
    |&gt; WandererApp.Repo.all()
    |&gt; Map.new()
  end

  defp get_connections_activity(map_id, cutoff_date) do
    from(ua in WandererApp.Api.UserActivity,
      join: c in assoc(ua, :character),
      where:
        ua.entity_id == ^map_id and
          ua.entity_type == :map and
          ua.event_type == :map_connection_added and
          ua.inserted_at &gt; ^cutoff_date,
      group_by: [c.id],
      select: {c.id, count(ua.id)}
    )
    |&gt; WandererApp.Repo.all()
    |&gt; Map.new()
  end

  defp get_signatures_activity(map_id, nil) do
    # Query all signature activity without time filter
    from(ua in WandererApp.Api.UserActivity,
      join: c in assoc(ua, :character),
      where:
        ua.entity_id == ^map_id and
          ua.entity_type == :map and
          ua.event_type == :signatures_added,
      select: {ua.character_id, ua.event_data}
    )
    |&gt; WandererApp.Repo.all()
    |&gt; process_signatures_data()
  end

  defp get_signatures_activity(map_id, cutoff_date) do
    from(ua in WandererApp.Api.UserActivity,
      join: c in assoc(ua, :character),
      where:
        ua.entity_id == ^map_id and
          ua.entity_type == :map and
          ua.event_type == :signatures_added and
          ua.inserted_at &gt; ^cutoff_date,
      select: {ua.character_id, ua.event_data}
    )
    |&gt; WandererApp.Repo.all()
    |&gt; process_signatures_data()
  end

  defp process_signatures_data(signatures_data) do
    signatures_data
    |&gt; Enum.group_by(fn {character_id, _} -&gt; character_id end)
    |&gt; Enum.map(&amp;process_character_signatures/1)
    |&gt; Map.new()
  end

  defp process_character_signatures({character_id, activities}) do
    signature_count =
      activities
      |&gt; Enum.map(fn {_, event_data} -&gt;
        case Jason.decode(event_data) do
          {:ok, data} -&gt; length(Map.get(data, &quot;signatures&quot;, []))
          _ -&gt; 0
        end
      end)
      |&gt; Enum.sum()

    {character_id, signature_count}
  end
end</file><file path="lib/wanderer_app/maps.ex">defmodule WandererApp.Maps do
  @moduledoc false
  use Nebulex.Caching

  require Ash.Query
  import Ecto.Query
  require Logger

  @minimum_route_attrs [
    :system_class,
    :class_title,
    :security,
    :triglavian_invasion_status,
    :solar_system_id,
    :solar_system_name,
    :region_name,
    :is_shattered
  ]

  def find_routes(map_id, hubs, origin, routes_settings, false) do
    {:ok, routes} =
      WandererApp.Esi.find_routes(
        map_id,
        origin,
        hubs,
        routes_settings
      )

    systems_static_data =
      routes
      |&gt; Enum.map(fn route_info -&gt; route_info.systems end)
      |&gt; List.flatten()
      |&gt; Enum.uniq()
      |&gt; Task.async_stream(
        fn system_id -&gt;
          case WandererApp.CachedInfo.get_system_static_info(system_id) do
            {:ok, nil} -&gt;
              nil

            {:ok, system} -&gt;
              system |&gt; Map.take(@minimum_route_attrs)
          end
        end,
        max_concurrency: 10
      )
      |&gt; Enum.map(fn {:ok, val} -&gt; val end)

    {:ok, %{routes: routes, systems_static_data: systems_static_data}}
  end

  def find_routes(map_id, hubs, origin, routes_settings, true) do
    origin = origin |&gt; String.to_integer()
    hubs = hubs |&gt; Enum.map(&amp;(&amp;1 |&gt; String.to_integer()))

    routes =
      hubs
      |&gt; Enum.map(fn hub -&gt;
        %{origin: origin, destination: hub, success: false, systems: [], has_connection: false}
      end)

    {:ok, %{routes: routes, systems_static_data: []}}
  end

  def get_available_maps() do
    case WandererApp.Api.Map.available() do
      {:ok, maps} -&gt; {:ok, maps}
      _ -&gt; {:ok, []}
    end
  end

  def get_available_maps(current_user) do
    case WandererApp.Api.Map.available(%{}, actor: current_user) do
      {:ok, maps} -&gt; {:ok, maps |&gt; filter_blocked_maps(current_user)}
      _ -&gt; {:ok, []}
    end
  end

  def get_tracked_map_characters(map_id, current_user) do
    case WandererApp.MapCharacterSettingsRepo.get_tracked_by_map_filtered(
           map_id,
           current_user.characters |&gt; Enum.map(&amp; &amp;1.id)
         ) do
      {:ok, settings} -&gt;
        {:ok,
         settings
         |&gt; Enum.map(fn s -&gt; s |&gt; Ash.load!(:character) |&gt; Map.get(:character) end)}

      _ -&gt;
        {:ok, []}
    end
  end

  def load_characters(map, character_settings, user_id) do
    {:ok, user_characters} =
      WandererApp.Api.Character.active_by_user(%{user_id: user_id})

    characters =
      map
      |&gt; get_map_available_characters(user_characters)
      |&gt; Enum.map(fn c -&gt;
        map_character(c, character_settings |&gt; Enum.find(&amp;(&amp;1.character_id == c.id)))
      end)

    {:ok, %{characters: characters}}
  end

  def map_character(
        %{
          name: name,
          id: id,
          eve_id: eve_id,
          access_token: access_token,
          corporation_id: corporation_id,
          alliance_id: alliance_id,
          alliance_ticker: alliance_ticker,
          corporation_ticker: corporation_ticker,
          solar_system_id: solar_system_id,
          ship: ship_type_id,
          ship_name: ship_name,
          inserted_at: inserted_at
        } =
          _character,
        nil
      ),
      do: %{
        name: name,
        id: id,
        eve_id: eve_id,
        access_token: access_token,
        corporation_id: corporation_id,
        alliance_id: alliance_id,
        alliance_ticker: alliance_ticker,
        corporation_ticker: corporation_ticker,
        solar_system_id: solar_system_id,
        ship: ship_type_id,
        ship_name: ship_name,
        inserted_at: inserted_at,
        tracked: false
      }

  def map_character(
        %{
          name: name,
          id: id,
          eve_id: eve_id,
          access_token: access_token,
          corporation_id: corporation_id,
          alliance_id: alliance_id,
          alliance_ticker: alliance_ticker,
          corporation_ticker: corporation_ticker,
          solar_system_id: solar_system_id,
          ship: ship_type_id,
          ship_name: ship_name,
          inserted_at: inserted_at
        } =
          _character,
        %{tracked: tracked} = _character_settings
      ),
      do: %{
        name: name,
        id: id,
        eve_id: eve_id,
        access_token: access_token,
        corporation_id: corporation_id,
        alliance_id: alliance_id,
        alliance_ticker: alliance_ticker,
        corporation_ticker: corporation_ticker,
        solar_system_id: solar_system_id,
        ship: ship_type_id,
        ship_name: ship_name,
        inserted_at: inserted_at,
        tracked: tracked
      }

  @decorate cacheable(
              cache: WandererApp.Cache,
              key: &quot;map_characters-#{map_id}&quot;,
              opts: [ttl: :timer.seconds(2)]
            )
  defp _get_map_characters(%{id: map_id} = map) do
    map_acls =
      map.acls
      |&gt; Enum.map(fn acl -&gt; acl |&gt; Ash.load!(:members) end)

    map_acl_owner_ids =
      map_acls
      |&gt; Enum.map(fn acl -&gt; acl.owner_id end)

    map_members =
      map_acls
      |&gt; Enum.map(fn acl -&gt; acl.members end)
      |&gt; List.flatten()
      |&gt; Enum.filter(fn member -&gt; member.role != :blocked end)

    map_member_eve_ids =
      map_members
      |&gt; Enum.filter(fn member -&gt; not is_nil(member.eve_character_id) end)
      |&gt; Enum.map(fn member -&gt; member.eve_character_id end)

    map_member_corporation_ids =
      map_members
      |&gt; Enum.filter(fn member -&gt; not is_nil(member.eve_corporation_id) end)
      |&gt; Enum.map(fn member -&gt; member.eve_corporation_id end)

    map_member_alliance_ids =
      map_members
      |&gt; Enum.filter(fn member -&gt; not is_nil(member.eve_alliance_id) end)
      |&gt; Enum.map(fn member -&gt; member.eve_alliance_id end)

    {:ok,
     %{
       map_acl_owner_ids: map_acl_owner_ids,
       map_member_eve_ids: map_member_eve_ids,
       map_member_corporation_ids: map_member_corporation_ids,
       map_member_alliance_ids: map_member_alliance_ids
     }}
  end

  defp get_map_available_characters(map, user_characters) do
    {:ok,
     %{
       map_acl_owner_ids: map_acl_owner_ids,
       map_member_eve_ids: map_member_eve_ids,
       map_member_corporation_ids: map_member_corporation_ids,
       map_member_alliance_ids: map_member_alliance_ids
     }} = _get_map_characters(map)

    user_characters
    |&gt; Enum.filter(fn c -&gt;
      is_owner = c.id == map.owner_id
      is_acl_owner = c.id in map_acl_owner_ids
      is_member_eve = c.eve_id in map_member_eve_ids
      is_member_corp = to_string(c.corporation_id) in map_member_corporation_ids
      is_member_alliance = to_string(c.alliance_id) in map_member_alliance_ids

      has_access =
        is_owner or is_acl_owner or is_member_eve or is_member_corp or is_member_alliance

      has_access
    end)
  end

  defp filter_blocked_maps(maps, current_user) do
    user_character_ids = current_user.characters |&gt; Enum.map(&amp; &amp;1.id)
    user_character_eve_ids = current_user.characters |&gt; Enum.map(&amp; &amp;1.eve_id)

    user_character_corporation_ids =
      current_user.characters
      |&gt; Enum.map(&amp; &amp;1.corporation_id)
      |&gt; Enum.map(&amp;to_string/1)

    user_character_alliance_ids =
      current_user.characters
      |&gt; Enum.map(&amp; &amp;1.alliance_id)
      |&gt; Enum.map(&amp;to_string/1)

    maps
    |&gt; Enum.reduce([], fn map, acc -&gt;
      case map.owner_id in user_character_ids do
        true -&gt;
          [map | acc]

        false -&gt;
          case map.acls do
            nil -&gt;
              [map | acc]

            acls -&gt;
              acls =
                acls
                |&gt; Enum.map(fn acl -&gt; acl |&gt; Ash.load!(:members) end)

              is_blocked_any =
                acls
                |&gt; Enum.any?(fn acl -&gt;
                  case acl.members do
                    nil -&gt;
                      false

                    members -&gt;
                      members
                      |&gt; Enum.any?(fn member -&gt;
                        (member.role == :blocked and
                           member.eve_character_id in user_character_eve_ids) or
                          (member.role == :blocked and
                             member.eve_corporation_id in user_character_corporation_ids) or
                          (member.role == :blocked and
                             member.eve_alliance_id in user_character_alliance_ids)
                      end)
                  end
                end)

              is_allowed_character =
                acls
                |&gt; Enum.any?(fn acl -&gt;
                  is_owner = acl.owner_id in user_character_ids

                  is_allowed_members =
                    case acl.members do
                      nil -&gt;
                        false

                      members -&gt;
                        members
                        |&gt; Enum.any?(fn member -&gt;
                          member.role != :blocked and
                            member.eve_character_id in user_character_eve_ids
                        end)
                    end

                  is_owner or is_allowed_members
                end)

              case [is_blocked_any, is_allowed_character] do
                [_, true] -&gt;
                  [map | acc]

                [false, false] -&gt;
                  [map | acc]

                _ -&gt;
                  acc
              end
          end
      end
    end)
  end

  def get_system_comments_activity(system_id) do
    from(sc in WandererApp.Api.MapSystemComment,
      where: sc.system_id == ^system_id,
      group_by: [sc.system_id],
      select: {count(sc.system_id)}
    )
    |&gt; WandererApp.Repo.all()
  end

  def can_edit?(map, user) do
    user_is_owner?(user, map) or
      user_has_roles?(user, map, [:admin])
  end

  def can_view_acls?(map, user) do
    user_is_owner?(user, map) or
      user_has_roles?(user, map, [:admin, :manager])
  end

  def user_is_owner?(user, map) do
    character_ids = user.characters |&gt; Enum.map(&amp; &amp;1.id)

    acl_owner_ids = map.acls |&gt; Enum.map(&amp; &amp;1.owner_id)

    map.owner_id in character_ids or character_ids |&gt; Enum.any?(fn id -&gt; id in acl_owner_ids end)
  end

  def user_has_roles?(user, map, roles) do
    acl_roles_eve_ids =
      map.acls
      |&gt; Enum.map(fn acl -&gt; acl.members end)
      |&gt; List.flatten()
      |&gt; Enum.filter(fn member -&gt; member.role in roles end)
      |&gt; Enum.map(fn member -&gt; member.eve_character_id end)

    character_eve_ids = user.characters |&gt; Enum.map(&amp; &amp;1.eve_id)

    character_eve_ids |&gt; Enum.any?(fn eve_id -&gt; eve_id in acl_roles_eve_ids end)
  end

  def check_user_can_delete_map(map_slug, current_user) do
    map_slug
    |&gt; WandererApp.Api.Map.get_map_by_slug()
    |&gt; Ash.load([:owner, :acls, :user_permissions], actor: current_user)
    |&gt; case do
      {:ok,
       %{
         user_permissions: user_permissions,
         owner_id: owner_id
       } = map} -&gt;
        user_permissions =
          WandererApp.Permissions.get_map_permissions(
            user_permissions,
            owner_id,
            current_user.characters |&gt; Enum.map(&amp; &amp;1.id)
          )

        case user_permissions.delete_map do
          true -&gt;
            {:ok, map}

          _ -&gt;
            {:error, :not_authorized}
        end

      error -&gt;
        {:error, error}
    end
  end
end</file><file path="lib/wanderer_app/permissions.ex">defmodule WandererApp.Permissions do
  @moduledoc false
  import Bitwise

  @view_system 1
  @view_character 2
  @view_connection 4
  @add_system 8
  @add_connection 16
  @update_system 32
  @track_character 64
  @delete_connection 128
  @delete_system 256
  @lock_system 512
  @add_acl 1024
  @delete_acl 2048
  @delete_map 4096
  @manage_map 8192
  @admin_map 16384

  @viewer_role [@view_system, @view_character, @view_connection]
  @member_role @viewer_role ++
                 [
                   @add_system,
                   @add_connection,
                   @update_system,
                   @track_character,
                   @delete_connection,
                   @delete_system
                 ]
  @manager_role @member_role ++ [@lock_system, @manage_map]
  @admin_role @manager_role ++ [@add_acl, @delete_acl, @delete_map, @admin_map]

  @viewer_role_mask @viewer_role |&gt; Enum.reduce(0, fn x, acc -&gt; x ||| acc end)
  @member_role_mask @member_role |&gt; Enum.reduce(0, fn x, acc -&gt; x ||| acc end)
  @manager_role_mask @manager_role |&gt; Enum.reduce(0, fn x, acc -&gt; x ||| acc end)
  @admin_role_mask @admin_role |&gt; Enum.reduce(0, fn x, acc -&gt; x ||| acc end)

  def role_mask(nil), do: 0
  def role_mask(:viewer), do: @viewer_role_mask
  def role_mask(:member), do: @member_role_mask
  def role_mask(:manager), do: @manager_role_mask
  def role_mask(:admin), do: @admin_role_mask
  def role_mask(:blocked), do: 0

  def calc_roles_mask([], mask), do: mask

  def calc_roles_mask([role | rest], mask) do
    calc_roles_mask(rest, calc_role_mask(role, mask))
  end

  def calc_role_mask(:blocked, _mask), do: -1

  def calc_role_mask(role, mask) do
    mask ||| role_mask(role)
  end

  def check_permission(-1, _permission), do: false

  def check_permission(user_permissions, permission) do
    (user_permissions &amp;&amp;&amp; permission) != 0
  end

  def get_map_permissions(user_permissions, owner_id, user_character_ids) do
    case owner_id in user_character_ids do
      true -&gt;
        role_mask(:admin) |&gt; get_permissions()

      _ -&gt;
        get_permissions(user_permissions)
    end
  end

  def get_permissions(user_permissions) do
    %{
      admin_map: check_permission(user_permissions, @admin_map),
      manage_map: check_permission(user_permissions, @manage_map),
      view_system: check_permission(user_permissions, @view_system),
      view_character: check_permission(user_permissions, @view_character),
      view_connection: check_permission(user_permissions, @view_connection),
      add_system: check_permission(user_permissions, @add_system),
      add_connection: check_permission(user_permissions, @add_connection),
      update_system: check_permission(user_permissions, @update_system),
      track_character: check_permission(user_permissions, @track_character),
      delete_connection: check_permission(user_permissions, @delete_connection),
      delete_system: check_permission(user_permissions, @delete_system),
      lock_system: check_permission(user_permissions, @lock_system),
      add_acl: check_permission(user_permissions, @add_acl),
      delete_acl: check_permission(user_permissions, @delete_acl),
      delete_map: check_permission(user_permissions, @delete_map)
    }
  end

  def check_characters_access(characters, acls) do
    character_ids = characters |&gt; Enum.map(&amp; &amp;1.id)
    character_eve_ids = characters |&gt; Enum.map(&amp; &amp;1.eve_id)

    character_corporation_ids =
      characters |&gt; Enum.map(&amp; &amp;1.corporation_id) |&gt; Enum.map(&amp;to_string/1)

    character_alliance_ids = characters |&gt; Enum.map(&amp; &amp;1.alliance_id) |&gt; Enum.map(&amp;to_string/1)

    result =
      acls
      |&gt; Enum.reduce([0, 0], fn acl, acc -&gt;
        is_owner? = acl.owner_id in character_ids

        is_character_member? =
          acl.members |&gt; Enum.any?(fn member -&gt; member.eve_character_id in character_eve_ids end)

        is_corporation_member? =
          acl.members
          |&gt; Enum.any?(fn member -&gt; member.eve_corporation_id in character_corporation_ids end)

        is_alliance_member? =
          acl.members
          |&gt; Enum.any?(fn member -&gt; member.eve_alliance_id in character_alliance_ids end)

        if is_owner? || is_character_member? || is_corporation_member? || is_alliance_member? do
          case acc do
            [_, -1] -&gt;
              [-1, -1]

            [-1, char_acc] -&gt;
              char_acl_mask =
                acl.members
                |&gt; Enum.filter(fn member -&gt;
                  member.eve_character_id in character_eve_ids
                end)
                |&gt; Enum.reduce(0, fn member, acc -&gt;
                  case acc do
                    -1 -&gt; -1
                    _ -&gt; calc_role_mask(member.role, acc)
                  end
                end)

              char_acc =
                case char_acl_mask do
                  -1 -&gt; -1
                  _ -&gt; char_acc ||| char_acl_mask
                end

              [-1, char_acc]

            [any_acc, char_acc] -&gt;
              any_acl_mask =
                acl.members
                |&gt; Enum.filter(fn member -&gt;
                  member.eve_character_id in character_eve_ids ||
                    member.eve_corporation_id in character_corporation_ids ||
                    member.eve_alliance_id in character_alliance_ids
                end)
                |&gt; Enum.reduce(0, fn member, acc -&gt;
                  case acc do
                    -1 -&gt; -1
                    _ -&gt; calc_role_mask(member.role, acc)
                  end
                end)

              char_acl_mask =
                acl.members
                |&gt; Enum.filter(fn member -&gt;
                  member.eve_character_id in character_eve_ids
                end)
                |&gt; Enum.reduce(0, fn member, acc -&gt;
                  case acc do
                    -1 -&gt; -1
                    _ -&gt; calc_role_mask(member.role, acc)
                  end
                end)

              any_acc =
                case any_acl_mask do
                  -1 -&gt; -1
                  _ -&gt; any_acc ||| any_acl_mask
                end

              char_acc =
                case char_acl_mask do
                  -1 -&gt; -1
                  _ -&gt; char_acc ||| char_acl_mask
                end

              [any_acc, char_acc]
          end
        else
          acc
        end
      end)

    case result do
      [_, -1] -&gt;
        [-1]

      [-1, char_acc] -&gt;
        [char_acc]

      [any_acc, _char_acc] -&gt;
        [any_acc]
    end
  end
end</file><file path="lib/wanderer_app/prom_ex.ex">defmodule WandererApp.PromEx do
  use PromEx, otp_app: :wanderer_app

  alias PromEx.Plugins

  @impl true
  def plugins do
    [
      # PromEx built in plugins
      {Plugins.Application, [otp_app: :wanderer_app]},
      Plugins.Beam,
      {Plugins.Phoenix, router: WandererAppWeb.Router},
      {Plugins.Ecto, otp_app: :wanderer_app},
      Plugins.PhoenixLiveView,
      WandererApp.Metrics.PromExPlugin
    ]
  end

  @impl true
  def dashboard_assigns do
    [
      datasource_id: Application.get_env(:wanderer_app, :grafana_datasource_id),
      default_selected_interval: &quot;30s&quot;
    ]
  end

  @impl true
  def dashboards do
    [
      # PromEx built in Grafana dashboards
      {:prom_ex, &quot;application.json&quot;},
      {:prom_ex, &quot;beam.json&quot;},
      {:prom_ex, &quot;phoenix.json&quot;},
      {:prom_ex, &quot;ecto.json&quot;},
      {:prom_ex, &quot;phoenix_live_view.json&quot;}
    ]
  end
end</file><file path="lib/wanderer_app/queue.ex">defmodule WandererApp.Queue do
  @moduledoc false

  def new(queue_name, items), do: queue_name |&gt; _update(Qex.new(items))

  def join(queue_name, items),
    do:
      queue_name
      |&gt; _insert_or_update(Qex.new(items), fn queue -&gt;
        Qex.join(queue, Qex.new(items))
      end)

  def push_uniq(queue_name, item) do
    case Enum.member?(queue_name |&gt; to_list!, item) do
      false -&gt;
        queue_name
        |&gt; _insert_or_update(Qex.new([item]), fn queue -&gt;
          Qex.push(queue, item)
        end)

      _ -&gt;
        :ok
    end
  end

  def push(queue_name, item),
    do:
      queue_name
      |&gt; _insert_or_update(Qex.new([item]), fn queue -&gt;
        Qex.push(queue, item)
      end)

  def push_front(queue_name, item),
    do:
      queue_name
      |&gt; _insert_or_update(Qex.new([item]), fn queue -&gt;
        Qex.push_front(queue, item)
      end)

  def next(queue_name) do
    {{:value, item}, _q} =
      queue_name
      |&gt; _lookup!()
      |&gt; Qex.pop()

    {:ok, item}
  end

  def pop(queue_name) do
    {{:value, item}, queue} =
      queue_name
      |&gt; _lookup!()
      |&gt; Qex.pop()

    queue_name
    |&gt; _update(queue)

    {:ok, item}
  end

  def to_list(queue_name),
    do:
      {:ok,
       queue_name
       |&gt; _lookup!()
       |&gt; Enum.to_list()}

  def to_list!(queue_name),
    do:
      queue_name
      |&gt; _lookup!()
      |&gt; Enum.to_list()

  def empty?(queue_name) when is_binary(queue_name) or is_atom(queue_name),
    do:
      queue_name
      |&gt; _lookup!()
      |&gt; Enum.empty?()

  def clear(queue_name),
    do:
      queue_name
      |&gt; _update(Qex.new())

  def _insert_or_update(queue_name, queue, update_fn),
    do: WandererApp.Cache.insert_or_update(queue_name, queue, update_fn)

  def _lookup!(queue_name),
    do: WandererApp.Cache.lookup!(queue_name, Qex.new())

  def _update(queue_name, queue),
    do: WandererApp.Cache.insert(queue_name, queue)
end</file><file path="lib/wanderer_app/release.ex">defmodule WandererApp.Release do
  @moduledoc &quot;&quot;&quot;
  Used for executing DB release tasks when run in production without Mix
  installed.
  &quot;&quot;&quot;
  @app :wanderer_app
  @start_apps [
    :postgrex,
    :ecto
  ]

  def createdb(repos \\ repos()) do
    prepare()

    for repo &lt;- repos do
      :ok = ensure_repo_created(repo)
    end

    IO.puts(&quot;Creation of Db successful!&quot;)
  end

  def migrate(repos \\ repos()) do
    IO.puts(&quot;Run migrations..&quot;)
    prepare()

    for repo &lt;- repos() do
      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &amp;Ecto.Migrator.run(&amp;1, :up, all: true))
    end

    :init.stop()
  end

  @doc &quot;&quot;&quot;
  `interweave_migrate/0` is a migration function that:

  - Lists all pending migrations across multiple repositories.
  - Sorts these migrations into a single list.
  - Groups consecutive migrations by repository into &quot;streaks&quot;.
  - Executes the migrations in the correct order by processing each streak sequentially.

  ### Why Use This Approach?

  This function resolves dependencies between migrations that span across different repositories.
  The default `migrate/0` function migrates each repository independently, which may result in
  migrations running in the wrong order when there are cross-repository dependencies.

  Consider the following example (adapted from reality, not 100% accurate):

  - **Migration 1**: The PostgreSQL (PG) repository creates a table named `site_imports`.
  - **Migration 2**: The ClickHouse (CH) repository creates `import_id` columns in `imported_*` tables.
  - **Migration 3**: The PG repository runs a data migration that utilizes both PG and CH databases,
    reading from the `import_id` column in `imported_*` tables.

  The default `migrate/0` would execute these migrations by repository, resulting in the following order:

  1. Migration 1 (PG)
  2. Migration 3 (PG)
  3. Migration 2 (CH)

  This sequence would fail at Migration 3, as the `import_id` columns in the CH repository have not been created yet.

  `interweave_migrate/0` addresses this issue by consolidating all pending migrations into a single, ordered queue:

  1. Migration 1 (PG)
  2. Migration 2 (CH)
  3. Migration 3 (PG)

  This ensures all dependencies are resolved in the correct order.
  &quot;&quot;&quot;
  def interweave_migrate(repos \\ repos()) do
    prepare()

    pending = all_pending_migrations(repos)
    streaks = migration_streaks(pending)

    Enum.each(streaks, fn {repo, up_to_version} -&gt;
      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &amp;Ecto.Migrator.run(&amp;1, :up, to: up_to_version))
    end)
  end

  defp migration_streaks(pending_migrations) do
    sorted_migrations =
      pending_migrations
      |&gt; Enum.map(fn {repo, version, _name} -&gt; {repo, version} end)
      |&gt; Enum.sort_by(fn {_repo, version} -&gt; version end, :asc)

    streaks_reversed =
      Enum.reduce(sorted_migrations, [], fn {repo, _version} = latest_migration, streaks_acc -&gt;
        case streaks_acc do
          # start the streak for repo
          [] -&gt; [latest_migration]
          # extend the streak
          [{^repo, _prev_version} | rest] -&gt; [latest_migration | rest]
          # end the streak for prev_repo, start the streak for repo
          [{_prev_repo, _prev_version} | _rest] -&gt; [latest_migration | streaks_acc]
        end
      end)

    :lists.reverse(streaks_reversed)
  end

  @spec all_pending_migrations([Ecto.Repo.t()]) :: [{Ecto.Repo.t(), integer, String.t()}]
  defp all_pending_migrations(repos) do
    Enum.flat_map(repos, fn repo -&gt;
      # credo:disable-for-lines:6 Credo.Check.Refactor.Nesting
      {:ok, pending, _started} =
        Ecto.Migrator.with_repo(repo, fn repo -&gt;
          Ecto.Migrator.migrations(repo)
          |&gt; Enum.filter(fn {status, _version, _name} -&gt; status == :down end)
          |&gt; Enum.map(fn {_status, version, name} -&gt; {repo, version, name} end)
        end)

      pending
    end)
  end

  def pending_streaks(repos \\ repos()) do
    prepare()
    IO.puts(&quot;Collecting pending migrations..&quot;)

    pending = all_pending_migrations(repos)

    if pending == [] do
      IO.puts(&quot;No pending migrations!&quot;)
    else
      streaks = migration_streaks(pending)
      print_migration_streaks(streaks, pending)
    end
  end

  defp print_migration_streaks([{repo, up_to_version} | streaks], pending) do
    {streak, pending} =
      Enum.split_with(pending, fn {pending_repo, version, _name} -&gt;
        pending_repo == repo and version &lt;= up_to_version
      end)

    IO.puts(
      &quot;\n#{inspect(repo)} [#{Path.relative_to_cwd(Ecto.Migrator.migrations_path(repo))}] streak up to version #{up_to_version}:&quot;
    )

    Enum.each(streak, fn {_repo, version, name} -&gt; IO.puts(&quot;  * #{version}_#{name}&quot;) end)
    print_migration_streaks(streaks, pending)
  end

  defp print_migration_streaks([], []), do: :ok

  def rollback do
    prepare()

    get_step =
      IO.gets(&quot;Enter the number of steps: &quot;)
      |&gt; String.trim()
      |&gt; Integer.parse()

    case get_step do
      {int, _trailing} -&gt;
        Enum.each(repos(), fn repo -&gt; run_rollbacks_for(repo, int) end)
        IO.puts(&quot;Rollback successful!&quot;)

      :error -&gt;
        IO.puts(&quot;Invalid integer&quot;)
    end
  end

  def rollback(repo, version) do
    prepare()
    {:ok, _, _} = Ecto.Migrator.with_repo(repo, &amp;Ecto.Migrator.run(&amp;1, :down, to: version))
  end

  defp repos do
    Application.fetch_env!(@app, :ecto_repos)
  end

  defp ensure_repo_created(repo) do
    config = repo.config()
    adapter = repo.__adapter__()

    case adapter.storage_status(config) do
      :up -&gt;
        IO.puts(&quot;#{inspect(repo)} database already exists&quot;)
        :ok

      :down -&gt;
        IO.puts(&quot;Creating #{inspect(repo)} database..&quot;)

        case adapter.storage_up(config) do
          :ok -&gt; :ok
          {:error, :already_up} -&gt; :ok
          {:error, _reason} = error -&gt; error
        end

      {:error, _reason} = error -&gt;
        error
    end
  end

  defp run_rollbacks_for(repo, step) do
    app = Keyword.get(repo.config, :otp_app)
    IO.puts(&quot;Running rollbacks for #{app} (STEP=#{step})&quot;)

    {:ok, _, _} =
      Ecto.Migrator.with_repo(repo, &amp;Ecto.Migrator.run(&amp;1, :down, all: false, step: step))
  end

  defp prepare do
    IO.puts(&quot;Loading #{@app}..&quot;)
    # Load the code for myapp, but don&apos;t start it
    :ok = Application.ensure_loaded(@app)

    IO.puts(&quot;Starting dependencies..&quot;)
    # Start apps necessary for executing migrations
    Enum.each(@start_apps, &amp;Application.ensure_all_started/1)

    # Start the Repo(s) for myapp
    IO.puts(&quot;Starting repos..&quot;)
    Enum.each(repos(), &amp; &amp;1.start_link(pool_size: 2))
  end
end</file><file path="lib/wanderer_app/repo.ex">defmodule WandererApp.Repo do
  use AshPostgres.Repo,
    otp_app: :wanderer_app

  def installed_extensions do
    # Ash installs some functions that it needs to run the
    # first time you generate migrations.
    [&quot;ash-functions&quot;]
  end
end</file><file path="lib/wanderer_app/sheduler.ex">defmodule WandererApp.Scheduler do
  use Quantum, otp_app: :wanderer_app
end</file><file path="lib/wanderer_app/structures.ex">defmodule WandererApp.Structure do
  @moduledoc &quot;&quot;&quot;
  Encapsulates the logic for parsing and updating system structures.
  &quot;&quot;&quot;

  require Logger
  alias WandererApp.Api.MapSystemStructure
  alias WandererApp.Character

  def update_structures(system, added, updated, removed, main_character_eve_id, user_id \\ nil) do
    Logger.info(&quot;[Structure] update_structures called by user_id=#{inspect(user_id)}&quot;)

    added_structs =
      parse_structures(added, main_character_eve_id, system)
      |&gt; Enum.map(&amp;Map.delete(&amp;1, :id))

    updated_structs = parse_structures(updated, main_character_eve_id, system)
    removed_structs = parse_structures(removed, main_character_eve_id, system)

    remove_structures(system.id, Enum.map(removed_structs, &amp; &amp;1.id))
    update_structures_in_db(system.id, updated_structs, Enum.map(updated_structs, &amp; &amp;1.id))
    add_structures(added_structs)

    :ok
  end

  def search_corporation_names([], _search), do: {:ok, []}

  def search_corporation_names([first_char | _], search) when is_binary(search) do
    Character.search(first_char.id, params: [search: search, categories: &quot;corporation&quot;])
  end

  def search_corporation_names(_user_chars, _search), do: {:ok, []}

  defp parse_structures(list_of_maps, character_eve_id, system) do
    Logger.debug(fn -&gt;
      &quot;[Structure] parse_structures =&gt;\n&quot; &lt;&gt; inspect(list_of_maps, pretty: true)
    end)

    Enum.map(list_of_maps, fn item -&gt;
      %{
        id: Map.get(item, &quot;id&quot;),
        system_id: system.id,
        solar_system_id: system.solar_system_id,
        solar_system_name: system.name,
        structure_type_id: Map.get(item, &quot;structureTypeId&quot;) || &quot;???&quot;,
        structure_type: Map.get(item, &quot;structureType&quot;),
        character_eve_id: character_eve_id,
        name: Map.get(item, &quot;name&quot;),
        notes: Map.get(item, &quot;notes&quot;),
        owner_name: Map.get(item, &quot;ownerName&quot;),
        owner_ticker: Map.get(item, &quot;ownerTicker&quot;),
        owner_id: Map.get(item, &quot;ownerId&quot;),
        status: Map.get(item, &quot;status&quot;),
        end_time: parse_end_time(Map.get(item, &quot;endTime&quot;))
      }
    end)
  end

  defp parse_end_time(str) when is_binary(str) do
    Logger.debug(fn -&gt;
      &quot;[parse_end_time] raw input =&gt; #{inspect(str)} (length=#{String.length(str)})&quot;
    end)

    if String.trim(str) == &quot;&quot; do
      nil
    else
      # Attempt to parse
      case DateTime.from_iso8601(str) do
        {:ok, dt, _offset} -&gt;
          dt

        {:error, reason} -&gt;
          Logger.error(
            &quot;[parse_end_time] Invalid ISO string: #{inspect(str)}, reason: #{inspect(reason)}&quot;
          )

          nil
      end
    end
  end

  defp parse_end_time(other) do
    Logger.error(&quot;[parse_end_time] Received non-string =&gt; #{inspect(other)}. Returning nil.&quot;)
    nil
  end

  defp remove_structures(system_id, removed_ids) do
    MapSystemStructure.by_system_id!(system_id)
    |&gt; Enum.filter(fn s -&gt; s.id in removed_ids end)
    |&gt; Enum.each(&amp;Ash.destroy!/1)
  end

  defp update_structures_in_db(system_id, updated_structs, updated_ids) do
    existing_records = MapSystemStructure.by_system_id!(system_id)

    Enum.each(existing_records, fn existing -&gt;
      if existing.id in updated_ids do
        updated_data = Enum.find(updated_structs, fn u -&gt; u.id == existing.id end)

        if updated_data do
          Logger.debug(fn -&gt;
            &quot;[Structure] about to update =&gt;\n&quot; &lt;&gt;
              inspect(updated_data, pretty: true)
          end)

          # remove PK so Ash doesn&apos;t treat it as a new record
          updated_data = Map.delete(updated_data, :id)

          # Merge update data with existing record to avoid nil required fields
          merged_data =
            Map.merge(Map.from_struct(existing), updated_data, fn _k, v1, v2 -&gt;
              if is_nil(v2), do: v1, else: v2
            end)

          # Only keep fields accepted by Ash update action
          allowed_keys = [
            :system_id,
            :solar_system_name,
            :solar_system_id,
            :structure_type_id,
            :structure_type,
            :character_eve_id,
            :name,
            :notes,
            :owner_name,
            :owner_ticker,
            :owner_id,
            :status,
            :end_time
          ]

          filtered_data = Map.take(merged_data, allowed_keys)

          Logger.debug(fn -&gt;
            &quot;[Structure] update_structures_in_db: calling update for id=#{existing.id} with: #{inspect(filtered_data)}&quot;
          end)

          new_record = MapSystemStructure.update(existing, filtered_data)

          Logger.debug(fn -&gt;
            &quot;[Structure] update_structures_in_db: update result for id=#{existing.id}: #{inspect(new_record)}&quot;
          end)

          Logger.debug(fn -&gt;
            &quot;[Structure] updated record =&gt;\n&quot; &lt;&gt; inspect(new_record, pretty: true)
          end)
        end
      end
    end)
  end

  defp add_structures(added_structs) do
    Enum.each(added_structs, fn struct_map -&gt;
      Logger.debug(fn -&gt;
        &quot;[Structure] Creating structure =&gt;\n&quot; &lt;&gt; inspect(struct_map, pretty: true)
      end)

      MapSystemStructure.create!(struct_map)
    end)
  end
end</file><file path="lib/wanderer_app/task_wrapper.ex">defmodule WandererApp.TaskWrapper do
  def start_link(module, func, args) do
    if Mix.env() == :test do
      apply(module, func, args)
    else
      Task.start_link(module, func, args)
    end
  end
end</file><file path="lib/wanderer_app/user.ex">defmodule WandererApp.User do
  @moduledoc false

  require Logger

  def load(nil), do: nil

  def load(user_id) do
    case WandererApp.Api.User.by_id(user_id) do
      {:ok, user} -&gt; user |&gt; Ash.load!([:balance])
      {:error, _} -&gt; nil
    end
  end

  def get_balance(nil), do: {:ok, 0.0}

  def get_balance(user), do: {:ok, user.balance || 0.0}
end</file><file path="lib/wanderer_app/vault.ex">defmodule WandererApp.Vault do
  use Cloak.Vault, otp_app: :wanderer_app

  @impl GenServer
  def init(config) do
    cipher_key = decode_env!(&quot;CLOAK_KEY&quot;)
    fallback_cipher_key = decode_env!(&quot;FALLBACK_CLOAK_KEY&quot;)

    config =
      Keyword.put(config, :ciphers,
        default: {
          Cloak.Ciphers.AES.GCM,
          tag: &quot;AES.GCM.V1&quot;, key: cipher_key, iv_length: 12
        },
        fallback: {
          Cloak.Ciphers.AES.GCM,
          tag: &quot;AES.GCM.V1&quot;, key: fallback_cipher_key, iv_length: 12
        }
      )

    {:ok, config}
  end

  @impl Cloak.Vault
  def encrypt(plaintext) do
    with {:ok, config} &lt;- Cloak.Vault.read_config(@table_name) do
      Cloak.Vault.encrypt(config, plaintext)
    end
  end

  @impl Cloak.Vault
  def encrypt!(plaintext) do
    case Cloak.Vault.read_config(@table_name) do
      {:ok, config} -&gt;
        Cloak.Vault.encrypt!(config, plaintext)

      {:error, error} -&gt;
        raise error
    end
  end

  @impl Cloak.Vault
  def encrypt(plaintext, label) do
    with {:ok, config} &lt;- Cloak.Vault.read_config(@table_name) do
      Cloak.Vault.encrypt(config, plaintext, label)
    end
  end

  @impl Cloak.Vault
  def encrypt!(plaintext, label) do
    case Cloak.Vault.read_config(@table_name) do
      {:ok, config} -&gt;
        Cloak.Vault.encrypt!(config, plaintext, label)

      {:error, error} -&gt;
        raise error
    end
  end

  @impl Cloak.Vault
  def decrypt(ciphertext) do
    with {:ok, config} &lt;- Cloak.Vault.read_config(@table_name) do
      decrypt(config, ciphertext)
    end
  end

  @impl Cloak.Vault
  def decrypt!(ciphertext) do
    case Cloak.Vault.read_config(@table_name) do
      {:ok, config} -&gt;
        decrypt!(config, ciphertext)

      {:error, error} -&gt;
        raise error
    end
  end

  defp decode_env!(var, fallback_key \\ &quot;OtPJXGfKNyOMWI7TdpcWgOlyNtD9AGSfoAdvEuTQIno=&quot;) do
    var
    |&gt; System.get_env(fallback_key)
    |&gt; Base.decode64!()
  end

  @doc false
  def decrypt(config, ciphertext) do
    case find_module_to_decrypt(config, ciphertext) do
      nil -&gt;
        {:error, Cloak.MissingCipher.exception(vault: config[:vault], ciphertext: ciphertext)}

      {_label, {module, opts}} -&gt;
        case module.decrypt(ciphertext, opts) do
          {:ok, :error} -&gt;
            case find_fallback_module_to_decrypt(config, ciphertext) do
              nil -&gt;
                {:ok, :error}

              {_label, {module, opts}} -&gt;
                module.decrypt(ciphertext, opts)
            end

          {:ok, plaintext} -&gt;
            {:ok, plaintext}

          error -&gt;
            error
        end
    end
  end

  @doc false
  def decrypt!(config, ciphertext) do
    case decrypt(config, ciphertext) do
      {:ok, plaintext} -&gt;
        plaintext

      {:error, error} -&gt;
        raise error
    end
  end

  defp find_module_to_decrypt(config, ciphertext) do
    Enum.find(config[:ciphers], fn {_label, {module, opts}} -&gt;
      module.can_decrypt?(ciphertext, opts)
    end)
  end

  defp find_fallback_module_to_decrypt(config, ciphertext) do
    Enum.find(config[:ciphers], fn {label, _} -&gt;
      label == :fallback
    end)
  end
end</file><file path="lib/wanderer_app_web/components/layouts/app.html.heex">&lt;main class=&quot;bg-stone-950&quot;&gt;
  &lt;%= @inner_content %&gt;
&lt;/main&gt;</file><file path="lib/wanderer_app_web/components/layouts/blog.html.heex">&lt;main
  class=&quot;main flex-col !min-h-screen justify-between flex z-0 focus:outline-none transition-all duration-500 opacity-0 phx-page-loading:opacity-0 bg-stone-950 ccp-font&quot;
  phx-mounted={JS.remove_class(&quot;opacity-0&quot;)}
&gt;
  &lt;navbar class=&quot;navbar bg-base-100 !sticky top-0 z-50 bg-opacity-0 &quot;&gt;
    &lt;div class=&quot;navbar-start&quot;&gt;
      &lt;div class=&quot;dropdown&quot;&gt;
        &lt;div tabindex=&quot;0&quot; role=&quot;button&quot; class=&quot;btn btn-ghost btn-circle&quot;&gt;
          &lt;svg
            xmlns=&quot;http://www.w3.org/2000/svg&quot;
            class=&quot;h-5 w-5&quot;
            fill=&quot;none&quot;
            viewBox=&quot;0 0 24 24&quot;
            stroke=&quot;currentColor&quot;
          &gt;
            &lt;path
              stroke-linecap=&quot;round&quot;
              stroke-linejoin=&quot;round&quot;
              stroke-width=&quot;2&quot;
              d=&quot;M4 6h16M4 12h16M4 18h7&quot;
            /&gt;
          &lt;/svg&gt;
        &lt;/div&gt;
        &lt;ul
          tabindex=&quot;0&quot;
          class=&quot;menu menu-sm dropdown-content bg-base-100 rounded-box z-[1] mt-3 w-52 p-2 shadow&quot;
        &gt;
          &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;/changelog&quot;&gt;Changelog&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;/news&quot;&gt;News&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;/license&quot;&gt;License&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;/contacts&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;navbar-center&quot;&gt;
      &lt;a href=&quot;/&quot; class=&quot;btn btn-ghost text-xl&quot;&gt;Wanderer&lt;/a&gt;
    &lt;/div&gt;
    &lt;div class=&quot;navbar-end&quot;&gt;&lt;/div&gt;
  &lt;/navbar&gt;
  &lt;div class=&quot;!z-10 min-h-[calc(100vh-7rem)]&quot;&gt;
    &lt;%= @inner_content %&gt;
  &lt;/div&gt;
  &lt;!--Footer--&gt;
  &lt;footer class=&quot;!z-10 w-full pb-4 text-sm text-center fade-in&quot;&gt;
    &lt;a class=&quot;text-gray-500 no-underline hover:no-underline&quot; href=&quot;#&quot;&gt;
      &amp;copy; Wanderer 2024
    &lt;/a&gt;
  &lt;/footer&gt;
  &lt;div class=&quot;fixed top-0 left-0 w-full h-full !-z-1 maps_bg&quot; /&gt;
&lt;/main&gt;</file><file path="lib/wanderer_app_web/components/layouts/landing.html.heex">&lt;div class=&quot;flex flex-col w-0 flex-1 overflow-hidden&quot;&gt;
  &lt;.flash_group flash={@flash} /&gt;
  &lt;.connection_status&gt;
    Re-establishing connection...
  &lt;/.connection_status&gt;

  &lt;main
    class=&quot;main flex-1 relative z-0 overflow-hidden focus:outline-none transition-all duration-500 opacity-0 phx-page-loading:opacity-0 bg-stone-950 maps_bg ccp-font&quot;
    phx-mounted={JS.remove_class(&quot;opacity-0&quot;)}
  &gt;
    &lt;%= @inner_content %&gt;
  &lt;/main&gt;
&lt;/div&gt;</file><file path="lib/wanderer_app_web/components/layouts/live.html.heex">&lt;div class=&quot;flex flex-col w-0 flex-1 overflow-hidden bg-stone-950&quot;&gt;
  &lt;.connection_status&gt;
    Re-establishing connection...
  &lt;/.connection_status&gt;

  &lt;main
    class=&quot;main flex-1 relative z-0 overflow-hidden focus:outline-none transition-all duration-500 opacity-0 phx-page-loading:opacity-0&quot;
    phx-mounted={JS.remove_class(&quot;opacity-0&quot;)}
  &gt;
    &lt;%= @inner_content %&gt;
  &lt;/main&gt;
  &lt;aside class=&quot;h-full w-14 left-0 absolute bg-gray-400 bg-opacity-5  text-gray-200 shadow-lg border-r border-stone-800  bg-opacity-70 bg-neutral-900&quot;&gt;
    &lt;.sidebar_nav_links
      active_tab={@active_tab}
      show_admin={@show_admin}
      map_subscriptions_enabled={@map_subscriptions_enabled?}
    /&gt;
  &lt;/aside&gt;
  &lt;.ping_container rtt_class={@rtt_class} /&gt;
  &lt;.donate_container /&gt;
  &lt;.feedback_container /&gt;
  &lt;.youtube_container /&gt;
  &lt;.new_version_banner app_version={@app_version} enabled={@map_subscriptions_enabled?} /&gt;
&lt;/div&gt;

&lt;%= live_render(@socket, WandererAppWeb.ServerStatusLive,
  container: {:div, class: &quot;&quot;},
  id: &quot;server-status&quot;
) %&gt;

&lt;.live_component module={WandererAppWeb.Alerts} id=&quot;notifications&quot; view_flash={@flash} /&gt;</file><file path="lib/wanderer_app_web/components/layouts/root.html.heex">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; data-theme=&quot;dark&quot; class=&quot;dark&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
    &lt;meta name=&quot;csrf-token&quot; content={get_csrf_token()} /&gt;
    &lt;.live_title suffix=&quot; ¬∑ Wanderer&quot;&gt;
      &lt;%= assigns[:page_title] || &quot;Welcome&quot; %&gt;
    &lt;/.live_title&gt;

    &lt;link phx-track-static rel=&quot;stylesheet&quot; href={~p&quot;/assets/app.css&quot;} /&gt;

    &lt;link
      href=&quot;https://web.ccpgamescdn.com/aws/webfonts/shentox/webfonts-2.0/Shentox-SemiBold.woff2&quot;
      type=&quot;font/woff2&quot;
      crossorigin=&quot;anonymous&quot;
    /&gt;
    &lt;link
      href=&quot;https://web.ccpgamescdn.com/aws/webfonts/shentox/webfonts-2.0/Shentox-Medium.woff2&quot;
      type=&quot;font/woff2&quot;
      crossorigin=&quot;anonymous&quot;
    /&gt;
    &lt;link
      href=&quot;https://web.ccpgamescdn.com/aws/webfonts/shentox/webfonts-2.0/Shentox-Light.woff2&quot;
      type=&quot;font/woff2&quot;
      crossorigin=&quot;anonymous&quot;
    /&gt;
    &lt;link
      href=&quot;https://web.ccpgamescdn.com/aws/webfonts/shentox/webfonts-2.0/Shentox-Regular.woff2&quot;
      type=&quot;font/woff2&quot;
      crossorigin=&quot;anonymous&quot;
    /&gt;

    &lt;script defer phx-track-static type=&quot;module&quot; src={~p&quot;/assets/app.js&quot;} crossorigin=&quot;anonymous&quot;&gt;
    &lt;/script&gt;
    &lt;!-- Google tag (gtag.js) --&gt;
    &lt;script
      defer
      src=&quot;https://www.googletagmanager.com/gtag/js?id=G-61PHLLS0LD&quot;
      crossorigin=&quot;anonymous&quot;
    &gt;
    &lt;/script&gt;
    &lt;script defer&gt;
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag(&apos;js&apos;, new Date());

      gtag(&apos;config&apos;, &apos;G-61PHLLS0LD&apos;);
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;%= @inner_content %&gt;
  &lt;/body&gt;
&lt;/html&gt;</file><file path="lib/wanderer_app_web/components/alerts.ex">defmodule WandererAppWeb.Alerts do
  @moduledoc &quot;&quot;&quot;
  Component that shows alerts.
  &quot;&quot;&quot;
  use WandererAppWeb, :live_component

  @impl true
  def update(assigns, socket) do
    {:ok,
     socket
     |&gt; assign(assigns)
     # this function will look and `push_event()` for each existing flash type
     |&gt; trigger_fade_out_flashes(assigns)}
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div&gt;
      &lt;div role=&quot;alert&quot; data-handle-fadeout-flash={delayed_fade_out_flash()} phx-value-key=&quot;info&quot;&gt;
        &lt;.flash id=&quot;client-info&quot; kind={:info} title=&quot;Info!&quot; flash={@view_flash} /&gt;
      &lt;/div&gt;
      &lt;div role=&quot;alert&quot; phx-value-key=&quot;error&quot;&gt;
        &lt;.flash id=&quot;client-error&quot; kind={:error} title=&quot;Error!&quot; flash={@view_flash} /&gt;
      &lt;/div&gt;
      &lt;div role=&quot;alert&quot; phx-value-key=&quot;warning&quot;&gt;
        &lt;.flash id=&quot;client-warning&quot; kind={:warning} title=&quot;Warning!&quot; flash={@view_flash} /&gt;
      &lt;/div&gt;
      &lt;div role=&quot;alert&quot; phx-value-key=&quot;loading&quot; data-handle-fadeout-flash={delayed_fade_out_flash()}&gt;
        &lt;.flash id=&quot;client-loading&quot; kind={:loading} title=&quot;Loading...&quot; flash={@view_flash} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  # depending on how you structured your code, `socket.assigns.flash` might have your flash map.
  # for me I was running this as a component, so it was being passed @flash into `view_flash`.
  defp trigger_fade_out_flashes(socket, %{view_flash: nil} = _assigns), do: socket

  defp trigger_fade_out_flashes(socket, %{view_flash: flash} = _assigns) do
    # push event for each flash type.
    Map.keys(flash)
    |&gt; Enum.reduce(socket, fn flash_key, piped_socket -&gt;
      piped_socket
      |&gt; push_event(&quot;fade-out-flash&quot;, %{type: flash_key})
    end)
  end

  # use TailwindCSS to wait 2 seconds before starting transition. Afterwards, send event to server to clear out flash.
  # `lv:clear-flash` will use `phx-value-key` attribute in element to remove flash per type.
  def delayed_fade_out_flash() do
    JS.hide(
      transition:
        {&quot;transition-opacity ease-out delay-5000 duration-6000&quot;, &quot;opacity-100&quot;, &quot;opacity-0&quot;},
      time: 6000
    )
    |&gt; JS.push(&quot;lv:clear-flash&quot;)
  end
end</file><file path="lib/wanderer_app_web/components/core_components.ex">defmodule WandererAppWeb.CoreComponents do
  @moduledoc &quot;&quot;&quot;
  Provides core UI components.

  At first glance, this module may seem daunting, but its goal is to provide
  core building blocks for your application, such as modals, tables, and
  forms. The components consist mostly of markup and are well-documented
  with doc strings and declarative assigns. You may customize and style
  them in any way you want, based on your application growth and needs.

  The default components use Tailwind CSS, a utility-first CSS framework.
  See the [Tailwind CSS documentation](https://tailwindcss.com) to learn
  how to customize them or feel free to swap in another framework altogether.

  Icons are provided by [heroicons](https://heroicons.com). See `icon/1` for usage.
  &quot;&quot;&quot;
  use Phoenix.Component

  alias Phoenix.LiveView.JS
  import WandererAppWeb.Gettext

  @image_base_url &quot;https://images.evetech.net&quot;

  attr(:url, :string, required: true)
  attr(:label, :string, required: false)

  def avatar(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;avatar&quot;&gt;
      &lt;div class=&quot;rounded-md w-8 h-8&quot;&gt;
        &lt;img src={@url} alt={@label} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a modal.

  ## Examples

      &lt;.modal id=&quot;confirm-modal&quot;&gt;
        This is a modal.
      &lt;/.modal&gt;

  JS commands may be passed to the `:on_cancel` to configure
  the closing/cancel event, for example:

      &lt;.modal id=&quot;confirm&quot; on_cancel={JS.navigate(~p&quot;/posts&quot;)}&gt;
        This is another modal.
      &lt;/.modal&gt;

  &quot;&quot;&quot;
  attr(:id, :string, required: true)
  attr(:title, :string, default: nil)
  attr(:show, :boolean, default: false)
  attr(:on_cancel, JS, default: %JS{})
  slot(:inner_block, required: true)
  attr(:class, :string, default: nil)

  def modal(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div
      id={@id}
      phx-mounted={@show &amp;&amp; show_modal(@id)}
      phx-remove={hide_modal(@id)}
      data-cancel={JS.exec(@on_cancel, &quot;phx-remove&quot;)}
      class=&quot;relative z-50 hidden overflow-visible&quot;
      class=&quot;&quot;
    &gt;
      &lt;div id={&quot;#{@id}-bg&quot;} class=&quot;overflow-visible p-dialog-resizable&quot; aria-hidden=&quot;true&quot; /&gt;
      &lt;div
        class=&quot;fixed inset-0 overflow-visible&quot;
        aria-labelledby={&quot;#{@id}-title&quot;}
        aria-describedby={&quot;#{@id}-description&quot;}
        role=&quot;dialog&quot;
        aria-modal=&quot;true&quot;
        tabindex=&quot;0&quot;
      &gt;
        &lt;div class=&quot;flex items-center justify-center w-full h-full p-4 sm:p-6 lg:py-8 p-dialog-mask p-dialog-center p-component-overlay p-component-overlay-enter p-dialog-resizable&quot;&gt;
          &lt;.focus_wrap
            id={&quot;#{@id}-container&quot;}
            phx-window-keydown={JS.exec(&quot;data-cancel&quot;, to: &quot;##{@id}&quot;)}
            phx-key=&quot;escape&quot;
            class={[
              &quot;relative hidden transition p-dialog p-component p-dialog-default p-ripple-disabled p-dialog-enter-done !overflow-visible max-w-full&quot;,
              @class
            ]}
          &gt;
            &lt;h3 class=&quot;p-dialog-header font-bold text-base&quot;&gt;
              &lt;div&gt;&lt;%= @title %&gt;&lt;/div&gt;
              &lt;div class=&quot;absolute right-4&quot;&gt;
                &lt;button
                  phx-click={JS.exec(&quot;data-cancel&quot;, to: &quot;##{@id}&quot;)}
                  type=&quot;button&quot;
                  class=&quot;p-link opacity-70 hover:opacity-100&quot;
                  aria-label={gettext(&quot;close&quot;)}
                &gt;
                  &lt;.icon name=&quot;hero-x-mark-solid&quot; class=&quot;h-5 w-5&quot; /&gt;
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;/h3&gt;
            &lt;div id={&quot;#{@id}-content&quot;} class=&quot;p-dialog-content !overflow-visible&quot;&gt;
              &lt;%= render_slot(@inner_block) %&gt;
            &lt;/div&gt;
          &lt;/.focus_wrap&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  slot :inner_block

  def connection_status(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div
      id=&quot;connection-status&quot;
      class=&quot;hidden fixed z-50&quot;
      js-show={show(&quot;#connection-status&quot;)}
      js-hide={hide(&quot;#connection-status&quot;)}
    &gt;
      &lt;div class=&quot;hs-overlay-backdrop transition duration fixed inset-0 bg-gray-900 bg-opacity-50 dark:bg-opacity-80 dark:bg-neutral-900 z-50&quot;&gt;
      &lt;/div&gt;
      &lt;div class=&quot;alert fixed top-20 right-4 shadow-lg w-72 fade-in-scale z-50&quot;&gt;
        &lt;div class=&quot;flex&quot;&gt;
          &lt;div class=&quot;flex-shrink-0 flex items-center&quot;&gt;
            &lt;span class=&quot;loading loading-ring loading-md&quot;&gt;&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class=&quot;ml-3 flex items-center&quot;&gt;
            &lt;p class=&quot;text-sm font-medium text-red-800&quot; role=&quot;alert&quot;&gt;
              &lt;%= render_slot(@inner_block) %&gt;
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  attr(:online, :boolean, default: false)

  def server_status(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div
      class=&quot;flex flex-col p-4 items-center absolute bottom-16 left-2 gap-2 tooltip tooltip-right&quot;
      data-tip=&quot;server: Tranquility&quot;
    &gt;
      &lt;div class={&quot;block w-2 h-2 rounded-full shadow-inner  #{if @online, do: &quot; bg-green-500&quot;, else: &quot;bg-red-500&quot;}&quot;}&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders flash notices.

  ## Examples

      &lt;.flash kind={:info} flash={@flash} /&gt;
      &lt;.flash kind={:info} phx-mounted={show(&quot;#flash&quot;)}&gt;Welcome Back!&lt;/.flash&gt;
  &quot;&quot;&quot;
  attr(:id, :string, doc: &quot;the optional id of flash container&quot;)
  attr(:flash, :map, default: %{}, doc: &quot;the map of flash messages to display&quot;)
  attr(:title, :string, default: nil)

  attr(:kind, :atom,
    values: [:info, :warning, :error, :loading],
    doc: &quot;used for styling and flash lookup&quot;
  )

  attr(:rest, :global, doc: &quot;the arbitrary HTML attributes to add to the flash container&quot;)

  slot(:inner_block, doc: &quot;the optional inner block that renders the flash message&quot;)

  def flash(assigns) do
    assigns = assign_new(assigns, :id, fn -&gt; &quot;flash-#{assigns.kind}&quot; end)

    ~H&quot;&quot;&quot;
    &lt;div
      :if={msg = render_slot(@inner_block) || Phoenix.Flash.get(@flash, @kind)}
      id={@id}
      phx-click={
        JS.push(&quot;lv:clear-flash&quot;, value: %{key: @kind})
        |&gt; JS.remove_class(&quot;fade-in-scale&quot;)
        |&gt; hide(&quot;##{@id}&quot;)
      }
      role=&quot;alert&quot;
      class={[
        &quot;alert shadow-lg flex items-center justify-between fixed top-12 right-2 w-80 z-50 fade-in-scale !rounded text-white !bg-black !bg-opacity-70  &quot;,
        @kind == :info &amp;&amp; &quot;alert-info &quot;,
        @kind == :warning &amp;&amp; &quot;alert-warning &quot;,
        @kind == :error &amp;&amp; &quot;alert-error&quot;,
        @kind == :loading &amp;&amp; &quot;alert-success&quot;
      ]}
      {@rest}
    &gt;
      &lt;div&gt;
        &lt;div class=&quot;flex gap-2 text-xs items-center&quot;&gt;
          &lt;.icon
            :if={@kind == :info}
            name=&quot;hero-information-circle&quot;
            class=&quot;h-5 !w-[50px] text-blue-500&quot;
          /&gt;
          &lt;.icon
            :if={@kind == :warning}
            name=&quot;hero-exclamation-triangle&quot;
            class=&quot;h-5 !w-[50px] text-orange-500&quot;
          /&gt;
          &lt;.icon :if={@kind == :error} name=&quot;hero-x-circle&quot; class=&quot;h-5 !w-[50px] text-red-500&quot; /&gt;
          &lt;span :if={@kind == :loading} class=&quot;loading loading-ring loading-md&quot;&gt;&lt;/span&gt; &lt;%= msg %&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;button type=&quot;button&quot; class=&quot;flex items-center&quot; aria-label={gettext(&quot;close&quot;)}&gt;
        &lt;.icon name=&quot;hero-x-mark-solid&quot; class=&quot;h-5 !w-[50px] opacity-40 group-hover:opacity-70&quot; /&gt;
      &lt;/button&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Shows the flash group with standard titles and content.

  ## Examples

      &lt;.flash_group flash={@flash} /&gt;
  &quot;&quot;&quot;
  attr(:flash, :map, required: true, doc: &quot;the map of flash messages&quot;)
  attr(:id, :string, default: &quot;flash-group&quot;, doc: &quot;the optional id of flash container&quot;)

  def flash_group(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div id={@id}&gt;
      &lt;.flash id=&quot;client-info&quot; kind={:info} title=&quot;Success!&quot; flash={@flash} /&gt;
      &lt;.flash id=&quot;client-error&quot; kind={:error} title=&quot;Error!&quot; flash={@flash} /&gt;
      &lt;.flash id=&quot;client-loading&quot; kind={:loading} title=&quot;Loading...&quot; flash={@flash} /&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a simple form.

  ## Examples

      &lt;.simple_form for={@form} phx-change=&quot;validate&quot; phx-submit=&quot;save&quot;&gt;
        &lt;.input field={@form[:email]} label=&quot;Email&quot;/&gt;
        &lt;.input field={@form[:username]} label=&quot;Username&quot; /&gt;
        &lt;:actions&gt;
          &lt;.button&gt;Save&lt;/.button&gt;
        &lt;/:actions&gt;
      &lt;/.simple_form&gt;
  &quot;&quot;&quot;
  attr(:for, :any, required: true, doc: &quot;the datastructure for the form&quot;)
  attr(:as, :any, default: nil, doc: &quot;the server side parameter to collect all input under&quot;)

  attr(:rest, :global,
    include: ~w(autocomplete name rel action enctype method novalidate target multipart),
    doc: &quot;the arbitrary HTML attributes to apply to the form tag&quot;
  )

  slot(:inner_block, required: true)
  slot(:actions, doc: &quot;the slot for form actions, such as a submit button&quot;)

  def simple_form(assigns) do
    ~H&quot;&quot;&quot;
    &lt;.form :let={f} for={@for} as={@as} {@rest}&gt;
      &lt;div class=&quot;w-full space-y-8&quot;&gt;
        &lt;%= render_slot(@inner_block, f) %&gt;
        &lt;div :for={action &lt;- @actions} class=&quot;mt-2 flex items-center justify-between gap-6&quot;&gt;
          &lt;%= render_slot(action, f) %&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/.form&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a button.

  ## Examples

      &lt;.button&gt;Send!&lt;/.button&gt;
      &lt;.button phx-click=&quot;go&quot; class=&quot;ml-2&quot;&gt;Send!&lt;/.button&gt;
  &quot;&quot;&quot;
  attr(:type, :string, default: nil)
  attr(:class, :string, default: nil)
  attr(:rest, :global, include: ~w(disabled form name value))

  slot(:inner_block, required: true)

  def button(assigns) do
    ~H&quot;&quot;&quot;
    &lt;button
      type={@type}
      class={[
        &quot;phx-submit-loading:opacity-75 p-button p-component p-button-outlined p-button-sm&quot;,
        @class
      ]}
      {@rest}
    &gt;
      &lt;%= render_slot(@inner_block) %&gt;
    &lt;/button&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders an input with label and error messages.

  A `Phoenix.HTML.FormField` may be passed as argument,
  which is used to retrieve the input name, id, and values.
  Otherwise all attributes may be passed explicitly.

  ## Types

  This function accepts all HTML input types, considering that:

    * You may also set `type=&quot;select&quot;` to render a `&lt;select&gt;` tag

    * `type=&quot;checkbox&quot;` is used exclusively to render boolean values

    * For live file uploads, see `Phoenix.Component.live_file_input/1`

  See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input
  for more information.

  ## Examples

      &lt;.input field={@form[:email]} type=&quot;email&quot; /&gt;
      &lt;.input name=&quot;my-input&quot; errors={[&quot;oh no!&quot;]} /&gt;
  &quot;&quot;&quot;
  attr(:id, :any, default: nil)
  attr(:class, :string, default: nil)
  attr(:wrapper_class, :string, default: nil)
  attr(:name, :any)
  attr(:label, :string, default: nil)
  attr(:prefix, :string, default: nil)
  attr(:value, :any)

  attr(:type, :string,
    default: &quot;text&quot;,
    values: ~w(checkbox color date datetime-local email file hidden month number password
               range radio search select tel text textarea time url week)
  )

  attr(:field, Phoenix.HTML.FormField,
    doc: &quot;a form field struct retrieved from the form, for example: @form[:email]&quot;
  )

  attr(:errors, :list, default: [])
  attr(:checked, :boolean, doc: &quot;the checked flag for checkbox inputs&quot;)
  attr(:show_value, :boolean, doc: &quot;show current value&quot;)
  attr(:prompt, :string, default: nil, doc: &quot;the prompt for select inputs&quot;)
  attr(:options, :list, doc: &quot;the options to pass to Phoenix.HTML.Form.options_for_select/2&quot;)
  attr(:multiple, :boolean, default: false, doc: &quot;the multiple flag for select inputs&quot;)

  attr(:rest, :global,
    include: ~w(accept autocomplete capture cols disabled form list max maxlength min minlength
                multiple pattern placeholder readonly required rows size step)
  )

  slot(:inner_block)

  def input(%{field: %Phoenix.HTML.FormField{} = field} = assigns) do
    assigns
    |&gt; assign(field: nil, id: assigns.id || field.id)
    |&gt; assign(:errors, Enum.map(field.errors, &amp;translate_error(&amp;1)))
    |&gt; assign_new(:name, fn -&gt; if assigns.multiple, do: field.name &lt;&gt; &quot;[]&quot;, else: field.name end)
    |&gt; assign_new(:value, fn -&gt; field.value end)
    |&gt; input()
  end

  def input(%{type: &quot;checkbox&quot;} = assigns) do
    assigns =
      assign_new(assigns, :checked, fn -&gt;
        Phoenix.HTML.Form.normalize_value(&quot;checkbox&quot;, assigns[:value])
      end)

    ~H&quot;&quot;&quot;
    &lt;div phx-feedback-for={@name} class=&quot;form-control mt-2&quot;&gt;
      &lt;label class=&quot;inputContainer&quot; for={@name}&gt;
        &lt;span&gt;&lt;%= @label %&gt;&lt;/span&gt;
        &lt;div&gt;&lt;/div&gt;
        &lt;div class=&quot;smallInputSwitch&quot;&gt;
          &lt;div class=&quot;flex items-center&quot;&gt;
            &lt;div
              class={[
                &quot;checkboxRoot sizeM p-checkbox p-component&quot;,
                classes(&quot;p-highlight&quot;: @checked)
              ]}
              data-p-highlight={@checked}
              data-p-disabled=&quot;false&quot;
              data-pc-name=&quot;checkbox&quot;
              data-pc-section=&quot;root&quot;
            &gt;
              &lt;input type=&quot;hidden&quot; name={@name} value=&quot;false&quot; disabled={@rest[:disabled]} /&gt;
              &lt;input
                id={@id}
                name={@name}
                type=&quot;checkbox&quot;
                class=&quot;p-checkbox-input&quot;
                aria-invalid=&quot;false&quot;
                data-pc-section=&quot;input&quot;
                value=&quot;true&quot;
                checked={@checked}
                {@rest}
              /&gt;
              &lt;div
                class=&quot;p-checkbox-box&quot;
                data-p-highlight={@checked}
                data-p-disabled=&quot;false&quot;
                data-pc-section=&quot;box&quot;
              &gt;
                &lt;svg
                  :if={@checked}
                  width=&quot;14&quot;
                  height=&quot;14&quot;
                  viewBox=&quot;0 0 14 14&quot;
                  fill=&quot;none&quot;
                  xmlns=&quot;http://www.w3.org/2000/svg&quot;
                  class=&quot;p-icon p-checkbox-icon&quot;
                  aria-hidden=&quot;true&quot;
                  data-pc-section=&quot;icon&quot;
                &gt;
                  &lt;path
                    d=&quot;M4.86199 11.5948C4.78717 11.5923 4.71366 11.5745 4.64596 11.5426C4.57826 11.5107 4.51779 11.4652 4.46827 11.4091L0.753985 7.69483C0.683167 7.64891 0.623706 7.58751 0.580092 7.51525C0.536478 7.44299 0.509851 7.36177 0.502221 7.27771C0.49459 7.19366 0.506156 7.10897 0.536046 7.03004C0.565935 6.95111 0.613367 6.88 0.674759 6.82208C0.736151 6.76416 0.8099 6.72095 0.890436 6.69571C0.970973 6.67046 1.05619 6.66385 1.13966 6.67635C1.22313 6.68886 1.30266 6.72017 1.37226 6.76792C1.44186 6.81567 1.4997 6.8786 1.54141 6.95197L4.86199 10.2503L12.6397 2.49483C12.7444 2.42694 12.8689 2.39617 12.9932 2.40745C13.1174 2.41873 13.2343 2.47141 13.3251 2.55705C13.4159 2.64268 13.4753 2.75632 13.4938 2.87973C13.5123 3.00315 13.4888 3.1292 13.4271 3.23768L5.2557 11.4091C5.20618 11.4652 5.14571 11.5107 5.07801 11.5426C5.01031 11.5745 4.9368 11.5923 4.86199 11.5948Z&quot;
                    fill=&quot;currentColor&quot;
                  &gt;
                  &lt;/path&gt;
                &lt;/svg&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;label for={@name} class=&quot;select-none ml-1.5&quot;&gt;&lt;/label&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/label&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  def input(%{type: &quot;range&quot;} = assigns) do
    ~H&quot;&quot;&quot;
    &lt;div phx-feedback-for={@name}&gt;
      &lt;div class=&quot;form-control w-full&quot;&gt;
        &lt;.label for={@id}&gt;
          &lt;span&gt;&lt;%= @label %&gt;&lt;/span&gt;
          &lt;div&gt;&lt;/div&gt;
          &lt;%= @value %&gt;
        &lt;/.label&gt;

        &lt;div&gt;
          &lt;input
            type=&quot;range&quot;
            id={@id}
            name={@name}
            value={@value}
            class={[
              &quot;p-component w-full&quot;,
              @class,
              @errors != [] &amp;&amp; &quot;border-rose-400 focus:border-rose-400&quot;
            ]}
            {@rest}
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;.error :for={msg &lt;- @errors}&gt;&lt;%= msg %&gt;&lt;/.error&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  def input(%{type: &quot;select&quot;} = assigns) do
    ~H&quot;&quot;&quot;
    &lt;div
      phx-feedback-for={@name}
      class={[
        &quot;inputContainer&quot;,
        @wrapper_class
      ]}
    &gt;
      &lt;.label :if={@label} for={@id}&gt;&lt;%= @label %&gt;&lt;/.label&gt;
      &lt;div :if={@label}&gt;&lt;/div&gt;
      &lt;select
        id={@id}
        name={@name}
        class={[
          &quot;p-component&quot;,
          @class
        ]}
        multiple={@multiple}
        {@rest}
      &gt;
        &lt;option :if={@prompt} value=&quot;&quot;&gt;&lt;%= @prompt %&gt;&lt;/option&gt;
        &lt;%= Phoenix.HTML.Form.options_for_select(@options, @value) %&gt;
      &lt;/select&gt;
      &lt;.error :for={msg &lt;- @errors}&gt;&lt;%= msg %&gt;&lt;/.error&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  def input(%{type: &quot;textarea&quot;} = assigns) do
    ~H&quot;&quot;&quot;
    &lt;label phx-feedback-for={@name} class=&quot;form-control&quot;&gt;
      &lt;.label for={@id}&gt;&lt;span class=&quot;label-text&quot;&gt;&lt;%= @label %&gt;&lt;/span&gt;&lt;/.label&gt;
      &lt;textarea
        id={@id}
        name={@name}
        class={[
          &quot;p-inputtextarea p-inputtext p-component w-full h-24&quot;,
          @class,
          @errors != [] &amp;&amp; &quot;p-invalid&quot;
        ]}
        {@rest}
      &gt;&lt;%= Phoenix.HTML.Form.normalize_value(&quot;textarea&quot;, @value) %&gt;&lt;/textarea&gt;
      &lt;.error :for={msg &lt;- @errors}&gt;&lt;%= msg %&gt;&lt;/.error&gt;
    &lt;/label&gt;
    &quot;&quot;&quot;
  end

  # All other inputs text, datetime-local, url, password, etc. are handled here...
  def input(assigns) do
    ~H&quot;&quot;&quot;
    &lt;label class=&quot;form-control w-full&quot; phx-feedback-for={@name}&gt;
      &lt;.label for={@id}&gt;&lt;span class=&quot;label-text&quot;&gt;&lt;%= @label %&gt;&lt;/span&gt;&lt;/.label&gt;
      &lt;div class=&quot;join&quot;&gt;
        &lt;input :if={@prefix} class=&quot;p-inputtext bg-neutral-700 join-item&quot; disabled value={@prefix} /&gt;
        &lt;input
          type={@type}
          name={@name}
          id={@id}
          value={Phoenix.HTML.Form.normalize_value(@type, @value)}
          class={[
            &quot;p-inputtext p-component w-full&quot;,
            @class,
            @errors != [] &amp;&amp; &quot;p-invalid&quot;
          ]}
          {@rest}
        /&gt;
      &lt;/div&gt;

      &lt;div class=&quot;label&quot;&gt;
        &lt;.error :for={msg &lt;- @errors}&gt;&lt;%= msg %&gt;&lt;/.error&gt;
      &lt;/div&gt;
    &lt;/label&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a label.
  &quot;&quot;&quot;
  attr(:for, :string, default: nil)
  slot(:inner_block, required: true)

  def label(assigns) do
    ~H&quot;&quot;&quot;
    &lt;label for={@for} class=&quot;inputContainer&quot;&gt;
      &lt;%= render_slot(@inner_block) %&gt;
    &lt;/label&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Generates a generic error message.
  &quot;&quot;&quot;
  slot(:inner_block, required: true)

  def error(assigns) do
    ~H&quot;&quot;&quot;
    &lt;p class=&quot;label-text-alt text-rose-600 phx-no-feedback:hidden&quot;&gt;
      &lt;.icon name=&quot;hero-exclamation-circle-mini&quot; class=&quot;mt-0.5 h-5 w-5 flex-none&quot; /&gt;
      &lt;%= render_slot(@inner_block) %&gt;
    &lt;/p&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a header with title.
  &quot;&quot;&quot;
  attr(:class, :string, default: nil)

  slot(:inner_block, required: true)
  slot(:subtitle)
  slot(:actions)

  def header(assigns) do
    ~H&quot;&quot;&quot;
    &lt;header class={[
      &quot;flex flex-col justify-between gap-2 p-2 bg-gray-400 bg-opacity-5 border border-gray-500 &quot;,
      @class
    ]}&gt;
      &lt;div&gt;
        &lt;h1 class=&quot;text-lg font-semibold leading-8&quot;&gt;
          &lt;%= render_slot(@inner_block) %&gt;
        &lt;/h1&gt;
        &lt;p :if={@subtitle != []} class=&quot;mt-2 text-sm leading-6&quot;&gt;
          &lt;%= render_slot(@subtitle) %&gt;
        &lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;flex-none&quot;&gt;&lt;%= render_slot(@actions) %&gt;&lt;/div&gt;
    &lt;/header&gt;
    &quot;&quot;&quot;
  end

  @doc ~S&quot;&quot;&quot;
  Renders a table with generic styling.

  ## Examples

      &lt;.table id=&quot;users&quot; rows={@users}&gt;
        &lt;:col :let={user} label=&quot;id&quot;&gt;&lt;%= user.id %&gt;&lt;/:col&gt;
        &lt;:col :let={user} label=&quot;username&quot;&gt;&lt;%= user.username %&gt;&lt;/:col&gt;
      &lt;/.table&gt;
  &quot;&quot;&quot;
  attr(:id, :string, required: true)
  attr(:class, :string, default: nil)
  attr(:empty_label, :string, default: nil)
  attr(:rows, :list, required: true)
  attr(:row_id, :any, default: nil, doc: &quot;the function for generating the row id&quot;)
  attr(:row_selected, :boolean, default: false, doc: &quot;the function for generating the row id&quot;)
  attr(:row_click, :any, default: nil, doc: &quot;the function for handling phx-click on each row&quot;)

  attr(:row_item, :any,
    default: &amp;Function.identity/1,
    doc: &quot;the function for mapping each row before calling the :col and :action slots&quot;
  )

  slot :col, required: true do
    attr(:label, :string)
  end

  slot(:action, doc: &quot;the slot for showing user actions in the last table column&quot;)

  def table(assigns) do
    assigns =
      with %{rows: %Phoenix.LiveView.LiveStream{}} &lt;- assigns do
        assign(assigns, row_id: assigns.row_id || fn {id, _item} -&gt; id end)
        assign(assigns, row_selected: assigns.row_selected || fn {_id, _item} -&gt; false end)
      end

    ~H&quot;&quot;&quot;
    &lt;div class={[&quot;overflow-y-auto px-4 sm:overflow-visible sm:px-0&quot;, @class]}&gt;
      &lt;table class=&quot;table overflow-y-auto&quot;&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th :for={col &lt;- @col}&gt;&lt;%= col[:label] %&gt;&lt;/th&gt;
            &lt;th :if={@action != []} class=&quot;relative p-0 pb-4&quot;&gt;
              &lt;span class=&quot;sr-only&quot;&gt;&lt;%= gettext(&quot;Actions&quot;) %&gt;&lt;/span&gt;
            &lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody id={@id} phx-update={match?(%Phoenix.LiveView.LiveStream{}, @rows) &amp;&amp; &quot;stream&quot;}&gt;
          &lt;tr :if={@rows |&gt; Enum.empty?()}&gt;
            &lt;td colspan={@col |&gt; Enum.count()}&gt;
              &lt;%= @empty_label %&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr
            :for={row &lt;- @rows}
            id={@row_id &amp;&amp; @row_id.(row)}
            phx-click={@row_click &amp;&amp; @row_click.(row)}
            class={&quot;hover #{if @row_selected &amp;&amp; @row_selected.(row), do: &quot;!bg-slate-600&quot;, else: &quot;&quot;} #{if @row_click, do: &quot;cursor-pointer&quot;, else: &quot;&quot;}&quot;}
          &gt;
            &lt;td :for={{col, _index} &lt;- Enum.with_index(@col)}&gt;
              &lt;%= render_slot(col, @row_item.(row)) %&gt;
            &lt;/td&gt;
            &lt;td :if={@action != []}&gt;
              &lt;div class=&quot;relative whitespace-nowrap text-right text-sm font-medium&quot;&gt;
                &lt;span class=&quot;absolute -inset-y-px -right-4 left-0 group-hover:bg-zinc-50 sm:rounded-r-xl&quot; /&gt;
                &lt;span :for={action &lt;- @action} class=&quot;relative pl-4 font-semibold leading-6&quot;&gt;
                  &lt;%= render_slot(action, @row_item.(row)) %&gt;
                &lt;/span&gt;
              &lt;/div&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a data list.

  ## Examples

      &lt;.list&gt;
        &lt;:item title=&quot;Title&quot;&gt;&lt;%= @post.title %&gt;&lt;/:item&gt;
        &lt;:item title=&quot;Views&quot;&gt;&lt;%= @post.views %&gt;&lt;/:item&gt;
      &lt;/.list&gt;
  &quot;&quot;&quot;
  slot :item, required: true do
    attr(:title, :string, required: true)
  end

  def list(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;mt-14&quot;&gt;
      &lt;dl class=&quot;-my-4 divide-y divide-zinc-100&quot;&gt;
        &lt;div :for={item &lt;- @item} class=&quot;flex gap-4 py-4 text-sm leading-6 sm:gap-8&quot;&gt;
          &lt;dt class=&quot;w-1/4 flex-none text-zinc-500&quot;&gt;&lt;%= item.title %&gt;&lt;/dt&gt;
          &lt;dd class=&quot;text-zinc-700&quot;&gt;&lt;%= render_slot(item) %&gt;&lt;/dd&gt;
        &lt;/div&gt;
      &lt;/dl&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  attr(:placeholder, :string, default: nil)
  attr(:label, :string, default: nil)
  attr(:label_class, :string, default: nil)
  attr(:input_class, :string, default: nil)
  attr(:dropdown_extra_class, :string, default: nil)
  attr(:option_extra_class, :string, default: nil)
  slot(:inner_block)

  def live_select(%{field: %Phoenix.HTML.FormField{} = field} = assigns) do
    assigns =
      assigns
      |&gt; assign(:errors, Enum.map(field.errors, &amp;translate_error(&amp;1)))
      |&gt; assign(
        :live_select_opts,
        assigns_to_attributes(assigns, [
          :errors,
          :label,
          :value_mapper,
          :label_class,
          :input_class,
          :dropdown_extra_class,
          :option_extra_class
        ])
      )

    ~H&quot;&quot;&quot;
    &lt;div
      phx-feedback-for={@field.name}
      class={[
        &quot;form-control&quot;,
        @label_class
      ]}
    &gt;
      &lt;div for=&quot;form_description&quot; class=&quot;label&quot;&gt;
        &lt;span class=&quot;label-text&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;LiveSelect.live_select
        field={@field}
        dropdown_class={[
          &quot;absolute shadow z-50 w-full max-h-64 bg-neutral-900 text-neutral-50 overflow-y-auto&quot;,
          @dropdown_extra_class
        ]}
        available_option_class=&quot;w-full&quot;
        option_class=&quot;p-2 hover:bg-neutral-800 hover:text-neutral-50&quot;
        tag_extra_class=&quot;rounded-none&quot;
        text_input_class={[
          &quot;p-autocomplete-input p-component p-inputtext  w-full&quot;,
          @errors != [] &amp;&amp; &quot;p-invalid&quot;,
          @input_class
        ]}
        text_input_selected_class=&quot;p-inputtext&quot;
        {@live_select_opts}
      &gt;
        &lt;%= render_slot(@inner_block) %&gt;
      &lt;/LiveSelect.live_select&gt;
      &lt;div for=&quot;form_description&quot; class=&quot;label&quot;&gt;
        &lt;.error :for={msg &lt;- @errors}&gt;&lt;%= msg %&gt;&lt;/.error&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a back navigation link.

  ## Examples

      &lt;.back navigate={~p&quot;/posts&quot;}&gt;Back to posts&lt;/.back&gt;
  &quot;&quot;&quot;
  attr(:navigate, :any, required: true)
  slot(:inner_block, required: true)
  attr(:class, :string, default: nil)

  def back(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;pt-16&quot;&gt;
      &lt;.link
        navigate={@navigate}
        class={[
          &quot;text-sm font-semibold leading-6&quot;,
          @class
        ]}
      &gt;
        &lt;.icon name=&quot;hero-arrow-left-solid&quot; class=&quot;h-3 w-3&quot; /&gt;
        &lt;%= render_slot(@inner_block) %&gt;
      &lt;/.link&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Add conditional class names to a component.

  ## Examples

  &lt;span class={[&quot;text-green-600 &quot;, classes(&quot;text-red-600&quot;: @value &lt; 0)]} /&gt;
  &quot;&quot;&quot;
  def classes(classes) do
    ([&quot; &quot;: true] ++ classes)
    |&gt; Enum.filter(&amp;elem(&amp;1, 1))
    |&gt; Enum.map_join(&quot; &quot;, &amp;elem(&amp;1, 0))
  end

  @doc &quot;&quot;&quot;
  Renders a [Heroicon](https://heroicons.com).

  Heroicons come in three styles ‚Äì outline, solid, and mini.
  By default, the outline style is used, but solid and mini may
  be applied by using the `-solid` and `-mini` suffix.

  You can customize the size and colors of the icons by setting
  width, height, and background color classes.

  Icons are extracted from your `assets/vendor/heroicons` directory and bundled
  within your compiled app.css by the plugin in your `assets/tailwind.config.js`.

  ## Examples

      &lt;.icon name=&quot;hero-x-mark-solid&quot; /&gt;
      &lt;.icon name=&quot;hero-arrow-path&quot; class=&quot;ml-1 w-3 h-3 animate-spin&quot; /&gt;
  &quot;&quot;&quot;
  attr(:name, :string, required: true)
  attr(:class, :string, default: nil)

  def icon(%{name: &quot;hero-&quot; &lt;&gt; _} = assigns) do
    ~H&quot;&quot;&quot;
    &lt;span class={[@name, @class]} /&gt;
    &quot;&quot;&quot;
  end

  def local_time(assigns) do
    ~H&quot;&quot;&quot;
    &lt;time phx-hook=&quot;LocalTime&quot; id={&quot;time-#{@id}&quot;} class=&quot;invisible&quot;&gt;&lt;%= @at %&gt;&lt;/time&gt;
    &quot;&quot;&quot;
  end

  attr(:at, :any, required: true)
  attr(:id, :any, required: true)

  def client_time(assigns) do
    ~H&quot;&quot;&quot;
    &lt;time phx-hook=&quot;ClientTime&quot; id={&quot;client-time-#{@id}&quot;} class=&quot;invisible&quot;&gt;&lt;%= @at %&gt;&lt;/time&gt;
    &quot;&quot;&quot;
  end

  ## JS Commands

  def show(js \\ %JS{}, selector) do
    JS.show(js,
      to: selector,
      transition:
        {&quot;transition-all transform ease-out duration-300&quot;,
         &quot;opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95&quot;,
         &quot;opacity-100 translate-y-0 sm:scale-100&quot;}
    )
  end

  def hide(js \\ %JS{}, selector) do
    JS.hide(js,
      to: selector,
      time: 200,
      transition:
        {&quot;transition-all transform ease-in duration-200&quot;,
         &quot;opacity-100 translate-y-0 sm:scale-100&quot;,
         &quot;opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95&quot;}
    )
  end

  def show_modal(js \\ %JS{}, id) when is_binary(id) do
    js
    |&gt; JS.show(to: &quot;##{id}&quot;)
    |&gt; JS.show(
      to: &quot;##{id}-bg&quot;,
      transition: {&quot;transition-all transform ease-out duration-300&quot;, &quot;opacity-0&quot;, &quot;opacity-100&quot;}
    )
    |&gt; show(&quot;##{id}-container&quot;)
    |&gt; JS.add_class(&quot;overflow-hidden&quot;, to: &quot;body&quot;)
    |&gt; JS.focus_first(to: &quot;##{id}-content&quot;)
  end

  def hide_modal(js \\ %JS{}, id) do
    js
    |&gt; JS.hide(
      to: &quot;##{id}-bg&quot;,
      transition: {&quot;transition-all transform ease-in duration-200&quot;, &quot;opacity-100&quot;, &quot;opacity-0&quot;}
    )
    |&gt; hide(&quot;##{id}-container&quot;)
    |&gt; JS.hide(to: &quot;##{id}&quot;, transition: {&quot;block&quot;, &quot;block&quot;, &quot;hidden&quot;})
    |&gt; JS.remove_class(&quot;overflow-hidden&quot;, to: &quot;body&quot;)
    |&gt; JS.pop_focus()
  end

  @doc &quot;&quot;&quot;
  Translates an error message using gettext.
  &quot;&quot;&quot;
  def translate_error({msg, opts}) do
    # When using gettext, we typically pass the strings we want
    # to translate as a static argument:
    #
    #     # Translate the number of files with plural rules
    #     dngettext(&quot;errors&quot;, &quot;1 file&quot;, &quot;%{count} files&quot;, count)
    #
    # However the error messages in our forms and APIs are generated
    # dynamically, so we need to translate them by calling Gettext
    # with our gettext backend as first argument. Translations are
    # available in the errors.po file (as we use the &quot;errors&quot; domain).
    if count = opts[:count] do
      Gettext.dngettext(WandererAppWeb.Gettext, &quot;errors&quot;, msg, msg, count, opts)
    else
      Gettext.dgettext(WandererAppWeb.Gettext, &quot;errors&quot;, msg, opts)
    end
  end

  @doc &quot;&quot;&quot;
  Translates the errors for a field from a keyword list of errors.
  &quot;&quot;&quot;
  def translate_errors(errors, field) when is_list(errors) do
    for {^field, {msg, opts}} &lt;- errors, do: translate_error({msg, opts})
  end

  def less(a, b) do
    a &lt; b
  end

  def more_or_equal(a, b) do
    a &gt;= b
  end

  def member_icon_url(eve_character_id)
      when is_binary(eve_character_id) or is_integer(eve_character_id) do
    &quot;#{@image_base_url}/characters/#{eve_character_id}/portrait&quot;
  end

  def member_icon_url(%{eve_character_id: eve_character_id} = _member)
      when is_binary(eve_character_id) or is_integer(eve_character_id) do
    &quot;#{@image_base_url}/characters/#{eve_character_id}/portrait&quot;
  end

  def member_icon_url(%{eve_corporation_id: eve_corporation_id} = _member)
      when is_binary(eve_corporation_id) or is_integer(eve_corporation_id) do
    &quot;#{@image_base_url}/corporations/#{eve_corporation_id}/logo?size=32&quot;
  end

  def member_icon_url(%{eve_alliance_id: eve_alliance_id} = _member)
      when is_binary(eve_alliance_id) or is_integer(eve_alliance_id) do
    &quot;#{@image_base_url}/alliances/#{eve_alliance_id}/logo?size=32&quot;
  end

  def pagination_opts do
    [
      ellipsis_attrs: [class: &quot;ellipsis&quot;],
      ellipsis_content: &quot;‚Ä•&quot;,
      next_link_content: next_icon(),
      page_links: {:ellipsis, 7},
      previous_link_content: previous_icon(),
      current_link_attrs: [
        class:
          &quot;relative z-10 inline-flex items-center bg-indigo-600 px-4 py-2 text-sm font-semibold text-white focus:z-20 focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600&quot;,
        aria: [current: &quot;page&quot;]
      ],
      next_link_attrs: [
        aria: [label: &quot;Go to next page&quot;],
        class: &quot;&quot;
      ],
      pagination_link_attrs: [
        class:
          &quot;relative z-10 inline-flex items-center px-4 py-2 text-sm font-semibold text-white focus:z-20 focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600&quot;
      ],
      previous_link_attrs: [
        aria: [label: &quot;Go to previous page&quot;],
        class: &quot;&quot;
      ]
    ]
  end

  defp next_icon do
    assigns = %{}

    ~H&quot;&quot;&quot;
    &lt;.icon name=&quot;hero-chevron-right&quot; class=&quot;h-5 w-5&quot; /&gt;
    &quot;&quot;&quot;
  end

  defp previous_icon do
    assigns = %{}

    ~H&quot;&quot;&quot;
    &lt;.icon name=&quot;hero-chevron-left&quot; class=&quot;h-5 w-5&quot; /&gt;
    &quot;&quot;&quot;
  end

  def table_opts do
    [
      container: true,
      container_attrs: [class: &quot;table-container&quot;],
      no_results_content: no_results_content(),
      table_attrs: [class: &quot;table&quot;]
    ]
  end

  defp no_results_content do
    assigns = %{}

    ~H&quot;&quot;&quot;
    &lt;p&gt;Nothing found.&lt;/p&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_app_web/components/layouts.ex">defmodule WandererAppWeb.Layouts do
  use WandererAppWeb, :html

  embed_templates &quot;layouts/*&quot;

  attr :rtt_class, :string

  def ping_container(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div
      id=&quot;ping-container&quot;
      class={[
        &quot;flex flex-col p-4 items-center absolute bottom-28 left-1 gap-2 tooltip tooltip-right text-gray-400 hover:text-white&quot;,
        @rtt_class
      ]}
      phx-hook=&quot;Ping&quot;
      phx-update=&quot;ignore&quot;
    &gt;
      &lt;.icon name=&quot;hero-wifi-solid&quot; class=&quot;h-4 w-4&quot; /&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  attr :app_version, :string
  attr :enabled, :boolean

  def new_version_banner(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div
      id=&quot;new-version-banner&quot;
      phx-hook=&quot;NewVersionUpdate&quot;
      phx-update=&quot;ignore&quot;
      data-version={@app_version}
      data-enabled={Jason.encode!(@enabled)}
      class=&quot;!z-1000 hidden absolute top-0 left-0 w-full h-full group items-center fade-in-scale text-white !bg-opacity-70 rounded p-px overflow-hidden flex items-center&quot;
    &gt;
      &lt;div class=&quot;hs-overlay-backdrop transition duration absolute left-0 top-0 w-full h-full bg-gray-900 bg-opacity-50 dark:bg-opacity-80 dark:bg-neutral-900&quot;&gt;
      &lt;/div&gt;
      &lt;div class=&quot;absolute top-[50%] left-[50%] translate-x-[-50%] translate-y-[-50%] flex items-center&quot;&gt;
        &lt;div class=&quot;rounded w-9 h-9 w-[80px] h-[66px] flex items-center justify-center relative z-20&quot;&gt;
          &lt;.icon name=&quot;hero-chevron-double-right&quot; class=&quot;w-9 h-9 mr-[-40px]&quot; /&gt;
        &lt;/div&gt;
        &lt;div id=&quot;refresh-area&quot;&gt;
          &lt;.live_component module={WandererAppWeb.MapRefresh} id=&quot;map-refresh&quot; /&gt;
        &lt;/div&gt;

        &lt;div class=&quot;rounded h-[66px] flex items-center justify-center relative z-20&quot;&gt;
          &lt;div class=&quot; flex items-center w-[200px] h-full&quot;&gt;
            &lt;.icon name=&quot;hero-chevron-double-left&quot; class=&quot;w-9 h-9 mr-[20px]&quot; /&gt;
            &lt;div class=&quot; flex flex-col items-center justify-center h-full&quot;&gt;
              &lt;div class=&quot;text-white text-nowrap text-sm [text-shadow:_0_1px_0_rgb(0_0_0_/_40%)]&quot;&gt;
                Update Required
              &lt;/div&gt;
              &lt;a
                href=&quot;/changelog&quot;
                target=&quot;_blank&quot;
                class=&quot;text-sm link-secondary [text-shadow:_0_1px_0_rgb(0_0_0_/_40%)]&quot;
              &gt;
                What&apos;s new?
              &lt;/a&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  def youtube_container(assigns) do
    ~H&quot;&quot;&quot;
    &lt;.link
      href=&quot;https://www.youtube.com/@wanderer_ltd&quot;
      class=&quot;flex flex-col p-4 items-center absolute bottom-52 left-0 gap-2 tooltip tooltip-right text-gray-400 hover:text-white&quot;
    &gt;
      &lt;svg
        width=&quot;24px&quot;
        height=&quot;24px&quot;
        viewBox=&quot;0 0 24 24&quot;
        fill=&quot;none&quot;
        xmlns=&quot;http://www.w3.org/2000/svg&quot;
      &gt;
        &lt;path
          d=&quot;M20.5245 6.00694C20.3025 5.81544 20.0333 5.70603 19.836 5.63863C19.6156 5.56337 19.3637 5.50148 19.0989 5.44892C18.5677 5.34348 17.9037 5.26005 17.1675 5.19491C15.6904 5.06419 13.8392 5 12 5C10.1608 5 8.30956 5.06419 6.83246 5.1949C6.09632 5.26005 5.43231 5.34348 4.9011 5.44891C4.63628 5.50147 4.38443 5.56337 4.16403 5.63863C3.96667 5.70603 3.69746 5.81544 3.47552 6.00694C3.26514 6.18846 3.14612 6.41237 3.07941 6.55976C3.00507 6.724 2.94831 6.90201 2.90314 7.07448C2.81255 7.42043 2.74448 7.83867 2.69272 8.28448C2.58852 9.18195 2.53846 10.299 2.53846 11.409C2.53846 12.5198 2.58859 13.6529 2.69218 14.5835C2.74378 15.047 2.81086 15.4809 2.89786 15.8453C2.97306 16.1603 3.09841 16.5895 3.35221 16.9023C3.58757 17.1925 3.92217 17.324 4.08755 17.3836C4.30223 17.461 4.55045 17.5218 4.80667 17.572C5.32337 17.6733 5.98609 17.7527 6.72664 17.8146C8.2145 17.9389 10.1134 18 12 18C13.8865 18 15.7855 17.9389 17.2733 17.8146C18.0139 17.7527 18.6766 17.6733 19.1933 17.572C19.4495 17.5218 19.6978 17.461 19.9124 17.3836C20.0778 17.324 20.4124 17.1925 20.6478 16.9023C20.9016 16.5895 21.0269 16.1603 21.1021 15.8453C21.1891 15.4809 21.2562 15.047 21.3078 14.5835C21.4114 13.6529 21.4615 12.5198 21.4615 11.409C21.4615 10.299 21.4115 9.18195 21.3073 8.28448C21.2555 7.83868 21.1874 7.42043 21.0969 7.07448C21.0517 6.90201 20.9949 6.72401 20.9206 6.55976C20.8539 6.41236 20.7349 6.18846 20.5245 6.00694Z&quot;
          stroke=&quot;currentColor&quot;
          stroke-width=&quot;2&quot;
          stroke-linecap=&quot;round&quot;
          stroke-linejoin=&quot;round&quot;
        /&gt;
        &lt;path
          d=&quot;M14.5385 11.5L10.0962 14.3578L10.0962 8.64207L14.5385 11.5Z&quot;
          stroke=&quot;currentColor&quot;
          stroke-width=&quot;2&quot;
          stroke-linecap=&quot;round&quot;
          stroke-linejoin=&quot;round&quot;
        /&gt;
      &lt;/svg&gt;
    &lt;/.link&gt;
    &quot;&quot;&quot;
  end

  def donate_container(assigns) do
    ~H&quot;&quot;&quot;
    &lt;.link
      href=&quot;https://www.patreon.com/WandererLtd&quot;
      target=&quot;_blank&quot;
      class=&quot;flex flex-col p-4 items-center absolute bottom-64 left-1 gap-2 tooltip tooltip-right text-gray-400 hover:text-white&quot;
    &gt;
      &lt;.icon name=&quot;hero-banknotes-solid&quot; class=&quot;h-4 w-4&quot; /&gt;
    &lt;/.link&gt;
    &quot;&quot;&quot;
  end

  def feedback_container(assigns) do
    ~H&quot;&quot;&quot;
    &lt;.link
      href=&quot;https://discord.gg/cafERvDD2k&quot;
      class=&quot;flex flex-col p-4 items-center absolute bottom-40 left-1 gap-2 tooltip tooltip-right text-gray-400 hover:text-white&quot;
    &gt;
      &lt;.icon name=&quot;hero-hand-thumb-up-solid&quot; class=&quot;h-4 w-4&quot; /&gt;
    &lt;/.link&gt;
    &quot;&quot;&quot;
  end

  attr :id, :string
  attr :active_tab, :atom
  attr :show_admin, :boolean
  attr :map_subscriptions_enabled, :boolean

  def sidebar_nav_links(assigns) do
    ~H&quot;&quot;&quot;
    &lt;ul class=&quot;text-center flex flex-col w-full&quot;&gt;
      &lt;div class=&quot;dropdown dropdown-right&quot;&gt;
        &lt;div tabindex=&quot;0&quot; role=&quot;button&quot;&gt;
          &lt;li class=&quot;flex-1 w-full h-14 block text-gray-400 hover:text-white p-3&quot;&gt;
            &lt;.icon name=&quot;hero-bars-3-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
          &lt;/li&gt;
        &lt;/div&gt;
        &lt;ul
          tabindex=&quot;0&quot;
          class=&quot;menu menu-sm dropdown-content bg-base-100 rounded-box z-[1] mt-3 w-52 p-2 shadow&quot;
        &gt;
          &lt;li&gt;&lt;a href=&quot;/changelog&quot;&gt;Changelog&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;/news&quot;&gt;News&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;/license&quot;&gt;License&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;/contacts&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;

      &lt;.nav_link
        href=&quot;/last&quot;
        active={@active_tab == :map}
        icon=&quot;hero-viewfinder-circle-solid&quot;
        tip=&quot;Map&quot;
      /&gt;
      &lt;.nav_link href=&quot;/maps&quot; active={@active_tab == :maps} icon=&quot;hero-map-solid&quot; tip=&quot;Maps&quot; /&gt;
      &lt;.nav_link
        href=&quot;/access-lists&quot;
        active={@active_tab == :access_lists}
        icon=&quot;hero-user-group-solid&quot;
        tip=&quot;Access Lists&quot;
      /&gt;
      &lt;.nav_link
        href=&quot;/characters&quot;
        active={@active_tab == :characters}
        icon=&quot;hero-user-plus-solid&quot;
        tip=&quot;Characters&quot;
      /&gt;
      &lt;.nav_link
        href=&quot;/tracking&quot;
        active={@active_tab == :characters_tracking}
        icon=&quot;hero-signal-solid&quot;
        tip=&quot;Characters Tracking&quot;
      /&gt;

      &lt;div class=&quot;absolute bottom-0 left-0 border-t border-gray-600 dropdown dropdown-right dropdown-end&quot;&gt;
        &lt;div tabindex=&quot;0&quot; role=&quot;button&quot; class=&quot;h-full w-full text-gray-400 hover:text-white block p-4&quot;&gt;
          &lt;.icon name=&quot;hero-user-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
        &lt;/div&gt;
        &lt;ul tabindex=&quot;0&quot; class=&quot;dropdown-content menu bg-base-100 rounded-box z-[1] w-52 p-2 shadow&quot;&gt;
          &lt;li :if={@show_admin}&gt;
            &lt;.link navigate=&quot;/admin&quot;&gt;
              Admin
            &lt;/.link&gt;
          &lt;/li&gt;
          &lt;li :if={@show_admin}&gt;
            &lt;.link navigate=&quot;/admin/errors&quot;&gt;
              Errors
            &lt;/.link&gt;
          &lt;/li&gt;
          &lt;li :if={@map_subscriptions_enabled}&gt;
            &lt;.link navigate=&quot;/profile&quot;&gt;
              Profile
            &lt;/.link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;.link navigate=&quot;/auth/signout&quot;&gt;
              Logout
            &lt;/.link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/ul&gt;
    &quot;&quot;&quot;
  end

  attr :href, :string
  attr :active, :boolean, default: false
  attr :class, :string, default: &quot;&quot;
  attr :icon, :string
  attr :tip, :string

  defp nav_link(assigns) do
    ~H&quot;&quot;&quot;
    &lt;li class={[&quot;flex-1 w-full &quot;, @class]}&gt;
      &lt;div class=&quot;tooltip tooltip-right&quot; data-tip={@tip}&gt;
        &lt;.link
          navigate={@href}
          class={[
            &quot;h-full w-full text-gray-400 hover:text-white block p-3&quot;,
            classes(&quot;border-r-4 text-white border-r-orange-400&quot;: @active)
          ]}
          aria-current={if @active, do: &quot;true&quot;, else: &quot;false&quot;}
        &gt;
          &lt;.icon name={@icon} class=&quot;w-6 h-6&quot; /&gt;
        &lt;/.link&gt;
      &lt;/div&gt;
    &lt;/li&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_app_web/controllers/blog_html/changelog.html.heex">&lt;article class=&quot;prose prose-lg ccp-font w-full max-w-3xl mx-auto&quot;&gt;
  &lt;div class=&quot;w-full px-4 md:px-6 text-xl leading-normal ccp-font&quot;&gt;
    &lt;%= raw(@file.body) %&gt;
  &lt;/div&gt;
&lt;/article&gt;</file><file path="lib/wanderer_app_web/controllers/blog_html/contacts.heex">&lt;div&gt;
  &lt;div class=&quot;flex mt-20px max-h-[calc(100vh-50px)] max-w-[100vw] flex-col items-center&quot;&gt;
    &lt;div class=&quot;shrink&quot;&gt;
      &lt;div class=&quot;flex min-h-[calc(100vh-100px)] items-center justify-center px-2 py-10 text-center xl:pe-0 xl:ps-10&quot;&gt;
        &lt;div&gt;
          &lt;h1 class=&quot;text-center text-[clamp(2rem,6vw,4rem)] font-black leading-[1.1] [word-break:auto-phrase] xl:w-[115%] xl:text-start [:root[dir=rtl]_&amp;amp;]:leading-[1.35]&quot;&gt;
            &lt;span class=&quot;[&amp;amp;::selection]:text-base-content brightness-150 contrast-150 [&amp;amp;::selection]:bg-blue-700/20&quot;&gt;
              Join or support us!
              &lt;!----&gt;
            &lt;/span&gt;
          &lt;/h1&gt;
          &lt;div class=&quot;h-10&quot;&gt;&lt;/div&gt;
          &lt;div&gt;
            &lt;div class=&quot;inline-flex w-full items-stretch justify-center gap-2 px-4 flex-col&quot;&gt;
              &lt;.link
                href=&quot;https://discord.gg/cafERvDD2k&quot;
                class=&quot;btn md:btn-lg group shrink-0 rounded-full [@media(min-width:768px)]:px-10 bg-[oklch(64.74%_0.124_270.62)] border-[oklch(64.74%_0.124_270.62)] hover:bg-[oklch(60%_0.124_270.62)] hover:border-[oklch(60%_0.124_270.62)]&quot;
              &gt;
                &lt;svg
                  class=&quot;h-7 w-auto transition-opacity opacity-100 group-hover:opacity-0&quot;
                  xmlns=&quot;http://www.w3.org/2000/svg&quot;
                  viewBox=&quot;0 0 124 34&quot;
                &gt;
                  &lt;g fill=&quot;white&quot;&gt;
                    &lt;path d=&quot;M26.0015 6.9529C24.0021 6.03845 21.8787 5.37198 19.6623 5C19.3833 5.48048 19.0733 6.13144 18.8563 6.64292C16.4989 6.30193 14.1585 6.30193 11.8336 6.64292C11.6166 6.13144 11.2911 5.48048 11.0276 5C8.79575 5.37198 6.67235 6.03845 4.6869 6.9529C0.672601 12.8736 -0.41235 18.6548 0.130124 24.3585C2.79599 26.2959 5.36889 27.4739 7.89682 28.2489C8.51679 27.4119 9.07477 26.5129 9.55525 25.5675C8.64079 25.2265 7.77283 24.808 6.93587 24.312C7.15286 24.1571 7.36986 23.9866 7.57135 23.8161C12.6241 26.1255 18.0969 26.1255 23.0876 23.8161C23.3046 23.9866 23.5061 24.1571 23.7231 24.312C22.8861 24.808 22.0182 25.2265 21.1037 25.5675C21.5842 26.5129 22.1422 27.4119 22.7621 28.2489C25.2885 27.4739 27.8769 26.2959 30.5288 24.3585C31.1952 17.7559 29.4733 12.0212 26.0015 6.9529ZM10.2527 20.8402C8.73376 20.8402 7.49382 19.4608 7.49382 17.7714C7.49382 16.082 8.70276 14.7025 10.2527 14.7025C11.7871 14.7025 13.0425 16.082 13.0115 17.7714C13.0115 19.4608 11.7871 20.8402 10.2527 20.8402ZM20.4373 20.8402C18.9183 20.8402 17.6768 19.4608 17.6768 17.7714C17.6768 16.082 18.8873 14.7025 20.4373 14.7025C21.9717 14.7025 23.2271 16.082 23.1961 17.7714C23.1961 19.4608 21.9872 20.8402 20.4373 20.8402Z&quot;&gt;
                    &lt;/path&gt;
                    &lt;path d=&quot;M41.2697 9.86615H47.8585C49.4394 9.86615 50.7878 10.1141 51.8883 10.6101C52.9887 11.1061 53.8102 11.7881 54.3527 12.6715C54.8951 13.555 55.1741 14.5624 55.1741 15.7094C55.1741 16.8253 54.8952 17.8328 54.3217 18.7472C53.7482 19.6462 52.8803 20.3746 51.7178 20.9016C50.5554 21.4286 49.1139 21.6921 47.3935 21.6921H41.2697V9.86615ZM47.316 18.6852C48.3854 18.6852 49.2069 18.4217 49.7804 17.8793C50.3539 17.3523 50.6484 16.6083 50.6484 15.6939C50.6484 14.8414 50.3849 14.1594 49.8734 13.648C49.3619 13.1365 48.587 12.873 47.5485 12.873H45.4871V18.6852H47.316Z&quot;&gt;
                    &lt;/path&gt;
                    &lt;path d=&quot;M65.4362 21.6774C64.5217 21.4449 63.7003 21.1039 62.9718 20.6389V17.8335C63.5298 18.2675 64.2582 18.6085 65.1882 18.8875C66.1181 19.1665 67.0171 19.306 67.8851 19.306C68.288 19.306 68.598 19.2595 68.7995 19.151C69.001 19.0425 69.1095 18.9185 69.1095 18.7635C69.1095 18.593 69.0475 18.4535 68.939 18.345C68.8305 18.2365 68.6135 18.1435 68.288 18.0505L66.2576 17.6011C65.0952 17.3376 64.2737 16.9501 63.7777 16.4851C63.2818 16.0201 63.0493 15.3847 63.0493 14.6097C63.0493 13.9587 63.2663 13.3853 63.6847 12.9048C64.1187 12.4243 64.7232 12.0523 65.5137 11.7888C66.3041 11.5254 67.2186 11.3859 68.288 11.3859C69.2335 11.3859 70.1014 11.4789 70.8919 11.6959C71.6823 11.8973 72.3333 12.1608 72.8448 12.4708V15.1212C72.3178 14.8112 71.6979 14.5632 71.0159 14.3772C70.3184 14.1912 69.6055 14.0982 68.877 14.0982C67.823 14.0982 67.2961 14.2842 67.2961 14.6407C67.2961 14.8112 67.3736 14.9352 67.5441 15.0282C67.7146 15.1212 68.009 15.1987 68.443 15.2917L70.1324 15.6017C71.2329 15.7876 72.0543 16.1286 72.5968 16.6091C73.1393 17.0896 73.4028 17.787 73.4028 18.7325C73.4028 19.7555 72.9533 20.5769 72.0543 21.1659C71.1554 21.7704 69.8844 22.0648 68.2415 22.0648C67.2806 22.0338 66.3506 21.9098 65.4362 21.6774Z&quot;&gt;
                    &lt;/path&gt;
                    &lt;path d=&quot;M77.5891 21.3213C76.6281 20.8408 75.8842 20.2054 75.4037 19.3994C74.9077 18.5934 74.6752 17.679 74.6752 16.656C74.6752 15.6486 74.9232 14.7341 75.4347 13.9437C75.9462 13.1377 76.6901 12.5177 77.6666 12.0528C78.643 11.6033 79.821 11.3708 81.1849 11.3708C82.8743 11.3708 84.2693 11.7273 85.3852 12.4402V15.5246C84.9977 15.2611 84.5328 15.0286 84.0058 14.8736C83.4788 14.7031 82.9208 14.6256 82.3319 14.6256C81.2779 14.6256 80.472 14.8116 79.8675 15.1991C79.2785 15.5866 78.984 16.0826 78.984 16.7025C78.984 17.307 79.263 17.803 79.852 18.1905C80.4254 18.5779 81.2624 18.7794 82.3474 18.7794C82.9053 18.7794 83.4633 18.7019 84.0058 18.5314C84.5483 18.3609 85.0287 18.175 85.4162 17.927V20.9183C84.1762 21.6623 82.7348 22.0343 81.1074 22.0343C79.728 22.0343 78.5655 21.7863 77.5891 21.3213Z&quot;&gt;
                    &lt;/path&gt;
                    &lt;path d=&quot;M89.8041 21.3213C88.8276 20.8408 88.0837 20.2054 87.5722 19.3839C87.0607 18.5624 86.7972 17.648 86.7972 16.625C86.7972 15.6176 87.0607 14.7031 87.5722 13.9127C88.0837 13.1222 88.8276 12.5022 89.7886 12.0528C90.7495 11.6033 91.9119 11.3708 93.2464 11.3708C94.5794 11.3708 95.7418 11.5878 96.7028 12.0528C97.6637 12.5022 98.4077 13.1222 98.9192 13.9127C99.4306 14.7031 99.6786 15.6021 99.6786 16.625C99.6786 17.6325 99.4306 18.5624 98.9192 19.3839C98.4077 20.2054 97.6792 20.8563 96.7028 21.3213C95.7263 21.7863 94.5794 22.0343 93.2464 22.0343C91.9274 22.0343 90.7805 21.7863 89.8041 21.3213ZM94.9358 18.3299C95.3388 17.927 95.5558 17.369 95.5558 16.7025C95.5558 16.0206 95.3543 15.4936 94.9358 15.0906C94.5174 14.6876 93.9594 14.4861 93.2619 14.4861C92.5335 14.4861 91.9739 14.6876 91.5555 15.0906C91.1525 15.4936 90.9355 16.0206 90.9355 16.7025C90.9355 17.3845 91.137 17.927 91.5555 18.3299C91.9739 18.7484 92.5335 18.9499 93.2619 18.9499C93.9594 18.9344 94.5329 18.7329 94.9358 18.3299Z&quot;&gt;
                    &lt;/path&gt;
                    &lt;path d=&quot;M110.048 11.9901V15.6325C109.614 15.3535 109.056 15.214 108.374 15.214C107.475 15.214 106.777 15.493 106.297 16.0354C105.816 16.5779 105.568 17.4304 105.568 18.5773V21.6772H101.43V11.8196H105.491V14.966C105.708 13.819 106.08 12.9666 106.576 12.4241C107.072 11.8816 107.723 11.5872 108.513 11.5872C109.102 11.5872 109.614 11.7267 110.048 11.9901Z&quot;&gt;
                    &lt;/path&gt;
                    &lt;path d=&quot;M124 9.52563V21.6925H119.862V19.4761C119.505 20.3131 118.978 20.9486 118.265 21.3825C117.551 21.8165 116.667 22.0335 115.613 22.0335C114.683 22.0335 113.862 21.801 113.164 21.3515C112.467 20.9021 111.925 20.2666 111.553 19.4761C111.181 18.6702 110.995 17.7712 110.995 16.7793C110.979 15.7408 111.181 14.8109 111.599 13.9894C112.002 13.168 112.591 12.5325 113.335 12.0675C114.079 11.6025 114.931 11.37 115.892 11.37C117.861 11.37 119.18 12.2225 119.862 13.9429V9.52563H124ZM119.242 18.2517C119.66 17.8487 119.877 17.3062 119.877 16.6553C119.877 16.0198 119.676 15.5083 119.257 15.1209C118.839 14.7334 118.281 14.5319 117.582 14.5319C116.884 14.5319 116.326 14.7334 115.908 15.1364C115.489 15.5393 115.288 16.0508 115.288 16.7018C115.288 17.3527 115.489 17.8642 115.908 18.2672C116.326 18.6702 116.869 18.8717 117.566 18.8717C118.265 18.8717 118.823 18.6702 119.242 18.2517Z&quot;&gt;
                    &lt;/path&gt;
                    &lt;path d=&quot;M58.9885 12.4091C60.1772 12.4091 61.1429 11.5416 61.1429 10.4717C61.1429 9.40164 60.1772 8.5343 58.9885 8.5343C57.7981 8.5343 56.8341 9.40164 56.8341 10.4717C56.8341 11.5416 57.7981 12.4091 58.9885 12.4091Z&quot;&gt;
                    &lt;/path&gt;
                    &lt;path d=&quot;M61.1429 13.741C59.8254 14.3144 58.1825 14.3299 56.8341 13.741V21.6921H61.1429V13.741Z&quot;&gt;
                    &lt;/path&gt;
                  &lt;/g&gt;
                &lt;/svg&gt;
                &lt;svg
                  xmlns=&quot;http://www.w3.org/2000/svg&quot;
                  width=&quot;24&quot;
                  height=&quot;24&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  class=&quot;inline-block absolute w-6 fill-white transition-all scale-90 group-hover:scale-100 opacity-0 group-hover:opacity-100&quot;
                &gt;
                  &lt;path
                    fill-rule=&quot;evenodd&quot;
                    d=&quot;M19,14 L19,19 C19,20.1045695 18.1045695,21 17,21 L5,21 C3.8954305,21 3,20.1045695 3,19 L3,7 C3,5.8954305 3.8954305,5 5,5 L10,5 L10,7 L5,7 L5,19 L17,19 L17,14 L19,14 Z M18.9971001,6.41421356 L11.7042068,13.7071068 L10.2899933,12.2928932 L17.5828865,5 L12.9971001,5 L12.9971001,3 L20.9971001,3 L20.9971001,11 L18.9971001,11 L18.9971001,6.41421356 Z&quot;
                  &gt;
                  &lt;/path&gt;
                &lt;/svg&gt;
              &lt;/.link&gt;

              &lt;a
                href=&quot;https://t.me/wanderer_mapper&quot;
                target=&quot;_blank&quot;
                rel=&quot;noopener noreferrer&quot;
                aria-label=&quot;Telegram&quot;
                class=&quot;btn md:btn-lg group shrink-0 rounded-full [@media(min-width:768px)]:px-10 bg-[#54a9eb] border-[#54a9eb] hover:bg-[#54a9eb] hover:border-[#54a9eb] text-white&quot;
              &gt;
                &lt;svg
                  width=&quot;44&quot;
                  height=&quot;44&quot;
                  xmlns=&quot;http://www.w3.org/2000/svg&quot;
                  xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;
                  viewBox=&quot;0 0 240.1 240.1&quot;
                  class=&quot;text-md transition-opacity opacity-100 group-hover:opacity-0&quot;
                &gt;
                  &lt;linearGradient
                    id=&quot;Oval_1_&quot;
                    gradientUnits=&quot;userSpaceOnUse&quot;
                    x1=&quot;-838.041&quot;
                    y1=&quot;660.581&quot;
                    x2=&quot;-838.041&quot;
                    y2=&quot;660.3427&quot;
                    gradientTransform=&quot;matrix(1000 0 0 -1000 838161 660581)&quot;
                  &gt;
                    &lt;stop offset=&quot;0&quot; style=&quot;stop-color:#2AABEE&quot; /&gt;
                    &lt;stop offset=&quot;1&quot; style=&quot;stop-color:#229ED9&quot; /&gt;
                  &lt;/linearGradient&gt;
                  &lt;path
                    fill-rule=&quot;evenodd&quot;
                    clip-rule=&quot;evenodd&quot;
                    fill=&quot;#FFFFFF&quot;
                    d=&quot;M54.3,118.8c35-15.2,58.3-25.3,70-30.2 c33.3-13.9,40.3-16.3,44.8-16.4c1,0,3.2,0.2,4.7,1.4c1.2,1,1.5,2.3,1.7,3.3s0.4,3.1,0.2,4.7c-1.8,19-9.6,65.1-13.6,86.3 c-1.7,9-5,12-8.2,12.3c-7,0.6-12.3-4.6-19-9c-10.6-6.9-16.5-11.2-26.8-18c-11.9-7.8-4.2-12.1,2.6-19.1c1.8-1.8,32.5-29.8,33.1-32.3 c0.1-0.3,0.1-1.5-0.6-2.1c-0.7-0.6-1.7-0.4-2.5-0.2c-1.1,0.2-17.9,11.4-50.6,33.5c-4.8,3.3-9.1,4.9-13,4.8 c-4.3-0.1-12.5-2.4-18.7-4.4c-7.5-2.4-13.5-3.7-13-7.9C45.7,123.3,48.7,121.1,54.3,118.8z&quot;
                  /&gt;
                &lt;/svg&gt;
                &lt;span class=&quot;text-lg font-bold transition-opacity opacity-100 group-hover:opacity-0 -ml-2&quot;&gt;
                  Telegram
                &lt;/span&gt;
                &lt;svg
                  xmlns=&quot;http://www.w3.org/2000/svg&quot;
                  width=&quot;24&quot;
                  height=&quot;24&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  class=&quot;inline-block absolute w-6 fill-white transition-all scale-90 group-hover:scale-100 opacity-0 group-hover:opacity-100&quot;
                &gt;
                  &lt;path
                    fill-rule=&quot;evenodd&quot;
                    d=&quot;M19,14 L19,19 C19,20.1045695 18.1045695,21 17,21 L5,21 C3.8954305,21 3,20.1045695 3,19 L3,7 C3,5.8954305 3.8954305,5 5,5 L10,5 L10,7 L5,7 L5,19 L17,19 L17,14 L19,14 Z M18.9971001,6.41421356 L11.7042068,13.7071068 L10.2899933,12.2928932 L17.5828865,5 L12.9971001,5 L12.9971001,3 L20.9971001,3 L20.9971001,11 L18.9971001,11 L18.9971001,6.41421356 Z&quot;
                  &gt;
                  &lt;/path&gt;
                &lt;/svg&gt;
              &lt;/a&gt;
              &lt;a
                href=&quot;https://github.com/wanderer-industries/wanderer&quot;
                target=&quot;_blank&quot;
                rel=&quot;noopener noreferrer&quot;
                aria-label=&quot;Github&quot;
                class=&quot;btn md:btn-lg group shrink-0 rounded-full [@media(min-width:768px)]:px-10 bg-[#fff] border-[#fff] hover:bg-[#fff] hover:border-[#fff] text-black&quot;
              &gt;
                &lt;svg
                  viewBox=&quot;0 0 24 24&quot;
                  width=&quot;32&quot;
                  height=&quot;32&quot;
                  aria-hidden=&quot;true&quot;
                  class=&quot;fill-slate-900 transition-opacity opacity-100 group-hover:opacity-0&quot;
                &gt;
                  &lt;path
                    fill-rule=&quot;evenodd&quot;
                    clip-rule=&quot;evenodd&quot;
                    d=&quot;M12 2C6.477 2 2 6.463 2 11.97c0 4.404 2.865 8.14 6.839 9.458.5.092.682-.216.682-.48 0-.236-.008-.864-.013-1.695-2.782.602-3.369-1.337-3.369-1.337-.454-1.151-1.11-1.458-1.11-1.458-.908-.618.069-.606.069-.606 1.003.07 1.531 1.027 1.531 1.027.892 1.524 2.341 1.084 2.91.828.092-.643.35-1.083.636-1.332-2.22-.251-4.555-1.107-4.555-4.927 0-1.088.39-1.979 1.029-2.675-.103-.252-.446-1.266.098-2.638 0 0 .84-.268 2.75 1.022A9.607 9.607 0 0 1 12 6.82c.85.004 1.705.114 2.504.336 1.909-1.29 2.747-1.022 2.747-1.022.546 1.372.202 2.386.1 2.638.64.696 1.028 1.587 1.028 2.675 0 3.83-2.339 4.673-4.566 4.92.359.307.678.915.678 1.846 0 1.332-.012 2.407-.012 2.734 0 .267.18.577.688.48 3.97-1.32 6.833-5.054 6.833-9.458C22 6.463 17.522 2 12 2Z&quot;
                  &gt;
                  &lt;/path&gt;
                &lt;/svg&gt;
                &lt;span class=&quot;text-lg font-bold transition-opacity opacity-100 group-hover:opacity-0 ml-2&quot;&gt;
                  Github
                &lt;/span&gt;
                &lt;svg
                  xmlns=&quot;http://www.w3.org/2000/svg&quot;
                  width=&quot;24&quot;
                  height=&quot;24&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  class=&quot;inline-block absolute w-6 fill-black transition-all scale-90 group-hover:scale-100 opacity-0 group-hover:opacity-100&quot;
                &gt;
                  &lt;path
                    fill-rule=&quot;evenodd&quot;
                    d=&quot;M19,14 L19,19 C19,20.1045695 18.1045695,21 17,21 L5,21 C3.8954305,21 3,20.1045695 3,19 L3,7 C3,5.8954305 3.8954305,5 5,5 L10,5 L10,7 L5,7 L5,19 L17,19 L17,14 L19,14 Z M18.9971001,6.41421356 L11.7042068,13.7071068 L10.2899933,12.2928932 L17.5828865,5 L12.9971001,5 L12.9971001,3 L20.9971001,3 L20.9971001,11 L18.9971001,11 L18.9971001,6.41421356 Z&quot;
                  &gt;
                  &lt;/path&gt;
                &lt;/svg&gt;
              &lt;/a&gt;

              &lt;a
                href=&quot;https://www.patreon.com/WandererLtd&quot;
                target=&quot;_blank&quot;
                rel=&quot;noopener noreferrer&quot;
                aria-label=&quot;Patreon&quot;
                class=&quot;btn md:btn-lg group shrink-0 rounded-full [@media(min-width:768px)]:px-10 bg-[#fff] border-[#fff] hover:bg-[#fff] hover:border-[#fff] text-black&quot;
              &gt;
                &lt;svg
                  xmlns=&quot;http://www.w3.org/2000/svg&quot;
                  viewBox=&quot;0 0 38 42&quot;
                  width=&quot;24&quot;
                  height=&quot;24&quot;
                  class=&quot;text-md transition-opacity opacity-100 group-hover:opacity-0 text-black&quot;
                &gt;
                  &lt;path
                    fill=&quot;currentColor&quot;
                    d=&quot;M36.975 12.392c0 .312.021.627-.004.937-.03.361-.082.722-.149 1.08a22.535 22.535 0 0 1-.331 1.512 8.59 8.59 0 0 1-.359 1.084c-.313.767-.66 1.518-1.117 2.21-.282.427-.57.849-.864 1.266a4.12 4.12 0 0 1-.37.431c-.225.238-.442.483-.686.695a13.5 13.5 0 0 1-1.123.905c-.356.25-.756.431-1.12.674-.404.268-.866.384-1.296.587-.384.18-.795.24-1.186.38-.498.18-1.021.222-1.531.331-.544.117-1.097.203-1.643.315-.449.09-.894.198-1.34.298-.254.056-.51.098-.756.173-.304.093-.6.214-.896.324-.201.072-.412.126-.604.219-.28.14-.544.315-.823.464-.457.242-.838.585-1.184.96-.292.32-.546.681-.8 1.036-.418.587-.706 1.244-.964 1.916-.254.657-.487 1.322-.725 1.986-.221.625-.43 1.252-.655 1.875a63.989 63.989 0 0 1-.618 1.615 13.447 13.447 0 0 1-1.12 2.215c-.331.531-.685 1.049-1.142 1.478-.366.343-.72.704-1.17.944-.446.24-.906.448-1.4.557a6.635 6.635 0 0 1-1.807.129c-.229-.012-.455-.075-.684-.117-.137-.026-.276-.047-.409-.089-.112-.035-.215-.097-.322-.151-.302-.147-.624-.264-.9-.448a8.802 8.802 0 0 1-.96-.776c-.554-.492-.97-1.103-1.342-1.74a13.04 13.04 0 0 1-.681-1.319c-.192-.436-.336-.893-.492-1.345a24.916 24.916 0 0 1-.34-1.063c-.092-.317-.165-.641-.243-.963-.073-.298-.15-.594-.212-.895-.112-.536-.215-1.073-.32-1.609a35.827 35.827 0 0 1-.133-.68c-.06-.34-.114-.681-.171-1.022-.044-.254-.092-.506-.13-.76-.044-.28-.08-.56-.124-.839-.036-.242-.078-.483-.112-.725-.032-.226-.06-.452-.089-.678a70.008 70.008 0 0 1-.094-.73c-.03-.236-.055-.471-.082-.707l-.096-.818c-.011-.098-.023-.193-.03-.291-.034-.401-.068-.804-.1-1.208a20.67 20.67 0 0 1-.05-.75c-.021-.39-.042-.777-.05-1.166A94.453 94.453 0 0 1 1 18.18c0-.378.002-.755.027-1.13.026-.392.08-.784.122-1.176.034-.312.064-.622.105-.934.023-.175.064-.348.1-.52.092-.432.176-.863.281-1.292.076-.31.181-.61.266-.916.157-.571.393-1.11.624-1.653.105-.25.235-.49.367-.725.186-.329.366-.66.576-.97.259-.378.533-.744.823-1.098a12.9 12.9 0 0 1 .873-.965c.24-.24.512-.448.77-.665.254-.212.501-.433.77-.624.412-.296.835-.576 1.263-.849.249-.158.514-.294.774-.434.405-.219.81-.44 1.22-.648.26-.13.527-.244.794-.354.683-.277 1.364-.557 2.055-.816.46-.17.932-.303 1.399-.452.24-.077.475-.161.717-.229.2-.056.402-.086.604-.133.22-.05.434-.119.656-.16.299-.059.603-.1.907-.147.34-.052.679-.105 1.02-.152.139-.019.283-.02.425-.03.47-.026.944-.054 1.414-.077.188-.01.382-.051.565-.019.443.08.889.017 1.332.05.428.03.853.076 1.278.127.306.038.608.103.914.15.268.04.535.065.802.107.215.035.43.081.645.128.46.103.919.196 1.374.317.404.11.797.275 1.204.37.469.113.899.332 1.351.479.462.149.86.424 1.3.608.515.217.96.546 1.418.858.347.238.685.492 1 .77.467.41.92.836 1.356 1.28.258.26.478.564.713.85.38.464.658.993.928 1.523.215.424.393.874.537 1.329.12.373.156.774.245 1.156.098.42.096.844.073 1.27l-.012.008z&quot;
                  &gt;
                  &lt;/path&gt;
                &lt;/svg&gt;
                &lt;span class=&quot;text-md transition-opacity opacity-100 group-hover:opacity-0&quot;&gt;
                  &lt;svg
                    version=&quot;1.1&quot;
                    id=&quot;Layer_1&quot;
                    xmlns=&quot;http://www.w3.org/2000/svg&quot;
                    xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;
                    width=&quot;100&quot;
                    height=&quot;34&quot;
                    viewBox=&quot;0 0 1826.3 619.9&quot;
                    style=&quot;enable-background:new 0 0 1826.3 619.9;&quot;
                    xml:space=&quot;preserve&quot;
                  &gt;
                    &lt;path d=&quot;M202.5,226c0-10,7.4-16.8,19-16.8h55.5c50.3,0,84.5,27.7,84.5,68.4c0,40-33.9,69.7-84.5,69.7h-7.7
	c-19.4,0-29.4,10-29.4,26.1V419c0,12.9-7.4,21-18.7,21c-11.3,0-18.7-8.1-18.7-21V226z M239.9,283.8c0,20.3,10.3,30,30,30h4.8
	c27.7,0,48.1-11.3,48.1-36.1s-20.3-36.1-48.1-36.1H270c-19.7,0-30,9.7-30,30V283.8z M361.6,422.2c0,10.6,7.4,17.7,18.7,17.7
	c7.4,0,14.2-4.8,18.1-14.8l6.8-18.1c5.5-14.5,15.2-21.3,25.8-21.3h61.3c10.6,0,20.3,6.8,25.8,21.3l6.8,18.1
	c3.9,10,10.6,14.8,18.1,14.8c11.3,0,18.7-7.1,18.7-17.7c0-2.9-0.6-6.5-1.9-10l-73.2-190.4c-4.5-11.6-14.8-17.4-24.8-17.4
	s-20.3,5.8-24.8,17.4l-73.2,190.4C362.2,415.8,361.6,419.3,361.6,422.2z M432.9,335.7c0-3.5,1-6.8,2.6-11.6l13.9-38.4
	c2.6-7.4,7.1-11,12.3-11s9.7,3.5,12.3,11l13.9,38.4c1.6,4.8,2.6,8.1,2.6,11.6c0,9.7-5.5,16.5-20,16.5h-17.4
	C438.4,352.2,432.9,345.4,432.9,335.7z M549.4,226.7c0-10.3,7.4-17.4,19.4-17.4h148.4c11.9,0,19.4,7.1,19.4,17.4
	s-7.4,17.4-19.4,17.4h-24.8c-19.7,0-30.3,10-30.3,32.9v141.7c0,13.2-7.4,21.3-19,21.3c-11.6,0-19-8.1-19-21.3V277
	c0-22.9-10.6-32.9-30.3-32.9h-24.8C556.8,244.1,549.4,237,549.4,226.7z M771.4,419c0,12.9,7.4,21,18.7,21s18.7-8.1,18.7-21v-51.3
	c0-14.5,8.4-20.7,18.7-20.7h2.6c6.8,0,13.6,4.2,17.7,10.3l49,72c4.5,6.8,10.3,10.6,17.7,10.6c9.7,0,17.4-8.1,17.4-17.7
	c0-3.9-1.3-8.1-4.2-12.3l-32.6-45.8c-3.9-5.5-5.5-10-5.5-13.9c0-8.1,7.1-13.9,15.5-20c15.2-11.3,31.6-26.1,31.6-54.5
	c0-39.7-31-66.5-82-66.5h-64.9c-11.6,0-18.7,6.8-18.7,16.8V419z M808.8,280.9v-9.7c0-21,11-29.7,27.7-29.7h16.1
	c27.7,0,45.5,10.3,45.5,34.2s-18.7,34.8-46.5,34.8h-15.2C819.8,310.6,808.8,301.9,808.8,280.9z M984.7,418.3V226
	c0-10,7.1-16.8,18.7-16.8h122c11.6,0,18.7,6.8,18.7,16.8s-7.1,16.8-18.7,16.8h-77.1c-15.2,0-26.1,9-26.1,26.1v7.1
	c0,17.1,11,26.1,26.1,26.1h59.7c11.6,0,18.7,6.8,18.7,16.8s-7.1,16.8-18.7,16.8h-57.4c-15.2,0-28.4,9.4-28.4,28.4v9
	c0,19,13.2,28.4,28.4,28.4h74.9c11.6,0,18.7,6.8,18.7,16.8s-7.1,16.8-18.7,16.8h-122C991.8,435.1,984.7,428.3,984.7,418.3z
	 M1166.3,322.2c0-69.7,52.3-117.8,113.6-117.8c61.3,0,113.6,48.1,113.6,117.8S1341.2,440,1279.9,440
	C1218.6,440,1166.3,391.9,1166.3,322.2z M1208.9,322.2c0,49,29,80.3,71,80.3c41.9,0,71-31.3,71-80.3c0-49.4-29-80.3-71-80.3
	C1238,241.8,1208.9,272.8,1208.9,322.2z M1438.3,419c0,12.9,7.4,21,18.7,21s18.7-8.1,18.7-21v-98.7c0-11.9,7.1-17.7,14.5-17.7
	c5.8,0,10.6,3.2,14.2,9l61.9,103.6c8.4,14.2,16.1,24.8,31.9,24.8c15.2,0,26.1-11,26.1-28.7V225.4c0-12.9-7.4-21-18.7-21
	c-11.3,0-18.7,8.1-18.7,21v98.7c0,11.9-7.1,17.7-14.5,17.7c-5.8,0-10.7-3.2-14.2-9l-61.9-103.6c-8.4-14.2-16.1-24.8-31.9-24.8
	c-15.2,0-26.1,11-26.1,28.7V419z&quot; /&gt;
                  &lt;/svg&gt;
                &lt;/span&gt;
                &lt;svg
                  xmlns=&quot;http://www.w3.org/2000/svg&quot;
                  width=&quot;24&quot;
                  height=&quot;24&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  class=&quot;inline-block absolute w-6 fill-black transition-all scale-90 group-hover:scale-100 opacity-0 group-hover:opacity-100&quot;
                &gt;
                  &lt;path
                    fill-rule=&quot;evenodd&quot;
                    d=&quot;M19,14 L19,19 C19,20.1045695 18.1045695,21 17,21 L5,21 C3.8954305,21 3,20.1045695 3,19 L3,7 C3,5.8954305 3.8954305,5 5,5 L10,5 L10,7 L5,7 L5,19 L17,19 L17,14 L19,14 Z M18.9971001,6.41421356 L11.7042068,13.7071068 L10.2899933,12.2928932 L17.5828865,5 L12.9971001,5 L12.9971001,3 L20.9971001,3 L20.9971001,11 L18.9971001,11 L18.9971001,6.41421356 Z&quot;
                  &gt;
                  &lt;/path&gt;
                &lt;/svg&gt;
              &lt;/a&gt;
              &lt;a
                href=&quot;https://www.youtube.com/@wanderer_ltd&quot;
                rel=&quot;noopener noreferrer&quot;
                aria-label=&quot;YouTube&quot;
                class=&quot;btn md:btn-lg group shrink-0 rounded-full [@media(min-width:768px)]:px-10 bg-[#ff0033] border-[#ff0033] hover:bg-[#ff0033] hover:border-[#ff0033] text-white&quot;
              &gt;
                &lt;svg
                  width=&quot;48px&quot;
                  height=&quot;48px&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  fill=&quot;none&quot;
                  xmlns=&quot;http://www.w3.org/2000/svg&quot;
                  class=&quot;transition-opacity opacity-100 group-hover:opacity-0&quot;
                &gt;
                  &lt;path
                    d=&quot;M20.5245 6.00694C20.3025 5.81544 20.0333 5.70603 19.836 5.63863C19.6156 5.56337 19.3637 5.50148 19.0989 5.44892C18.5677 5.34348 17.9037 5.26005 17.1675 5.19491C15.6904 5.06419 13.8392 5 12 5C10.1608 5 8.30956 5.06419 6.83246 5.1949C6.09632 5.26005 5.43231 5.34348 4.9011 5.44891C4.63628 5.50147 4.38443 5.56337 4.16403 5.63863C3.96667 5.70603 3.69746 5.81544 3.47552 6.00694C3.26514 6.18846 3.14612 6.41237 3.07941 6.55976C3.00507 6.724 2.94831 6.90201 2.90314 7.07448C2.81255 7.42043 2.74448 7.83867 2.69272 8.28448C2.58852 9.18195 2.53846 10.299 2.53846 11.409C2.53846 12.5198 2.58859 13.6529 2.69218 14.5835C2.74378 15.047 2.81086 15.4809 2.89786 15.8453C2.97306 16.1603 3.09841 16.5895 3.35221 16.9023C3.58757 17.1925 3.92217 17.324 4.08755 17.3836C4.30223 17.461 4.55045 17.5218 4.80667 17.572C5.32337 17.6733 5.98609 17.7527 6.72664 17.8146C8.2145 17.9389 10.1134 18 12 18C13.8865 18 15.7855 17.9389 17.2733 17.8146C18.0139 17.7527 18.6766 17.6733 19.1933 17.572C19.4495 17.5218 19.6978 17.461 19.9124 17.3836C20.0778 17.324 20.4124 17.1925 20.6478 16.9023C20.9016 16.5895 21.0269 16.1603 21.1021 15.8453C21.1891 15.4809 21.2562 15.047 21.3078 14.5835C21.4114 13.6529 21.4615 12.5198 21.4615 11.409C21.4615 10.299 21.4115 9.18195 21.3073 8.28448C21.2555 7.83868 21.1874 7.42043 21.0969 7.07448C21.0517 6.90201 20.9949 6.72401 20.9206 6.55976C20.8539 6.41236 20.7349 6.18846 20.5245 6.00694Z&quot;
                    stroke=&quot;currentColor&quot;
                    stroke-width=&quot;2&quot;
                    stroke-linecap=&quot;round&quot;
                    stroke-linejoin=&quot;round&quot;
                  /&gt;
                  &lt;path
                    d=&quot;M14.5385 11.5L10.0962 14.3578L10.0962 8.64207L14.5385 11.5Z&quot;
                    stroke=&quot;currentColor&quot;
                    stroke-width=&quot;2&quot;
                    stroke-linecap=&quot;round&quot;
                    stroke-linejoin=&quot;round&quot;
                  /&gt;
                &lt;/svg&gt;
                &lt;span class=&quot;text-lg font-bold transition-opacity opacity-100 group-hover:opacity-0 ml-2&quot;&gt;
                YouTube
                &lt;/span&gt;
                &lt;svg
                  xmlns=&quot;http://www.w3.org/2000/svg&quot;
                  width=&quot;24&quot;
                  height=&quot;24&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  class=&quot;inline-block absolute w-6 fill-white transition-all scale-90 group-hover:scale-100 opacity-0 group-hover:opacity-100&quot;
                &gt;
                  &lt;path
                    fill-rule=&quot;evenodd&quot;
                    d=&quot;M19,14 L19,19 C19,20.1045695 18.1045695,21 17,21 L5,21 C3.8954305,21 3,20.1045695 3,19 L3,7 C3,5.8954305 3.8954305,5 5,5 L10,5 L10,7 L5,7 L5,19 L17,19 L17,14 L19,14 Z M18.9971001,6.41421356 L11.7042068,13.7071068 L10.2899933,12.2928932 L17.5828865,5 L12.9971001,5 L12.9971001,3 L20.9971001,3 L20.9971001,11 L18.9971001,11 L18.9971001,6.41421356 Z&quot;
                  &gt;
                  &lt;/path&gt;
                &lt;/svg&gt;
              &lt;/a&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</file><file path="lib/wanderer_app_web/controllers/blog_html/index.html.heex">&lt;section class=&quot;prose prose-lg max-w-full w-full leading-normal tracking-normal text-indigo-400 bg-cover bg-fixed flex items-center justify-center&quot;&gt;
  &lt;canvas id=&quot;bg-canvas&quot;&gt;&lt;/canvas&gt;
  &lt;div class=&quot;h-full w-full flex flex-col items-center&quot;&gt;
    &lt;!--Main--&gt;
    &lt;div class=&quot;artboard artboard-horizontal phone-3 pt-10 !h-40&quot;&gt;
      &lt;div class=&quot;container pt-5 mx-auto flex flex-wrap flex-row justify-center items-center gap-8&quot;&gt;
        &lt;!--Left Col--&gt;
        &lt;div class=&quot;flex flex-col justify-center items-center overflow-y-hidden&quot;&gt;
          &lt;h1 class=&quot;ccp-font my-4 text-2xl text-white font-bold leading-tight text-center md:text-left &quot;&gt;
            THE #1 EVE MAPPER TOOL
          &lt;/h1&gt;
        &lt;/div&gt;
        &lt;!--Right Col--&gt;
        &lt;div :if={@invite_token_valid} class=&quot;overflow-hidden&quot;&gt;
          &lt;div class=&quot;!z-100 relative group alert items-center fade-in-scale text-white w-[224px] h-[44px] rounded p-px overflow-hidden&quot;&gt;
            &lt;div class=&quot;group animate-rotate absolute inset-0 h-full w-full rounded-full bg-[conic-gradient(#0ea5e9_20deg,transparent_120deg)] group-hover:bg-[#0ea5e9]&quot; /&gt;
            &lt;div class=&quot;!bg-black  rounded w-[220px] h-[40px] flex items-center justify-center relative z-20&quot;&gt;
              &lt;.link navigate={~p&quot;/auth/eve?invite=#{@invite_token}&quot;} class=&quot;opacity-100&quot;&gt;
                &lt;img
                  src=&quot;https://web.ccpgamescdn.com/eveonlineassets/developers/eve-sso-login-black-large.png&quot;
                  class=&quot;w-[220px] h-[40px]&quot;
                /&gt;
              &lt;/.link&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;carousel carousel-center bg-neutral rounded-box max-w-[80%] space-x-4 p-4&quot;&gt;
      &lt;%= for post &lt;- @posts do %&gt;
        &lt;.link class=&quot;group carousel-item relative&quot; navigate={~p&quot;/news/#{post.id}&quot;}&gt;
          &lt;div class=&quot;artboard-horizontal phone-1 relative hover:text-white mt-10&quot;&gt;
            &lt;img
              class=&quot;rounded-lg shadow-lg block !w-[400px] !h-[200px] opacity-75&quot;
              src={post.cover_image_uri}
            /&gt;
            &lt;div class=&quot;absolute top-0 left-0 w-full h-full bg-gradient-to-b from-transparent to-black opacity-75 group-hover:opacity-25 transition-opacity duration-300&quot;&gt;
            &lt;/div&gt;
            &lt;h3 class=&quot;absolute bottom-4 left-14 font-bold break-normal pt-6 pb-2 ccp-font text-white&quot;&gt;
              &lt;%= post.title %&gt;
            &lt;/h3&gt;
          &lt;/div&gt;
        &lt;/.link&gt;
      &lt;% end %&gt;
    &lt;/div&gt;
    &lt;%!-- &lt;div class=&quot;carousel carousel-center !bg-neutral rounded-box max-w-4xl space-x-6 p-4&quot;&gt;

    &lt;/div&gt; --%&gt;
  &lt;/div&gt;
&lt;/section&gt;</file><file path="lib/wanderer_app_web/controllers/blog_html/license.html.heex">&lt;article class=&quot;prose prose-lg ccp-font w-full max-w-3xl mx-auto&quot;&gt;
  &lt;div class=&quot;w-full px-4 md:px-6 text-xl leading-normal ccp-font&quot;&gt;
    &lt;h1 class=&quot;font-bold break-normal pt-10 ccp-font text-white&quot;&gt;
      License
    &lt;/h1&gt;
    &lt;h3 class=&quot;txt-color txt-color-grayLight&quot;&gt;
      &lt;strong class=&quot;flex items-center gap-0&quot;&gt;
        &lt;.icon name=&quot;hero-at-symbol&quot; class=&quot;h-8 w-8&quot; /&gt; CCP Copyright Notice
      &lt;/strong&gt;
    &lt;/h3&gt;
    &lt;p&gt;
      EVE Online and the EVE logo are the registered trademarks of CCP hf. All rights are reserved worldwide.
      All other trademarks are the property of their respective owners.
      EVE Online, the EVE logo, EVE and all associated logos and designs are the intellectual property of CCP hf.
      All artwork, screenshots, characters, vehicles, storylines, world facts or other recognizable features of the
      intellectual property relating to these trademarks are likewise the intellectual property of CCP hf.
      CCP is in no way responsible for the content on or functioning of this website, nor can it be liable for
      any damage arising from the use of this website.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/article&gt;</file><file path="lib/wanderer_app_web/controllers/blog_html/list.html.heex">&lt;section class=&quot;max-w-full w-full text-indigo-400 bg-cover bg-fixed&quot;&gt;
  &lt;div class=&quot;w-full text-xl leading-normal ccp-font text-center&quot;&gt;
    &lt;.link navigate={~p&quot;/news&quot;}&gt;
      &lt;h1 class=&quot;font-bold break-normal ccp-font text-white&quot;&gt;
        News
      &lt;/h1&gt;
    &lt;/.link&gt;
  &lt;/div&gt;

  &lt;div class=&quot;flex flex-col-reverse justify-between gap-6 xl:flex-row text-white&quot; dir=&quot;ltr&quot;&gt;
    &lt;div class=&quot;w-full max-w-none flex-grow pt-10&quot;&gt;
      &lt;div class=&quot;flex min-h-[50vh] w-full flex-col justify-center gap-6 p-4 lg:flex-row&quot;&gt;
        &lt;div class=&quot;max-w-2xl max-lg:mx-auto max-lg:w-full&quot;&gt;
          &lt;div class=&quot;sticky top-32 mx-auto sm:max-w-none&quot;&gt;
            &lt;ul class=&quot;menu menu-horizontal lg:menu-vertical lg:w-56&quot;&gt;
              &lt;li class=&quot;menu-title&quot;&gt;Tags&lt;/li&gt;
              &lt;%= for tag &lt;- @tags do %&gt;
                &lt;li&gt;
                  &lt;.link
                    navigate={~p&quot;/news?tag=#{tag}&quot;}
                    class={if @selected_tag == tag, do: &quot;active&quot;, else: &quot;false&quot;}
                  &gt;
                    &lt;%= tag %&gt;
                  &lt;/.link&gt;
                &lt;/li&gt;
              &lt;% end %&gt;
            &lt;/ul&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;mx-auto w-full max-w-2xl&quot;&gt;
          &lt;!----&gt;&lt;!----&gt;&lt;!----&gt; &lt;!----&gt;
          &lt;div class=&quot;grid justify-items-stretch gap-6&quot;&gt;
            &lt;%= for post &lt;- @posts do %&gt;
              &lt;.link
                navigate={~p&quot;/news/#{post.id}&quot;}
                class=&quot;card sm:card-side hover:bg-base-200 transition-colors sm:max-w-none hover:text-white&quot;
              &gt;
                &lt;figure class=&quot;mx-auto w-full object-cover p-6 max-sm:pb-0 sm:max-w-[12rem] sm:pe-0&quot;&gt;
                  &lt;img
                    loading=&quot;lazy&quot;
                    class=&quot;border-base-content bg-base-300 rounded-btn border border-opacity-5&quot;
                    alt={post.title}
                    src={post.cover_image_uri}
                  /&gt;
                &lt;/figure&gt;
                &lt;div class=&quot;card-body hover:text-white&quot;&gt;
                  &lt;h2 class=&quot;card-title&quot;&gt;&lt;%= post.title %&gt;&lt;/h2&gt;
                  &lt;p class=&quot;text-xs opacity-60&quot;&gt;
                    &lt;%= post.description %&gt;
                  &lt;/p&gt;
                  &lt;div class=&quot;card-actions justify-end&quot;&gt;
                    &lt;ul class=&quot;flex flex-wrap items-center p-0 m-0&quot;&gt;
                      &lt;li
                        :for={tag &lt;- post.tags}
                        class=&quot;inline-flex rounded-[35px] bg-primary px-1 text-white&quot;
                      &gt;
                        &lt;div class=&quot;badge badge-outline text-primary rounded-none border-none text-sm&quot;&gt;
                          #&lt;%= tag %&gt;
                        &lt;/div&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/.link&gt;
            &lt;% end %&gt;
          &lt;/div&gt;
          &lt;!----&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;flex justify-center xl:hidden&quot;&gt;
        &lt;!----&gt;&lt;!----&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/section&gt;</file><file path="lib/wanderer_app_web/controllers/blog_html/show.html.heex">&lt;article class=&quot;prose prose-lg ccp-font w-full max-w-3xl mx-auto&quot;&gt;
  &lt;!--Container--&gt;
  &lt;div class=&quot;w-full px-4 md:px-6 text-xl leading-normal ccp-font&quot;&gt;
    &lt;!--Title--&gt;
    &lt;h1 class=&quot;font-bold break-normal pt-10 ccp-font text-white&quot;&gt;
      &lt;%= @post.title %&gt;
    &lt;/h1&gt;

    &lt;div class=&quot;text-md md:text-base font-normal mt-0 ccp-font flex items-center gap-4&quot;&gt;
      &lt;div class=&quot;flex justify-start content-center gap-2&quot;&gt;
        &lt;%= @post.date %&gt; - BY &lt;span class=&quot;uppercase&quot;&gt;&lt;%= @post.author %&gt;&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class=&quot;min-h-[10px] w-px self-stretch border-t-0 bg-gradient-to-tr from-transparent to-transparent opacity-25 via-neutral-200 block&quot;&gt;
      &lt;/div&gt;
      &lt;div class=&quot;flex justify-start content-center&quot;&gt;
        &lt;a
          class=&quot;no-underline hover:text-pink-500 hover:text-underline h-8 md:h-auto p-2 text-center h-auto transform hover:scale-125 duration-300 ease-in-out&quot;
          href={&quot;https://twitter.com/intent/tweet?url=#{current_url(@conn)}&quot;}
          target=&quot;_blank&quot;
        &gt;
          &lt;svg class=&quot;fill-current h-6&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 32 32&quot;&gt;
            &lt;path d=&quot;M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z&quot;&gt;
            &lt;/path&gt;
          &lt;/svg&gt;
        &lt;/a&gt;
        &lt;a
          class=&quot;inline-block no-underline hover:text-pink-500 hover:text-underline text-center h-auto p-2 transform hover:scale-125 duration-300 ease-in-out&quot;
          href={&quot;https://www.facebook.com/sharer/sharer.php?u=#{current_url(@conn)}&quot;}
          target=&quot;_blank&quot;
        &gt;
          &lt;svg class=&quot;fill-current h-6&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 32 32&quot;&gt;
            &lt;path d=&quot;M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z&quot;&gt;
            &lt;/path&gt;
          &lt;/svg&gt;
        &lt;/a&gt;
        &lt;a
          class=&quot;inline-block no-underline hover:text-pink-500 hover:text-underline text-center h-auto p-2 transform hover:scale-125 duration-300 ease-in-out&quot;
          href={&quot;https://www.reddit.com/submit?url=#{current_url(@conn)}&quot;}
          target=&quot;_blank&quot;
        &gt;
          &lt;svg
            class=&quot;fill-current h-6&quot;
            aria-hidden=&quot;true&quot;
            xmlns=&quot;http://www.w3.org/2000/svg&quot;
            width=&quot;24&quot;
            height=&quot;24&quot;
            fill=&quot;none&quot;
            viewBox=&quot;0 0 24 24&quot;
          &gt;
            &lt;path
              fill=&quot;currentColor&quot;
              d=&quot;M12.008 16.521a3.84 3.84 0 0 0 2.47-.77v.04a.281.281 0 0 0 .005-.396.281.281 0 0 0-.395-.005 3.291 3.291 0 0 1-2.09.61 3.266 3.266 0 0 1-2.081-.63.27.27 0 0 0-.38.381 3.84 3.84 0 0 0 2.47.77Z&quot;
            /&gt;
            &lt;path
              fill=&quot;currentColor&quot;
              fill-rule=&quot;evenodd&quot;
              d=&quot;M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Zm-4.845-1.407A1.463 1.463 0 0 1 18.67 12a1.46 1.46 0 0 1-.808 1.33c.01.146.01.293 0 .44 0 2.242-2.61 4.061-5.829 4.061s-5.83-1.821-5.83-4.061a3.25 3.25 0 0 1 0-.44 1.458 1.458 0 0 1-.457-2.327 1.458 1.458 0 0 1 2.063-.064 7.163 7.163 0 0 1 3.9-1.23l.738-3.47v-.006a.31.31 0 0 1 .37-.236l2.452.49a1 1 0 1 1-.132.611l-2.14-.45-.649 3.12a7.11 7.11 0 0 1 3.85 1.23c.259-.246.6-.393.957-.405Z&quot;
              clip-rule=&quot;evenodd&quot;
            /&gt;
            &lt;path
              fill=&quot;currentColor&quot;
              d=&quot;M15.305 13a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm-4.625 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z&quot;
            /&gt;
          &lt;/svg&gt;
        &lt;/a&gt;
      &lt;/div&gt;
      &lt;div class=&quot;min-h-[10px] w-px self-stretch border-t-0 bg-gradient-to-tr from-transparent to-transparent opacity-25 via-neutral-200 block&quot;&gt;
      &lt;/div&gt;
      &lt;div class=&quot;flex justify-start content-center&quot;&gt;
        &lt;button
          id=&quot;link-share-button&quot;
          class=&quot;copy-link flex no-underline hover:text-pink-500 hover:text-underline md:h-auto p-2 text-center h-auto relative transform hover:scale-125 duration-300 ease-in-out&quot;
          type=&quot;button&quot;
          data-url={current_url(@conn)}
        &gt;
          &lt;svg
            xmlns=&quot;http://www.w3.org/2000/svg&quot;
            viewBox=&quot;0 0 16 16&quot;
            fill=&quot;currentColor&quot;
            class=&quot;fill-current h-6&quot;
          &gt;
            &lt;path
              fill-rule=&quot;evenodd&quot;
              d=&quot;M8.914 6.025a.75.75 0 0 1 1.06 0 3.5 3.5 0 0 1 0 4.95l-2 2a3.5 3.5 0 0 1-5.396-4.402.75.75 0 0 1 1.251.827 2 2 0 0 0 3.085 2.514l2-2a2 2 0 0 0 0-2.828.75.75 0 0 1 0-1.06Z&quot;
              clip-rule=&quot;evenodd&quot;
            /&gt;
            &lt;path
              fill-rule=&quot;evenodd&quot;
              d=&quot;M7.086 9.975a.75.75 0 0 1-1.06 0 3.5 3.5 0 0 1 0-4.95l2-2a3.5 3.5 0 0 1 5.396 4.402.75.75 0 0 1-1.251-.827 2 2 0 0 0-3.085-2.514l-2 2a2 2 0 0 0 0 2.828.75.75 0 0 1 0 1.06Z&quot;
              clip-rule=&quot;evenodd&quot;
            /&gt;
          &lt;/svg&gt;
          &lt;div class=&quot;absolute w-[100px] left-8 link-copied hidden&quot;&gt;Link copied&lt;/div&gt;
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;w-full justify-end&quot;&gt;
      &lt;ul class=&quot;flex flex-wrap items-center p-0 m-0&quot;&gt;
        &lt;li :for={tag &lt;- @post.tags} class=&quot;inline-flex rounded-[35px] bg-primary px-1 text-white&quot;&gt;
          &lt;a href=&quot;#&quot;&gt;
            &lt;div class=&quot;badge badge-outline text-primary rounded-none border-none text-xl&quot;&gt;
              #&lt;%= tag %&gt;
            &lt;/div&gt;
          &lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;

    &lt;h4 class=&quot; break-normal font-normal mt-8 ccp-font&quot;&gt;
      &lt;%= @post.description %&gt;
    &lt;/h4&gt;
    &lt;!--Post Content--&gt;
    &lt;%= raw(@post.body) %&gt;
  &lt;/div&gt;
  &lt;!--/container--&gt;
&lt;/article&gt;</file><file path="lib/wanderer_app_web/controllers/plugs/assign_map_owner.ex">defmodule WandererAppWeb.Plugs.AssignMapOwner do
  import Plug.Conn

  alias WandererApp.Map.Operations

  def init(opts), do: opts

  def call(conn, _opts) do
    map_id = conn.assigns[:map_id]
    case Operations.get_owner_character_id(map_id) do
      {:ok, %{id: char_id, user_id: user_id}} -&gt;
        conn
        |&gt; assign(:owner_character_id, char_id)
        |&gt; assign(:owner_user_id, user_id)
      _ -&gt;
        conn
        |&gt; assign(:owner_character_id, nil)
        |&gt; assign(:owner_user_id, nil)
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/plugs/check_acl_api_key.ex">defmodule WandererAppWeb.Plugs.CheckAclApiKey do
  @moduledoc &quot;&quot;&quot;
  A plug that checks the &quot;Authorization: Bearer &lt;token&gt;&quot; header
  against the ACL‚Äôs stored api_key.
  &quot;&quot;&quot;

  import Plug.Conn
  alias WandererApp.Repo
  alias WandererApp.Api.AccessList

  def init(opts), do: opts

  def call(conn, _opts) do
    header = get_req_header(conn, &quot;authorization&quot;) |&gt; List.first()

    case header do
      &quot;Bearer &quot; &lt;&gt; incoming_token -&gt;
        acl_id = conn.params[&quot;id&quot;] || conn.params[&quot;acl_id&quot;]

        if acl_id do
          case Repo.get(AccessList, acl_id) do
            nil -&gt;
              conn
              |&gt; send_resp(404, &quot;ACL not found&quot;)
              |&gt; halt()

            acl -&gt;
              cond do
                is_nil(acl.api_key) -&gt;
                  conn
                  |&gt; send_resp(401, &quot;Unauthorized (no API key set for ACL)&quot;)
                  |&gt; halt()

                acl.api_key == incoming_token -&gt;
                  conn

                true -&gt;
                  conn
                  |&gt; send_resp(401, &quot;Unauthorized (invalid API key for ACL)&quot;)
                  |&gt; halt()
              end
          end
        else
          conn
          |&gt; send_resp(400, &quot;ACL ID not provided&quot;)
          |&gt; halt()
        end

      _ -&gt;
        conn
        |&gt; send_resp(401, &quot;Missing or invalid &apos;Bearer&apos; token&quot;)
        |&gt; halt()
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/plugs/check_api_disabled.ex">defmodule WandererAppWeb.Plugs.CheckApiDisabled do
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    if WandererApp.Env.public_api_disabled?() do
      conn
      |&gt; send_resp(403, &quot;Public API is disabled&quot;)
      |&gt; halt()
    else
      conn
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/plugs/check_character_api_disabled.ex">defmodule WandererAppWeb.Plugs.CheckCharacterApiDisabled do
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    if WandererApp.Env.character_api_disabled?() do
      conn
      |&gt; send_resp(403, &quot;Character API is disabled&quot;)
      |&gt; halt()
    else
      conn
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/plugs/check_kills_disabled.ex">defmodule WandererAppWeb.Plugs.CheckKillsDisabled do
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    if WandererApp.Env.zkill_preload_disabled?() do
      conn
      |&gt; send_resp(403, &quot;Map kill feed is disabled&quot;)
      |&gt; halt()
    else
      conn
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/plugs/check_map_api_key.ex">defmodule WandererAppWeb.Plugs.CheckMapApiKey do
  @behaviour Plug

  import Plug.Conn
  alias Plug.Crypto
  alias WandererApp.Api.Map, as: ApiMap
  alias WandererAppWeb.Schemas.ResponseSchemas, as: R
  require Logger

  @impl true
  def init(opts), do: opts

  @impl true
  def call(conn, _opts) do
    with [&quot;Bearer &quot; &lt;&gt; token] &lt;- get_req_header(conn, &quot;authorization&quot;),
         {:ok, map_id}       &lt;- fetch_map_id(conn),
         {:ok, map}          &lt;- ApiMap.by_id(map_id),
         true                &lt;- is_binary(map.public_api_key) &amp;&amp;
                               Crypto.secure_compare(map.public_api_key, token)
    do
      conn
      |&gt; assign(:map, map)
      |&gt; assign(:map_id, map.id)
    else
      [] -&gt;
        Logger.warning(&quot;Missing or invalid &apos;Bearer&apos; token&quot;)
        conn |&gt; respond(401, &quot;Missing or invalid &apos;Bearer&apos; token&quot;) |&gt; halt()

      {:error, :bad_request, msg} -&gt;
        Logger.warning(&quot;Bad request: #{msg}&quot;)
        conn |&gt; respond(400, msg) |&gt; halt()

      {:error, :not_found, msg} -&gt;
        Logger.warning(&quot;Not found: #{msg}&quot;)
        conn |&gt; respond(404, msg) |&gt; halt()

      {:error, _} -&gt;
        Logger.warning(&quot;Map identifier required&quot;)
        conn
        |&gt; respond(400, &quot;Map identifier required. Provide `map_identifier` in the path or `map_id`/`slug` in query.&quot;)
        |&gt; halt()

      false -&gt;
        Logger.warning(&quot;Unauthorized: invalid token for map #{inspect(conn.params[&quot;map_identifier&quot;])}&quot;)
        conn |&gt; respond(401, &quot;Unauthorized (invalid token for map)&quot;) |&gt; halt()

      error -&gt;
        Logger.error(&quot;Unexpected error: #{inspect(error)}&quot;)
        conn |&gt; respond(500, &quot;Unexpected error&quot;) |&gt; halt()
    end
  end

  # Try unified path param first, then fall back to legacy query params
  defp fetch_map_id(%Plug.Conn{params: %{&quot;map_identifier&quot; =&gt; id}}) when is_binary(id) and id != &quot;&quot; do
    resolve_identifier(id)
  end
  defp fetch_map_id(conn), do: legacy_fetch(conn)

  # Try ID lookup first, then slug lookup
  defp resolve_identifier(id) do
    case ApiMap.by_id(id) do
      {:ok, %{id: map_id}} -&gt;
        {:ok, map_id}

      _ -&gt;
        case ApiMap.get_map_by_slug(id) do
          {:ok, %{id: map_id}} -&gt;
            {:ok, map_id}

          _ -&gt;
            {:error, :not_found, &quot;Map not found for identifier: #{id}&quot;}
        end
    end
  end

  # Legacy: check assigns, then params[&quot;map_id&quot;], then params[&quot;slug&quot;]
  defp legacy_fetch(conn) do
    map_id_from_assign = conn.assigns[:map_id]
    map_id_param       = conn.params[&quot;map_id&quot;]
    slug_param         = conn.params[&quot;slug&quot;]

    cond do
      is_binary(map_id_from_assign) and map_id_from_assign != &quot;&quot; -&gt;
        {:ok, map_id_from_assign}

      is_binary(map_id_param) and map_id_param != &quot;&quot; -&gt;
        {:ok, map_id_param}

      is_binary(slug_param) and slug_param != &quot;&quot; -&gt;
        case ApiMap.get_map_by_slug(slug_param) do
          {:ok, %{id: map_id}} -&gt; {:ok, map_id}
          _                    -&gt; {:error, :not_found, &quot;Map not found for slug: #{slug_param}&quot;}
        end

      true -&gt;
        {:error, :bad_request,
         &quot;Map identifier required. Provide `map_identifier` in the path or `map_id`/`slug` in query.&quot;}
    end
  end

  # Pick the right shared schema and send JSON
  defp respond(conn, status, msg) do
    {_desc, content_type, _schema} =
      case status do
        400 -&gt; R.bad_request(msg)
        401 -&gt; R.unauthorized(msg)
        404 -&gt; R.not_found(msg)
        500 -&gt; R.internal_server_error(msg)
        _   -&gt; R.internal_server_error(&quot;Unexpected error&quot;)
      end

    conn
    |&gt; put_resp_content_type(content_type)
    |&gt; send_resp(status, Jason.encode!(%{error: msg}))
  end
end</file><file path="lib/wanderer_app_web/controllers/plugs/check_map_subscription.ex">defmodule WandererAppWeb.Plugs.CheckMapSubscription do
  @moduledoc &quot;&quot;&quot;
  A plug that checks the Map has active subscription
  Halts with 401 if no active subscription.
  &quot;&quot;&quot;

  import Plug.Conn
  require Logger

  def init(opts), do: opts

  def call(conn, _opts) do
    # First check if map_id is already in conn.assigns (from CheckMapApiKey)
    case get_map_id_from_assigns_or_params(conn) do
      {:ok, map_id} -&gt;
        {:ok, is_subscription_active} = map_id |&gt; WandererApp.Map.is_subscription_active?()

        if is_subscription_active do
          conn
        else
          conn
          |&gt; send_resp(401, &quot;Unauthorized (map subscription not active)&quot;)
          |&gt; halt()
        end

      {:error, msg} -&gt;
        conn
        |&gt; send_resp(400, msg)
        |&gt; halt()
    end
  end

  # First try to get map_id from conn.assigns
  defp get_map_id_from_assigns_or_params(conn) do
    if Map.has_key?(conn.assigns, :map_id) do
      Logger.debug(&quot;Found map_id in conn.assigns: #{conn.assigns.map_id}&quot;)
      {:ok, conn.assigns.map_id}
    else
      # Fall back to query params if not in assigns
      fetch_map_id(conn.query_params)
    end
  end

  defp fetch_map_id(%{&quot;map_id&quot; =&gt; mid}) when is_binary(mid) and mid != &quot;&quot; do
    {:ok, mid}
  end

  defp fetch_map_id(%{&quot;slug&quot; =&gt; slug}) when is_binary(slug) and slug != &quot;&quot; do
    case WandererApp.Api.Map.get_map_by_slug(slug) do
      {:ok, map} -&gt;
        {:ok, map.id}

      {:error, _reason} -&gt;
        {:error, &quot;No map found for slug=#{slug}&quot;}
    end
  end

  defp fetch_map_id(_), do: {:error, &quot;Must provide either ?map_id=UUID or ?slug=SLUG&quot;}
end</file><file path="lib/wanderer_app_web/controllers/plugs/license_auth.ex">defmodule WandererAppWeb.Plugs.LicenseAuth do
  @moduledoc &quot;&quot;&quot;
  Plug for authenticating license API requests.

  This plug provides two authentication methods:
  1. LM_AUTH_KEY authentication for management endpoints
  2. License key authentication for validation endpoints
  &quot;&quot;&quot;

  import Plug.Conn
  import Phoenix.Controller
  require Logger

  alias WandererApp.License.LicenseManager
  alias WandererApp.Helpers.Config

  @doc &quot;&quot;&quot;
  Authenticates requests using the LM_AUTH_KEY.

  This is used for management endpoints that require administrative access.
  &quot;&quot;&quot;
  def authenticate_lm(conn, _opts) do
    auth_header = get_req_header(conn, &quot;authorization&quot;)
    lm_auth_key = Config.get_env(:wanderer_app, :lm_auth_key)

    case auth_header do
      [&quot;Bearer &quot; &lt;&gt; token] -&gt;
        if token == lm_auth_key do
          conn
        else
          conn
          |&gt; put_status(:unauthorized)
          |&gt; json(%{error: &quot;Invalid authentication token&quot;})
          |&gt; halt()
        end

      _ -&gt;
        conn
        |&gt; put_status(:unauthorized)
        |&gt; json(%{error: &quot;Missing authentication token&quot;})
        |&gt; halt()
    end
  end

  @doc &quot;&quot;&quot;
  Authenticates requests using a license key.

  This is used for validation endpoints that check if a license is valid.
  &quot;&quot;&quot;
  def authenticate_license(conn, _opts) do
    auth_header = get_req_header(conn, &quot;authorization&quot;)

    case auth_header do
      [&quot;Bearer &quot; &lt;&gt; license_key] -&gt;
        case LicenseManager.validate_license(license_key) do
          {:ok, license} -&gt;
            conn
            |&gt; assign(:license, license)

          {:error, :license_invalidated} -&gt;
            conn
            |&gt; put_status(:unauthorized)
            |&gt; json(%{error: &quot;License has been invalidated&quot;})
            |&gt; halt()

          {:error, :license_expired} -&gt;
            conn
            |&gt; put_status(:unauthorized)
            |&gt; json(%{error: &quot;License has expired&quot;})
            |&gt; halt()

          {:error, _} -&gt;
            conn
            |&gt; put_status(:unauthorized)
            |&gt; json(%{error: &quot;Invalid license key&quot;})
            |&gt; halt()
        end

      _ -&gt;
        conn
        |&gt; put_status(:unauthorized)
        |&gt; json(%{error: &quot;Missing license key&quot;})
        |&gt; halt()
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/plugs/set_user.ex">defmodule WandererAppWeb.Plugs.SetUser do
  @moduledoc false

  import Plug.Conn

  alias WandererApp.Api.User

  def init(opts), do: opts

  def call(conn, _opts) do
    user_id = get_session(conn, :user_id)

    case _load_user(user_id) do
      nil -&gt;
        conn
        |&gt; assign(:current_user, nil)
        |&gt; assign(:current_user_role, :none)

      user -&gt;
        admins = WandererApp.Env.admins()

        user_role =
          case Enum.empty?(admins) or user.hash in admins do
            true -&gt;
              :admin

            _ -&gt;
              :user
          end

        conn
        |&gt; assign(:current_user, user)
        |&gt; assign(:current_user_role, user_role)
    end
  end

  defp _load_user(nil), do: nil

  defp _load_user(user_id) do
    case User.by_id(user_id, load: :characters) do
      {:ok, user} -&gt; user
      {:error, _} -&gt; nil
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/access_list_api_controller.ex">defmodule WandererAppWeb.MapAccessListAPIController do
  @moduledoc &quot;&quot;&quot;
  API endpoints for managing Access Lists.

  Endpoints:
    - GET /api/map/acls?map_id=... or ?slug=...   (list ACLs)
    - POST /api/map/acls                         (create ACL)
    - GET /api/acls/:id                          (show ACL)
    - PUT /api/acls/:id                          (update ACL)
  &quot;&quot;&quot;

  use WandererAppWeb, :controller
  use OpenApiSpex.ControllerSpecs

  alias WandererApp.Api.{AccessList, Character}
  alias WandererAppWeb.Helpers.APIUtils
  import Ash.Query
  require Logger

  # ------------------------------------------------------------------------
  # Inline Schemas for OpenApiSpex
  # ------------------------------------------------------------------------

  # Used in operation :index =&gt; the response &quot;List of ACLs&quot;
  @acl_index_response_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      data: %OpenApiSpex.Schema{
        type: :array,
        items: %OpenApiSpex.Schema{
          type: :object,
          properties: %{
            id: %OpenApiSpex.Schema{type: :string},
            name: %OpenApiSpex.Schema{type: :string},
            description: %OpenApiSpex.Schema{type: :string},
            owner_eve_id: %OpenApiSpex.Schema{type: :string},
            inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
            updated_at: %OpenApiSpex.Schema{type: :string, format: :date_time}
          },
          required: [&quot;id&quot;, &quot;name&quot;]
        }
      }
    },
    required: [&quot;data&quot;]
  }

  # Used in operation :create =&gt; the request body &quot;ACL parameters&quot;
  @acl_create_request_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      acl: %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          owner_eve_id: %OpenApiSpex.Schema{
            type: :string,
            description: &quot;EVE character ID of the owner (must match an existing character)&quot;
          },
          name: %OpenApiSpex.Schema{
            type: :string,
            description: &quot;Name of the access list&quot;
          },
          description: %OpenApiSpex.Schema{
            type: :string,
            description: &quot;Optional description of the access list&quot;
          }
        },
        required: [&quot;owner_eve_id&quot;, &quot;name&quot;],
        example: %{
          &quot;owner_eve_id&quot; =&gt; &quot;2112073677&quot;,
          &quot;name&quot; =&gt; &quot;My Access List&quot;,
          &quot;description&quot; =&gt; &quot;Optional description&quot;
        }
      }
    },
    required: [&quot;acl&quot;]
  }

  # Used in operation :create =&gt; the response &quot;Created ACL&quot;
  @acl_create_response_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      data: %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          id: %OpenApiSpex.Schema{type: :string},
          name: %OpenApiSpex.Schema{type: :string},
          description: %OpenApiSpex.Schema{type: :string},
          owner_id: %OpenApiSpex.Schema{type: :string},
          api_key: %OpenApiSpex.Schema{type: :string},
          inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
          updated_at: %OpenApiSpex.Schema{type: :string, format: :date_time}
        },
        required: [&quot;id&quot;, &quot;name&quot;]
      }
    },
    required: [&quot;data&quot;]
  }

  # Used in operation :show =&gt; the response &quot;ACL details&quot;
  @acl_show_response_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      data: %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          id: %OpenApiSpex.Schema{type: :string},
          name: %OpenApiSpex.Schema{type: :string},
          description: %OpenApiSpex.Schema{type: :string},
          owner_id: %OpenApiSpex.Schema{type: :string},
          api_key: %OpenApiSpex.Schema{type: :string},
          inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
          updated_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
          members: %OpenApiSpex.Schema{
            type: :array,
            items: %OpenApiSpex.Schema{
              type: :object,
              properties: %{
                id: %OpenApiSpex.Schema{type: :string},
                name: %OpenApiSpex.Schema{type: :string},
                role: %OpenApiSpex.Schema{type: :string},
                eve_character_id: %OpenApiSpex.Schema{type: :string},
                eve_corporation_id: %OpenApiSpex.Schema{type: :string},
                eve_alliance_id: %OpenApiSpex.Schema{type: :string},
                inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
                updated_at: %OpenApiSpex.Schema{type: :string, format: :date_time}
              },
              required: [&quot;id&quot;, &quot;name&quot;, &quot;role&quot;]
            }
          }
        },
        required: [&quot;id&quot;, &quot;name&quot;]
      }
    },
    required: [&quot;data&quot;]
  }

  # Used in operation :update =&gt; the request body &quot;ACL update payload&quot;
  @acl_update_request_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      acl: %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          name: %OpenApiSpex.Schema{type: :string},
          description: %OpenApiSpex.Schema{type: :string}
        }
        # If &quot;name&quot; is truly required, add it to required: [&quot;name&quot;] here
      }
    },
    required: [&quot;acl&quot;]
  }

  # Used in operation :update =&gt; the response &quot;Updated ACL&quot;
  @acl_update_response_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      data: %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          id: %OpenApiSpex.Schema{type: :string},
          name: %OpenApiSpex.Schema{type: :string},
          description: %OpenApiSpex.Schema{type: :string},
          owner_id: %OpenApiSpex.Schema{type: :string},
          api_key: %OpenApiSpex.Schema{type: :string},
          inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
          updated_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
          members: %OpenApiSpex.Schema{
            type: :array,
            items: %OpenApiSpex.Schema{
              type: :object,
              properties: %{
                id: %OpenApiSpex.Schema{type: :string},
                name: %OpenApiSpex.Schema{type: :string},
                role: %OpenApiSpex.Schema{type: :string},
                eve_character_id: %OpenApiSpex.Schema{type: :string},
                eve_corporation_id: %OpenApiSpex.Schema{type: :string},
                eve_alliance_id: %OpenApiSpex.Schema{type: :string},
                inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
                updated_at: %OpenApiSpex.Schema{type: :string, format: :date_time}
              },
              required: [&quot;id&quot;, &quot;name&quot;, &quot;role&quot;]
            }
          }
        },
        required: [&quot;id&quot;, &quot;name&quot;]
      }
    },
    required: [&quot;data&quot;]
  }

  # ------------------------------------------------------------------------
  # ENDPOINTS
  # ------------------------------------------------------------------------

  @doc &quot;&quot;&quot;
  GET /api/map/acls?map_id=... or ?slug=...

  Lists the ACLs for a given map.
  &quot;&quot;&quot;
  @spec index(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :index,
    summary: &quot;List ACLs for a Map&quot;,
    description: &quot;Lists the ACLs for a given map. Provide only one of map_id or slug as a query parameter. If both are provided, the request will fail.&quot;,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Provide only one of map_id or slug.&quot;,
        type: :string,
        required: false
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Provide only one of map_id or slug.&quot;,
        type: :string,
        required: false
      ]
    ],
    responses: [
      ok: {&quot;List of ACLs&quot;, &quot;application/json&quot;, @acl_index_response_schema},
      bad_request: {&quot;Error&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
        type: :object,
        properties: %{error: %OpenApiSpex.Schema{type: :string}},
        required: [&quot;error&quot;],
        example: %{&quot;error&quot; =&gt; &quot;Must provide only one of map_id or slug as a query parameter&quot;}
      }}
    ]
  def index(conn, params) do
    case APIUtils.fetch_map_id(params) do
      {:ok, map_identifier} -&gt;
        with {:ok, map} &lt;- get_map(map_identifier),
             {:ok, loaded_map} &lt;- Ash.load(map, acls: [:owner]) do
          acls = loaded_map.acls || []
          json(conn, %{data: Enum.map(acls, &amp;acl_to_list_json/1)})
        else
          {:error, :map_not_found} -&gt;
            conn
            |&gt; put_status(:not_found)
            |&gt; json(%{error: &quot;Map not found. Please provide a valid map_id or slug as a query parameter.&quot;})

          {:error, error} -&gt;
            conn
            |&gt; put_status(:internal_server_error)
            |&gt; json(%{error: inspect(error)})
        end

      {:error, _msg} -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: &quot;Must provide either ?map_id=UUID or ?slug=SLUG as a query parameter&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  POST /api/map/acls

  Creates a new ACL for a map.
  &quot;&quot;&quot;
  @spec create(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :create,
    summary: &quot;Create ACL for a Map&quot;,
    description: &quot;Creates a new ACL for a given map. Provide only one of map_id or slug as a query parameter. If both are provided, the request will fail.&quot;,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Provide only one of map_id or slug.&quot;,
        type: :string,
        required: false
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Provide only one of map_id or slug.&quot;,
        type: :string,
        required: false
      ]
    ],
    request_body: {&quot;ACL parameters&quot;, &quot;application/json&quot;, @acl_create_request_schema},
    responses: [
      created: {&quot;Created ACL&quot;, &quot;application/json&quot;, @acl_create_response_schema},
      bad_request: {&quot;Error&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
        type: :object,
        properties: %{error: %OpenApiSpex.Schema{type: :string}},
        required: [&quot;error&quot;],
        example: %{&quot;error&quot; =&gt; &quot;Must provide only one of map_id or slug as a query parameter&quot;}
      }}
    ]
  def create(conn, params) do
    with {:ok, map_identifier} &lt;- APIUtils.fetch_map_id(params),
         {:ok, map} &lt;- get_map(map_identifier),
         %{&quot;acl&quot; =&gt; acl_params} &lt;- params,
         owner_eve_id when not is_nil(owner_eve_id) &lt;- Map.get(acl_params, &quot;owner_eve_id&quot;),
         owner_eve_id_str = to_string(owner_eve_id),
         {:ok, character} &lt;- find_character_by_eve_id(owner_eve_id_str),
         {:ok, new_api_key} &lt;- {:ok, UUID.uuid4()},
         new_params &lt;-
           acl_params
           |&gt; Map.delete(&quot;owner_eve_id&quot;)
           |&gt; Map.put(&quot;owner_id&quot;, character.id)
           |&gt; Map.put(&quot;api_key&quot;, new_api_key),
         {:ok, new_acl} &lt;- AccessList.new(new_params),
         {:ok, _updated_map} &lt;- associate_acl_with_map(map, new_acl) do
      json(conn, %{data: acl_to_json(new_acl)})
    else
      {:error, :map_not_found} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Map not found. Please provide a valid map_id or slug as a query parameter.&quot;})

      {:error, &quot;Must provide either ?map_id=UUID or ?slug=SLUG&quot;} -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: &quot;Must provide either ?map_id=UUID or ?slug=SLUG as a query parameter&quot;})

      nil -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: &quot;Missing required field: owner_eve_id&quot;})

      {:error, &quot;owner_eve_id does not match any existing character&quot;} = _error -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: &quot;Character not found: The provided owner_eve_id does not match any existing character&quot;})

      %{} -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: &quot;Missing required &apos;acl&apos; object in request body&quot;})

      error -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: inspect(error)})
    end
  end

  @doc &quot;&quot;&quot;
  GET /api/acls/:id

  Shows a specific ACL (with its members).
  &quot;&quot;&quot;
  @spec show(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :show,
    summary: &quot;Get ACL details&quot;,
    description: &quot;Retrieves details for a specific ACL by its ID.&quot;,
    parameters: [
      id: [
        in: :path,
        description: &quot;ACL identifier (UUID)&quot;,
        type: :string,
        required: true,
        example: &quot;00000000-0000-0000-0000-000000000000&quot;
      ]
    ],
    responses: [
      ok: {
        &quot;ACL details&quot;,
        &quot;application/json&quot;,
        @acl_show_response_schema
      },
      not_found: {&quot;Error&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          error: %OpenApiSpex.Schema{type: :string}
        },
        required: [&quot;error&quot;],
        example: %{
          &quot;error&quot; =&gt; &quot;ACL not found&quot;
        }
      }},
      internal_server_error: {&quot;Error&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          error: %OpenApiSpex.Schema{type: :string}
        },
        required: [&quot;error&quot;],
        example: %{
          &quot;error&quot; =&gt; &quot;Failed to load ACL members: reason&quot;
        }
      }}
    ]
  def show(conn, %{&quot;id&quot; =&gt; id}) do
    query =
      AccessList
      |&gt; Ash.Query.new()
      |&gt; filter(id == ^id)

    case WandererApp.Api.read(query) do
      {:ok, [acl]} -&gt;
        case Ash.load(acl, :members) do
          {:ok, loaded_acl} -&gt;
            json(conn, %{data: acl_to_json(loaded_acl)})

          {:error, error} -&gt;
            conn
            |&gt; put_status(:internal_server_error)
            |&gt; json(%{error: &quot;Failed to load ACL members: #{inspect(error)}&quot;})
        end

      {:ok, []} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;ACL not found&quot;})

      {:error, error} -&gt;
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: &quot;Error reading ACL: #{inspect(error)}&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  PUT /api/acls/:id

  Updates an ACL.
  &quot;&quot;&quot;
  @spec update(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :update,
    summary: &quot;Update an ACL&quot;,
    description: &quot;Updates an existing ACL by its ID.&quot;,
    parameters: [
      id: [
        in: :path,
        description: &quot;ACL identifier (UUID)&quot;,
        type: :string,
        required: true,
        example: &quot;00000000-0000-0000-0000-000000000000&quot;
      ]
    ],
    request_body: {
      &quot;ACL update payload&quot;,
      &quot;application/json&quot;,
      @acl_update_request_schema
    },
    responses: [
      ok: {
        &quot;Updated ACL&quot;,
        &quot;application/json&quot;,
        @acl_update_response_schema
      },
      bad_request: {&quot;Error&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          error: %OpenApiSpex.Schema{type: :string}
        },
        required: [&quot;error&quot;],
        example: %{
          &quot;error&quot; =&gt; &quot;Failed to update ACL: invalid parameters&quot;
        }
      }},
      not_found: {&quot;Error&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          error: %OpenApiSpex.Schema{type: :string}
        },
        required: [&quot;error&quot;],
        example: %{
          &quot;error&quot; =&gt; &quot;ACL not found&quot;
        }
      }}
    ]
  def update(conn, %{&quot;id&quot; =&gt; id, &quot;acl&quot; =&gt; acl_params}) do
    with {:ok, acl} &lt;- AccessList.by_id(id),
         {:ok, updated_acl} &lt;- AccessList.update(acl, acl_params),
         {:ok, updated_acl} &lt;- Ash.load(updated_acl, :members) do
      json(conn, %{data: acl_to_json(updated_acl)})
    else
      {:error, error} -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: &quot;Failed to update ACL: #{inspect(error)}&quot;})
    end
  end

  # ---------------------------------------------------------------------------
  # Private / Helper Functions
  # ---------------------------------------------------------------------------
  defp get_map(map_identifier) do
    case WandererApp.Api.Map.by_id(map_identifier) do
      {:ok, map} -&gt; {:ok, map}
      {:error, _} -&gt; {:error, :map_not_found}
    end
  end

  defp acl_to_json(acl) do
    members =
      case acl.members do
        %Ash.NotLoaded{} -&gt; []
        list when is_list(list) -&gt; Enum.map(list, &amp;member_to_json/1)
        _ -&gt; []
      end

    %{
      id: acl.id,
      name: acl.name,
      description: acl.description,
      owner_id: acl.owner_id,
      api_key: acl.api_key,
      inserted_at: acl.inserted_at,
      updated_at: acl.updated_at,
      members: members
    }
  end

  defp acl_to_list_json(acl) do
    owner_eve_id =
      case acl.owner do
        %Character{eve_id: eid} -&gt; eid
        _ -&gt; nil
      end

    %{
      id: acl.id,
      name: acl.name,
      description: acl.description,
      owner_eve_id: owner_eve_id,
      inserted_at: acl.inserted_at,
      updated_at: acl.updated_at
    }
  end

  defp member_to_json(member) do
    base = %{
      id: member.id,
      name: member.name,
      role: member.role,
      inserted_at: member.inserted_at,
      updated_at: member.updated_at
    }

    cond do
      member.eve_character_id -&gt; Map.put(base, :eve_character_id, member.eve_character_id)
      member.eve_corporation_id -&gt; Map.put(base, :eve_corporation_id, member.eve_corporation_id)
      member.eve_alliance_id -&gt; Map.put(base, :eve_alliance_id, member.eve_alliance_id)
      true -&gt; base
    end
  end

  defp find_character_by_eve_id(eve_id) do
    query =
      Character
      |&gt; Ash.Query.new()
      |&gt; filter(eve_id == ^eve_id)

    case WandererApp.Api.read(query) do
      {:ok, [character]} -&gt;
        {:ok, character}

      {:ok, []} -&gt;
        {:error, &quot;owner_eve_id does not match any existing character&quot;}

      other -&gt;
        other
    end
  end

  # Helper to associate a new ACL with a map.
  defp associate_acl_with_map(map, new_acl) do
    with {:ok, api_map} &lt;- WandererApp.Api.Map.by_id(map.id),
         {:ok, loaded_map} &lt;- Ash.load(api_map, :acls) do
      new_acl_id = if is_binary(new_acl), do: new_acl, else: new_acl.id

      # Extract IDs from current ACLs to ensure we&apos;re working with UUIDs only
      current_acl_ids = loaded_map.acls
                        |&gt; Kernel.||([])
                        |&gt; Enum.map(fn
                          acl when is_binary(acl) -&gt; acl
                          acl -&gt; acl.id
                        end)

      updated_acls = current_acl_ids ++ [new_acl_id]

      case WandererApp.Api.Map.update_acls(loaded_map, %{acls: updated_acls}) do
        {:ok, updated_map} -&gt;
          {:ok, updated_map}

        {:error, error} -&gt;
          Logger.error(&quot;Failed to update map #{loaded_map.id} with new ACL: #{inspect(error)}&quot;)
          {:error, error}
      end
    else
      error -&gt;
        Logger.error(&quot;Error loading map ACLs: #{inspect(error)}&quot;)
        {:error, error}
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/access_list_member_api_controller.ex">defmodule WandererAppWeb.AccessListMemberAPIController do
  @moduledoc &quot;&quot;&quot;
  Handles creation, role updates, and deletion of individual ACL members.
  &quot;&quot;&quot;

  use WandererAppWeb, :controller
  use OpenApiSpex.ControllerSpecs

  alias WandererApp.Api.AccessListMember
  import Ash.Query
  require Logger

  # ------------------------------------------------------------------------
  # Inline Schemas
  # ------------------------------------------------------------------------
  @acl_member_create_request_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      member: %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          eve_character_id: %OpenApiSpex.Schema{type: :string},
          eve_corporation_id: %OpenApiSpex.Schema{type: :string},
          eve_alliance_id: %OpenApiSpex.Schema{type: :string},
          role: %OpenApiSpex.Schema{type: :string}
        }
        # no &apos;required&apos; fields if you truly allow any of them
      }
    },
    required: [&quot;member&quot;]
  }

  @acl_member_create_response_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      data: %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          id: %OpenApiSpex.Schema{type: :string},
          name: %OpenApiSpex.Schema{type: :string},
          role: %OpenApiSpex.Schema{type: :string},
          eve_character_id: %OpenApiSpex.Schema{type: :string},
          eve_corporation_id: %OpenApiSpex.Schema{type: :string},
          eve_alliance_id: %OpenApiSpex.Schema{type: :string},
          inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
          updated_at: %OpenApiSpex.Schema{type: :string, format: :date_time}
        },
        required: [&quot;id&quot;, &quot;name&quot;, &quot;role&quot;]
      }
    },
    required: [&quot;data&quot;]
  }

  @acl_member_update_request_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      member: %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          role: %OpenApiSpex.Schema{type: :string}
        },
        required: [&quot;role&quot;]
      }
    },
    required: [&quot;member&quot;]
  }

  @acl_member_update_response_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      data: %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          id: %OpenApiSpex.Schema{type: :string},
          name: %OpenApiSpex.Schema{type: :string},
          role: %OpenApiSpex.Schema{type: :string},
          eve_character_id: %OpenApiSpex.Schema{type: :string},
          eve_corporation_id: %OpenApiSpex.Schema{type: :string},
          eve_alliance_id: %OpenApiSpex.Schema{type: :string},
          inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
          updated_at: %OpenApiSpex.Schema{type: :string, format: :date_time}
        },
        required: [&quot;id&quot;, &quot;name&quot;, &quot;role&quot;]
      }
    },
    required: [&quot;data&quot;]
  }

  @acl_member_delete_response_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      ok: %OpenApiSpex.Schema{type: :boolean}
    },
    required: [&quot;ok&quot;]
  }

  # ------------------------------------------------------------------------
  # ENDPOINTS
  # ------------------------------------------------------------------------

  @doc &quot;&quot;&quot;
  POST /api/acls/:acl_id/members

  Creates a new ACL member.
  &quot;&quot;&quot;
  @spec create(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :create,
    summary: &quot;Create ACL Member&quot;,
    description: &quot;Creates a new ACL member for a given ACL.&quot;,
    parameters: [
      acl_id: [
        in: :path,
        description: &quot;Access List ID&quot;,
        type: :string,
        required: true
      ]
    ],
    request_body: {
      &quot;ACL Member parameters&quot;,
      &quot;application/json&quot;,
      @acl_member_create_request_schema
    },
    responses: [
      ok: {
        &quot;Created ACL Member&quot;,
        &quot;application/json&quot;,
        @acl_member_create_response_schema
      }
    ]
  def create(conn, %{&quot;acl_id&quot; =&gt; acl_id, &quot;member&quot; =&gt; member_params}) do
    chosen =
      cond do
        Map.has_key?(member_params, &quot;eve_corporation_id&quot;) -&gt;
          {&quot;eve_corporation_id&quot;, &quot;corporation&quot;}

        Map.has_key?(member_params, &quot;eve_alliance_id&quot;) -&gt;
          {&quot;eve_alliance_id&quot;, &quot;alliance&quot;}

        Map.has_key?(member_params, &quot;eve_character_id&quot;) -&gt;
          {&quot;eve_character_id&quot;, &quot;character&quot;}

        true -&gt;
          nil
      end

    if is_nil(chosen) do
      conn
      |&gt; put_status(:bad_request)
      |&gt; json(%{
        error:
          &quot;Missing one of eve_character_id, eve_corporation_id, or eve_alliance_id in payload&quot;
      })
    else
      {key, type} = chosen
      raw_id = Map.get(member_params, key)
      id_str = to_string(raw_id)
      role = Map.get(member_params, &quot;role&quot;, &quot;viewer&quot;)

      if type in [&quot;corporation&quot;, &quot;alliance&quot;] and role in [&quot;admin&quot;, &quot;manager&quot;] do
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{
          error:
            &quot;#{String.capitalize(type)} members cannot have an admin or manager role&quot;
        })
      else
        info_fetcher =
          case type do
            &quot;character&quot; -&gt; &amp;WandererApp.Esi.get_character_info/1
            &quot;corporation&quot; -&gt; &amp;WandererApp.Esi.get_corporation_info/1
            &quot;alliance&quot; -&gt; &amp;WandererApp.Esi.get_alliance_info/1
          end

        with {:ok, entity_info} &lt;- info_fetcher.(id_str) do
          member_name = Map.get(entity_info, &quot;name&quot;)

          new_params =
            member_params
            |&gt; Map.drop([&quot;eve_corporation_id&quot;, &quot;eve_alliance_id&quot;, &quot;eve_character_id&quot;])
            |&gt; Map.put(key, id_str)
            |&gt; Map.put(&quot;name&quot;, member_name)
            |&gt; Map.put(&quot;access_list_id&quot;, acl_id)

          case AccessListMember.create(new_params) do
            {:ok, new_member} -&gt;
              json(conn, %{data: member_to_json(new_member)})

            {:error, error} -&gt;
              conn
              |&gt; put_status(:bad_request)
              |&gt; json(%{error: &quot;Creation failed: #{inspect(error)}&quot;})
          end
        else
          {:error, error} -&gt;
            conn
            |&gt; put_status(:bad_request)
            |&gt; json(%{error: &quot;Entity lookup failed: #{inspect(error)}&quot;})
        end
      end
    end
  end

  @doc &quot;&quot;&quot;
  PUT /api/acls/:acl_id/members/:member_id

  Updates the role of an ACL member.
  &quot;&quot;&quot;
  @spec update_role(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :update_role,
    summary: &quot;Update ACL Member Role&quot;,
    description: &quot;Updates the role of an ACL member identified by ACL ID and member external ID.&quot;,
    parameters: [
      acl_id: [
        in: :path,
        description: &quot;Access List ID&quot;,
        type: :string,
        required: true
      ],
      member_id: [
        in: :path,
        description: &quot;Member external ID&quot;,
        type: :string,
        required: true
      ]
    ],
    request_body: {
      &quot;ACL Member update payload&quot;,
      &quot;application/json&quot;,
      @acl_member_update_request_schema
    },
    responses: [
      ok: {
        &quot;Updated ACL Member&quot;,
        &quot;application/json&quot;,
        @acl_member_update_response_schema
      }
    ]
  def update_role(conn, %{
        &quot;acl_id&quot; =&gt; acl_id,
        &quot;member_id&quot; =&gt; external_id,
        &quot;member&quot; =&gt; member_params
      }) do
    external_id_str = to_string(external_id)

    membership_query =
      AccessListMember
      |&gt; Ash.Query.new()
      |&gt; filter(access_list_id == ^acl_id)
      |&gt; filter(
        eve_character_id == ^external_id_str or
          eve_corporation_id == ^external_id_str or
          eve_alliance_id == ^external_id_str
      )

    case WandererApp.Api.read(membership_query) do
      {:ok, [membership]} -&gt;
        new_role = Map.get(member_params, &quot;role&quot;, membership.role)

        member_type =
          cond do
            membership.eve_corporation_id -&gt; &quot;corporation&quot;
            membership.eve_alliance_id -&gt; &quot;alliance&quot;
            membership.eve_character_id -&gt; &quot;character&quot;
            true -&gt; &quot;character&quot;
          end

        if member_type in [&quot;corporation&quot;, &quot;alliance&quot;] and new_role in [&quot;admin&quot;, &quot;manager&quot;] do
          conn
          |&gt; put_status(:bad_request)
          |&gt; json(%{
            error:
              &quot;#{String.capitalize(member_type)} members cannot have an admin or manager role&quot;
          })
        else
          case AccessListMember.update_role(membership, member_params) do
            {:ok, updated_membership} -&gt;
              json(conn, %{data: member_to_json(updated_membership)})

            {:error, error} -&gt;
              conn
              |&gt; put_status(:bad_request)
              |&gt; json(%{error: inspect(error)})
          end
        end

      {:ok, []} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Membership not found for given ACL and external id&quot;})

      {:error, error} -&gt;
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: inspect(error)})
    end
  end

  @doc &quot;&quot;&quot;
  DELETE /api/acls/:acl_id/members/:member_id

  Deletes an ACL member.
  &quot;&quot;&quot;
  @spec delete(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :delete,
    summary: &quot;Delete ACL Member&quot;,
    description: &quot;Deletes an ACL member identified by ACL ID and member external ID.&quot;,
    parameters: [
      acl_id: [
        in: :path,
        description: &quot;Access List ID&quot;,
        type: :string,
        required: true
      ],
      member_id: [
        in: :path,
        description: &quot;Member external ID&quot;,
        type: :string,
        required: true
      ]
    ],
    responses: [
      ok: {
        &quot;ACL Member deletion confirmation&quot;,
        &quot;application/json&quot;,
        @acl_member_delete_response_schema
      }
    ]
  def delete(conn, %{&quot;acl_id&quot; =&gt; acl_id, &quot;member_id&quot; =&gt; external_id}) do
    external_id_str = to_string(external_id)

    membership_query =
      AccessListMember
      |&gt; Ash.Query.new()
      |&gt; filter(access_list_id == ^acl_id)
      |&gt; filter(
        eve_character_id == ^external_id_str or
          eve_corporation_id == ^external_id_str or
          eve_alliance_id == ^external_id_str
      )

    case WandererApp.Api.read(membership_query) do
      {:ok, [membership]} -&gt;
        case AccessListMember.destroy(membership) do
          :ok -&gt;
            json(conn, %{ok: true})

          {:error, error} -&gt;
            conn
            |&gt; put_status(:bad_request)
            |&gt; json(%{error: inspect(error)})
        end

      {:ok, []} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Membership not found for given ACL and external id&quot;})

      {:error, error} -&gt;
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: inspect(error)})
    end
  end

  # ---------------------------------------------------------------------------
  # Private Helpers
  # ---------------------------------------------------------------------------
  @doc false
  defp member_to_json(member) do
    base = %{
      id: member.id,
      name: member.name,
      role: member.role,
      eve_character_id: member.eve_character_id,
      eve_corporation_id: member.eve_corporation_id,
      eve_alliance_id: member.eve_alliance_id,
      inserted_at: member.inserted_at,
      updated_at: member.updated_at
    }

    cond do
      member.eve_character_id -&gt; Map.put(base, :eve_character_id, member.eve_character_id)
      member.eve_corporation_id -&gt; Map.put(base, :eve_corporation_id, member.eve_corporation_id)
      member.eve_alliance_id -&gt; Map.put(base, :eve_alliance_id, member.eve_alliance_id)
      true -&gt; base
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/auth_controller.ex">defmodule WandererAppWeb.AuthController do
  use WandererAppWeb, :controller
  plug Ueberauth

  import Plug.Conn
  import Phoenix.Controller

  require Logger

  def callback(%{assigns: %{ueberauth_auth: auth, current_user: user} = _assigns} = conn, _params) do
    character_data = %{
      eve_id: &quot;#{auth.info.email}&quot;,
      name: auth.info.name,
      access_token: auth.credentials.token,
      refresh_token: auth.credentials.refresh_token,
      expires_at: auth.credentials.expires_at,
      scopes: auth.credentials.scopes
    }

    %{
      &quot;CharacterOwnerHash&quot; =&gt; character_owner_hash
    } = auth.extra.raw_info.user

    {:ok, character} =
      case WandererApp.Api.Character.by_eve_id(character_data.eve_id) do
        {:ok, character} -&gt;
          character_update = %{
            name: auth.info.name,
            access_token: auth.credentials.token,
            refresh_token: auth.credentials.refresh_token,
            expires_at: auth.credentials.expires_at,
            scopes: auth.credentials.scopes
          }

          {:ok, character} =
            character
            |&gt; WandererApp.Api.Character.update(character_update)

          WandererApp.Character.update_character(character.id, character_update)

          {:ok, character}

        {:error, _error} -&gt;
          {:ok, character} = WandererApp.Api.Character.create(character_data)
          :telemetry.execute([:wanderer_app, :user, :character, :registered], %{count: 1})

          {:ok, character}
      end

    user_id =
      case user do
        nil -&gt;
          case WandererApp.Api.User.by_hash(character_owner_hash) do
            {:ok, user} -&gt;
              user.id

            _ -&gt;
              case character.user_id do
                nil -&gt;
                  :telemetry.execute([:wanderer_app, :user, :registered], %{count: 1})

                  WandererApp.Api.User
                  |&gt; Ash.Changeset.for_create(:create, %{
                    name: &quot;User_#{character_owner_hash}&quot;,
                    hash: character_owner_hash
                  })
                  |&gt; Ash.create!()
                  |&gt; Map.get(:id)

                user_id -&gt;
                  user_id
              end
          end

        user -&gt;
          user.id
      end

    maybe_update_character_user_id(character, user_id)

    conn
    |&gt; put_session(:user_id, user_id)
    |&gt; redirect(to: &quot;/characters&quot;)
  end

  def callback(conn, _params) do
    conn
    |&gt; redirect(to: &quot;/characters&quot;)
  end

  def signout(conn, _params) do
    conn
    |&gt; configure_session(drop: true)
    |&gt; redirect(to: ~p&quot;/&quot;)
  end

  def maybe_update_character_user_id(character, user_id) when not is_nil(user_id) do
    WandererApp.Api.Character.assign_user!(character, %{user_id: user_id})
  end

  def maybe_update_character_user_id(_character, _user_id), do: :ok
end</file><file path="lib/wanderer_app_web/controllers/basic_auth.ex">defmodule WandererAppWeb.BasicAuth do
  @moduledoc false

  def admin_basic_auth(conn, _opts) do
    admin_password = WandererApp.Env.admin_password()

    if is_nil(admin_password) do
      conn
    else
      conn
      |&gt; Plug.BasicAuth.basic_auth(
        username: WandererApp.Env.admin_username(),
        password: admin_password
      )
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/blog_controller.ex">defmodule WandererAppWeb.BlogController do
  use WandererAppWeb, :controller

  alias WandererApp.Blog
  require Logger

  def index(conn, _params) do
    invite_token = conn.query_params[&quot;invite&quot;]

    invite_token_valid =
      case WandererApp.Env.invites() do
        true -&gt;
          case invite_token do
            nil -&gt; false
            token -&gt; WandererApp.Cache.lookup!(&quot;invite_#{token}&quot;, false)
          end

        _ -&gt;
          true
      end

    posts = Blog.all_posts()

    render(conn, &quot;index.html&quot;,
      posts: posts,
      invite_token: invite_token || &quot;&quot;,
      invite_token_valid: invite_token_valid
    )
  end

  def list(conn, params) do
    tags = Blog.all_tags()

    {posts, selected_tag} =
      params
      |&gt; case do
        %{&quot;tag&quot; =&gt; tag} -&gt; {Blog.get_by_tag(tag), tag}
        _ -&gt; {Blog.all_posts(), nil}
      end

    render(conn, &quot;list.html&quot;,
      posts: posts,
      tags: tags,
      selected_tag: selected_tag
    )
  end

  def show(conn, %{&quot;slug&quot; =&gt; slug}) do
    post = Blog.get_by_id!(slug)

    if post do
      render(conn, &quot;show.html&quot;, post: post)
    else
      conn
      |&gt; put_status(:not_found)
    end
  end

  def contacts(conn, _params) do
    render(conn, &quot;contacts.html&quot;)
  end

  def changelog(conn, _params) do
    [file] = WandererApp.Changelog.all_files()
    render(conn, &quot;changelog.html&quot;, file: file)
  end

  def license(conn, _params) do
    render(conn, &quot;license.html&quot;)
  end
end</file><file path="lib/wanderer_app_web/controllers/blog_html.ex">defmodule WandererAppWeb.BlogHTML do
  use WandererAppWeb, :html

  embed_templates &quot;blog_html/*&quot;
end</file><file path="lib/wanderer_app_web/controllers/character_api_controller.ex">defmodule WandererAppWeb.CharactersAPIController do
  @moduledoc &quot;&quot;&quot;
  Exposes an endpoint for listing ALL characters in the database
  &quot;&quot;&quot;

  use WandererAppWeb, :controller
  use OpenApiSpex.ControllerSpecs
  alias WandererApp.Api.Character

  @characters_index_response_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      data: %OpenApiSpex.Schema{
        type: :array,
        items: %OpenApiSpex.Schema{
          type: :object,
          properties: %{
            eve_id: %OpenApiSpex.Schema{type: :string},
            name: %OpenApiSpex.Schema{type: :string},
            corporation_id: %OpenApiSpex.Schema{type: :string},
            corporation_ticker: %OpenApiSpex.Schema{type: :string},
            alliance_id: %OpenApiSpex.Schema{type: :string},
            alliance_ticker: %OpenApiSpex.Schema{type: :string}
          },
          required: [&quot;eve_id&quot;, &quot;name&quot;]
        }
      }
    },
    required: [&quot;data&quot;]
  }

  @doc &quot;&quot;&quot;
  GET /api/characters
  &quot;&quot;&quot;
  @spec index(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :index,
    summary: &quot;List Characters&quot;,
    description: &quot;Lists ALL characters in the database.&quot;,
    responses: [
      ok: {
        &quot;List of characters&quot;,
        &quot;application/json&quot;,
        @characters_index_response_schema
      }
    ]
  def index(conn, _params) do
    case WandererApp.Api.read(Character) do
      {:ok, characters} -&gt;
        result =
          characters
          |&gt; Enum.map(&amp;WandererAppWeb.MapEventHandler.map_ui_character_stat/1)

        json(conn, %{data: result})

      {:error, error} -&gt;
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: inspect(error)})
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/common_api_controller.ex">defmodule WandererAppWeb.CommonAPIController do
  use WandererAppWeb, :controller
  use OpenApiSpex.ControllerSpecs

  alias WandererApp.CachedInfo
  alias WandererAppWeb.Helpers.APIUtils

  @system_static_response_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      data: %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          solar_system_id: %OpenApiSpex.Schema{type: :integer},
          region_id: %OpenApiSpex.Schema{type: :integer},
          constellation_id: %OpenApiSpex.Schema{type: :integer},
          solar_system_name: %OpenApiSpex.Schema{type: :string},
          solar_system_name_lc: %OpenApiSpex.Schema{type: :string},
          constellation_name: %OpenApiSpex.Schema{type: :string},
          region_name: %OpenApiSpex.Schema{type: :string},
          system_class: %OpenApiSpex.Schema{type: :integer},
          security: %OpenApiSpex.Schema{type: :string},
          type_description: %OpenApiSpex.Schema{type: :string},
          class_title: %OpenApiSpex.Schema{type: :string},
          is_shattered: %OpenApiSpex.Schema{type: :boolean},
          effect_name: %OpenApiSpex.Schema{type: :string},
          effect_power: %OpenApiSpex.Schema{type: :integer},
          statics: %OpenApiSpex.Schema{type: :array, items: %OpenApiSpex.Schema{type: :string}},
          static_details: %OpenApiSpex.Schema{
            type: :array,
            items: %OpenApiSpex.Schema{
              type: :object,
              properties: %{
                name: %OpenApiSpex.Schema{type: :string},
                destination: %OpenApiSpex.Schema{
                  type: :object,
                  properties: %{
                    id: %OpenApiSpex.Schema{type: :string},
                    name: %OpenApiSpex.Schema{type: :string},
                    short_name: %OpenApiSpex.Schema{type: :string}
                  }
                },
                properties: %OpenApiSpex.Schema{
                  type: :object,
                  properties: %{
                    lifetime: %OpenApiSpex.Schema{type: :string},
                    max_mass: %OpenApiSpex.Schema{type: :integer},
                    max_jump_mass: %OpenApiSpex.Schema{type: :integer},
                    mass_regeneration: %OpenApiSpex.Schema{type: :integer}
                  }
                }
              }
            }
          },
          wandering: %OpenApiSpex.Schema{type: :array, items: %OpenApiSpex.Schema{type: :string}},
          triglavian_invasion_status: %OpenApiSpex.Schema{type: :string},
          sun_type_id: %OpenApiSpex.Schema{type: :integer}
        },
        required: [&quot;solar_system_id&quot;, &quot;solar_system_name&quot;]
      }
    },
    required: [&quot;data&quot;]
  }

  @doc &quot;&quot;&quot;
  GET /api/common/system-static-info?id=&lt;solar_system_id&gt;
  &quot;&quot;&quot;
  @spec show_system_static(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :show_system_static,
    summary: &quot;Get System Static Information&quot;,
    description: &quot;Retrieves static information for a given solar system.&quot;,
    parameters: [
      id: [
        in: :query,
        description: &quot;Solar system ID&quot;,
        type: :string,
        example: &quot;30000142&quot;,
        required: true
      ]
    ],
    responses: [
      ok: {
        &quot;System static info&quot;,
        &quot;application/json&quot;,
        @system_static_response_schema
      }
    ]
  def show_system_static(conn, params) do
    with {:ok, solar_system_str} &lt;- APIUtils.require_param(params, &quot;id&quot;),
         {:ok, solar_system_id} &lt;- APIUtils.parse_int(solar_system_str) do
      case CachedInfo.get_system_static_info(solar_system_id) do
        {:ok, system} -&gt;
          # Get basic system data
          data = static_system_to_json(system)

          # Enhance with wormhole type information if statics exist
          enhanced_data = enhance_with_static_details(data)

          # Return the enhanced data
          json(conn, %{data: enhanced_data})

        {:error, :not_found} -&gt;
          conn
          |&gt; put_status(:not_found)
          |&gt; json(%{error: &quot;System not found&quot;})
      end
    else
      {:error, msg} -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: msg})
    end
  end

  defp static_system_to_json(system) do
    system
    |&gt; Map.take([
      :solar_system_id,
      :region_id,
      :constellation_id,
      :solar_system_name,
      :solar_system_name_lc,
      :constellation_name,
      :region_name,
      :system_class,
      :security,
      :type_description,
      :class_title,
      :is_shattered,
      :effect_name,
      :effect_power,
      :statics,
      :wandering,
      :triglavian_invasion_status,
      :sun_type_id
    ])
  end

  defp enhance_with_static_details(data) do
    if data[:statics] &amp;&amp; length(data[:statics]) &gt; 0 do
      # Add the enhanced static details to the response
      Map.put(data, :static_details, get_static_details(data[:statics]))
    else
      # No statics, return the original data
      data
    end
  end

  defp get_static_details(statics) do
    # Get wormhole data from CachedInfo
    {:ok, wormhole_types} = CachedInfo.get_wormhole_types()
    wormhole_classes = CachedInfo.get_wormhole_classes!()

    # Create a map of wormhole classes by ID for quick lookup
    classes_by_id = Enum.reduce(wormhole_classes, %{}, fn class, acc -&gt;
      Map.put(acc, class.id, class)
    end)

    # Find detailed information for each static
    Enum.map(statics, fn static_name -&gt;
      # Find the wormhole type by name
      wh_type = Enum.find(wormhole_types, fn type -&gt; type.name == static_name end)

      if wh_type do
        create_wormhole_details(wh_type, classes_by_id)
      else
        create_fallback_wormhole_details(static_name)
      end
    end)
  end

  defp create_wormhole_details(wh_type, classes_by_id) do
    # Get destination class info
    dest_class = Map.get(classes_by_id, wh_type.dest)

    # Create enhanced static info
    %{
      name: wh_type.name,
      destination: %{
        id: to_string(wh_type.dest),
        name: (if dest_class, do: dest_class.title, else: wh_type.dest),
        short_name: (if dest_class, do: dest_class.short_name, else: wh_type.dest)
      },
      properties: %{
        lifetime: wh_type.lifetime,
        max_mass: wh_type.total_mass,
        max_jump_mass: wh_type.max_mass_per_jump,
        mass_regeneration: wh_type.mass_regen
      }
    }
  end

  defp create_fallback_wormhole_details(static_name) do
    %{
      name: static_name,
      destination: %{
        id: nil,
        name: &quot;Unknown&quot;,
        short_name: &quot;?&quot;
      },
      properties: %{
        lifetime: nil,
        max_mass: nil,
        max_jump_mass: nil,
        mass_regeneration: nil
      }
    }
  end
end</file><file path="lib/wanderer_app_web/controllers/error_html.ex">defmodule WandererAppWeb.ErrorHTML do
  use WandererAppWeb, :html

  # If you want to customize your error pages,
  # uncomment the embed_templates/1 call below
  # and add pages to the error directory:
  #
  #   * lib/wanderer_app_web/controllers/error_html/404.html.heex
  #   * lib/wanderer_app_web/controllers/error_html/500.html.heex
  #
  # embed_templates &quot;error_html/*&quot;

  # The default is to render a plain text page based on
  # the template name. For example, &quot;404.html&quot; becomes
  # &quot;Not Found&quot;.
  def render(template, _assigns) do
    Phoenix.Controller.status_message_from_template(template)
  end
end</file><file path="lib/wanderer_app_web/controllers/error_json.ex">defmodule WandererAppWeb.ErrorJSON do
  # If you want to customize a particular status code,
  # you may add your own clauses, such as:
  #
  # def render(&quot;500.json&quot;, _assigns) do
  #   %{errors: %{detail: &quot;Internal Server Error&quot;}}
  # end

  # By default, Phoenix returns the status message from
  # the template name. For example, &quot;404.json&quot; becomes
  # &quot;Not Found&quot;.
  def render(template, _assigns) do
    %{errors: %{detail: Phoenix.Controller.status_message_from_template(template)}}
  end
end</file><file path="lib/wanderer_app_web/controllers/fallback_controller.ex">defmodule WandererAppWeb.FallbackController do
  use WandererAppWeb, :controller

  alias WandererAppWeb.Helpers.APIUtils

  # Handles not_found errors from with/else
  def call(conn, {:error, :not_found}) do
    APIUtils.error_response(conn, :not_found, &quot;Not found&quot;, &quot;The requested resource could not be found&quot;)
  end

  # Handles invalid_id errors
  def call(conn, {:error, :invalid_id}) do
    APIUtils.error_response(conn, :bad_request, &quot;Invalid system ID&quot;)
  end

  # Handles invalid_coordinates_format errors
  def call(conn, {:error, :invalid_coordinates_format}) do
    APIUtils.error_response(conn, :bad_request, &quot;Invalid coordinates format. Use %{\&quot;coordinates\&quot; =&gt; %{\&quot;x\&quot; =&gt; number, \&quot;y\&quot; =&gt; number}}&quot;)
  end

  # Handles not_associated errors
  def call(conn, {:error, :not_associated}) do
    APIUtils.error_response(conn, :not_found, &quot;Connection not associated with specified system&quot;)
  end

  # Handles not_involved errors
  def call(conn, {:error, :not_involved}) do
    APIUtils.error_response(conn, :bad_request, &quot;Connection must involve specified system&quot;)
  end

  # Handles creation_failed errors
  def call(conn, {:error, :creation_failed}) do
    APIUtils.error_response(conn, :internal_server_error, &quot;Failed to create resource&quot;)
  end

  # Handles deletion_failed errors
  def call(conn, {:error, :deletion_failed}) do
    APIUtils.error_response(conn, :internal_server_error, &quot;Failed to delete resource&quot;)
  end

  # Handles any other {:error, message} returns
  def call(conn, {:error, msg}) when is_binary(msg) do
    APIUtils.error_response(conn, :bad_request, msg)
  end

  # Handles any other unmatched errors
  def call(conn, _error) do
    APIUtils.error_response(conn, :internal_server_error, &quot;An unexpected error occurred&quot;)
  end
end</file><file path="lib/wanderer_app_web/controllers/license_api_controller.ex">defmodule WandererAppWeb.LicenseApiController do
  @moduledoc &quot;&quot;&quot;
  Controller for the Bot License API.

  This controller provides endpoints for:
  - Creating new licenses for maps with active subscriptions
  - Updating license validity and expiration
  - Validating license keys

  All endpoints require proper authentication.
  &quot;&quot;&quot;

  use WandererAppWeb, :controller
  require Logger

  alias WandererApp.License.LicenseManager
  alias WandererApp.Api.License
  alias WandererApp.Api.Map

  @doc &quot;&quot;&quot;
  Creates a new license for a map.

  Requires LM_AUTH_KEY authentication.

  ## Request

  POST /api/licenses

  ```json
  {
    &quot;map_id&quot;: &quot;uuid-of-map&quot;
  }
  ```

  ## Response

  ```json
  {
    &quot;id&quot;: &quot;license-uuid&quot;,
    &quot;license_key&quot;: &quot;BOT-XXXXXXXXXXXX&quot;,
    &quot;is_valid&quot;: true,
    &quot;expire_at&quot;: &quot;2024-12-31T23:59:59Z&quot;,
    &quot;map_id&quot;: &quot;uuid-of-map&quot;
  }
  ```
  &quot;&quot;&quot;
  def create(conn, %{&quot;map_id&quot; =&gt; map_id}) do
    with {:ok, _map} &lt;- Map.by_id(map_id),
         {:ok, license} &lt;- LicenseManager.create_license_for_map(map_id) do
      conn
      |&gt; put_status(:created)
      |&gt; json(format_license(license))
    else
      {:error, :no_active_subscription} -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: &quot;Map does not have an active subscription&quot;})

      {:error, :not_found} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Map not found&quot;})

      {:error, reason} -&gt;
        Logger.error(&quot;Failed to create license: #{inspect(reason)}&quot;)
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: &quot;Failed to create license&quot;})
    end
  end

  def create(conn, _params) do
    conn
    |&gt; put_status(:bad_request)
    |&gt; json(%{error: &quot;Missing required parameter: map_id&quot;})
  end

  @doc &quot;&quot;&quot;
  Updates a license&apos;s validity status.

  Requires LM_AUTH_KEY authentication.

  ## Request

  PUT /api/licenses/:id/validity

  ```json
  {
    &quot;is_valid&quot;: true
  }
  ```

  ## Response

  ```json
  {
    &quot;id&quot;: &quot;license-uuid&quot;,
    &quot;license_key&quot;: &quot;BOT-XXXXXXXXXXXX&quot;,
    &quot;is_valid&quot;: true,
    &quot;expire_at&quot;: &quot;2024-12-31T23:59:59Z&quot;,
    &quot;map_id&quot;: &quot;uuid-of-map&quot;
  }
  ```
  &quot;&quot;&quot;
  def update_validity(conn, %{&quot;id&quot; =&gt; license_id, &quot;is_valid&quot; =&gt; is_valid}) do
    with {:ok, license} &lt;- License.by_id(license_id),
         {:ok, updated_license} &lt;- LicenseManager.invalidate_license(license_id) do
      conn
      |&gt; json(format_license(updated_license))
    else
      {:error, :not_found} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;License not found&quot;})

      {:error, reason} -&gt;
        Logger.error(&quot;Failed to update license validity: #{inspect(reason)}&quot;)
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: &quot;Failed to update license validity&quot;})
    end
  end

  def update_validity(conn, %{&quot;id&quot; =&gt; _license_id}) do
    conn
    |&gt; put_status(:bad_request)
    |&gt; json(%{error: &quot;Missing required parameter: is_valid&quot;})
  end

  @doc &quot;&quot;&quot;
  Updates a license&apos;s expiration date.

  Requires LM_AUTH_KEY authentication.

  ## Request

  PUT /api/licenses/:id/expiration

  ```json
  {
    &quot;expire_at&quot;: &quot;2024-12-31T23:59:59Z&quot;
  }
  ```

  ## Response

  ```json
  {
    &quot;id&quot;: &quot;license-uuid&quot;,
    &quot;license_key&quot;: &quot;BOT-XXXXXXXXXXXX&quot;,
    &quot;is_valid&quot;: true,
    &quot;expire_at&quot;: &quot;2024-12-31T23:59:59Z&quot;,
    &quot;map_id&quot;: &quot;uuid-of-map&quot;
  }
  ```
  &quot;&quot;&quot;
  def update_expiration(conn, %{&quot;id&quot; =&gt; license_id, &quot;expire_at&quot; =&gt; expire_at}) do
    with {:ok, _license} &lt;- License.by_id(license_id),
         {:ok, updated_license} &lt;- LicenseManager.update_expiration(license_id, expire_at) do
      conn
      |&gt; json(format_license(updated_license))
    else
      {:error, :not_found} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;License not found&quot;})

      {:error, reason} -&gt;
        Logger.error(&quot;Failed to update license expiration: #{inspect(reason)}&quot;)
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: &quot;Failed to update license expiration&quot;})
    end
  end

  def update_expiration(conn, %{&quot;id&quot; =&gt; _license_id}) do
    conn
    |&gt; put_status(:bad_request)
    |&gt; json(%{error: &quot;Missing required parameter: expire_at&quot;})
  end

  @doc &quot;&quot;&quot;
  Gets a license by map ID.

  Requires LM_AUTH_KEY authentication.

  ## Request

  GET /api/licenses/map/:map_id

  ## Response

  ```json
  {
    &quot;id&quot;: &quot;license-uuid&quot;,
    &quot;license_key&quot;: &quot;BOT-XXXXXXXXXXXX&quot;,
    &quot;is_valid&quot;: true,
    &quot;expire_at&quot;: &quot;2024-12-31T23:59:59Z&quot;,
    &quot;map_id&quot;: &quot;uuid-of-map&quot;
  }
  ```
  &quot;&quot;&quot;
  def get_by_map_id(conn, %{&quot;map_id&quot; =&gt; map_id}) do
    case LicenseManager.get_license_by_map_id(map_id) do
      {:ok, license} -&gt;
        conn
        |&gt; json(format_license(license))

      {:error, :license_not_found} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;No license found for this map&quot;})

      {:error, reason} -&gt;
        Logger.error(&quot;Failed to get license by map ID: #{inspect(reason)}&quot;)
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: &quot;Failed to get license&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  Validates a license key.

  Requires the license key as a Bearer token in the Authorization header.

  ## Request

  GET /api/license/validate

  ## Response

  ```json
  {
    &quot;license_valid&quot;: true,
    &quot;expire_at&quot;: &quot;2024-12-31T23:59:59Z&quot;,
    &quot;map_id&quot;: &quot;uuid-of-map&quot;
  }
  ```
  &quot;&quot;&quot;
  def validate(conn, _params) do
    license = conn.assigns.license

    conn
    |&gt; json(%{
      license_valid: license.is_valid,
      expire_at: license.expire_at,
      map_id: license.map_id
    })
  end

  # Helper to format license for JSON response
  defp format_license(license) do
    %{
      id: license.id,
      license_key: license.license_key,
      is_valid: license.is_valid,
      expire_at: license.expire_at,
      map_id: license.map_id
    }
  end
end</file><file path="lib/wanderer_app_web/controllers/map_api_controller.ex">defmodule WandererAppWeb.MapAPIController do
  use WandererAppWeb, :controller
  use OpenApiSpex.ControllerSpecs

  import Ash.Query, only: [filter: 2]
  require Logger

  alias WandererApp.Api.Character
  alias WandererApp.MapSystemRepo
  alias WandererApp.MapCharacterSettingsRepo
  alias WandererApp.MapConnectionRepo
  alias WandererApp.Zkb.KillsProvider.KillsCache
  alias WandererAppWeb.Helpers.APIUtils
  alias WandererAppWeb.Schemas.{ApiSchemas, ResponseSchemas}

  # -----------------------------------------------------------------
  # Schema Definitions
  # -----------------------------------------------------------------

  # Basic entity schemas
  @character_schema ApiSchemas.character_schema()

  # Character tracking schemas
  @character_tracking_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      id: %OpenApiSpex.Schema{type: :string},
      map_id: %OpenApiSpex.Schema{type: :string},
      character_id: %OpenApiSpex.Schema{type: :string},
      tracked: %OpenApiSpex.Schema{type: :boolean},
      inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
      updated_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
      character: @character_schema
    },
    required: [&quot;id&quot;, &quot;map_id&quot;, &quot;character_id&quot;, &quot;tracked&quot;]
  }

  @tracked_characters_response_schema ApiSchemas.data_wrapper(
    %OpenApiSpex.Schema{
      type: :array,
      items: @character_tracking_schema
    }
  )

  # Structure timer schemas
  @structure_timer_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      system_id: %OpenApiSpex.Schema{type: :string},
      solar_system_name: %OpenApiSpex.Schema{type: :string},
      solar_system_id: %OpenApiSpex.Schema{type: :integer},
      structure_type_id: %OpenApiSpex.Schema{type: :integer},
      structure_type: %OpenApiSpex.Schema{type: :string},
      character_eve_id: %OpenApiSpex.Schema{type: :string},
      name: %OpenApiSpex.Schema{type: :string},
      notes: %OpenApiSpex.Schema{type: :string},
      owner_name: %OpenApiSpex.Schema{type: :string},
      owner_ticker: %OpenApiSpex.Schema{type: :string},
      owner_id: %OpenApiSpex.Schema{type: :string},
      status: %OpenApiSpex.Schema{type: :string},
      end_time: %OpenApiSpex.Schema{type: :string, format: :date_time}
    },
    required: [&quot;system_id&quot;, &quot;solar_system_id&quot;, &quot;name&quot;, &quot;status&quot;]
  }

  @structure_timers_response_schema ApiSchemas.data_wrapper(
    %OpenApiSpex.Schema{
      type: :array,
      items: @structure_timer_schema
    }
  )

  # System kills schemas
  @kill_detail_schema %OpenApiSpex.Schema{
    type: :object,
    description: &quot;Kill detail object&quot;,
    properties: %{
      kill_id: %OpenApiSpex.Schema{type: :integer, description: &quot;Unique identifier for the kill&quot;},
      kill_time: %OpenApiSpex.Schema{type: :string, format: :date_time, description: &quot;Time when the kill occurred&quot;},
      victim_id: %OpenApiSpex.Schema{type: :integer, description: &quot;ID of the victim character&quot;},
      victim_name: %OpenApiSpex.Schema{type: :string, description: &quot;Name of the victim character&quot;},
      ship_type_id: %OpenApiSpex.Schema{type: :integer, description: &quot;Type ID of the destroyed ship&quot;},
      ship_name: %OpenApiSpex.Schema{type: :string, description: &quot;Name of the destroyed ship&quot;}
    }
  }

  @system_kills_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      solar_system_id: %OpenApiSpex.Schema{type: :integer},
      kills: %OpenApiSpex.Schema{
        type: :array,
        items: @kill_detail_schema
      }
    },
    required: [&quot;solar_system_id&quot;, &quot;kills&quot;]
  }

  @systems_kills_response_schema ApiSchemas.data_wrapper(
    %OpenApiSpex.Schema{
      type: :array,
      items: @system_kills_schema
    }
  )

  # Character activity schemas
  @character_activity_schema %OpenApiSpex.Schema{
    type: :object,
    description: &quot;Character activity data&quot;,
    properties: %{
      character: @character_schema,
      passages: %OpenApiSpex.Schema{type: :integer, description: &quot;Number of passages through systems&quot;},
      connections: %OpenApiSpex.Schema{type: :integer, description: &quot;Number of connections created&quot;},
      signatures: %OpenApiSpex.Schema{type: :integer, description: &quot;Number of signatures added&quot;},
      timestamp: %OpenApiSpex.Schema{type: :string, format: :date_time, description: &quot;Timestamp of the activity&quot;}
    },
    required: [&quot;character&quot;, &quot;passages&quot;, &quot;connections&quot;, &quot;signatures&quot;]
  }

  @character_activity_response_schema ApiSchemas.data_wrapper(
    %OpenApiSpex.Schema{
      type: :array,
      items: @character_activity_schema
    }
  )

  # User characters schemas
  @user_character_group_schema %OpenApiSpex.Schema{
    type: :object,
    description: &quot;Character group information with main character identification&quot;,
    properties: %{
      characters: %OpenApiSpex.Schema{
        type: :array,
        items: @character_schema,
        description: &quot;List of characters belonging to a user&quot;
      },
      main_character_eve_id: %OpenApiSpex.Schema{
        type: :string,
        description: &quot;EVE ID of the main character for this user on this map&quot;,
        nullable: true
      }
    },
    required: [&quot;characters&quot;]
  }

  @user_characters_response_schema ApiSchemas.data_wrapper(
    %OpenApiSpex.Schema{
      type: :array,
      items: @user_character_group_schema
    }
  )

  # Map connection schemas
  @map_connection_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      id: %OpenApiSpex.Schema{type: :string},
      map_id: %OpenApiSpex.Schema{type: :string},
      solar_system_source: %OpenApiSpex.Schema{type: :integer},
      solar_system_target: %OpenApiSpex.Schema{type: :integer},
      type: %OpenApiSpex.Schema{type: :integer},
      mass_status: %OpenApiSpex.Schema{type: :integer},
      time_status: %OpenApiSpex.Schema{type: :integer},
      ship_size_type: %OpenApiSpex.Schema{type: :integer},
      locked: %OpenApiSpex.Schema{type: :boolean},
      custom_info: %OpenApiSpex.Schema{type: :string, nullable: true}
    }
  }

  @map_connections_response_schema ApiSchemas.data_wrapper(
    %OpenApiSpex.Schema{
      type: :array,
      items: @map_connection_schema
    }
  )

  # -----------------------------------------------------------------
  # Helper functions for the API controller
  # -----------------------------------------------------------------

  defp get_map_id_by_slug(slug) do
    case WandererApp.Api.Map.get_map_by_slug(slug) do
      {:ok, map} -&gt; {:ok, map.id}
      {:error, error} -&gt; {:error, &quot;Map not found for slug: #{slug}, error: #{inspect(error)}&quot;}
    end
  end

  defp normalize_map_identifier(params) do
    case Map.get(params, &quot;map_identifier&quot;) do
      nil -&gt; params
      id -&gt;
        if Ecto.UUID.cast(id) == :error,
          do: Map.put(params, &quot;slug&quot;, id),
          else: Map.put(params, &quot;map_id&quot;, id)
    end
  end

  defp find_tracked_characters_by_map(map_id) do
    # Create a query to select tracked characters for the map and preload the character relationship
    query =
      WandererApp.Api.MapCharacterSettings
      |&gt; Ash.Query.filter(map_id == ^map_id and tracked == true)
      |&gt; Ash.Query.load(:character)

    case WandererApp.Api.read(query) do
      {:ok, settings} -&gt;
        # Format the settings to include character data
        formatted_settings = Enum.map(settings, fn setting -&gt;
          character_data =
            if Ash.Resource.loaded?(setting, :character) and not is_nil(setting.character) do
              WandererAppWeb.MapEventHandler.map_ui_character_stat(setting.character)
            else
              nil
            end

          # Extract only the fields we need for JSON serialization
          %{
            id: setting.id,
            map_id: setting.map_id,
            character_id: setting.character_id,
            tracked: setting.tracked,
            followed: setting.followed,
            inserted_at: setting.inserted_at,
            updated_at: setting.updated_at,
            character: character_data
          }
        end)

        {:ok, formatted_settings}
      {:error, error} -&gt; {:error, &quot;Could not fetch tracked characters: #{inspect(error)}&quot;}
    end
  end

  # -----------------------------------------------------------------
  # OpenAPI Operation Definitions
  # -----------------------------------------------------------------

  @doc &quot;&quot;&quot;
  GET /api/map/tracked-characters
  &quot;&quot;&quot;
  operation :list_tracked_characters,
    summary: &quot;List Tracked Characters&quot;,
    description: &quot;Lists all characters that are tracked on a specified map.&quot;,
    parameters: [
      slug: [
        in: :query,
        description: &quot;Map slug&quot;,
        type: :string,
        required: false
      ],
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID)&quot;,
        type: :string,
        required: false
      ]
    ],
    responses: [
      ok: ResponseSchemas.ok(@tracked_characters_response_schema, &quot;Tracked characters&quot;),
      bad_request: ResponseSchemas.bad_request(&quot;Must provide either ?map_id=UUID or ?slug=SLUG as a query parameter&quot;),
      internal_server_error: ResponseSchemas.internal_server_error()
    ]
  def list_tracked_characters(conn, params) do
    with {:ok, map_id} &lt;- APIUtils.fetch_map_id(params) do
      # Find tracked characters for this map
      case find_tracked_characters_by_map(map_id) do
        {:ok, formatted_settings} -&gt;
          # Return the formatted tracked characters
          json(conn, %{data: formatted_settings})

        {:error, reason} -&gt;
          Logger.error(&quot;Error listing tracked characters: #{APIUtils.format_error(reason)}&quot;)
          conn
          |&gt; put_status(:internal_server_error)
          |&gt; json(%{error: APIUtils.format_error(reason)})
      end
    else
      {:error, msg} -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: APIUtils.format_error(msg)})
    end
  end

  @doc &quot;&quot;&quot;
  GET /api/maps/{map_identifier}/tracked-characters
  &quot;&quot;&quot;
  operation :show_tracked_characters,
    summary: &quot;Show Tracked Characters for a Map&quot;,
    description: &quot;Lists all characters that are tracked on a specified map.&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug). Provide either a UUID or a slug.&quot;,
        type: :string,
        required: true,
        example: &quot;my-map-slug&quot;
      ]
    ],
    responses: [
      ok: ResponseSchemas.ok(@tracked_characters_response_schema, &quot;Tracked characters&quot;),
      bad_request: ResponseSchemas.bad_request(&quot;Map identifier is required&quot;),
      internal_server_error: ResponseSchemas.internal_server_error()
    ]
  def show_tracked_characters(%{assigns: %{map_id: map_id}} = conn, _params) do
    # Find tracked characters for this map
    case find_tracked_characters_by_map(map_id) do
      {:ok, formatted_settings} -&gt;
        # Return the formatted tracked characters
        json(conn, %{data: formatted_settings})

      {:error, reason} -&gt;
        Logger.error(&quot;Error listing tracked characters: #{APIUtils.format_error(reason)}&quot;)
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: APIUtils.format_error(reason)})
    end
  end

  @doc &quot;&quot;&quot;
  GET /api/map/structure-timers

  Returns structure timers for visible systems on the map or for a specific system.
  &quot;&quot;&quot;
  @spec show_structure_timers(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :show_structure_timers,
    summary: &quot;Show Structure Timers&quot;,
    description: &quot;Retrieves structure timers for a map.&quot;,
    deprecated: true,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ],
      system_id: [
        in: :query,
        description: &quot;Optional: System ID to filter timers for a specific system&quot;,
        type: :string,
        required: false
      ]
    ],
    responses: [
      ok: ResponseSchemas.ok(@structure_timers_response_schema, &quot;Structure timers&quot;),
      bad_request: ResponseSchemas.bad_request(&quot;Must provide either ?map_id=UUID or ?slug=SLUG as a query parameter&quot;),
      not_found: ResponseSchemas.not_found(&quot;System not found&quot;),
      internal_server_error: ResponseSchemas.internal_server_error()
    ]
  def show_structure_timers(conn, params) do
    with {:ok, map_id} &lt;- APIUtils.fetch_map_id(params) do
      system_id_str = params[&quot;system_id&quot;]

      case system_id_str do
        nil -&gt;
          handle_all_structure_timers(conn, map_id)

        _ -&gt;
          case APIUtils.parse_int(system_id_str) do
            {:ok, system_id} -&gt;
              handle_single_structure_timers(conn, map_id, system_id)

            {:error, reason} -&gt;
              conn
              |&gt; put_status(:bad_request)
              |&gt; json(%{error: &quot;system_id must be int: #{reason}&quot;})
          end
      end
    else
      {:error, msg} -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: msg})
    end
  end

  @doc &quot;&quot;&quot;
  GET /api/map/systems_kills

  Returns kills data for all *visible* systems on the map.
  &quot;&quot;&quot;
  @spec list_systems_kills(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :list_systems_kills,
    summary: &quot;List Systems Kills&quot;,
    description: &quot;Returns kills data for all visible systems on the map.&quot;,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ],
      hours: [
        in: :query,
        description: &quot;Number of hours to look back for kills&quot;,
        type: :string,
        required: false
      ]
    ],
    responses: [
      ok: ResponseSchemas.ok(@systems_kills_response_schema, &quot;Systems kills data&quot;),
      bad_request: ResponseSchemas.bad_request(&quot;Must provide either ?map_id=UUID or ?slug=SLUG as a query parameter&quot;),
      not_found: ResponseSchemas.not_found(&quot;Could not fetch systems&quot;)
    ]
  def list_systems_kills(conn, params) do
    with {:ok, map_id} &lt;- APIUtils.fetch_map_id(params),
         {:ok, systems} &lt;- MapSystemRepo.get_visible_by_map(map_id),
         {:ok, hours_ago} &lt;- parse_hours_ago(
           params[&quot;hours&quot;]      # documented name
           || params[&quot;hours_ago&quot;] # legacy fallback
           || params[&quot;hour_ago&quot;]  # legacy typo
         ) do
      solar_ids = Enum.map(systems, &amp; &amp;1.solar_system_id)
      kills_map = KillsCache.fetch_cached_kills_for_systems(solar_ids)

      data =
        Enum.map(systems, fn sys -&gt;
          kills = Map.get(kills_map, sys.solar_system_id, [])
          filtered_kills = maybe_filter_kills_by_time(kills, hours_ago)

          Logger.debug(fn -&gt;
            &quot;[list_systems_kills] For system_id=#{sys.solar_system_id}, &quot; &lt;&gt;
            &quot;found #{length(kills)} kills total, &quot; &lt;&gt;
            &quot;returning #{length(filtered_kills)} kills after hours_ago=#{inspect(hours_ago)} filter&quot;
          end)

          %{
            solar_system_id: sys.solar_system_id,
            kills: filtered_kills
          }
        end)

      json(conn, %{data: data})
    else
      {:error, msg} when is_binary(msg) -&gt;
        Logger.warning(&quot;[list_systems_kills] Bad request: #{msg}&quot;)
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: msg})

      {:error, reason} -&gt;
        Logger.error(&quot;[list_systems_kills] Could not fetch systems: #{inspect(reason)}&quot;)
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Could not fetch systems: #{inspect(reason)}&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  GET /api/map/character_activity

  Returns character activity data for a map.
  &quot;&quot;&quot;
  @spec character_activity(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :character_activity,
    summary: &quot;Get Character Activity&quot;,
    description: &quot;Returns character activity data for a map.&quot;,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ],
      days: [
        in: :query,
        description: &quot;Optional: Number of days to look back for activity data.&quot;,
        type: :integer,
        required: false
      ]
    ],
    responses: [
      ok: ResponseSchemas.ok(@character_activity_response_schema, &quot;Character activity data&quot;),
      bad_request: ResponseSchemas.bad_request(&quot;Must provide either ?map_id=UUID or ?slug=SLUG as a query parameter&quot;),
      internal_server_error: ResponseSchemas.internal_server_error()
    ]
  def character_activity(conn, params) do
    # Normalize params to make sure we handle both map_id and slug variations
    normalized_params = normalize_map_identifier(params)

    with {:ok, map_id} &lt;- APIUtils.fetch_map_id(normalized_params),
         {:ok, days} &lt;- parse_days(params[&quot;days&quot;]) do
      raw_activity = WandererApp.Map.get_character_activity(map_id, days)

      summarized_result =
        if raw_activity == [] do
          []
        else
          raw_activity
          |&gt; Enum.group_by(fn activity -&gt; activity.character.user_id end)
          |&gt; Enum.map(fn {_user_id, user_activities} -&gt;
            representative_activity =
              user_activities
              |&gt; Enum.max_by(fn act -&gt; act.passages + act.connections + act.signatures end)

            total_passages = Enum.sum(Enum.map(user_activities, &amp; &amp;1.passages))
            total_connections = Enum.sum(Enum.map(user_activities, &amp; &amp;1.connections))
            total_signatures = Enum.sum(Enum.map(user_activities, &amp; &amp;1.signatures))

            %{
              character: character_to_json(representative_activity.character),
              passages: total_passages,
              connections: total_connections,
              signatures: total_signatures,
              timestamp: representative_activity.timestamp
            }
          end)
        end

      json(conn, %{data: summarized_result})
    else
      {:error, msg} when is_binary(msg) -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: msg})

      {:error, reason} -&gt;
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: &quot;Could not fetch character activity: #{inspect(reason)}&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  GET /api/map/user_characters

  Returns characters grouped by user for a specific map.
  &quot;&quot;&quot;
  @spec user_characters(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :user_characters,
    summary: &quot;Get User Characters&quot;,
    description: &quot;Returns characters grouped by user for a specific map.&quot;,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ]
    ],
    responses: [
      ok: ResponseSchemas.ok(@user_characters_response_schema, &quot;User characters with main character indication&quot;),
      bad_request: ResponseSchemas.bad_request(&quot;Must provide either ?map_id=UUID or ?slug=SLUG as a query parameter&quot;),
      internal_server_error: ResponseSchemas.internal_server_error()
    ]
  def user_characters(conn, params) do
    with {:ok, map_id} &lt;- APIUtils.fetch_map_id(params) do
      fetch_and_format_user_characters(conn, map_id)
    else
      {:error, msg} when is_binary(msg) -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: msg})

      {:error, reason} -&gt;
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: &quot;Could not fetch user characters: #{inspect(reason)}&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  GET /api/maps/{map_identifier}/user-characters
  &quot;&quot;&quot;
  @spec show_user_characters(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :show_user_characters,
    summary: &quot;Show User Characters for a Map&quot;,
    description: &quot;Returns characters grouped by user for a specific map.&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug). Provide either a UUID or a slug.&quot;,
        type: :string,
        required: true,
        example: &quot;my-map-slug&quot;
      ]
    ],
    responses: [
      ok: ResponseSchemas.ok(@user_characters_response_schema, &quot;User characters with main character indication&quot;),
      internal_server_error: ResponseSchemas.internal_server_error()
    ]
  def show_user_characters(%{assigns: %{map_id: map_id}} = conn, _params) do
    fetch_and_format_user_characters(conn, map_id)
  end

  # Helper function to fetch and format user characters for a map
  defp fetch_and_format_user_characters(conn, map_id) do
    # Create a query to get all MapCharacterSettings for this map and preload characters
    settings_query =
      WandererApp.Api.MapCharacterSettings
      |&gt; Ash.Query.filter(map_id == ^map_id)
      |&gt; Ash.Query.load(:character)

    case WandererApp.Api.read(settings_query) do
      {:ok, map_character_settings} when map_character_settings != [] -&gt;
        # Extract characters and filter out those without a user_id
        characters =
          map_character_settings
          |&gt; Enum.map(&amp; &amp;1.character)
          |&gt; Enum.filter(fn char -&gt; char != nil &amp;&amp; not is_nil(char.user_id) end)

        if characters != [] do
          # Group characters by user_id
          characters_by_user = Enum.group_by(characters, &amp; &amp;1.user_id)

          # Get main character settings
          user_settings_query =
            WandererApp.Api.MapUserSettings
            |&gt; Ash.Query.new()
            |&gt; Ash.Query.filter(map_id == ^map_id)

          main_characters_by_user =
            case WandererApp.Api.read(user_settings_query) do
              {:ok, map_user_settings} -&gt;
                Map.new(map_user_settings, fn settings -&gt; {settings.user_id, settings.main_character_eve_id} end)
              _ -&gt; %{}
            end

          # Format the characters by user
          character_groups =
            Enum.map(characters_by_user, fn {user_id, user_characters} -&gt;
              formatted_characters = Enum.map(user_characters, fn char -&gt;
                character_to_json(char)
              end)

              %{
                characters: formatted_characters,
                main_character_eve_id: Map.get(main_characters_by_user, user_id)
              }
            end)

          json(conn, %{data: character_groups})
        else
          json(conn, %{data: []})
        end
      {:ok, []} -&gt; json(conn, %{data: []})
      {:error, reason} -&gt;
        Logger.error(&quot;Failed to fetch map character settings: #{inspect(reason)}&quot;)
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: &quot;Failed to fetch map character settings: #{inspect(reason)}&quot;})
    end
  end

  # --- Helpers for Structure Timers ---
  defp handle_all_structure_timers(conn, map_id) do
    case MapSystemRepo.get_visible_by_map(map_id) do
      {:ok, systems} -&gt;
        all_timers = systems |&gt; Enum.flat_map(&amp;get_timers_for_system/1)
        json(conn, %{data: all_timers})
      {:error, reason} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Could not fetch visible systems for map_id=#{map_id}: #{inspect(reason)}&quot;})
    end
  end

  defp handle_single_structure_timers(conn, map_id, system_id) do
    case MapSystemRepo.get_by_map_and_solar_system_id(map_id, system_id) do
      {:ok, map_system} -&gt;
        timers = get_timers_for_system(map_system)
        json(conn, %{data: timers})
      {:error, :not_found} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;No system with solar_system_id=#{system_id} in map=#{map_id}&quot;})
      {:error, reason} -&gt;
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: &quot;Failed to retrieve system: #{inspect(reason)}&quot;})
    end
  end

  defp get_timers_for_system(map_system) do
    structures = WandererApp.Api.MapSystemStructure.by_system_id!(map_system.id)

    structures
    |&gt; Enum.filter(&amp;timer_needed?/1)
    |&gt; Enum.map(&amp;structure_to_timer_json/1)
  end

  defp timer_needed?(structure) do
    structure.status in [&quot;Anchoring&quot;, &quot;Reinforced&quot;] and not is_nil(structure.end_time)
  end

  defp structure_to_timer_json(s) do
    Map.take(s, [
      :system_id,
      :solar_system_name,
      :solar_system_id,
      :structure_type_id,
      :structure_type,
      :character_eve_id,
      :name,
      :notes,
      :owner_name,
      :owner_ticker,
      :owner_id,
      :status,
      :end_time
    ])
  end

  # --- Helpers for System Kills ---
  defp parse_hours_ago(nil), do: {:ok, nil}
  defp parse_hours_ago(hours_str) do
    Logger.debug(fn -&gt; &quot;[parse_hours_ago] Parsing hours_str: #{inspect(hours_str)}&quot; end)
    case Integer.parse(hours_str) do
      {num, &quot;&quot;} when num &gt; 0 -&gt; {:ok, num}
      {0, &quot;&quot;} -&gt; {:ok, nil} # 0 means &quot;disable filtering&quot;
      _ -&gt; {:error, &quot;hours must be a positive integer&quot;}
    end
  end

  defp maybe_filter_kills_by_time(kills, hours_ago) when is_integer(hours_ago) do
    cutoff = DateTime.utc_now() |&gt; DateTime.add(-hours_ago * 3600, :second)
    Logger.debug(fn -&gt; &quot;[maybe_filter_kills_by_time] Filtering kills with cutoff: #{DateTime.to_iso8601(cutoff)}&quot; end)
    filtered = Enum.filter(kills, fn kill -&gt;
      kill_time = kill[&quot;kill_time&quot;]
      result = case kill_time do
        %DateTime{} = dt -&gt; DateTime.compare(dt, cutoff) != :lt
        time when is_binary(time) -&gt;
          case DateTime.from_iso8601(time) do
            {:ok, dt, _} -&gt; DateTime.compare(dt, cutoff) != :lt
            _ -&gt; false
          end
        _ -&gt; false
      end
      Logger.debug(fn -&gt;
        kill_time_str = if is_binary(kill_time), do: kill_time, else: inspect(kill_time)
        &quot;[maybe_filter_kills_by_time] Kill time: #{kill_time_str}, included: #{result}&quot;
      end)
      result
    end)
    filtered
  end

  defp maybe_filter_kills_by_time(kills, nil), do: kills

  # --- Helpers for Character Activity ---
  defp parse_days(nil), do: {:ok, nil}
  defp parse_days(days_str) do
    case Integer.parse(days_str) do
      {days, &quot;&quot;} when days &gt; 0 -&gt; {:ok, days}
      _ -&gt; {:error, &quot;days must be a positive integer&quot;}
    end
  end

  # --- JSON Formatting Helpers ---
  defp character_to_json(nil), do: nil
  defp character_to_json(ch) do
    WandererAppWeb.MapEventHandler.map_ui_character_stat(ch)
  end

  @doc &quot;&quot;&quot;
  GET /api/map/connections

  Requires either `?map_id=&lt;UUID&gt;` **OR** `?slug=&lt;map-slug&gt;` in the query params.
  &quot;&quot;&quot;
  @spec list_connections(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation :list_connections,
    summary: &quot;List Map Connections&quot;,
    description: &quot;Lists all connections for a map. Requires either &apos;map_id&apos; or &apos;slug&apos; as a query parameter to identify the map.&quot;,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ]
    ],
    responses: [
      ok: ResponseSchemas.ok(@map_connections_response_schema, &quot;List of map connections&quot;),
      bad_request: ResponseSchemas.bad_request(&quot;Must provide either ?map_id=UUID or ?slug=SLUG&quot;),
      not_found: ResponseSchemas.not_found(&quot;Could not fetch connections&quot;)
    ]
  def list_connections(conn, params) do
    with {:ok, map_id} &lt;- APIUtils.fetch_map_id(params),
          {:ok, connections} &lt;- MapConnectionRepo.get_by_map(map_id) do
      data = Enum.map(connections, &amp;APIUtils.connection_to_json/1)
      json(conn, %{data: data})
    else
      {:error, msg} when is_binary(msg) -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: msg})

      {:error, reason} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Could not fetch connections: #{APIUtils.format_error(reason)}&quot;})
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/map_audit_api_controller.ex">defmodule WandererAppWeb.MapAuditAPIController do
  use WandererAppWeb, :controller
  use OpenApiSpex.ControllerSpecs

  require Logger

  alias WandererApp.Api

  alias WandererAppWeb.Helpers.APIUtils

  # -----------------------------------------------------------------
  # Inline Schemas
  # -----------------------------------------------------------------

  @character_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      eve_id: %OpenApiSpex.Schema{type: :string},
      name: %OpenApiSpex.Schema{type: :string},
      corporation_id: %OpenApiSpex.Schema{type: :string},
      corporation_ticker: %OpenApiSpex.Schema{type: :string},
      alliance_id: %OpenApiSpex.Schema{type: :string},
      alliance_ticker: %OpenApiSpex.Schema{type: :string}
    },
    required: [&quot;eve_id&quot;, &quot;name&quot;]
  }

  @map_audit_event_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      entity_type: %OpenApiSpex.Schema{type: :string},
      event_name: %OpenApiSpex.Schema{type: :string},
      event_data: %OpenApiSpex.Schema{type: :string},
      character: @character_schema,
      inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time}
    },
    required: [&quot;entity_type&quot;, &quot;event_name&quot;, &quot;event_data&quot;, &quot;inserted_at&quot;]
  }

  @map_audit_response_schema %OpenApiSpex.Schema{
    type: :object,
    properties: %{
      data: %OpenApiSpex.Schema{
        type: :array,
        items: @map_audit_event_schema
      }
    },
    required: [&quot;data&quot;]
  }

  # -----------------------------------------------------------------
  # MAP endpoints
  # -----------------------------------------------------------------

  @doc &quot;&quot;&quot;
  GET /api/map/audit

  Requires either `?map_id=&lt;UUID&gt;` **OR** `?slug=&lt;map-slug&gt;` in the query params.

  Examples:
      GET /api/map/audit?map_id=466e922b-e758-485e-9b86-afae06b88363&amp;period=1H
      GET /api/map/audit?slug=my-unique-wormhole-map&amp;period=1H
  &quot;&quot;&quot;
  @spec index(Plug.Conn.t(), map()) :: Plug.Conn.t()
  operation(:index,
    summary: &quot;List Map Audit events&quot;,
    description:
      &quot;Lists all audit events for a map. Requires either &apos;map_id&apos; or &apos;slug&apos; as a query parameter to identify the map.&quot;,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false,
        example: &quot;&quot;
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Either map_id or slug must be provided&quot;,
        type: :string,
        required: false,
        example: &quot;map-name&quot;
      ],
      period: [
        in: :query,
        description: &quot;Activity period (1H, 1D, 1W, 1M, 2M, 3M)&quot;,
        type: :string,
        required: true,
        example: &quot;1D&quot;
      ]
    ],
    responses: [
      ok: {
        &quot;List of map audit events&quot;,
        &quot;application/json&quot;,
        @map_audit_response_schema
      },
      bad_request:
        {&quot;Error&quot;, &quot;application/json&quot;,
         %OpenApiSpex.Schema{
           type: :object,
           properties: %{
             error: %OpenApiSpex.Schema{type: :string}
           },
           required: [&quot;error&quot;],
           example: %{
             &quot;error&quot; =&gt; &quot;Must provide either ?map_id=UUID or ?slug=SLUG&quot;
           }
         }}
    ]
  )

  def index(conn, params) do
    with {:ok, map_id} &lt;- APIUtils.fetch_map_id(params),
         {:ok, period} &lt;- APIUtils.require_param(params, &quot;period&quot;),
         query &lt;- WandererApp.Map.Audit.get_activity_query(map_id, period, &quot;all&quot;),
         {:ok, data} &lt;-
           Api.read(query) do
      data = Enum.map(data, &amp;map_audit_event_to_json/1)
      json(conn, %{data: data})
    else
      {:error, msg} when is_binary(msg) -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: msg})

      {:error, reason} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Request failed: #{inspect(reason)}&quot;})
    end
  end

  defp map_audit_event_to_json(
         %{event_type: event_type, event_data: event_data, character: character} = event
       ) do
    # Start with the basic system data
    result =
      Map.take(event, [
        :entity_type,
        :inserted_at
      ])

    result
    |&gt; Map.put(:character, WandererAppWeb.MapEventHandler.map_ui_character_stat(character))
    |&gt; Map.put(:event_name, WandererAppWeb.UserActivity.get_event_name(event_type))
    |&gt; Map.put(
      :event_data,
      WandererAppWeb.UserActivity.get_event_data(
        event_type,
        Jason.decode!(event_data) |&gt; Map.drop([&quot;character_id&quot;])
      )
    )
  end
end</file><file path="lib/wanderer_app_web/controllers/map_connection_api_controller.ex"># lib/wanderer_app_web/controllers/map_connection_api_controller.ex
defmodule WandererAppWeb.MapConnectionAPIController do
  @moduledoc &quot;&quot;&quot;
  API controller for managing map connections.
  Provides operations to list, show, create, delete, and batch-delete connections, with legacy routing support.
  &quot;&quot;&quot;

  use WandererAppWeb, :controller
  use OpenApiSpex.ControllerSpecs

  require Logger

  alias OpenApiSpex.Schema
  alias WandererApp.Map, as: MapData
  alias WandererApp.Map.Operations
  alias WandererAppWeb.Helpers.APIUtils
  alias WandererAppWeb.Schemas.ResponseSchemas

  action_fallback WandererAppWeb.FallbackController

  # -- JSON Schemas --
  @connection_request_schema %Schema{
    type: :object,
    properties: %{
      solar_system_source: %Schema{type: :integer, description: &quot;Source system ID&quot;},
      solar_system_target: %Schema{type: :integer, description: &quot;Target system ID&quot;},
      type: %Schema{type: :integer, description: &quot;Connection type (default 0)&quot;},
      mass_status: %Schema{type: :integer, description: &quot;Mass status (0-3)&quot;, nullable: true},
      time_status: %Schema{type: :integer, description: &quot;Time status (0-3)&quot;, nullable: true},
      ship_size_type: %Schema{type: :integer, description: &quot;Ship size limit (0-3)&quot;, nullable: true},
      locked: %Schema{type: :boolean, description: &quot;Locked flag&quot;, nullable: true},
      custom_info: %Schema{type: :string, nullable: true, description: &quot;Optional metadata&quot;},
      wormhole_type: %Schema{type: :string, nullable: true, description: &quot;Wormhole code&quot;}
    },
    required: ~w(solar_system_source solar_system_target)a,
    example: %{
      solar_system_source: 30_000_142,
      solar_system_target: 30_000_144,
      type: 0,
      mass_status: 1,
      time_status: 2,
      ship_size_type: 1,
      locked: false,
      custom_info: &quot;Frigate only&quot;,
      wormhole_type: &quot;C2&quot;
    }
  }

  @list_response_schema %Schema{
    type: :object,
    properties: %{
      data: %Schema{
        type: :array,
        items: %Schema{
          type: :object,
          properties: %{
            id: %Schema{type: :string},
            map_id: %Schema{type: :string},
            solar_system_source: %Schema{type: :integer},
            solar_system_target: %Schema{type: :integer},
            type: %Schema{type: :integer},
            mass_status: %Schema{type: :integer},
            time_status: %Schema{type: :integer},
            ship_size_type: %Schema{type: :integer},
            locked: %Schema{type: :boolean},
            custom_info: %Schema{type: :string, nullable: true},
            wormhole_type: %Schema{type: :string, nullable: true}
          }
        }
      }
    },
    example: %{
      data: [
        %{
          id: &quot;conn-uuid-1&quot;,
          map_id: &quot;map-uuid-1&quot;,
          solar_system_source: 30_000_142,
          solar_system_target: 30_000_144,
          type: 0,
          mass_status: 1,
          time_status: 2,
          ship_size_type: 1,
          locked: false,
          custom_info: &quot;Frigate only&quot;,
          wormhole_type: &quot;C2&quot;
        }
      ]
    }
  }

  @detail_response_schema %Schema{
    type: :object,
    properties: %{
      data: %Schema{
        type: :object,
        properties: %{
          id: %Schema{type: :string},
          map_id: %Schema{type: :string},
          solar_system_source: %Schema{type: :integer},
          solar_system_target: %Schema{type: :integer},
          type: %Schema{type: :integer},
          mass_status: %Schema{type: :integer},
          time_status: %Schema{type: :integer},
          ship_size_type: %Schema{type: :integer},
          locked: %Schema{type: :boolean},
          custom_info: %Schema{type: :string, nullable: true},
          wormhole_type: %Schema{type: :string, nullable: true}
        }
      }
    },
    example: %{
      data: %{
        id: &quot;conn-uuid-1&quot;,
        map_id: &quot;map-uuid-1&quot;,
        solar_system_source: 30_000_142,
        solar_system_target: 30_000_144,
        type: 0,
        mass_status: 1,
        time_status: 2,
        ship_size_type: 1,
        locked: false,
        custom_info: &quot;Frigate only&quot;,
        wormhole_type: &quot;C2&quot;
      }
    }
  }

  # -- Actions --

  operation :index,
    summary: &quot;List Map Connections&quot;,
    description: &quot;Lists all connections for a map.&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ],
      solar_system_source: [
        in: :query,
        description: &quot;Filter connections by source system ID&quot;,
        type: :integer,
        required: false,
        example: 30000142
      ],
      solar_system_target: [
        in: :query,
        description: &quot;Filter connections by target system ID&quot;,
        type: :integer,
        required: false,
        example: 30000144
      ]
    ],
    responses: [
      ok: {
        &quot;List of Map Connections&quot;,
        &quot;application/json&quot;,
        @list_response_schema
      },
      not_found: {&quot;Error&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          error: %OpenApiSpex.Schema{type: :string}
        },
        required: [&quot;error&quot;],
        example: %{
          &quot;error&quot; =&gt; &quot;Map not found&quot;
        }
      }}
    ]
  def index(%{assigns: %{map_id: map_id}} = conn, params) do
    with {:ok, src_filter} &lt;- parse_optional(params, &quot;solar_system_source&quot;),
         {:ok, tgt_filter} &lt;- parse_optional(params, &quot;solar_system_target&quot;) do
      conns = MapData.list_connections!(map_id)
      conns =
        conns
        |&gt; filter_by_source(src_filter)
        |&gt; filter_by_target(tgt_filter)
      data = Enum.map(conns, &amp;APIUtils.connection_to_json/1)
      APIUtils.respond_data(conn, data)
    else
      {:error, msg} when is_binary(msg) -&gt;
        conn
        |&gt; Plug.Conn.put_status(:bad_request)
        |&gt; APIUtils.error_response(:bad_request, msg)
      {:error, _} -&gt;
        conn
        |&gt; Plug.Conn.put_status(:bad_request)
        |&gt; APIUtils.error_response(:bad_request, &quot;Invalid filter parameter&quot;)
    end
  end

  defp parse_optional(params, key) do
    case Map.get(params, key) do
      nil -&gt; {:ok, nil}
      val -&gt; APIUtils.parse_int(val)
    end
  end

  defp filter_by_source(conns, nil), do: conns
  defp filter_by_source(conns, s),   do: Enum.filter(conns, &amp;(&amp;1.solar_system_source == s))

  defp filter_by_target(conns, nil), do: conns
  defp filter_by_target(conns, t),   do: Enum.filter(conns, &amp;(&amp;1.solar_system_target == t))

  operation :show,
    summary: &quot;Show Connection (by id or by source/target)&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ],
      id: [in: :path, type: :string, required: false],
      solar_system_source: [in: :query, type: :integer, required: false],
      solar_system_target: [in: :query, type: :integer, required: false]
    ],
    responses: ResponseSchemas.standard_responses(@detail_response_schema)
  def show(%{assigns: %{map_id: map_id}} = conn, %{&quot;id&quot; =&gt; id}) do
    case Operations.get_connection(map_id, id) do
      {:ok, conn_struct} -&gt; APIUtils.respond_data(conn, APIUtils.connection_to_json(conn_struct))
      err -&gt; err
    end
  end
  def show(%{assigns: %{map_id: map_id}} = conn, %{&quot;solar_system_source&quot; =&gt; src, &quot;solar_system_target&quot; =&gt; tgt}) do
    with {:ok, source} &lt;- APIUtils.parse_int(src),
         {:ok, target} &lt;- APIUtils.parse_int(tgt),
         {:ok, conn_struct} &lt;- Operations.get_connection_by_systems(map_id, source, target) do
      APIUtils.respond_data(conn, APIUtils.connection_to_json(conn_struct))
    else
      err -&gt; err
    end
  end

  operation :create,
    summary: &quot;Create Connection&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ]
    ],
    request_body: {&quot;Connection create&quot;, &quot;application/json&quot;, @connection_request_schema},
    responses: ResponseSchemas.create_responses(@detail_response_schema)
  def create(conn, params) do
    case Operations.create_connection(conn, params) do
      {:ok, conn_struct} when is_map(conn_struct) -&gt;
        conn
        |&gt; APIUtils.respond_data(APIUtils.connection_to_json(conn_struct), :created)
      {:ok, :created} -&gt;
        conn
        |&gt; put_status(:created)
        |&gt; json(%{data: %{result: &quot;created&quot;}})
      {:skip, :exists} -&gt;
        conn
        |&gt; put_status(:ok)
        |&gt; json(%{data: %{result: &quot;exists&quot;}})
      {:error, reason} -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; json(%{error: reason})
      _other -&gt;
        conn
        |&gt; put_status(:internal_server_error)
        |&gt; json(%{error: &quot;Unexpected error&quot;})
    end
  end

  operation :delete,
    summary: &quot;Delete Connection (by id or by source/target)&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ],
      id: [in: :path, type: :string, required: false],
      solar_system_source: [in: :query, type: :integer, required: false],
      solar_system_target: [in: :query, type: :integer, required: false]
    ],
    responses: ResponseSchemas.delete_responses(nil)
  def delete(%{assigns: %{map_id: _map_id}} = conn, %{&quot;id&quot; =&gt; id}) do
    delete_connection_id(conn, id)
  end

  def delete(%{assigns: %{map_id: _map_id}} = conn, %{&quot;solar_system_source&quot; =&gt; src, &quot;solar_system_target&quot; =&gt; tgt}) do
    delete_by_systems(conn, src, tgt)
  end

  # Private helpers for delete/2

  defp delete_connection_id(conn, id) do
    case Operations.get_connection(conn, id) do
      {:ok, conn_struct} -&gt;
        source_id = conn_struct.solar_system_source
        target_id = conn_struct.solar_system_target
        case Operations.delete_connection(conn, source_id, target_id) do
          :ok -&gt; {:ok, conn_struct}
          error -&gt; error
        end
      _ -&gt; {:error, :invalid_id}
    end
  end

  defp delete_by_systems(conn, src, tgt) do
    with {:ok, source} &lt;- APIUtils.parse_int(src),
         {:ok, target} &lt;- APIUtils.parse_int(tgt) do
      do_delete_by_systems(conn, source, target, src, tgt)
    else
      {:error, :not_found} -&gt;
        Logger.error(&quot;[delete_connection] Connection not found for source=#{inspect(src)}, target=#{inspect(tgt)}&quot;)
        {:error, :not_found}
      {:error, reason} -&gt;
        Logger.error(&quot;[delete_connection] Error: #{inspect(reason)}&quot;)
        {:error, reason}
      error -&gt;
        Logger.error(&quot;[delete_connection] Unexpected error: #{inspect(error)}&quot;)
        {:error, :internal_server_error}
    end
  end

  defp do_delete_by_systems(conn, source, target, src, tgt) do
    map_id = conn.assigns.map_id
    case Operations.get_connection_by_systems(map_id, source, target) do
      {:ok, nil} -&gt;
        Logger.error(&quot;[delete_connection] No connection found for source=#{inspect(source)}, target=#{inspect(target)}&quot;)
        try_reverse_delete(conn, source, target, src, tgt)
      {:ok, conn_struct} -&gt;
        case Operations.delete_connection(conn, conn_struct.solar_system_source, conn_struct.solar_system_target) do
          :ok -&gt; send_resp(conn, :no_content, &quot;&quot;)
          error -&gt; {:error, error}
        end
      {:error, _} -&gt;
        try_reverse_delete(conn, source, target, src, tgt)
    end
  end

  defp try_reverse_delete(conn, source, target, src, tgt) do
    map_id = conn.assigns.map_id
    case Operations.get_connection_by_systems(map_id, target, source) do
      {:ok, nil} -&gt;
        Logger.error(&quot;[delete_connection] No connection found for source=#{inspect(target)}, target=#{inspect(source)}&quot;)
        {:error, :not_found}
      {:ok, conn_struct} -&gt;
        case Operations.delete_connection(conn, conn_struct.solar_system_source, conn_struct.solar_system_target) do
          :ok -&gt; send_resp(conn, :no_content, &quot;&quot;)
          error -&gt; {:error, error}
        end
      {:error, reason} -&gt;
        Logger.error(&quot;[delete_connection] Connection not found for source=#{inspect(src)}, target=#{inspect(tgt)} (both orders)&quot;)
        {:error, reason}
    end
  end

  operation :update,
    summary: &quot;Update Connection (by id or by source/target)&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ],
      id: [in: :path, type: :string, required: false],
      solar_system_source: [in: :query, type: :integer, required: false],
      solar_system_target: [in: :query, type: :integer, required: false]
    ],
    request_body: {&quot;Connection update&quot;, &quot;application/json&quot;, @connection_request_schema},
    responses: ResponseSchemas.standard_responses(@detail_response_schema)
  def update(%{assigns: %{map_id: map_id}} = conn, %{&quot;id&quot; =&gt; id}) do
    allowed_fields = [&quot;mass_status&quot;, &quot;ship_size_type&quot;, &quot;locked&quot;, &quot;custom_info&quot;, &quot;type&quot;]
    attrs =
      conn.body_params
      |&gt; Map.take(allowed_fields)
      |&gt; Enum.reject(fn {_k, v} -&gt; is_nil(v) end)
      |&gt; Enum.into(%{})
    update_by_id(conn, map_id, id, attrs)
  end

  def update(%{assigns: %{map_id: map_id}} = conn, %{&quot;solar_system_source&quot; =&gt; src, &quot;solar_system_target&quot; =&gt; tgt}) do
    allowed_fields = [&quot;mass_status&quot;, &quot;ship_size_type&quot;, &quot;locked&quot;, &quot;custom_info&quot;, &quot;type&quot;]
    attrs =
      conn.body_params
      |&gt; Map.take(allowed_fields)
      |&gt; Enum.reject(fn {_k, v} -&gt; is_nil(v) end)
      |&gt; Enum.into(%{})
    update_by_systems(conn, map_id, src, tgt, attrs)
  end

  # Private helpers for update/2

  defp update_by_id(conn, _map_id, id, attrs) do
    case Operations.update_connection(conn, id, attrs) do
      {:ok, updated_conn} -&gt; APIUtils.respond_data(conn, APIUtils.connection_to_json(updated_conn))
      err -&gt; err
    end
  end

  defp update_by_systems(conn, _map_id, src, tgt, attrs) do
    require Logger
    with {:ok, source} &lt;- APIUtils.parse_int(src),
         {:ok, target} &lt;- APIUtils.parse_int(tgt) do
      do_update_by_systems(conn, source, target, src, tgt, attrs)
    else
      {:error, :not_found} -&gt;
        Logger.error(&quot;[update_connection] Connection not found for source=#{inspect(src)}, target=#{inspect(tgt)}&quot;)
        {:error, :not_found}
      {:error, reason} -&gt;
        Logger.error(&quot;[update_connection] Error: #{inspect(reason)}&quot;)
        {:error, reason}
      error -&gt;
        Logger.error(&quot;[update_connection] Unexpected error: #{inspect(error)}&quot;)
        {:error, :internal_server_error}
    end
  end

  defp do_update_by_systems(conn, source, target, src, tgt, attrs) do
    map_id = conn.assigns.map_id
    case Operations.get_connection_by_systems(map_id, source, target) do
      {:ok, nil} -&gt;
        Logger.error(&quot;[update_connection] No connection found for source=#{inspect(source)}, target=#{inspect(target)}&quot;)
        try_reverse_update(conn, source, target, src, tgt, attrs)
      {:ok, conn_struct} -&gt;
        do_update_connection(conn, conn_struct.id, attrs)
      {:error, _} -&gt;
        try_reverse_update(conn, source, target, src, tgt, attrs)
    end
  end

  defp try_reverse_update(conn, source, target, src, tgt, attrs) do
    map_id = conn.assigns.map_id
    case Operations.get_connection_by_systems(map_id, target, source) do
      {:ok, nil} -&gt;
        Logger.error(&quot;[update_connection] No connection found for source=#{inspect(target)}, target=#{inspect(source)}&quot;)
        {:error, :not_found}
      {:ok, conn_struct} -&gt;
        do_update_connection(conn, conn_struct.id, attrs)
      {:error, reason} -&gt;
        Logger.error(&quot;[update_connection] Connection not found for source=#{inspect(src)}, target=#{inspect(tgt)} (both orders)&quot;)
        {:error, reason}
    end
  end

  defp do_update_connection(conn, id, attrs) do
    case Operations.update_connection(conn, id, attrs) do
      {:ok, updated_conn} -&gt; APIUtils.respond_data(conn, APIUtils.connection_to_json(updated_conn))
      {:error, %Ash.Error.Invalid{errors: [%Ash.Error.Query.NotFound{} | _]}} -&gt;
        Logger.error(&quot;[update_connection] Ash update NotFound for id=#{id}&quot;)
        {:error, :not_found}
      err -&gt; err
    end
  end

  @deprecated &quot;Use GET /api/maps/:map_identifier/systems instead&quot;
  operation :list_all_connections,
    summary: &quot;List All Connections (Legacy)&quot;,
    description: &quot;Legacy endpoint for listing connections. Use GET /api/maps/:map_identifier/connections instead. Requires exactly one of map_id or slug as a query parameter. If both are provided, a 400 Bad Request will be returned.&quot;,
    deprecated: true,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Exactly one of map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Exactly one of map_id or slug must be provided&quot;,
        type: :string,
        required: false
      ]
    ],
    responses: [
      ok: {
        &quot;List of Map Connections&quot;,
        &quot;application/json&quot;,
        @list_response_schema
      },
      bad_request: {&quot;Error&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          error: %OpenApiSpex.Schema{type: :string}
        },
        required: [&quot;error&quot;],
        example: %{
          &quot;error&quot; =&gt; &quot;Must provide exactly one of map_id or slug as a query parameter&quot;
        }
      }},
      not_found: {&quot;Error&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
        type: :object,
        properties: %{
          error: %OpenApiSpex.Schema{type: :string}
        },
        required: [&quot;error&quot;],
        example: %{
          &quot;error&quot; =&gt; &quot;Map not found. Please provide a valid map_id or slug as a query parameter.&quot;
        }
      }}
    ]
  def list_all_connections(%{assigns: %{map_id: map_id}} = conn, _params) do
    connections = Operations.list_connections(map_id)
    data = Enum.map(connections, &amp;APIUtils.connection_to_json/1)
    APIUtils.respond_data(conn, data)
  end
end</file><file path="lib/wanderer_app_web/controllers/map_system_api_controller.ex"># lib/wanderer_app_web/controllers/map_system_api_controller.ex
defmodule WandererAppWeb.MapSystemAPIController do
  @moduledoc &quot;&quot;&quot;
  API controller for managing map systems and their associated connections.
  Provides CRUD operations and batch upsert for systems and connections.
  &quot;&quot;&quot;

  use WandererAppWeb, :controller
  use OpenApiSpex.ControllerSpecs

  alias OpenApiSpex.Schema
  alias WandererApp.Map.Operations
  alias WandererAppWeb.Helpers.APIUtils
  alias WandererAppWeb.Schemas.{ApiSchemas, ResponseSchemas}

  action_fallback WandererAppWeb.FallbackController

  # -- JSON Schemas --
  @map_system_schema %Schema{
    type: :object,
    properties: %{
      id: %Schema{type: :string, description: &quot;Map system UUID&quot;},
      map_id: %Schema{type: :string, description: &quot;Map UUID&quot;},
      solar_system_id: %Schema{type: :integer, description: &quot;EVE solar system ID&quot;},
      solar_system_name: %Schema{type: :string, description: &quot;EVE solar system name&quot;},
      region_name: %Schema{type: :string, description: &quot;EVE region name&quot;},
      position_x: %Schema{type: :integer, description: &quot;X coordinate&quot;},
      position_y: %Schema{type: :integer, description: &quot;Y coordinate&quot;},
      status: %Schema{
        type: :integer,
        description: &quot;System status (0: unknown, 1: friendly, 2: warning, 3: targetPrimary, 4: targetSecondary, 5: dangerousPrimary, 6: dangerousSecondary, 7: lookingFor, 8: home)&quot;
      },
      visible: %Schema{type: :boolean, description: &quot;Visibility flag&quot;},
      description: %Schema{type: :string, nullable: true, description: &quot;Custom description&quot;},
      tag: %Schema{type: :string, nullable: true, description: &quot;Custom tag&quot;},
      locked: %Schema{type: :boolean, description: &quot;Lock flag&quot;},
      temporary_name: %Schema{type: :string, nullable: true, description: &quot;Temporary name&quot;},
      labels: %Schema{type: :string, description: &quot;Comma-separated list of labels&quot;}
    },
    required: ~w(id map_id solar_system_id)a
  }

  @system_request_schema %Schema{
    type: :object,
    properties: %{
      solar_system_id: %Schema{type: :integer, description: &quot;EVE solar system ID&quot;},
      solar_system_name: %Schema{type: :string, description: &quot;EVE solar system name&quot;},
      position_x: %Schema{type: :integer, description: &quot;X coordinate&quot;},
      position_y: %Schema{type: :integer, description: &quot;Y coordinate&quot;},
      status: %Schema{
        type: :integer,
        description: &quot;System status (0: unknown, 1: friendly, 2: warning, 3: targetPrimary, 4: targetSecondary, 5: dangerousPrimary, 6: dangerousSecondary, 7: lookingFor, 8: home)&quot;
      },
      visible: %Schema{type: :boolean, description: &quot;Visibility flag&quot;},
      description: %Schema{type: :string, nullable: true, description: &quot;Custom description&quot;},
      tag: %Schema{type: :string, nullable: true, description: &quot;Custom tag&quot;},
      locked: %Schema{type: :boolean, description: &quot;Lock flag&quot;},
      temporary_name: %Schema{type: :string, nullable: true, description: &quot;Temporary name&quot;},
      labels: %Schema{type: :string, description: &quot;Comma-separated list of labels&quot;}
    },
    required: ~w(solar_system_id)a,
    example: %{
      solar_system_id: 30_000_142,
      solar_system_name: &quot;Jita&quot;,
      position_x: 100,
      position_y: 200,
      visible: true,
      labels: &quot;market,hub&quot;
    }
  }

  @system_update_schema %Schema{
    type: :object,
    properties: %{
      solar_system_name: %Schema{type: :string, description: &quot;EVE solar system name&quot;, nullable: true},
      position_x: %Schema{type: :integer, description: &quot;X coordinate&quot;, nullable: true},
      position_y: %Schema{type: :integer, description: &quot;Y coordinate&quot;, nullable: true},
      status: %Schema{
        type: :integer,
        description: &quot;System status (0: unknown, 1: friendly, 2: warning, 3: targetPrimary, 4: targetSecondary, 5: dangerousPrimary, 6: dangerousSecondary, 7: lookingFor, 8: home)&quot;,
        nullable: true
      },
      visible: %Schema{type: :boolean, description: &quot;Visibility flag&quot;, nullable: true},
      description: %Schema{type: :string, nullable: true, description: &quot;Custom description&quot;},
      tag: %Schema{type: :string, nullable: true, description: &quot;Custom tag&quot;},
      locked: %Schema{type: :boolean, description: &quot;Lock flag&quot;, nullable: true},
      temporary_name: %Schema{type: :string, nullable: true, description: &quot;Temporary name&quot;},
      labels: %Schema{type: :string, description: &quot;Comma-separated list of labels&quot;}
    },
    example: %{
      solar_system_name: &quot;Jita&quot;,
      position_x: 101,
      position_y: 202,
      visible: false,
      status: 0,
      tag: &quot;HQ&quot;,
      locked: true,
      labels: &quot;market,hub&quot;
    }
  }

  @map_connection_schema %Schema{
    type: :object,
    properties: %{
      id: %Schema{type: :string, description: &quot;Connection UUID&quot;},
      map_id: %Schema{type: :string, description: &quot;Map UUID&quot;},
      solar_system_source: %Schema{type: :integer},
      solar_system_target: %Schema{type: :integer},
      type: %Schema{type: :integer},
      mass_status: %Schema{type: :integer, nullable: true},
      time_status: %Schema{type: :integer, nullable: true},
      ship_size_type: %Schema{type: :integer, nullable: true},
      locked: %Schema{type: :boolean},
      custom_info: %Schema{type: :string, nullable: true},
      wormhole_type: %Schema{type: :string, nullable: true}
    },
    required: ~w(id map_id solar_system_source solar_system_target)a
  }

  @list_response_schema %Schema{
    type: :object,
    properties: %{
      data: %Schema{
        type: :object,
        properties: %{
          systems: %Schema{type: :array, items: @map_system_schema},
          connections: %Schema{type: :array, items: @map_connection_schema}
        }
      }
    },
    example: %{
      data: %{
        systems: [
          %{
            id: &quot;sys-uuid-1&quot;,
            map_id: &quot;map-uuid-1&quot;,
            solar_system_id: 30_000_142,
            solar_system_name: &quot;Jita&quot;,
            region_name: &quot;The Forge&quot;,
            position_x: 100.5,
            position_y: 200.3,
            status: &quot;active&quot;,
            visible: true,
            description: &quot;Trade hub&quot;,
            tag: &quot;HQ&quot;,
            locked: false,
            temporary_name: nil,
            labels: [&quot;market&quot;, &quot;hub&quot;]
          }
        ],
        connections: [
          %{
            id: &quot;conn-uuid-1&quot;,
            map_id: &quot;map-uuid-1&quot;,
            solar_system_source: 30_000_142,
            solar_system_target: 30_000_144,
            type: 0,
            mass_status: 1,
            time_status: 2,
            ship_size_type: 1,
            locked: false,
            custom_info: &quot;Frigate only&quot;,
            wormhole_type: &quot;C2&quot;
          }
        ]
      }
    }
  }

  @detail_response_schema %Schema{
    type: :object,
    properties: %{
      data: @map_system_schema
    },
    example: %{
      data: %{
        id: &quot;sys-uuid-1&quot;,
        map_id: &quot;map-uuid-1&quot;,
        solar_system_id: 30_000_142,
        solar_system_name: &quot;Jita&quot;,
        region_name: &quot;The Forge&quot;,
        position_x: 100.5,
        position_y: 200.3,
        status: &quot;active&quot;,
        visible: true,
        description: &quot;Trade hub&quot;,
        tag: &quot;HQ&quot;,
        locked: false,
        temporary_name: nil,
        labels: [&quot;market&quot;, &quot;hub&quot;]
      }
    }
  }

  @delete_response_schema %Schema{
    type: :object,
    properties: %{deleted: %Schema{type: :boolean, description: &quot;Deleted flag&quot;}},
    required: [&quot;deleted&quot;],
    example: %{deleted: true}
  }

  @batch_response_schema %Schema{
    type: :object,
    properties: %{
      data: %Schema{
        type: :object,
        properties: %{
          systems: %Schema{
            type: :object,
            properties: %{created: %Schema{type: :integer}, updated: %Schema{type: :integer}},
            required: ~w(created updated)a
          },
          connections: %Schema{
            type: :object,
            properties: %{created: %Schema{type: :integer}, updated: %Schema{type: :integer}, deleted: %Schema{type: :integer}},
            required: ~w(created updated deleted)a
          }
        },
        required: ~w(systems connections)a
      }
    },
    example: %{
      data: %{
        systems: %{created: 2, updated: 1},
        connections: %{created: 1, updated: 0, deleted: 1}
      }
    }
  }

  @batch_delete_schema %Schema{
    type: :object,
    properties: %{
      system_ids: %Schema{
        type: :array,
        items: %Schema{type: :integer},
        description: &quot;IDs to delete&quot;
      },
      connection_ids: %Schema{
        type: :array,
        items: %Schema{type: :string},
        description: &quot;Connection UUIDs to delete&quot;,
        nullable: true
      }
    },
    required: [&quot;system_ids&quot;],
    example: %{
      system_ids: [30_000_142, 30_000_143],
      connection_ids: [&quot;conn-uuid-1&quot;, &quot;conn-uuid-2&quot;]
    }
  }

  @batch_delete_response_schema %Schema{
    type: :object,
    properties: %{deleted_count: %Schema{type: :integer, description: &quot;Deleted count&quot;}},
    required: [&quot;deleted_count&quot;],
    example: %{deleted_count: 2}
  }

  @batch_request_schema ApiSchemas.data_wrapper(%Schema{
    type: :object,
    properties: %{
      systems: %Schema{type: :array, items: @system_request_schema},
      connections: %Schema{type: :array, items: %Schema{
        type: :object,
        properties: %{
          solar_system_source: %Schema{type: :integer, description: &quot;Source system ID&quot;},
          solar_system_target: %Schema{type: :integer, description: &quot;Target system ID&quot;},
          type: %Schema{type: :integer, description: &quot;Connection type (default 0)&quot;},
          mass_status: %Schema{type: :integer, description: &quot;Mass status (0-3)&quot;, nullable: true},
          time_status: %Schema{type: :integer, description: &quot;Time decay status (0-3)&quot;, nullable: true},
          ship_size_type: %Schema{type: :integer, description: &quot;Ship size limit (0-3)&quot;, nullable: true},
          locked: %Schema{type: :boolean, description: &quot;Lock flag&quot;, nullable: true},
          custom_info: %Schema{type: :string, description: &quot;Optional metadata&quot;, nullable: true}
        },
        required: ~w(solar_system_source solar_system_target)a
      }}
    },
    example: %{
      systems: [
        %{
          solar_system_id: 30_000_142,
          solar_system_name: &quot;Jita&quot;,
          position_x: 100.5,
          position_y: 200.3,
          visible: true
        }
      ],
      connections: [
        %{
          solar_system_source: 30_000_142,
          solar_system_target: 30_000_144,
          type: 0
        }
      ]
    }
  })

  # -- Actions --

  operation :index,
    summary: &quot;List Map Systems and Connections&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ]
    ],
    responses: [
      ok: {
        &quot;List Map Systems and Connections&quot;,
        &quot;application/json&quot;,
        @list_response_schema
      }
    ]
  def index(%{assigns: %{map_id: map_id}} = conn, _params) do
    systems = Operations.list_systems(map_id) |&gt; Enum.map(&amp;APIUtils.map_system_to_json/1)
    connections = Operations.list_connections(map_id) |&gt; Enum.map(&amp;APIUtils.connection_to_json/1)
    APIUtils.respond_data(conn, %{systems: systems, connections: connections})
  end

  operation :show,
    summary: &quot;Show Map System&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ],
      id: [
        in: :path,
        description: &quot;System ID&quot;,
        type: :string,
        required: true
      ]
    ],
    responses: ResponseSchemas.standard_responses(@detail_response_schema)
  def show(%{assigns: %{map_id: map_id}} = conn, %{&quot;id&quot; =&gt; id}) do
    with {:ok, system_id} &lt;- APIUtils.parse_int(id),
         {:ok, system} &lt;- Operations.get_system(map_id, system_id) do
      APIUtils.respond_data(conn, APIUtils.map_system_to_json(system))
    end
  end

  operation :create,
    summary: &quot;Upsert Systems and Connections (batch or single)&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ]
    ],
    request_body: {&quot;Systems+Connections upsert&quot;, &quot;application/json&quot;, @batch_request_schema},
    responses: ResponseSchemas.standard_responses(@batch_response_schema)
  def create(conn, params) do
    systems = Map.get(params, &quot;systems&quot;, [])
    connections = Map.get(params, &quot;connections&quot;, [])
    case Operations.upsert_systems_and_connections(conn, systems, connections) do
      {:ok, result} -&gt;
        APIUtils.respond_data(conn, result)
      error -&gt;
        error
    end
  end

  operation :update,
    summary: &quot;Update System&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ],
      id: [
        in: :path,
        description: &quot;System ID&quot;,
        type: :string,
        required: true
      ]
    ],
    request_body: {&quot;System update request&quot;, &quot;application/json&quot;, @system_update_schema},
    responses: ResponseSchemas.update_responses(@detail_response_schema)
  def update(conn, %{&quot;id&quot; =&gt; id} = params) do
    with {:ok, sid} &lt;- APIUtils.parse_int(id),
         {:ok, attrs} &lt;- APIUtils.extract_update_params(params),
         update_attrs = Map.put(attrs, &quot;solar_system_id&quot;, sid),
         {:ok, system} &lt;- Operations.update_system(conn, sid, update_attrs) do
      APIUtils.respond_data(conn, APIUtils.map_system_to_json(system))
    end
  end

  operation :delete,
    summary: &quot;Batch Delete Systems and Connections&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ]
    ],
    request_body: {&quot;Batch delete&quot;, &quot;application/json&quot;, @batch_delete_schema},
    responses: ResponseSchemas.standard_responses(@batch_delete_response_schema)
  def delete(conn, params) do
    system_ids = Map.get(params, &quot;system_ids&quot;, [])
    connection_ids = Map.get(params, &quot;connection_ids&quot;, [])

    deleted_systems = Enum.map(system_ids, &amp;delete_system_id(conn, &amp;1))
    deleted_connections = Enum.map(connection_ids, &amp;delete_connection_id(conn, &amp;1))

    systems_deleted = Enum.count(deleted_systems, &amp;match?({:ok, _}, &amp;1))
    connections_deleted = Enum.count(deleted_connections, &amp;match?({:ok, _}, &amp;1))
    deleted_count = systems_deleted + connections_deleted

    APIUtils.respond_data(conn, %{deleted_count: deleted_count})
  end

  defp delete_system_id(conn, id) do
    case APIUtils.parse_int(id) do
      {:ok, sid} -&gt; Operations.delete_system(conn, sid)
      _ -&gt; {:error, :invalid_id}
    end
  end

  defp delete_connection_id(conn, id) do
    case Operations.get_connection(conn, id) do
      {:ok, conn_struct} -&gt;
        source_id = conn_struct.solar_system_source
        target_id = conn_struct.solar_system_target
        case Operations.delete_connection(conn, source_id, target_id) do
          :ok -&gt; {:ok, conn_struct}
          error -&gt; error
        end
      _ -&gt; {:error, :invalid_id}
    end
  end

  operation :delete_single,
    summary: &quot;Delete a single Map System&quot;,
    parameters: [
      map_identifier: [
        in: :path,
        description: &quot;Map identifier (UUID or slug)&quot;,
        type: :string,
        required: true,
        example: &quot;map-slug or map UUID&quot;
      ],
      id: [
        in: :path,
        description: &quot;System ID&quot;,
        type: :string,
        required: true
      ]
    ],
    responses: ResponseSchemas.standard_responses(@delete_response_schema)
  def delete_single(conn, %{&quot;id&quot; =&gt; id}) do
    with {:ok, sid} &lt;- APIUtils.parse_int(id),
         {:ok, _}   &lt;- Operations.delete_system(conn, sid) do
      APIUtils.respond_data(conn, %{deleted: true})
    else
      {:error, :not_found} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; APIUtils.respond_data(%{deleted: false, error: &quot;System not found&quot;})
      {:error, reason} -&gt;
        conn
        |&gt; put_status(:unprocessable_entity)
        |&gt; APIUtils.respond_data(%{deleted: false, error: &quot;Failed to delete system&quot;, reason: reason})
      _ -&gt;
        conn
        |&gt; put_status(:bad_request)
        |&gt; APIUtils.respond_data(%{deleted: false, error: &quot;Invalid system ID format&quot;})
    end
  end

  # -- Legacy endpoints --

  operation :list_systems,
    summary: &quot;List Map Systems (Legacy)&quot;,
    deprecated: true,
    description: &quot;Deprecated, use GET /api/maps/:map_identifier/systems instead&quot;,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Either map_id or slug must be provided, but not both&quot;,
        type: :string,
        required: false,
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Either map_id or slug must be provided, but not both&quot;,
        type: :string,
        required: false,
      ]
    ],
    responses: ResponseSchemas.standard_responses(@list_response_schema)
  defdelegate list_systems(conn, params), to: __MODULE__, as: :index

  operation :show_system,
    summary: &quot;Show Map System (Legacy)&quot;,
    deprecated: true,
    description: &quot;Deprecated, use GET /api/maps/:map_identifier/systems/:id instead&quot;,
    parameters: [
      map_id: [
        in: :query,
        description: &quot;Map identifier (UUID) - Either map_id or slug must be provided, but not both&quot;,
        type: :string,
        required: false,
      ],
      slug: [
        in: :query,
        description: &quot;Map slug - Either map_id or slug must be provided, but not both&quot;,
        type: :string,
        required: false,
      ],
      id: [
        in: :query,
        description: &quot;System ID&quot;,
        type: :string,
        required: true
      ]
    ],
    responses: ResponseSchemas.standard_responses(@detail_response_schema)
  defdelegate show_system(conn, params), to: __MODULE__, as: :show

end</file><file path="lib/wanderer_app_web/controllers/map_system_signature_api_controller.ex">defmodule WandererAppWeb.MapSystemSignatureAPIController do
  use WandererAppWeb, :controller
  use OpenApiSpex.ControllerSpecs

  alias WandererApp.Api.MapSystemSignature
  alias WandererApp.Map.Operations, as: MapOperations

  @moduledoc &quot;&quot;&quot;
  API controller for managing map system signatures.
  &quot;&quot;&quot;

  # Inlined OpenAPI schema for a map system signature
  @signature_schema %OpenApiSpex.Schema{
    title: &quot;MapSystemSignature&quot;,
    type: :object,
    properties: %{
      id: %OpenApiSpex.Schema{type: :string, format: :uuid},
      system_id: %OpenApiSpex.Schema{type: :string, format: :uuid},
      eve_id: %OpenApiSpex.Schema{type: :string},
      character_eve_id: %OpenApiSpex.Schema{type: :string},
      name: %OpenApiSpex.Schema{type: :string, nullable: true},
      description: %OpenApiSpex.Schema{type: :string, nullable: true},
      type: %OpenApiSpex.Schema{type: :string, nullable: true},
      linked_system_id: %OpenApiSpex.Schema{type: :integer, nullable: true},
      kind: %OpenApiSpex.Schema{type: :string, nullable: true},
      group: %OpenApiSpex.Schema{type: :string, nullable: true},
      custom_info: %OpenApiSpex.Schema{type: :string, nullable: true},
      updated: %OpenApiSpex.Schema{type: :integer, nullable: true},
      inserted_at: %OpenApiSpex.Schema{type: :string, format: :date_time},
      updated_at: %OpenApiSpex.Schema{type: :string, format: :date_time}
    },
    required: [
      :id, :system_id, :eve_id, :character_eve_id
    ],
    example: %{
      id: &quot;sig-uuid-1&quot;,
      system_id: &quot;sys-uuid-1&quot;,
      eve_id: &quot;ABC-123&quot;,
      character_eve_id: &quot;123456789&quot;,
      name: &quot;Wormhole K162&quot;,
      description: &quot;Leads to unknown space&quot;,
      type: &quot;Wormhole&quot;,
      linked_system_id: 30000144,
      kind: &quot;cosmic_signature&quot;,
      group: &quot;wormhole&quot;,
      custom_info: &quot;Fresh&quot;,
      updated: 1,
      inserted_at: &quot;2025-04-30T10:00:00Z&quot;,
      updated_at: &quot;2025-04-30T10:00:00Z&quot;
    }
  }

  @doc &quot;&quot;&quot;
  List all signatures for a map.
  &quot;&quot;&quot;
  operation :index,
    summary: &quot;List all signatures for a map&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true]
    ],
    responses: [ok: {&quot;List of signatures&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
      type: :object,
      properties: %{
        data: %OpenApiSpex.Schema{
          type: :array,
          items: @signature_schema
        }
      },
      example: %{
        data: [@signature_schema.example]
      }
    }}]
  def index(conn, _params) do
    map_id = conn.assigns.map_id
    signatures = MapOperations.list_signatures(map_id)
    json(conn, %{data: signatures})
  end

  @doc &quot;&quot;&quot;
  Show a single signature by ID.
  &quot;&quot;&quot;
  operation :show,
    summary: &quot;Show a single signature by ID&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true],
      id: [in: :path, description: &quot;Signature UUID&quot;, type: :string, required: true]
    ],
    responses: [ok: {&quot;Signature&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
      type: :object,
      properties: %{data: @signature_schema},
      example: %{data: @signature_schema.example}
    }}]
  def show(conn, %{&quot;id&quot; =&gt; id}) do
    map_id = conn.assigns.map_id
    case MapSystemSignature.by_id(id) do
      {:ok, signature} -&gt;
        case WandererApp.Api.MapSystem.by_id(signature.system_id) do
          {:ok, system} when system.map_id == map_id -&gt;
            json(conn, %{data: signature})
          _ -&gt;
            conn |&gt; put_status(:not_found) |&gt; json(%{error: &quot;Signature not found&quot;})
        end
      _ -&gt; conn |&gt; put_status(:not_found) |&gt; json(%{error: &quot;Signature not found&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  Create a new signature.
  &quot;&quot;&quot;
  operation :create,
    summary: &quot;Create a new signature&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true]
    ],
    request_body: {&quot;Signature&quot;, &quot;application/json&quot;, @signature_schema},
    responses: [created: {&quot;Created signature&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
      type: :object,
      properties: %{data: @signature_schema},
      example: %{data: @signature_schema.example}
    }}]
  def create(conn, params) do
    case MapOperations.create_signature(conn, params) do
      {:ok, sig} -&gt; conn |&gt; put_status(:created) |&gt; json(%{data: sig})
      {:error, error} -&gt; conn |&gt; put_status(:unprocessable_entity) |&gt; json(%{error: error})
    end
  end

  @doc &quot;&quot;&quot;
  Update a signature by ID.
  &quot;&quot;&quot;
  operation :update,
    summary: &quot;Update a signature by ID&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true],
      id: [in: :path, description: &quot;Signature UUID&quot;, type: :string, required: true]
    ],
    request_body: {&quot;Signature update&quot;, &quot;application/json&quot;, @signature_schema},
    responses: [ok: {&quot;Updated signature&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
      type: :object,
      properties: %{data: @signature_schema},
      example: %{data: @signature_schema.example}
    }}]
  def update(conn, %{&quot;id&quot; =&gt; id} = params) do
    case MapOperations.update_signature(conn, id, params) do
      {:ok, sig} -&gt; json(conn, %{data: sig})
      {:error, error} -&gt; conn |&gt; put_status(:unprocessable_entity) |&gt; json(%{error: error})
    end
  end

  @doc &quot;&quot;&quot;
  Delete a signature by ID.
  &quot;&quot;&quot;
  operation :delete,
    summary: &quot;Delete a signature by ID&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true],
      id: [in: :path, description: &quot;Signature UUID&quot;, type: :string, required: true]
    ],
    responses: [no_content: {&quot;Deleted&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
      type: :object,
      example: %{}
    }}]
  def delete(conn, %{&quot;id&quot; =&gt; id}) do
    case MapOperations.delete_signature(conn, id) do
      :ok -&gt; send_resp(conn, :no_content, &quot;&quot;)
      {:error, error} -&gt; conn |&gt; put_status(:unprocessable_entity) |&gt; json(%{error: error})
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/map_system_structure_api_controller.ex">defmodule WandererAppWeb.MapSystemStructureAPIController do
  use WandererAppWeb, :controller
  use OpenApiSpex.ControllerSpecs

  alias WandererApp.Api.MapSystemStructure
  alias OpenApiSpex.Schema
  alias WandererApp.Map.Operations, as: MapOperations

  @moduledoc &quot;&quot;&quot;
  API controller for managing map system structures.
  &quot;&quot;&quot;

  # Inlined OpenAPI schema for a map system structure
  @structure_schema %Schema{
    title: &quot;MapSystemStructure&quot;,
    type: :object,
    properties: %{
      id: %Schema{type: :string, format: :uuid},
      system_id: %Schema{type: :string, format: :uuid},
      solar_system_name: %Schema{type: :string},
      solar_system_id: %Schema{type: :integer},
      structure_type_id: %Schema{type: :string},
      structure_type: %Schema{type: :string},
      character_eve_id: %Schema{type: :string},
      name: %Schema{type: :string},
      notes: %Schema{type: :string, nullable: true},
      owner_name: %Schema{type: :string, nullable: true},
      owner_ticker: %Schema{type: :string, nullable: true},
      owner_id: %Schema{type: :string, nullable: true},
      status: %Schema{type: :string, nullable: true},
      end_time: %Schema{type: :string, format: :date_time, nullable: true},
      inserted_at: %Schema{type: :string, format: :date_time},
      updated_at: %Schema{type: :string, format: :date_time}
    },
    required: [
      :id, :system_id, :solar_system_name, :solar_system_id, :structure_type_id, :structure_type, :character_eve_id, :name
    ],
    example: %{
      id: &quot;struct-uuid-1&quot;,
      system_id: &quot;sys-uuid-1&quot;,
      solar_system_name: &quot;Jita&quot;,
      solar_system_id: 30000142,
      structure_type_id: &quot;35832&quot;,
      structure_type: &quot;Astrahus&quot;,
      character_eve_id: &quot;123456789&quot;,
      name: &quot;Jita Trade Hub&quot;,
      notes: &quot;Main market structure&quot;,
      owner_name: &quot;Wanderer Corp&quot;,
      owner_ticker: &quot;WANDR&quot;,
      owner_id: &quot;corp-uuid-1&quot;,
      status: &quot;anchoring&quot;,
      end_time: &quot;2025-05-01T12:00:00Z&quot;,
      inserted_at: &quot;2025-04-30T10:00:00Z&quot;,
      updated_at: &quot;2025-04-30T10:00:00Z&quot;
    }
  }

  @doc &quot;&quot;&quot;
  List all structures for a map.
  &quot;&quot;&quot;
  operation :index,
    summary: &quot;List all structures for a map&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true]
    ],
    responses: [ok: {&quot;List of structures&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
      type: :object,
      properties: %{
        data: %OpenApiSpex.Schema{
          type: :array,
          items: @structure_schema
        }
      },
      example: %{
        data: [@structure_schema.example]
      }
    }}]
  def index(conn, _params) do
    map_id = conn.assigns.map_id
    structures = MapOperations.list_structures(map_id)
    json(conn, %{data: structures})
  end

  @doc &quot;&quot;&quot;
  Show a single structure by ID.
  &quot;&quot;&quot;
  operation :show,
    summary: &quot;Show a single structure by ID&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true],
      id: [in: :path, description: &quot;Structure UUID&quot;, type: :string, required: true]
    ],
    responses: [ok: {&quot;Structure&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
      type: :object,
      properties: %{data: @structure_schema},
      example: %{data: @structure_schema.example}
    }}]
  def show(conn, %{&quot;id&quot; =&gt; id}) do
    map_id = conn.assigns.map_id
    case MapSystemStructure.by_id(id) do
      {:ok, structure} -&gt;
        case WandererApp.Api.MapSystem.by_id(structure.system_id) do
          {:ok, system} when system.map_id == map_id -&gt;
            json(conn, %{data: structure})
          _ -&gt;
            conn |&gt; put_status(:not_found) |&gt; json(%{error: &quot;Structure not found&quot;})
        end
      _ -&gt; conn |&gt; put_status(:not_found) |&gt; json(%{error: &quot;Structure not found&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  Create a new structure.
  &quot;&quot;&quot;
  operation :create,
    summary: &quot;Create a new structure&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true]
    ],
    request_body: {&quot;Structure&quot;, &quot;application/json&quot;, @structure_schema},
    responses: [created: {&quot;Created structure&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
      type: :object,
      properties: %{data: @structure_schema},
      example: %{data: @structure_schema.example}
    }}]
  def create(conn, params) do
    case MapOperations.create_structure(conn, params) do
      {:ok, struct} -&gt; conn |&gt; put_status(:created) |&gt; json(%{data: struct})
      {:error, error} -&gt; conn |&gt; put_status(:unprocessable_entity) |&gt; json(%{error: error})
    end
  end

  @doc &quot;&quot;&quot;
  Update a structure by ID.
  &quot;&quot;&quot;
  operation :update,
    summary: &quot;Update a structure by ID&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true],
      id: [in: :path, description: &quot;Structure UUID&quot;, type: :string, required: true]
    ],
    request_body: {&quot;Structure update&quot;, &quot;application/json&quot;, @structure_schema},
    responses: [ok: {&quot;Updated structure&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
      type: :object,
      properties: %{data: @structure_schema},
      example: %{data: @structure_schema.example}
    }}]
  def update(conn, %{&quot;id&quot; =&gt; id} = params) do
    case MapOperations.update_structure(conn, id, params) do
      {:ok, struct} -&gt; json(conn, %{data: struct})
      {:error, error} -&gt; conn |&gt; put_status(:unprocessable_entity) |&gt; json(%{error: error})
    end
  end

  @doc &quot;&quot;&quot;
  Delete a structure by ID.
  &quot;&quot;&quot;
  operation :delete,
    summary: &quot;Delete a structure by ID&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true],
      id: [in: :path, description: &quot;Structure UUID&quot;, type: :string, required: true]
    ],
    responses: [no_content: {&quot;Deleted&quot;, &quot;application/json&quot;, %OpenApiSpex.Schema{
      type: :object,
      example: %{}
    }}]
  def delete(conn, %{&quot;id&quot; =&gt; id}) do
    case MapOperations.delete_structure(conn, id) do
      :ok -&gt; send_resp(conn, :no_content, &quot;&quot;)
      {:error, error} -&gt; conn |&gt; put_status(:unprocessable_entity) |&gt; json(%{error: error})
    end
  end

  @doc &quot;&quot;&quot;
  Get structure timers for a map.
  &quot;&quot;&quot;
  operation :structure_timers,
    summary: &quot;Get structure timers for a map&quot;,
    parameters: [
      map_identifier: [in: :path, description: &quot;Map identifier (UUID or slug)&quot;, type: :string, required: true]
    ],
    responses: [ok: {&quot;Structure timers&quot;, &quot;application/json&quot;, %Schema{
      type: :object,
      properties: %{
        data: %Schema{
          type: :array,
          items: @structure_schema
        }
      },
      example: %{
        data: [@structure_schema.example]
      }
    }}]
  def structure_timers(conn, _params) do
    map_id = conn.assigns.map_id
    structures = MapOperations.list_structures(map_id)
    json(conn, %{data: structures})
  end
end</file><file path="lib/wanderer_app_web/controllers/maps_controller.ex">defmodule WandererAppWeb.MapsController do
  use WandererAppWeb, :controller

  def last(%{assigns: %{current_user: %{last_map_id: last_map_id}} = _assigns} = conn, _params)
      when not is_nil(last_map_id) do
    {:ok, map} = WandererApp.Api.Map.by_id(last_map_id)

    conn
    |&gt; redirect(to: ~p&quot;/#{map.slug}&quot;)
  end

  def last(conn, _params) do
    conn
    |&gt; redirect(to: ~p&quot;/maps&quot;)
  end
end</file><file path="lib/wanderer_app_web/controllers/redirect_controller.ex">defmodule WandererAppWeb.RedirectController do
  use WandererAppWeb, :controller

  import WandererAppWeb.UserAuth, only: [fetch_current_user: 2]

  plug :fetch_current_user

  def redirect_authenticated(conn, _) do
    if conn.assigns.current_user do
      WandererAppWeb.UserAuth.redirect_if_user_is_authenticated(conn, [])
    else
      redirect(conn, to: ~p&quot;/welcome&quot;)
    end
  end
end</file><file path="lib/wanderer_app_web/controllers/user_auth.ex">defmodule WandererAppWeb.UserAuth do
  @moduledoc false

  use WandererAppWeb, :verified_routes
  import Plug.Conn
  import Phoenix.Controller

  alias Phoenix.LiveView

  alias WandererApp.Api.{User}

  def on_mount(:ensure_authenticated, _params, session, socket) do
    case session do
      %{&quot;user_id&quot; =&gt; user_id} -&gt;
        user = User.by_id!(user_id) |&gt; Ash.load!(:characters)
        admins = WandererApp.Env.admins()

        user_role =
          case Enum.empty?(admins) or user.hash in admins do
            true -&gt;
              :admin

            _ -&gt;
              :user
          end

        new_socket =
          socket
          |&gt; Phoenix.Component.assign_new(:current_user, fn -&gt;
            user
          end)
          |&gt; Phoenix.Component.assign_new(:current_user_role, fn -&gt;
            user_role
          end)

        case new_socket.assigns.current_user do
          nil -&gt;
            {:halt, redirect_require_login(socket)}

          %User{characters: characters} -&gt;
            :ok = track_characters(characters)

            {:cont, new_socket}
        end

      %{} -&gt;
        {:halt, redirect_require_login(socket)}
    end
  rescue
    _ -&gt; {:halt, redirect_require_login(socket)}
  end

  def on_mount(:ensure_admin, _params, _session, socket) do
    case socket.assigns.current_user_role do
      :admin -&gt;
        {:cont, socket}

      _ -&gt;
        {:halt, redirect_not_admin(socket)}
    end
  end

  @doc &quot;&quot;&quot;
  Authenticates the user by looking into the session.
  &quot;&quot;&quot;
  def fetch_current_user(conn, _opts) do
    user_id = get_session(conn, :user_id)

    case user_id &amp;&amp; WandererApp.Api.User.by_id(user_id, load: :characters) do
      {:ok, user} -&gt;
        conn
        |&gt; assign(:current_user, user)

      _ -&gt;
        conn
        |&gt; assign(:current_user, nil)
    end
  end

  def redirect_if_user_is_authenticated(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
      |&gt; redirect(to: ~p&quot;/last&quot;)
      |&gt; halt()
    else
      conn
    end
  end

  @doc &quot;&quot;&quot;
  Used for routes that require the user to be authenticated.

  If you want to enforce the user email is confirmed before
  they use the application at all, here would be a good place.
  &quot;&quot;&quot;
  def require_authenticated_user(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
    else
      conn
      |&gt; maybe_store_return_to()
      |&gt; redirect(to: ~p&quot;/characters&quot;)
      |&gt; halt()
    end
  end

  defp redirect_require_login(socket) do
    socket
    |&gt; LiveView.redirect(to: ~p&quot;/welcome&quot;)
  end

  defp redirect_not_admin(socket) do
    socket
    |&gt; LiveView.redirect(to: ~p&quot;/&quot;)
  end

  defp track_characters([]), do: :ok

  defp track_characters([%{id: character_id} | characters]) do
    :ok = WandererApp.Character.TrackerManager.start_tracking(character_id)
    track_characters(characters)
  end

  defp maybe_store_return_to(%{method: &quot;GET&quot;} = conn) do
    %{request_path: request_path, query_string: query_string} = conn
    return_to = if query_string == &quot;&quot;, do: request_path, else: request_path &lt;&gt; &quot;?&quot; &lt;&gt; query_string
    put_session(conn, :user_return_to, return_to)
  end

  defp maybe_store_return_to(conn), do: conn
end</file><file path="lib/wanderer_app_web/helpers/api_utils.ex">defmodule WandererAppWeb.Helpers.APIUtils do
  @moduledoc &quot;&quot;&quot;
  Unified helper module for API operations:
  - Parameter parsing and validation
  - Map ID resolution
  - Standardized responses
  - JSON serialization
  &quot;&quot;&quot;

  # Explicit imports to avoid unnecessary dependencies
  import Plug.Conn, only: [put_status: 2]
  import Phoenix.Controller, only: [json: 2]

  alias WandererApp.Api.Map, as: MapApi
  alias WandererApp.Api.MapSolarSystem
  require Logger

  # -----------------------------------------------------------------------------
  # Map ID Resolution
  # -----------------------------------------------------------------------------

  @spec fetch_map_id(map()) :: {:ok, String.t()} | {:error, String.t()}
  def fetch_map_id(%{&quot;map_id&quot; =&gt; id}) when is_binary(id) do
    case Ecto.UUID.cast(id) do
      {:ok, _} -&gt; {:ok, id}
      :error -&gt; {:error, &quot;Invalid UUID format for map_id: #{id}&quot;}
    end
  end

  def fetch_map_id(%{&quot;slug&quot; =&gt; slug}) when is_binary(slug) do
    case MapApi.get_map_by_slug(slug) do
      {:ok, %{id: id}} -&gt; {:ok, id}
      _ -&gt; {:error, &quot;No map found for slug=#{slug}&quot;}
    end
  end

  def fetch_map_id(_), do: {:error, &quot;Must provide either ?map_id=UUID or ?slug=SLUG&quot;}

  # -----------------------------------------------------------------------------
  # Parameter Validators and Parsers
  # -----------------------------------------------------------------------------

  @spec require_param(map(), String.t()) :: {:ok, any()} | {:error, String.t()}
  def require_param(params, key) do
    case Map.fetch(params, key) do
      {:ok, val} when is_binary(val) -&gt;
        trimmed = String.trim(val)
        if trimmed == &quot;&quot; do
          {:error, &quot;Param #{key} cannot be empty&quot;}
        else
          {:ok, trimmed}
        end

      {:ok, val} -&gt;
        {:ok, val}

      :error -&gt;
        {:error, &quot;Missing required param: #{key}&quot;}
    end
  end

  @spec parse_int(binary() | integer()) :: {:ok, integer()} | {:error, String.t()}
  def parse_int(str) when is_binary(str) do
    Logger.debug(&quot;Parsing integer from: #{inspect(str)}&quot;)

    case Integer.parse(str) do
      {num, &quot;&quot;} -&gt; {:ok, num}
      _ -&gt; {:error, &quot;Invalid integer format: #{str}&quot;}
    end
  end

  def parse_int(num) when is_integer(num), do: {:ok, num}
  def parse_int(other), do: {:error, &quot;Expected integer or string, got: #{inspect(other)}&quot;}

  @spec parse_int!(binary() | integer()) :: integer()
  def parse_int!(str) do
    case parse_int(str) do
      {:ok, num} -&gt; num
      {:error, msg} -&gt; raise ArgumentError, msg
    end
  end

  @spec validate_uuid(any()) :: {:ok, String.t()} | {:error, String.t()}
  def validate_uuid(id) when is_binary(id) do
    case Ecto.UUID.cast(id) do
      {:ok, uuid} -&gt; {:ok, uuid}
      :error -&gt; {:error, &quot;Invalid UUID format: #{id}&quot;}
    end
  end

  def validate_uuid(_), do: {:error, &quot;ID must be a UUID string&quot;}

  # -----------------------------------------------------------------------------
  # Parameter Extraction
  # -----------------------------------------------------------------------------

  @doc &quot;&quot;&quot;
  Extract and validate parameters for upserting a system.
  Returns {:ok, attrs} or {:error, error_message}.
  &quot;&quot;&quot;
  @spec extract_upsert_params(map()) :: {:ok, map()} | {:error, String.t()}
  def extract_upsert_params(params) when is_map(params) do
    required = [&quot;solar_system_id&quot;]
    optional = [
      &quot;solar_system_name&quot;, &quot;position_x&quot;, &quot;position_y&quot;, &quot;coordinates&quot;,
      &quot;status&quot;, &quot;visible&quot;, &quot;description&quot;, &quot;tag&quot;,
      &quot;locked&quot;, &quot;temporary_name&quot;, &quot;labels&quot;
    ]

    case Map.fetch(params, &quot;solar_system_id&quot;) do
      :error -&gt; {:error, &quot;Missing solar_system_id in request body&quot;}
      {:ok, _} -&gt;
        params
        |&gt; Map.take(required ++ optional)
        |&gt; Enum.reject(fn {_k, v} -&gt; is_nil(v) end)
        |&gt; Enum.into(%{})
        |&gt; then(&amp;{:ok, &amp;1})
    end
  end

  @doc &quot;&quot;&quot;
  Extract and validate parameters for updating a system.
  Returns {:ok, attrs} or {:error, error_message}.
  &quot;&quot;&quot;
  @spec extract_update_params(map()) :: {:ok, map()} | {:error, String.t()}
  def extract_update_params(params) when is_map(params) do
    allowed = [
      &quot;solar_system_name&quot;, &quot;position_x&quot;, &quot;position_y&quot;, &quot;coordinates&quot;,
      &quot;status&quot;, &quot;visible&quot;, &quot;description&quot;, &quot;tag&quot;,
      &quot;locked&quot;, &quot;temporary_name&quot;, &quot;labels&quot;
    ]

    attrs =
      params
      |&gt; Map.take(allowed)
      |&gt; Enum.reject(fn {_k, v} -&gt; is_nil(v) end)
      |&gt; Enum.into(%{})

    {:ok, attrs}
  end

  @spec normalize_connection_params(map()) :: {:ok, map()} | {:error, String.t()}
  def normalize_connection_params(params) do
    # Convert all keys to strings for consistent access
    string_params = for {k, v} &lt;- params, into: %{} do
      {to_string(k), v}
    end

    # Define parameter mappings for normalization
    aliases = %{
      &quot;source&quot; =&gt; &quot;solar_system_source&quot;,
      &quot;source_id&quot; =&gt; &quot;solar_system_source&quot;,
      &quot;target&quot; =&gt; &quot;solar_system_target&quot;,
      &quot;target_id&quot; =&gt; &quot;solar_system_target&quot;
    }

    # Normalize parameters using aliases
    normalized_params = Enum.reduce(aliases, string_params, fn {alias_key, std_key}, acc -&gt;
      if Map.has_key?(acc, alias_key) &amp;&amp; !Map.has_key?(acc, std_key) do
        Map.put(acc, std_key, acc[alias_key])
      else
        acc
      end
    end)

    # Handle required parameters
    with {:ok, src} &lt;- parse_to_int(normalized_params[&quot;solar_system_source&quot;], &quot;solar_system_source&quot;),
         {:ok, tgt} &lt;- parse_to_int(normalized_params[&quot;solar_system_target&quot;], &quot;solar_system_target&quot;) do

      # Handle optional parameters with sane defaults
      type = normalized_params[&quot;type&quot;] || 0
      mass_status = normalized_params[&quot;mass_status&quot;] || 0
      time_status = normalized_params[&quot;time_status&quot;] || 0
      ship_size_type = normalized_params[&quot;ship_size_type&quot;] || 0
      # Coerce to boolean; accept &quot;true&quot;/&quot;false&quot;, 1/0, etc.
      locked =
        case normalized_params[&quot;locked&quot;] do
          val when val in [true, &quot;true&quot;, 1, &quot;1&quot;]   -&gt; true
          val when val in [false, &quot;false&quot;, 0, &quot;0&quot;] -&gt; false
          nil                                         -&gt; false
          other                                       -&gt; other  # keep unknowns for caller-side validation
        end
      custom_info = normalized_params[&quot;custom_info&quot;]
      wormhole_type = normalized_params[&quot;wormhole_type&quot;]

      # Build standardized attrs map
      attrs = %{
        &quot;solar_system_source&quot; =&gt; src,
        &quot;solar_system_target&quot; =&gt; tgt,
        &quot;type&quot; =&gt; parse_optional_int(type, 0),
        &quot;mass_status&quot; =&gt; parse_optional_int(mass_status, 0),
        &quot;time_status&quot; =&gt; parse_optional_int(time_status, 0),
        &quot;ship_size_type&quot; =&gt; parse_optional_int(ship_size_type, 0)
      }

      # Add non-nil optional attributes
      attrs = if is_nil(locked), do: attrs, else: Map.put(attrs, &quot;locked&quot;, locked)
      attrs = if is_nil(custom_info), do: attrs, else: Map.put(attrs, &quot;custom_info&quot;, custom_info)
      attrs = if is_nil(wormhole_type), do: attrs, else: Map.put(attrs, &quot;wormhole_type&quot;, wormhole_type)

      {:ok, attrs}
    else
      {:error, msg} -&gt; {:error, msg}
    end
  end

  # Helper to handle various input formats
  defp parse_to_int(nil, field), do: {:error, &quot;Missing #{field}&quot;}
  defp parse_to_int(val, _field) when is_integer(val), do: {:ok, val}
  defp parse_to_int(val, field) when is_binary(val) do
    case Integer.parse(val) do
      {i, &quot;&quot;} -&gt; {:ok, i}
      :error -&gt; {:error, &quot;Invalid #{field}: #{val}&quot;}
      _ -&gt; {:error, &quot;Invalid #{field}: #{val}&quot;}
    end
  end
  defp parse_to_int(val, field), do: {:error, &quot;Invalid #{field} type: #{inspect(val)}&quot;}

  defp parse_optional_int(nil, default), do: default
  defp parse_optional_int(i, _default) when is_integer(i), do: i
  defp parse_optional_int(s, default) when is_binary(s) do
    case Integer.parse(s) do
      {i, _} -&gt; i
      :error -&gt; default
    end
  end

  # -----------------------------------------------------------------------------
  # Standardized JSON Responses
  # -----------------------------------------------------------------------------

  @spec respond_data(Plug.Conn.t(), any(), atom() | integer()) :: Plug.Conn.t()
  def respond_data(conn, data, status \\ :ok) do
    conn
    |&gt; put_status(status)
    |&gt; json(%{data: data})
  end

  @spec error_response(Plug.Conn.t(), atom() | integer(), String.t(), map() | nil) :: Plug.Conn.t()
  def error_response(conn, status, message, details \\ nil) do
    body = if details, do: %{error: message, details: details}, else: %{error: message}

    conn
    |&gt; put_status(status)
    |&gt; json(body)
  end

  @spec error_not_found(Plug.Conn.t(), String.t()) :: Plug.Conn.t()
  def error_not_found(conn, message), do: error_response(conn, :not_found, message)

  @doc &quot;&quot;&quot;
  Formats error messages for consistent display.
  &quot;&quot;&quot;
  @spec format_error(any()) :: String.t()
  def format_error(error) when is_binary(error), do: error
  def format_error(error) when is_atom(error), do: Atom.to_string(error)
  def format_error(error), do: inspect(error)

  # -----------------------------------------------------------------------------
  # JSON Serialization
  # -----------------------------------------------------------------------------

  @spec map_system_to_json(struct()) :: map()
  def map_system_to_json(system) do
    base =
      Map.take(system, ~w(
        id map_id solar_system_id custom_name temporary_name description tag labels
        locked visible status position_x position_y inserted_at updated_at
      )a)

    original = get_original_name(system.solar_system_id)
    name = pick_name(system)

    base
    |&gt; Map.put(:original_name, original)
    |&gt; Map.put(:name, name)
  end

  defp get_original_name(id) do
    case MapSolarSystem.by_solar_system_id(id) do
      {:ok, sys} -&gt; sys.solar_system_name
      _ -&gt; &quot;System #{id}&quot;
    end
  end

  defp pick_name(%{temporary_name: t, custom_name: c, solar_system_id: id}) do
    cond do
      t not in [nil, &quot;&quot;] -&gt; t
      c not in [nil, &quot;&quot;] -&gt; c
      true -&gt; get_original_name(id)
    end
  end

  @spec connection_to_json(struct()) :: map()
  def connection_to_json(conn) do
    Map.take(conn, ~w(
      id map_id solar_system_source solar_system_target mass_status
      time_status ship_size_type type wormhole_type inserted_at updated_at
    )a)
  end
end</file><file path="lib/wanderer_app_web/helpers/csp.ex">defmodule WandererAppWeb.Helpers.CSP do
  @moduledoc false

  # sobelow_skip [&quot;Traversal.FileModule&quot;]
  @spec integrity_hash(priv_path :: Path.t()) :: String.t() | nil
  def integrity_hash(priv_path) do
    %{path: priv_path} = URI.parse(priv_path)

    :wanderer_app
    |&gt; Application.app_dir(&quot;priv/static/&quot;)
    |&gt; Path.join(priv_path)
    |&gt; File.read()
    |&gt; case do
      {:ok, content} -&gt;
        hash =
          :sha512
          |&gt; :crypto.hash(content)
          |&gt; Base.encode64()

        &quot;sha512-#{hash}&quot;

      {:error, :enoent} -&gt;
        nil
    end
  end

  @spec nonce(conn :: Plug.Conn.t(), type :: atom) :: String.t()
  def nonce(conn, type) do
    conn.assigns[String.to_existing_atom(&quot;#{type}_src_nonce&quot;)]
  end
end</file><file path="lib/wanderer_app_web/live/access_lists/components/acl_member.ex">defmodule WandererAppWeb.AclMember do
  use WandererAppWeb, :live_component

  use LiveViewEvents

  @roles [
    :admin,
    :manager,
    :member,
    :viewer,
    :blocked
  ]

  @impl true
  def mount(socket) do
    {:ok, socket |&gt; assign(roles: get_roles())}
  end

  @impl true
  def update(
        %{
          member: member
        } = assigns,
        socket
      ) do
    socket = handle_info_or_assign(socket, assigns)

    {:ok,
     socket
     |&gt; assign(member: member, form: to_form(%{&quot;role&quot; =&gt; member.role}))}
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div id={@id} class=&quot;flex items-center gap-2&quot;&gt;
      &lt;.icon :if={not is_nil(@member.role)} name={member_role_icon(@member.role)} class=&quot;w-6 h-6&quot; /&gt;
      &lt;.form :let={f} id={&quot;role_form_&quot; &lt;&gt; @id} for={@form} phx-change=&quot;select&quot; phx-target={@myself}&gt;
        &lt;.input
          type=&quot;select&quot;
          field={f[:role]}
          class=&quot;select h-8 min-h-[0px] !pt-1 !pb-1 text-sm bg-neutral-900&quot;
          wrapper_class=&quot;w-[60px] mr-16&quot;
          placeholder=&quot;Select a role...&quot;
          options={Enum.map(@roles, fn role -&gt; {role.label, role.value} end)}
        /&gt;
      &lt;/.form&gt;
      &lt;div class=&quot;avatar&quot;&gt;
        &lt;div class=&quot;rounded-md w-8 h-8&quot;&gt;
          &lt;img src={member_icon_url(@member)} alt={@member.name} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;%= @member.name %&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @impl true
  def handle_event(
        &quot;select&quot;,
        %{&quot;role&quot; =&gt; role} = _params,
        %{assigns: %{event_name: event_name, member: member, notify_to: notify_to}} = socket
      ) do
    notify_to(notify_to, event_name, %{
      member_id: member.id,
      role: role
    })

    {:noreply, socket}
  end

  def member_role_icon(:admin), do: &quot;hero-user-group-solid&quot;
  def member_role_icon(:manager), do: &quot;hero-academic-cap-solid&quot;
  def member_role_icon(:member), do: &quot;hero-user-solid&quot;
  def member_role_icon(:viewer), do: &quot;hero-eye-solid&quot;
  def member_role_icon(:blocked), do: &quot;hero-no-symbol-solid text-red-500&quot;
  def member_role_icon(_), do: &quot;hero-cake-solid&quot;

  def member_role_title(:admin), do: &quot;Admin&quot;
  def member_role_title(:manager), do: &quot;Manager&quot;
  def member_role_title(:member), do: &quot;Member&quot;
  def member_role_title(:viewer), do: &quot;Viewer&quot;
  def member_role_title(:blocked), do: &quot;-blocked-&quot;
  def member_role_title(_), do: &quot;-&quot;

  defp get_roles(), do: @roles |&gt; Enum.map(&amp;%{label: member_role_title(&amp;1), value: &amp;1})
end</file><file path="lib/wanderer_app_web/live/access_lists/access_lists_live.ex">defmodule WandererAppWeb.AccessListsLive do
  alias Pathex.Builder.Viewer
  use WandererAppWeb, :live_view

  require Logger

  @impl true
  def mount(_params, %{&quot;user_id&quot; =&gt; user_id} = _session, socket) when not is_nil(user_id) do
    {:ok, characters} = WandererApp.Api.Character.active_by_user(%{user_id: user_id})

    characters =
      characters
      |&gt; Enum.sort_by(&amp; &amp;1.name, :asc)
      |&gt; Enum.map(&amp;map_character/1)

    {:ok, access_lists} = WandererApp.Acls.get_available_acls(socket.assigns.current_user)

    {:ok,
     socket
     |&gt; assign(
       selected_acl: nil,
       selected_acl_id: &quot;&quot;,
       user_id: user_id,
       access_lists: access_lists |&gt; Enum.map(fn acl -&gt; map_ui_acl(acl, nil) end),
       characters: characters,
       members: []
     )}
  end

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |&gt; assign(
       selected_acl: nil,
       selected_acl_id: &quot;&quot;,
       access_lists: [],
       characters: [],
       members: []
     )}
  end

  @impl true
  def handle_params(params, _url, socket) do
    {:noreply, apply_action(socket, socket.assigns.live_action, params)}
  end

  defp apply_action(socket, :index, _params) do
    socket
    |&gt; assign(:active_page, :access_lists)
    |&gt; assign(:page_title, &quot;Access Lists&quot;)
  end

  defp apply_action(socket, :create, _params) do
    socket
    |&gt; assign(:active_page, :access_lists)
    |&gt; assign(:page_title, &quot;Access Lists - New&quot;)
    |&gt; assign(
      :form,
      AshPhoenix.Form.for_create(WandererApp.Api.AccessList, :new,
        forms: [
          auto?: true
        ]
      )
      |&gt; to_form()
    )
  end

  defp apply_action(socket, :edit, %{&quot;id&quot; =&gt; acl_id} = _params) do
    access_list = socket.assigns.access_lists |&gt; Enum.find(&amp;(&amp;1.id == acl_id))

    socket
    |&gt; assign(:active_page, :access_lists)
    |&gt; assign(:page_title, &quot;Access Lists - Edit&quot;)
    |&gt; assign(:acl_id, acl_id)
    |&gt; assign(
      :form,
      access_list |&gt; AshPhoenix.Form.for_update(:update, forms: [auto?: true]) |&gt; to_form()
    )
  end

  defp apply_action(socket, :members, %{&quot;id&quot; =&gt; acl_id} = _params) do
    with access_list when not is_nil(access_list) &lt;-
           socket.assigns.access_lists |&gt; Enum.find(&amp;(&amp;1.id == acl_id)),
         {:ok, access_list} &lt;- access_list |&gt; Ash.load(:owner),
         {:ok, members} &lt;-
           WandererApp.Api.AccessListMember.read_by_access_list(%{access_list_id: acl_id}) do
      socket
      |&gt; assign(:active_page, :access_lists)
      |&gt; assign(:page_title, &quot;Access Lists - Members&quot;)
      |&gt; assign(:selected_acl_id, acl_id)
      |&gt; assign(:access_list, access_list)
      |&gt; assign(
        :members,
        members
      )
    else
      _ -&gt;
        socket
        |&gt; put_flash(:error, &quot;You don&apos;t have an access to this access list.&quot;)
        |&gt; push_navigate(to: ~p&quot;/access-lists&quot;)
    end
  end

  defp apply_action(socket, :add_members, %{&quot;id&quot; =&gt; acl_id} = _params) do
    with {:ok, %{owner: %{id: _character_id}} = access_list} &lt;-
           socket.assigns.access_lists |&gt; Enum.find(&amp;(&amp;1.id == acl_id)) |&gt; Ash.load(:owner),
         user_character_ids &lt;- socket.assigns.current_user.characters |&gt; Enum.map(&amp; &amp;1.id) do
      user_character_ids
      |&gt; Enum.each(fn user_character_id -&gt;
        :ok = WandererApp.Character.TrackerManager.start_tracking(user_character_id)
      end)

      socket
      |&gt; assign(:active_page, :access_lists)
      |&gt; assign(:page_title, &quot;Access Lists - Add Members&quot;)
      |&gt; assign(:selected_acl_id, acl_id)
      |&gt; assign(:user_character_ids, user_character_ids)
      |&gt; assign(
        member_search_options: socket.assigns.characters |&gt; Enum.map(&amp;map_user_character_info/1)
      )
      |&gt; assign(:access_list, access_list)
      |&gt; assign(
        :members,
        WandererApp.Api.AccessListMember.read_by_access_list!(%{access_list_id: acl_id})
      )
      |&gt; assign(
        :member_form,
        %{} |&gt; to_form()
      )
    else
      _ -&gt;
        socket
    end
  end

  @impl true
  def handle_event(
        &quot;live_select_change&quot;,
        %{&quot;id&quot; =&gt; &quot;_member_id_live_select_component&quot; = id, &quot;text&quot; =&gt; text} = _change_event,
        socket
      ) do
    options =
      if text == &quot;&quot; do
        socket.assigns.characters
      else
        DebounceAndThrottle.Debounce.apply(
          Process,
          :send_after,
          [self(), {:search, text}, 100],
          &quot;member_search_#{socket.assigns.selected_acl_id}&quot;,
          250
        )

        [%{label: &quot;Loading...&quot;, value: :loading, disabled: true}]
      end

    send_update(LiveSelect.Component, options: options, id: id)

    {:noreply,
     socket
     |&gt; assign(member_search_options: options, member_search_text: text, member_search_id: id)}
  end

  @impl true
  def handle_event(&quot;live_select_change&quot;, %{&quot;id&quot; =&gt; id, &quot;text&quot; =&gt; text} = _change_event, socket) do
    options =
      if text == &quot;&quot; do
        socket.assigns.characters
      else
        socket.assigns.characters
      end

    send_update(LiveSelect.Component, options: options, id: id)

    {:noreply, socket}
  end

  @impl true
  def handle_event(&quot;select_acl_&quot; &lt;&gt; acl_id, _, socket) do
    {:noreply,
     socket
     |&gt; push_patch(to: ~p&quot;/access-lists/#{acl_id}&quot;)}
  end

  def handle_event(&quot;validate&quot;, %{&quot;form&quot; =&gt; params}, socket) do
    form = AshPhoenix.Form.validate(socket.assigns.form, params)
    {:noreply, assign(socket, form: form)}
  end

  def handle_event(&quot;create&quot;, %{&quot;form&quot; =&gt; form}, socket) do
    case WandererApp.Api.AccessList.new(form) do
      {:ok, _acl} -&gt;
        {:ok, access_lists} = WandererApp.Acls.get_available_acls(socket.assigns.current_user)

        {:noreply,
         socket
         |&gt; assign(
           selected_acl: nil,
           access_lists: access_lists |&gt; Enum.map(fn acl -&gt; map_ui_acl(acl, nil) end)
         )
         |&gt; push_patch(to: ~p&quot;/access-lists&quot;)}

      _ -&gt;
        {:noreply, socket |&gt; put_flash(:error, &quot;Failed to create access list. Try again.&quot;)}
    end
  end

  def handle_event(&quot;edit&quot;, %{&quot;form&quot; =&gt; form} = _params, socket) do
    {:ok, _} =
      socket.assigns.access_lists
      |&gt; Enum.find(&amp;(&amp;1.id == socket.assigns.acl_id))
      |&gt; WandererApp.Api.AccessList.update(form)

    {:ok, access_lists} = WandererApp.Acls.get_available_acls(socket.assigns.current_user)

    {:noreply,
     socket
     |&gt; assign(access_lists: access_lists |&gt; Enum.map(fn acl -&gt; map_ui_acl(acl, nil) end))
     |&gt; push_patch(to: ~p&quot;/access-lists&quot;)}
  end

  def handle_event(
        &quot;add_members&quot;,
        %{&quot;member_id&quot; =&gt; [member_id]} = _params,
        %{assigns: assigns} = socket
      )
      when is_binary(member_id) and member_id != &quot;&quot; do
    member_option =
      assigns.member_search_options
      |&gt; Enum.find(&amp;(&amp;1.value == member_id))

    add_member(socket, assigns.access_list.id, member_option)

    {:noreply, socket |&gt; push_patch(to: ~p&quot;/access-lists/#{assigns.access_list.id}&quot;)}
  end

  def handle_event(&quot;delete-acl&quot;, %{&quot;id&quot; =&gt; acl_id} = _params, socket) do
    case socket.assigns.access_lists
         |&gt; Enum.find(&amp;(&amp;1.id == acl_id))
         |&gt; WandererApp.Api.AccessList.destroy!() do
      :ok -&gt;
        Phoenix.PubSub.broadcast(
          WandererApp.PubSub,
          &quot;acls:#{acl_id}&quot;,
          {:acl_deleted, %{acl_id: acl_id}}
        )

        {:ok, access_lists} = WandererApp.Acls.get_available_acls(socket.assigns.current_user)

        {:noreply,
         socket
         |&gt; assign(access_lists: access_lists |&gt; Enum.map(fn acl -&gt; map_ui_acl(acl, nil) end))}

      _error -&gt;
        {:noreply,
         socket
         |&gt; put_flash(
           :error,
           &quot;You can&apos;t delete this access list. Plese remove it from the map first.&quot;
         )}
    end
  rescue
    _error -&gt;
      {:noreply,
       socket
       |&gt; put_flash(
         :error,
         &quot;You can&apos;t delete this access list. Plese remove it from the map first.&quot;
       )}
  end

  def handle_event(&quot;delete-member&quot;, %{&quot;id&quot; =&gt; member_id} = _params, socket) do
    socket.assigns.members
    |&gt; Enum.find(&amp;(&amp;1.id == member_id))
    |&gt; WandererApp.Api.AccessListMember.destroy!()

    Phoenix.PubSub.broadcast(
      WandererApp.PubSub,
      &quot;acls:#{socket.assigns.selected_acl_id}&quot;,
      {:acl_updated, %{acl_id: socket.assigns.selected_acl_id}}
    )

    {:noreply,
     socket
     |&gt; assign(
       members:
         WandererApp.Api.AccessListMember.read_by_access_list!(%{
           access_list_id: socket.assigns.selected_acl_id
         })
     )}
  end

  @impl true
  def handle_event(
        &quot;dropped&quot;,
        %{&quot;draggedId&quot; =&gt; dragged_id, &quot;dropzoneId&quot; =&gt; dropzone_id},
        %{assigns: %{access_list: access_list, members: members}} = socket
      ) do
    role_atom =
      [:admin, :manager, :member, :viewer, :blocked]
      |&gt; Enum.find(fn role_atom -&gt; to_string(role_atom) == dropzone_id end)

    case role_atom do
      nil -&gt;
        {:noreply, socket}

      role_atom -&gt;
        member =
          members
          |&gt; Enum.find(&amp;(&amp;1.id == dragged_id))

        {:noreply, socket |&gt; maybe_update_role(member, role_atom, access_list)}
    end
  end

  def handle_event(&quot;generate-api-key&quot;, _params, socket) do
    new_api_key = UUID.uuid4()
    new_params = Map.put(socket.assigns.form.params || %{}, &quot;api_key&quot;, new_api_key)
    form = AshPhoenix.Form.validate(socket.assigns.form, new_params)
    {:noreply, assign(socket, form: form)}
  end

  @impl true
  def handle_event(&quot;noop&quot;, _, socket) do
    {:noreply, socket}
  end

  @impl true
  def handle_event(event, body, socket) do
    Logger.warning(fn -&gt; &quot;unhandled event: #{event} #{inspect(body)}&quot; end)
    {:noreply, socket}
  end

  @impl true
  def handle_info(
        {&quot;update_role&quot;, %{member_id: member_id, role: role}},
        %{assigns: %{access_list: access_list, members: members}} = socket
      ) do
    role_atom = role |&gt; String.to_existing_atom()

    member =
      members
      |&gt; Enum.find(&amp;(&amp;1.id == member_id))

    {:noreply, socket |&gt; maybe_update_role(member, role_atom, access_list)}
  end

  @impl true
  def handle_info({:search, text}, socket) do
    active_character_id =
      socket.assigns.current_user.characters
      |&gt; Enum.filter(fn character -&gt; not is_nil(character.refresh_token) end)
      |&gt; Enum.map(&amp; &amp;1.id)
      |&gt; Enum.at(0)

    uniq_search_req_id = UUID.uuid4(:default)

    Task.async(fn -&gt;
      {:ok, options} = search(active_character_id, text)

      {:search_results, uniq_search_req_id, options}
    end)

    {:noreply, socket |&gt; assign(uniq_search_req_id: uniq_search_req_id)}
  end

  def handle_info(
        {ref, result},
        %{assigns: %{member_search_id: member_search_id, uniq_search_req_id: uniq_search_req_id}} =
          socket
      )
      when is_reference(ref) do
    Process.demonitor(ref, [:flush])

    case result do
      {:search_results, ^uniq_search_req_id, options} -&gt;
        send_update(LiveSelect.Component, options: options, id: member_search_id)
        {:noreply, socket |&gt; assign(member_search_options: options)}

      _ -&gt;
        {:noreply, socket}
    end
  end

  @impl true
  def handle_info(_event, socket), do: {:noreply, socket}

  defp maybe_update_role(
         socket,
         %{
           id: member_id,
           eve_character_id: eve_character_id,
           eve_corporation_id: eve_corporation_id,
           eve_alliance_id: eve_alliance_id
         } = member,
         role_atom,
         access_list
       )
       when not is_nil(eve_character_id) or
              ((not is_nil(eve_corporation_id) or not is_nil(eve_alliance_id)) and
                 role_atom not in [:admin, :manager]) do
    can_assign_role =
      cond do
        current_user_is_owner?(socket.assigns.current_user, access_list) -&gt;
          true

        current_user_has_role?(socket.assigns.current_user, access_list, :admin) -&gt;
          true

        not is_nil(eve_character_id) and
          (characters_has_role?([eve_character_id], access_list, :admin) or
             characters_has_role?([eve_character_id], access_list, :manager)) and
            not current_user_has_role?(socket.assigns.current_user, access_list, :admin) -&gt;
          false

        current_user_has_role?(socket.assigns.current_user, access_list, :manager) and
            role_atom in [:member, :viewer, :blocked] -&gt;
          true

        true -&gt;
          false
      end

    case can_assign_role do
      true -&gt;
        member =
          member
          |&gt; WandererApp.Api.AccessListMember.update_role!(%{role: role_atom})

        {:ok, _} =
          WandererApp.User.ActivityTracker.track_acl_event(:map_acl_member_updated, %{
            user_id: socket.assigns.current_user.id,
            acl_id: socket.assigns.selected_acl_id,
            member:
              member
              |&gt; Map.take([:eve_character_id, :eve_corporation_id, :eve_alliance_id, :role])
          })

        :telemetry.execute([:wanderer_app, :acl, :member, :update], %{count: 1})

        Phoenix.PubSub.broadcast(
          WandererApp.PubSub,
          &quot;acls:#{socket.assigns.selected_acl_id}&quot;,
          {:acl_updated, %{acl_id: socket.assigns.selected_acl_id}}
        )

        socket
        |&gt; assign(
          :members,
          socket.assigns.members
          |&gt; Enum.map(fn m -&gt; if m.id == member_id, do: member, else: m end)
        )

      _ -&gt;
        socket
        |&gt; put_flash(:error, &quot;You&apos;re not allowed to assign this role&quot;)
        |&gt; push_navigate(to: ~p&quot;/access-lists/#{socket.assigns.selected_acl_id}&quot;)
    end
  end

  defp maybe_update_role(
         socket,
         _member,
         _role_atom,
         _access_list
       ),
       do:
         socket
         |&gt; put_flash(:info, &quot;Only Characters can have Admin or Manager roles&quot;)
         |&gt; push_navigate(to: ~p&quot;/access-lists/#{socket.assigns.selected_acl_id}&quot;)

  defp characters_has_role?(character_eve_ids, access_list, role_atom) do
    access_list.members
    |&gt; Enum.any?(fn member -&gt;
      member.eve_character_id in character_eve_ids and member.role == role_atom
    end)
  end

  defp current_user_is_owner?(current_user, access_list) do
    character_ids = current_user.characters |&gt; Enum.map(&amp; &amp;1.id)

    access_list.owner_id in character_ids
  end

  defp current_user_has_role?(current_user, access_list, role_atom) do
    character_eve_ids = current_user.characters |&gt; Enum.map(&amp; &amp;1.eve_id)

    characters_has_role?(character_eve_ids, access_list, role_atom)
  end

  defp can_add_members?(nil, _current_user), do: false

  defp can_add_members?(access_list, current_user) do
    character_eve_ids = current_user.characters |&gt; Enum.map(&amp; &amp;1.eve_id)

    member = access_list.members |&gt; Enum.find(&amp;(&amp;1.eve_character_id in character_eve_ids))

    current_user_is_owner?(current_user, access_list) or
      (not is_nil(member) and member.role in [:admin, :manager])
  end

  defp can_delete_member?(
         %{eve_character_id: eve_character_id, role: role_atom} = _member,
         access_list,
         current_user
       ) do
    cond do
      current_user_is_owner?(current_user, access_list) -&gt;
        true

      current_user_has_role?(current_user, access_list, :admin) -&gt;
        true

      not is_nil(eve_character_id) and
        (characters_has_role?([eve_character_id], access_list, :admin) or
           characters_has_role?([eve_character_id], access_list, :manager)) and
          not current_user_has_role?(current_user, access_list, :admin) -&gt;
        false

      current_user_has_role?(current_user, access_list, :manager) and
          role_atom in [:member, :viewer, :blocked] -&gt;
        true

      true -&gt;
        false
    end
  end

  defp can_edit?(access_list, current_user) do
    character_eve_ids = current_user.characters |&gt; Enum.map(&amp; &amp;1.eve_id)

    member = access_list.members |&gt; Enum.find(&amp;(&amp;1.eve_character_id in character_eve_ids))

    current_user_is_owner?(current_user, access_list) or
      (not is_nil(member) and member.role == :admin)
  end

  defp add_member(
         socket,
         access_list_id,
         %{label: name, value: eve_id, character: true} = _member_option
       ) do
    case WandererApp.Api.AccessListMember.create(%{
           access_list_id: access_list_id,
           name: name,
           eve_character_id: eve_id,
           eve_alliance_id: nil,
           eve_corporation_id: nil
         }) do
      {:ok, member} -&gt;
        {:ok, _} =
          WandererApp.User.ActivityTracker.track_acl_event(:map_acl_member_added, %{
            user_id: socket.assigns.current_user.id,
            acl_id: access_list_id,
            member:
              member
              |&gt; Map.take([:eve_character_id, :eve_corporation_id, :eve_alliance_id, :role])
          })

        :telemetry.execute([:wanderer_app, :acl, :member, :add], %{count: 1})

        {:ok, member}

      _ -&gt;
        {:ok, nil}
    end
  end

  defp add_member(
         socket,
         access_list_id,
         %{label: name, value: eve_id, corporation: true} = _member_option
       ) do
    case WandererApp.Api.AccessListMember.create(%{
           access_list_id: access_list_id,
           name: name,
           eve_character_id: nil,
           eve_alliance_id: nil,
           eve_corporation_id: eve_id
         }) do
      {:ok, member} -&gt;
        {:ok, _} =
          WandererApp.User.ActivityTracker.track_acl_event(:map_acl_member_added, %{
            user_id: socket.assigns.current_user.id,
            acl_id: access_list_id,
            member:
              member
              |&gt; Map.take([:eve_character_id, :eve_corporation_id, :eve_alliance_id, :role])
          })

        :telemetry.execute([:wanderer_app, :acl, :member, :add], %{count: 1})

        {:ok, member}

      _ -&gt;
        {:ok, nil}
    end
  end

  defp add_member(
         socket,
         access_list_id,
         %{label: name, value: eve_id, alliance: true} = _member_option
       ) do
    case WandererApp.Api.AccessListMember.create(%{
           access_list_id: access_list_id,
           name: name,
           eve_character_id: nil,
           eve_corporation_id: nil,
           eve_alliance_id: eve_id,
           role: :viewer
         }) do
      {:ok, member} -&gt;
        {:ok, _} =
          WandererApp.User.ActivityTracker.track_acl_event(:map_acl_member_added, %{
            user_id: socket.assigns.current_user.id,
            acl_id: access_list_id,
            member:
              member
              |&gt; Map.take([:eve_character_id, :eve_corporation_id, :eve_alliance_id, :role])
          })

        :telemetry.execute([:wanderer_app, :acl, :member, :add], %{count: 1})

        {:ok, member}

      error -&gt;
        Logger.error(error)
        {:ok, nil}
    end
  end

  attr :disabled, :boolean, default: true
  attr :name, :string
  attr :icon, :string
  attr :title, :string

  def dropzone(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div
      class={[
        &quot;dropzone stat text-center flex flex-1 items-center justify-center border-gray-500&quot;,
        classes(&quot;bg-grey-800&quot;: @disabled, &quot;hover:bg-orange-600 hover:bg-opacity-30&quot;: not @disabled)
      ]}
      id={@name}
      data-dropzone={@name}
      title={@title}
    &gt;
      &lt;.icon name={@icon} class=&quot;w-6 h-6&quot; /&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  slot(:option)

  def search_member_item(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;flex items-center&quot;&gt;
      &lt;div :if={@option.value != :loading} class=&quot;avatar&quot;&gt;
        &lt;div class=&quot;rounded-md w-12 h-12&quot;&gt;
          &lt;img src={search_member_icon_url(@option)} alt={@option.label} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;span :if={@option.value == :loading} &lt;span class=&quot;loading loading-spinner loading-xs&quot;&gt;&lt;/span&gt;
      &amp;nbsp; &lt;%= @option.label %&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  def search_member_icon_url(%{character: true} = option),
    do: member_icon_url(%{eve_character_id: option.value})

  def search_member_icon_url(%{corporation: true} = option),
    do: member_icon_url(%{eve_corporation_id: option.value})

  def search_member_icon_url(%{alliance: true} = option),
    do: member_icon_url(%{eve_alliance_id: option.value})

  def search_member_icon_url(%{eve_id: eve_id} = _option),
    do: member_icon_url(%{eve_character_id: eve_id})

  defp search(character_id, search),
    do:
      WandererApp.Character.search(character_id,
        params: [search: search, categories: &quot;character,alliance,corporation&quot;]
      )

  defp map_user_character_info(%{eve_id: eve_id, label: label} = _character) do
    %{
      label: label,
      value: eve_id,
      character: true
    }
  end

  defp map_character(%{name: name, id: id, eve_id: eve_id} = _character) do
    %{label: name, value: id, id: id, eve_id: eve_id}
  end

  defp map_ui_acl(acl, selected_id) do
    acl |&gt; Map.put(:selected, acl.id == selected_id)
  end
end</file><file path="lib/wanderer_app_web/live/access_lists/access_lists_live.html.heex">&lt;div class=&quot;p-3 h-full w-full pl-20&quot;&gt;
  &lt;main class=&quot;flex gap-4 w-full h-full shadow-sm col-span-2 lg:col-span-1 overflow-auto p-3&quot;&gt;
    &lt;div class=&quot;flex-1 flex flex-col w-64 h-full bg-gray-400 bg-opacity-5 border border-gray-500 rounded-none justify-between table overflow-auto&quot;&gt;
      &lt;.table
        class=&quot;h-[calc(100vh-106px)] !overflow-y-auto&quot;
        id=&quot;access-lists&quot;
        rows={@access_lists}
        row_click={fn acl -&gt; send(self(), &quot;select_acl_#{acl.id}&quot;) end}
        row_selected={fn acl -&gt; @selected_acl_id == acl.id end}
      &gt;
        &lt;:col :let={acl} label=&quot;Access List&quot;&gt;
          &lt;%= acl.name %&gt;
        &lt;/:col&gt;
        &lt;:col :let={acl} label=&quot;Description&quot;&gt;
          &lt;%= acl.description %&gt;
        &lt;/:col&gt;
        &lt;:action :let={acl}&gt;
          &lt;.link
            :if={can_edit?(acl, @current_user)}
            class=&quot;hover:text-white&quot;
            patch={~p&quot;/access-lists/#{acl.id}/edit&quot;}
          &gt;
            &lt;.icon name=&quot;hero-pencil-solid&quot; class=&quot;w-4 h-4&quot; /&gt;
          &lt;/.link&gt;
        &lt;/:action&gt;
        &lt;:action :let={acl}&gt;
          &lt;button
            :if={can_edit?(acl, @current_user)}
            phx-click=&quot;delete-acl&quot;
            phx-value-id={acl.id}
            data={[confirm: &quot;Please confirm to delete access list!&quot;]}
          &gt;
            &lt;.icon name=&quot;hero-trash-solid&quot; class=&quot;w-4 h-4 hover:text-white&quot; /&gt;
          &lt;/button&gt;
        &lt;/:action&gt;
      &lt;/.table&gt;
      &lt;.link class=&quot;btn mt-2 w-full btn-neutral rounded-none&quot; patch={~p&quot;/access-lists/new&quot;}&gt;
        &lt;.icon name=&quot;hero-plus-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
        &lt;h3 class=&quot;card-title text-center text-md&quot;&gt;New Access List&lt;/h3&gt;
      &lt;/.link&gt;
    &lt;/div&gt;
    &lt;div class=&quot;flex-2 w-[50%] flex flex-col h-full bg-gray-400 bg-opacity-5 border border-gray-500 justify-between&quot;&gt;
      &lt;div phx-hook=&quot;Drag&quot; id=&quot;drag&quot;&gt;
        &lt;div class=&quot;stats h-14 w-full rounded-none&quot;&gt;
          &lt;.dropzone
            name=&quot;admin&quot;
            icon=&quot;hero-user-group-solid&quot;
            disabled={@selected_acl_id == &quot;&quot;}
            title=&quot;Admin&quot;
          /&gt;
          &lt;.dropzone
            name=&quot;manager&quot;
            icon=&quot;hero-academic-cap-solid&quot;
            disabled={@selected_acl_id == &quot;&quot;}
            title=&quot;Manager&quot;
          /&gt;
          &lt;.dropzone
            name=&quot;member&quot;
            icon=&quot;hero-user-solid&quot;
            disabled={@selected_acl_id == &quot;&quot;}
            title=&quot;Member&quot;
          /&gt;
          &lt;.dropzone
            name=&quot;viewer&quot;
            icon=&quot;hero-eye-solid&quot;
            disabled={@selected_acl_id == &quot;&quot;}
            title=&quot;Viewer&quot;
          /&gt;
          &lt;.dropzone
            name=&quot;blocked&quot;
            icon=&quot;hero-no-symbol-solid text-red-500&quot;
            disabled={@selected_acl_id == &quot;&quot;}
            title=&quot;Blocked&quot;
          /&gt;
        &lt;/div&gt;
        &lt;h3 class=&quot;w-full p-2 text-center text-sm border-t border-gray-500&quot;&gt;
          Drag members into the area above to assign a role
        &lt;/h3&gt;

        &lt;div
          class=&quot;dropzone droppable draggable-dropzone--occupied flex flex-col gap-1 w-full rounded-none h-[calc(100vh-211px)] !overflow-y-auto&quot;
          id=&quot;acl_members&quot;
        &gt;
          &lt;div
            :for={member &lt;- @members |&gt; Enum.sort_by(&amp;{&amp;1.role, &amp;1.name}, &amp;&lt;=/2)}
            draggable=&quot;true&quot;
            id={member.id}
            class=&quot;draggable !p-1 h-10 cursor-move bg-black bg-opacity-25 hover:text-white&quot;
            data-dropzone=&quot;pool&quot;
          &gt;
            &lt;div class=&quot;flex justify-between relative&quot;&gt;
              &lt;.live_component
                module={WandererAppWeb.AclMember}
                id={&quot;select_role_&quot; &lt;&gt; member.id}
                notify_to={self()}
                member={member}
                event_name=&quot;update_role&quot;
              /&gt;
              &lt;button
                :if={can_delete_member?(member, @access_list, @current_user)}
                class=&quot;z-10 absolute top-0 right-2&quot;
                draggable=&quot;false&quot;
                phx-click=&quot;delete-member&quot;
                phx-value-id={member.id}
                data={[confirm: &quot;Please confirm to delete member!&quot;]}
              &gt;
                &lt;.icon name=&quot;hero-trash-solid&quot; class=&quot;w-4 h-4 hover:text-white&quot; /&gt;
              &lt;/button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;.link
        disabled={@selected_acl_id == &quot;&quot; or not can_add_members?(@access_list, @current_user)}
        class=&quot;btn mt-2 w-full btn-neutral rounded-none&quot;
        patch={~p&quot;/access-lists/#{@selected_acl_id}/add-members&quot;}
      &gt;
        &lt;.icon name=&quot;hero-plus-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
        &lt;h3 class=&quot;card-title text-center text-md&quot;&gt;Add Members&lt;/h3&gt;
      &lt;/.link&gt;
    &lt;/div&gt;
  &lt;/main&gt;
&lt;/div&gt;

&lt;.modal
  :if={@live_action in [:create, :edit]}
  title={&quot;#{(@live_action == :create &amp;&amp; &quot;Create&quot;) || &quot;Edit&quot;} Access List&quot;}
  class=&quot;!w-[500px]&quot;
  id=&quot;add_acl_modal&quot;
  show
  on_cancel={JS.patch(~p&quot;/access-lists/#{@selected_acl_id}&quot;)}
&gt;
  &lt;.form :let={f} for={@form} phx-change=&quot;validate&quot; phx-submit={@live_action}&gt;
    &lt;.input type=&quot;text&quot; field={f[:name]} placeholder=&quot;Name&quot; /&gt;
    &lt;.input type=&quot;textarea&quot; field={f[:description]} placeholder=&quot;Public description&quot; /&gt;
    &lt;.input
      type=&quot;select&quot;
      field={f[:owner_id]}
      class=&quot;select h-8 min-h-[10px] !pt-1 !pb-1 text-sm bg-neutral-900&quot;
      wrapper_class=&quot;mt-2&quot;
      label=&quot;Owner&quot;
      placeholder=&quot;Select an owner&quot;
      options={Enum.map(@characters, fn character -&gt; {character.label, character.id} end)}
    /&gt;

    &lt;!-- Divider between above inputs and the API key section --&gt;
    &lt;hr class=&quot;my-4 border-gray-600&quot; /&gt;

    &lt;!-- API Key Section with grid layout --&gt;
    &lt;div class=&quot;mt-2&quot;&gt;
      &lt;label class=&quot;block text-sm font-medium text-gray-200 mb-1&quot;&gt;ACL API key&lt;/label&gt;
      &lt;div class=&quot;grid grid-cols-12 gap-2&quot;&gt;
        &lt;div class=&quot;col-span-7&quot;&gt;
          &lt;.input
            type=&quot;text&quot;
            field={f[:api_key]}
            placeholder=&quot;No API Key yet&quot;
            readonly
            class=&quot;w-full&quot;
          /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-span-3&quot;&gt;
          &lt;.button
            type=&quot;button&quot;
            phx-click=&quot;generate-api-key&quot;
            class=&quot;p-button p-component p-button-primary w-full&quot;
            style=&quot;min-width: 0;&quot;
          &gt;
            &lt;span class=&quot;p-button-label&quot;&gt;Generate&lt;/span&gt;
          &lt;/.button&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-span-2&quot;&gt;
          &lt;.button
            type=&quot;button&quot;
            phx-hook=&quot;CopyToClipboard&quot;
            id=&quot;copy-acl-api-key&quot;
            data-url={f[:api_key].value}
            disabled={is_nil(f[:api_key].value) or f[:api_key].value == &quot;&quot;}
            class={&quot;p-button p-component w-full &quot; &lt;&gt; if(is_nil(f[:api_key].value) or f[:api_key].value == &quot;&quot;, do: &quot;p-disabled&quot;, else: &quot;&quot;)}
          &gt;
            &lt;span class=&quot;p-button-label&quot;&gt;Copy&lt;/span&gt;
          &lt;/.button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;hr class=&quot;my-4 border-gray-600&quot; /&gt;

    &lt;div class=&quot;modal-action&quot;&gt;
      &lt;.button class=&quot;mt-2&quot; type=&quot;submit&quot; phx-disable-with=&quot;Saving...&quot;&gt;
        &lt;%= (@live_action == :create &amp;&amp; &quot;Create&quot;) || &quot;Save&quot; %&gt;
      &lt;/.button&gt;
    &lt;/div&gt;
  &lt;/.form&gt;
&lt;/.modal&gt;

&lt;.modal
  :if={@live_action in [:add_members]}
  title=&quot;Add Member&quot;
  class=&quot;!w-[500px]&quot;
  id=&quot;add_member&quot;
  show
  on_cancel={JS.patch(~p&quot;/access-lists/#{@selected_acl_id}&quot;)}
&gt;
  &lt;%!-- &lt;div class=&quot;mt-4 mb-2 p-tabmenu p-component &quot; data-pc-section=&quot;tabmenu&quot;&gt;
    &lt;ul
      class=&quot;p-tabmenu-nav border-none h-[25px] w-full flex&quot;
      role=&quot;menubar&quot;
      data-pc-section=&quot;menu&quot;
    &gt;
      &lt;li
        id=&quot;pr_id_17_0&quot;
        class=&quot;p-tabmenuitem p-highlight&quot;
        role=&quot;presentation&quot;
        data-p-highlight=&quot;true&quot;
        data-p-disabled=&quot;false&quot;
        data-pc-section=&quot;menuitem&quot;
      &gt;
        &lt;a
          href=&quot;#&quot;
          role=&quot;menuitem&quot;
          aria-label=&quot;Router Link&quot;
          tabindex=&quot;0&quot;
          class=&quot;p-menuitem-link&quot;
          data-pc-section=&quot;action&quot;
        &gt;
          &lt;span class=&quot;p-menuitem-text&quot; data-pc-section=&quot;label&quot;&gt;Character&lt;/span&gt;
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li
        id=&quot;pr_id_17_1&quot;
        class=&quot;p-tabmenuitem&quot;
        role=&quot;presentation&quot;
        data-p-highlight=&quot;false&quot;
        data-p-disabled=&quot;false&quot;
        data-pc-section=&quot;menuitem&quot;
      &gt;
        &lt;a
          href=&quot;#&quot;
          role=&quot;menuitem&quot;
          aria-label=&quot;Programmatic&quot;
          tabindex=&quot;-1&quot;
          class=&quot;p-menuitem-link&quot;
          data-pc-section=&quot;action&quot;
        &gt;
          &lt;span class=&quot;p-menuitem-text&quot; data-pc-section=&quot;label&quot;&gt;Corporation&lt;/span&gt;
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li
        id=&quot;pr_id_17_2&quot;
        class=&quot;p-tabmenuitem&quot;
        role=&quot;presentation&quot;
        data-p-highlight=&quot;false&quot;
        data-p-disabled=&quot;false&quot;
        data-pc-section=&quot;menuitem&quot;
      &gt;
        &lt;a
          href=&quot;#&quot;
          role=&quot;menuitem&quot;
          aria-label=&quot;External&quot;
          tabindex=&quot;-1&quot;
          class=&quot;p-menuitem-link&quot;
          data-pc-section=&quot;action&quot;
        &gt;
          &lt;span class=&quot;p-menuitem-text&quot; data-pc-section=&quot;label&quot;&gt;Alliance&lt;/span&gt;
        &lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt; --%&gt;
  &lt;.form :let={f} for={@member_form} phx-submit={@live_action}&gt;
    &lt;.live_select
      field={f[:member_id]}
      dropdown_extra_class=&quot;max-h-64&quot;
      available_option_class=&quot;w-full&quot;
      debounce={250}
      update_min_len={3}
      mode={:tags}
      options={@member_search_options}
      placeholder=&quot;Search a character/corporation/alliance&quot;
    &gt;
      &lt;:option :let={option}&gt;
        &lt;.search_member_item option={option} /&gt;
      &lt;/:option&gt;
    &lt;/.live_select&gt;
    &lt;div class=&quot;modal-action&quot;&gt;
      &lt;.button class=&quot;mt-2&quot; type=&quot;submit&quot;&gt;
        Add
      &lt;/.button&gt;
    &lt;/div&gt;
  &lt;/.form&gt;
&lt;/.modal&gt;</file><file path="lib/wanderer_app_web/live/admin/admin_live.ex">defmodule WandererAppWeb.AdminLive do
  use WandererAppWeb, :live_view

  require Logger
  alias BetterNumber, as: Number

  @invite_link_ttl :timer.hours(24)

  def mount(_params, %{&quot;user_id&quot; =&gt; user_id} = _session, socket)
      when not is_nil(user_id) do
    WandererApp.StartCorpWalletTrackerTask.maybe_start_corp_wallet_tracker(
      {:ok, socket.assigns.current_user.characters}
    )

    corp_wallet_character =
      socket.assigns.current_user.characters
      |&gt; Enum.find(fn character -&gt;
        WandererApp.Character.can_track_corp_wallet?(character)
      end)

    Phoenix.PubSub.subscribe(
      WandererApp.PubSub,
      &quot;corporation&quot;
    )

    user_character_ids = socket.assigns.current_user.characters |&gt; Enum.map(&amp; &amp;1.id)

    user_character_ids
    |&gt; Enum.each(fn user_character_id -&gt;
      :ok = WandererApp.Character.TrackerManager.start_tracking(user_character_id)
    end)

    socket =
      if not is_nil(corp_wallet_character) do
        {:ok, total_balance} =
          WandererApp.Character.TransactionsTracker.get_total_balance(corp_wallet_character.id)

        {:ok, transactions} =
          WandererApp.Character.TransactionsTracker.get_transactions(corp_wallet_character.id)

        socket
        |&gt; assign(
          total_balance: total_balance,
          transactions: transactions
        )
      else
        socket
        |&gt; assign(
          total_balance: 0,
          transactions: []
        )
      end

    {:ok, active_map_subscriptions} =
      WandererApp.Api.MapSubscription.all_active()

    {:ok,
     socket
     |&gt; assign(
       active_map_subscriptions: active_map_subscriptions,
       show_invites?: WandererApp.Env.invites(),
       user_character_ids: user_character_ids,
       user_id: user_id,
       invite_link: nil,
       map_subscriptions_enabled?: WandererApp.Env.map_subscriptions_enabled?(),
       restrict_maps_creation?: WandererApp.Env.restrict_maps_creation?()
     )}
  end

  @impl true
  def mount(_params, _session, socket) do
    {:ok, socket |&gt; assign(user_id: nil)}
  end

  @impl true
  def handle_params(params, uri, socket) do
    {:noreply, apply_action(socket, socket.assigns.live_action, params, uri)}
  end

  def handle_event(&quot;generate-invite-link&quot;, _params, socket) do
    uuid = UUID.uuid4(:default)
    WandererApp.Cache.put(&quot;invite_#{uuid}&quot;, true, ttl: @invite_link_ttl)

    invite_link =
      socket.assigns.uri
      |&gt; Map.put(:path, &quot;/welcome&quot;)
      |&gt; Map.put(:query, URI.encode_query(%{invite: uuid}))
      |&gt; URI.to_string()

    {:noreply,
     socket
     |&gt; assign(invite_link: invite_link)}
  end

  @impl true
  def handle_event(&quot;update-eve-db-data&quot;, _params, socket) do
    WandererApp.EveDataService.update_eve_data()
    {:noreply, socket |&gt; put_flash(:info, &quot;EVE Data updated. Please restart server.&quot;)}
  end

  @impl true
  def handle_event(&quot;authorize&quot;, _params, socket) do
    token = UUID.uuid4(:default)
    WandererApp.Cache.put(&quot;invite_#{token}&quot;, true, ttl: :timer.minutes(30))

    {:noreply, socket |&gt; push_navigate(to: ~p&quot;/auth/eve?invite=#{token}&amp;admin=true&quot;)}
  end

  @impl true
  def handle_event(
        &quot;live_select_change&quot;,
        %{&quot;id&quot; =&gt; &quot;_character_id_live_select_component&quot; = id, &quot;text&quot; =&gt; text} = _change_event,
        socket
      ) do
    options =
      if text == &quot;&quot; do
        []
      else
        DebounceAndThrottle.Debounce.apply(
          Process,
          :send_after,
          [self(), {:search, text}, 100],
          &quot;character_search&quot;,
          500
        )

        [%{label: &quot;Loading...&quot;, value: :loading, disabled: true}]
      end

    send_update(LiveSelect.Component, options: options, id: id)

    {:noreply,
     socket
     |&gt; assign(
       character_search_options: options,
       character_search_text: text,
       character_search_id: id
     )}
  end

  @impl true
  def handle_event(
        &quot;live_select_change&quot;,
        %{&quot;id&quot; =&gt; &quot;_unlink_character_id_live_select_component&quot; = id, &quot;text&quot; =&gt; text} =
          _change_event,
        socket
      ) do
    options =
      if text == &quot;&quot; do
        []
      else
        DebounceAndThrottle.Debounce.apply(
          Process,
          :send_after,
          [self(), {:search, text}, 100],
          &quot;character_search&quot;,
          500
        )

        [%{label: &quot;Loading...&quot;, value: :loading, disabled: true}]
      end

    send_update(LiveSelect.Component, options: options, id: id)

    {:noreply,
     socket
     |&gt; assign(
       character_search_options: options,
       character_search_text: text,
       character_search_id: id
     )}
  end

  @impl true
  def handle_event(
        &quot;update-balance&quot;,
        %{&quot;amount&quot; =&gt; amount, &quot;character_id&quot; =&gt; character_id} = _form,
        socket
      ) do
    {:ok, %{user: user}} = WandererApp.Api.Character.by_id!(character_id) |&gt; Ash.load([:user])

    {:ok, _user} =
      user
      |&gt; WandererApp.Api.User.update_balance(%{
        balance: String.to_integer(amount)
      })

    {:noreply,
     socket
     |&gt; put_flash(:info, &quot;User balance updated.&quot;)}
  end

  @impl true
  def handle_event(
        &quot;unlink-character&quot;,
        %{&quot;unlink_character_id&quot; =&gt; character_id} = _form,
        socket
      ) do
    character =
      character_id
      |&gt; WandererApp.Api.Character.by_id!()

    character
    |&gt; WandererApp.Api.Character.mark_as_deleted!()

    {:noreply,
     socket
     |&gt; put_flash(:info, &quot;Character unlinked.&quot;)}
  end

  @impl true
  def handle_event(
        &quot;create-map&quot;,
        _params,
        socket
      ) do
    WandererApp.Cache.put(
      &quot;create_map_once&quot;,
      true
    )

    {:noreply,
     socket
     |&gt; push_navigate(to: ~p&quot;/maps/new&quot;)}
  end

  @impl true
  def handle_event(event, body, socket) do
    Logger.warning(fn -&gt; &quot;unhandled event: #{event} #{inspect(body)}&quot; end)
    {:noreply, socket}
  end

  @impl true
  def handle_info(
        {:total_balance_changed, _corporation_id, total_balance},
        socket
      ) do
    {:noreply, socket |&gt; assign(total_balance: total_balance)}
  end

  @impl true
  def handle_info(
        {:transactions, _corporation_id, transactions},
        socket
      ) do
    {:noreply, socket |&gt; assign(transactions: transactions)}
  end

  @impl true
  def handle_info({:search, text}, socket) do
    {:ok, options} = search(text)

    send_update(LiveSelect.Component, options: options, id: socket.assigns.character_search_id)
    {:noreply, socket |&gt; assign(character_search_options: options)}
  end

  defp apply_action(socket, :index, _params, uri) do
    socket
    |&gt; assign(:active_page, :admin)
    |&gt; assign(:uri, URI.parse(uri))
    |&gt; assign(:page_title, &quot;Administration&quot;)
    |&gt; assign(:character_search_options, [])
    |&gt; assign(:amounts, [
      %{label: &quot;500M&quot;, value: 500_000_000},
      %{label: &quot;1B&quot;, value: 1_000_000_000},
      %{label: &quot;5B&quot;, value: 5_000_000_000},
      %{label: &quot;10B&quot;, value: 10_000_000_000}
    ])
    |&gt; assign(:form, to_form(%{&quot;amount&quot; =&gt; 500_000_000}))
    |&gt; assign(:unlink_character_form, to_form(%{}))
  end

  defp search(search) do
    {:ok, characters} = WandererApp.Api.Character.search_by_name(%{name: search})
    {:ok, characters |&gt; Enum.map(&amp;map_character/1)}
  end

  defp map_character(%{name: name, id: id, eve_id: eve_id} = _character) do
    %{label: name, value: id, id: id, eve_id: eve_id}
  end

  attr :option, :any, required: true

  def search_member_item(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;flex items-center&quot;&gt;
      &lt;div :if={@option.value != :loading} class=&quot;avatar&quot;&gt;
        &lt;div class=&quot;rounded-md w-12 h-12&quot;&gt;
          &lt;img src={search_member_icon_url(@option)} alt={@option.label} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;span :if={@option.value == :loading} &lt;span class=&quot;loading loading-spinner loading-xs&quot;&gt;&lt;/span&gt;
      &amp;nbsp; &lt;%= @option.label %&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  def search_member_icon_url(%{character: true} = option),
    do: member_icon_url(%{eve_character_id: option.value})

  def search_member_icon_url(%{corporation: true} = option),
    do: member_icon_url(%{eve_corporation_id: option.value})

  def search_member_icon_url(%{alliance: true} = option),
    do: member_icon_url(%{eve_alliance_id: option.value})

  def search_member_icon_url(%{eve_id: eve_id} = _option),
    do: member_icon_url(%{eve_character_id: eve_id})
end</file><file path="lib/wanderer_app_web/live/admin/admin_live.html.heex">&lt;main class=&quot;w-full h-full col-span-2 lg:col-span-1 p-4 pl-20 overflow-auto&quot;&gt;
  &lt;div class=&quot;page-content&quot;&gt;
    &lt;div class=&quot;container-fluid px-[0.625rem]&quot;&gt;
      &lt;div class=&quot;grid grid-cols-1 pb-6&quot;&gt;
        &lt;div class=&quot;md:flex items-center justify-between px-[2px]&quot;&gt;
          &lt;h4 class=&quot;text-[18px] font-medium text-gray-800 mb-sm-0 grow dark:text-gray-100 mb-2 md:mb-0&quot;&gt;
            Administration
          &lt;/h4&gt;
          &lt;.link :if={@map_subscriptions_enabled?} phx-click=&quot;authorize&quot;&gt;
            &lt;.icon
              name=&quot;hero-key-solid&quot;
              class=&quot;w-6 h-6 text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-100&quot;
            /&gt;
          &lt;/.link&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;grid grid-cols-1 gap-6 md:grid-cols-2 2xl:grid-cols-4 pb-6&quot;&gt;
        &lt;div :if={@restrict_maps_creation?} class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
          &lt;div class=&quot;card-body&quot;&gt;
            &lt;.button class=&quot;mt-2&quot; type=&quot;button&quot; phx-click=&quot;create-map&quot;&gt;
              Create Map
            &lt;/.button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div :if={@map_subscriptions_enabled?} class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
          &lt;div class=&quot;card-body&quot;&gt;
            &lt;div class=&quot;col-span-6&quot;&gt;
              &lt;span class=&quot;text-gray-400 dark:text-gray-400&quot;&gt;Wanderer Balance&lt;/span&gt;
              &lt;h4 class=&quot;my-4 font-medium text-gray-800 text-4xl  dark:text-gray-100&quot;&gt;
                &lt;span class=&quot;counter-value&quot;&gt;
                  &lt;%= @total_balance |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;]) %&gt;
                &lt;/span&gt;
                ISK
              &lt;/h4&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div :if={@map_subscriptions_enabled?} class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
          &lt;div class=&quot;card-body&quot;&gt;
            &lt;div class=&quot;col-span-6&quot;&gt;
              &lt;span class=&quot;text-gray-400 dark:text-gray-400&quot;&gt;Update User Balance&lt;/span&gt;
              &lt;.form :let={f} for={@form} phx-change=&quot;check-amount&quot; phx-submit=&quot;update-balance&quot;&gt;
                &lt;.live_select
                  field={f[:character_id]}
                  dropdown_extra_class=&quot;max-h-64 overflow-y-auto flex flex-row&quot;
                  available_option_class=&quot;w-full&quot;
                  debounce={250}
                  update_min_len={3}
                  options={@character_search_options}
                  placeholder=&quot;Search a character&quot;
                &gt;
                  &lt;:option :let={option}&gt;
                    &lt;.search_member_item option={option} /&gt;
                  &lt;/:option&gt;
                &lt;/.live_select&gt;
                &lt;.live_select
                  field={f[:amount]}
                  update_min_len={0}
                  options={@amounts}
                  placeholder=&quot;Amount&quot;
                /&gt;
                &lt;div class=&quot;modal-action&quot;&gt;
                  &lt;.button class=&quot;mt-2&quot; type=&quot;submit&quot;&gt;
                    Update Balance
                  &lt;/.button&gt;
                &lt;/div&gt;
              &lt;/.form&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
          &lt;div class=&quot;card-body&quot;&gt;
            &lt;div class=&quot;col-span-6&quot;&gt;
              &lt;span class=&quot;text-gray-400 dark:text-gray-400&quot;&gt;Unlink Character&lt;/span&gt;
              &lt;.form :let={f} for={@unlink_character_form} phx-submit=&quot;unlink-character&quot;&gt;
                &lt;.live_select
                  field={f[:unlink_character_id]}
                  dropdown_extra_class=&quot;max-h-64 overflow-y-auto flex flex-row&quot;
                  available_option_class=&quot;w-full&quot;
                  debounce={250}
                  update_min_len={3}
                  options={@character_search_options}
                  placeholder=&quot;Search a character&quot;
                &gt;
                  &lt;:option :let={option}&gt;
                    &lt;.search_member_item option={option} /&gt;
                  &lt;/:option&gt;
                &lt;/.live_select&gt;
                &lt;div class=&quot;modal-action&quot;&gt;
                  &lt;.button class=&quot;mt-2&quot; type=&quot;submit&quot;&gt;
                    Unlink
                  &lt;/.button&gt;
                &lt;/div&gt;
              &lt;/.form&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
          &lt;div class=&quot;card-body&quot;&gt;
            &lt;span class=&quot;text-gray-400 dark:text-gray-400&quot;&gt;EVE DB Data&lt;/span&gt;
            &lt;.button
              class=&quot;mt-2&quot;
              type=&quot;button&quot;
              phx-click=&quot;update-eve-db-data&quot;
              phx-disable-with=&quot;Updating EVE DB Data...&quot;
            &gt;
              Update EVE DB Data
            &lt;/.button&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div :if={@show_invites?} class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
          &lt;div class=&quot;card-body&quot;&gt;
            &lt;div class=&quot;col-span-6&quot;&gt;
              &lt;span class=&quot;text-gray-400 dark:text-gray-400&quot;&gt;Invite Link&lt;/span&gt;
              &lt;h4 class=&quot;my-4 font-medium text-gray-800 text-4xl  dark:text-gray-100&quot;&gt;
                &lt;.button class=&quot;btn btn-primary&quot; phx-click=&quot;generate-invite-link&quot;&gt;
                  Generate
                &lt;/.button&gt;

                &lt;div :if={not is_nil(@invite_link)} class=&quot;join&quot;&gt;
                  &lt;input
                    class=&quot;input input-bordered join-item&quot;
                    readonly
                    type=&quot;text&quot;
                    value={@invite_link}
                  /&gt;
                  &lt;.button
                    phx-hook=&quot;CopyToClipboard&quot;
                    id=&quot;copy-to-clipboard&quot;
                    class=&quot;copy-link btn join-item rounded-r-full&quot;
                    data-url={@invite_link}
                  &gt;
                    Copy
                    &lt;div class=&quot;absolute w-[100px] !mr-[-170px] link-copied hidden&quot;&gt;
                      Link copied
                    &lt;/div&gt;
                  &lt;/.button&gt;
                &lt;/div&gt;
              &lt;/h4&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div :if={@map_subscriptions_enabled?} class=&quot;grid grid-cols-1 gap-4 lg:grid-cols-12&quot;&gt;
        &lt;div class=&quot;col-span-12 2xl:col-span-5&quot;&gt;
          &lt;div class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
            &lt;div class=&quot;nav-tabs border-b-tabs&quot;&gt;
              &lt;div class=&quot;py-3&quot;&gt;
                &lt;div class=&quot;px-3&quot; data-simplebar=&quot;init&quot;&gt;
                  &lt;div class=&quot;simplebar-wrapper&quot;&gt;
                    &lt;div class=&quot;simplebar-height-auto-observer-wrapper&quot;&gt;
                      &lt;div class=&quot;simplebar-height-auto-observer&quot;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;simplebar-mask&quot;&gt;
                      &lt;div class=&quot;simplebar-offset&quot;&gt;
                        &lt;div class=&quot;simplebar-content-wrapper&quot;&gt;
                          &lt;div class=&quot;simplebar-content&quot; style=&quot;padding: 0px 12px;&quot;&gt;
                            &lt;.table
                              id=&quot;transactions&quot;
                              rows={@transactions}
                              class=&quot;!max-h-[40vh] !overflow-y-auto&quot;
                            &gt;
                              &lt;:col :let={transaction}&gt;
                                &lt;div class=&quot; text-22&quot;&gt;
                                  &lt;.icon name=&quot;hero-credit-card-solid&quot; class=&quot;h-5 w-5&quot; /&gt;
                                &lt;/div&gt;
                              &lt;/:col&gt;
                              &lt;:col :let={transaction} label=&quot;Transaction&quot;&gt;
                                &lt;div&gt;
                                  &lt;h5 class=&quot;mb-1 text-sm font-medium text-gray-700 dark:text-gray-100&quot;&gt;
                                    &lt;%= transaction.reason_encoded %&gt;
                                  &lt;/h5&gt;
                                  &lt;p class=&quot;mb-0 text-xs text-gray-600 dark:text-zinc-100 whitespace-nowrap&quot;&gt;
                                    &lt;%= transaction.date %&gt;
                                  &lt;/p&gt;
                                &lt;/div&gt;
                              &lt;/:col&gt;
                              &lt;:col :let={transaction} label=&quot;Description&quot;&gt;
                                &lt;%= transaction.description %&gt;
                              &lt;/:col&gt;
                              &lt;:col :let={transaction} label=&quot;&quot;&gt;
                                &lt;div class=&quot;text-end&quot;&gt;
                                  &lt;h5 class=&quot;mb-0 text-sm text-gray-500 dark:text-zinc-100&quot;&gt;
                                    &lt;%= transaction.amount_encoded
                                    |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;]) %&gt;
                                  &lt;/h5&gt;
                                  &lt;p class=&quot;mb-0 text-xs text-gray-600 dark:text-zinc-100 whitespace-nowrap&quot;&gt;
                                    ISK
                                  &lt;/p&gt;
                                &lt;/div&gt;
                              &lt;/:col&gt;
                            &lt;/.table&gt;
                          &lt;/div&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;simplebar-placeholder&quot;&gt;&lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div class=&quot;col-span-12 2xl:col-span-5 mt-6&quot;&gt;
            &lt;div class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
              &lt;div class=&quot;nav-tabs border-b-tabs&quot;&gt;
                &lt;div class=&quot;py-3&quot;&gt;
                  &lt;div class=&quot;px-3&quot; data-simplebar=&quot;init&quot;&gt;
                    &lt;div class=&quot;simplebar-wrapper&quot;&gt;
                      &lt;div class=&quot;simplebar-height-auto-observer-wrapper&quot;&gt;
                        &lt;div class=&quot;simplebar-height-auto-observer&quot;&gt;&lt;/div&gt;
                      &lt;/div&gt;
                      &lt;div class=&quot;simplebar-mask&quot;&gt;
                        &lt;div class=&quot;simplebar-offset&quot;&gt;
                          &lt;div class=&quot;simplebar-content-wrapper&quot;&gt;
                            &lt;div class=&quot;simplebar-content&quot; style=&quot;padding: 0px 12px;&quot;&gt;
                              &lt;.table
                                id=&quot;transactions&quot;
                                rows={@active_map_subscriptions}
                                class=&quot;!max-h-[40vh] !overflow-y-auto&quot;
                              &gt;
                                &lt;:col :let={subscription}&gt;
                                  &lt;div class=&quot; text-22&quot;&gt;
                                    &lt;.icon name=&quot;hero-check-badge-solid&quot; class=&quot;w-5 h-5&quot; /&gt;
                                  &lt;/div&gt;
                                &lt;/:col&gt;
                                &lt;:col :let={subscription} label=&quot;Active Till&quot;&gt;
                                  &lt;.local_time
                                    :if={subscription.active_till}
                                    id={&quot;subscription-active-till-#{subscription.id}&quot;}
                                    at={subscription.active_till}
                                  &gt;
                                    &lt;%= subscription.active_till %&gt;
                                  &lt;/.local_time&gt;
                                &lt;/:col&gt;
                                &lt;:col :let={subscription} label=&quot;Characters Limit&quot;&gt;
                                  &lt;%= subscription.characters_limit %&gt;
                                &lt;/:col&gt;
                                &lt;:col :let={subscription} label=&quot;Hubs Limit&quot;&gt;
                                  &lt;%= subscription.hubs_limit %&gt;
                                &lt;/:col&gt;
                                &lt;:col :let={subscription} label=&quot;Auto Renew&quot;&gt;
                                  &lt;%= if subscription.auto_renew?, do: &quot;Yes&quot;, else: &quot;No&quot; %&gt;
                                &lt;/:col&gt;
                              &lt;/.table&gt;
                            &lt;/div&gt;
                          &lt;/div&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/main&gt;</file><file path="lib/wanderer_app_web/live/characters/characters_live.ex">defmodule WandererAppWeb.CharactersLive do
  use WandererAppWeb, :live_view

  import Pathex

  alias BetterNumber, as: Number

  def mount(_params, %{&quot;user_id&quot; =&gt; user_id} = _session, socket)
      when not is_nil(user_id) do
    {:ok, characters} = WandererApp.Api.Character.active_by_user(%{user_id: user_id})

    characters
    |&gt; Enum.map(&amp; &amp;1.id)
    |&gt; Enum.each(fn character_id -&gt;
      Phoenix.PubSub.subscribe(
        WandererApp.PubSub,
        &quot;character:#{character_id}:alliance&quot;
      )

      Phoenix.PubSub.subscribe(
        WandererApp.PubSub,
        &quot;character:#{character_id}:corporation&quot;
      )

      :ok = WandererApp.Character.TrackerManager.start_tracking(character_id)
    end)

    {:ok,
     socket
     |&gt; assign(
       show_characters_add_alert: true,
       mode: :blocks,
       wallet_tracking_enabled?: WandererApp.Env.wallet_tracking_enabled?(),
       characters: characters |&gt; Enum.sort_by(&amp; &amp;1.name, :asc) |&gt; Enum.map(&amp;map_ui_character/1),
       user_id: user_id
     )}
  end

  @impl true
  def mount(_params, _session, socket) do
    {:ok, socket |&gt; assign(characters: [], user_id: nil)}
  end

  @impl true
  def handle_params(params, _url, socket) do
    {:noreply, apply_action(socket, socket.assigns.live_action, params)}
  end

  @impl true
  def handle_event(&quot;restore_show_characters_add_alert&quot;, %{&quot;value&quot; =&gt; value}, socket) do
    {:noreply,
     socket
     |&gt; assign(show_characters_add_alert: value)}
  end

  @impl true
  def handle_event(&quot;authorize&quot;, form, socket) do
    track_wallet = form |&gt; Map.get(&quot;track_wallet&quot;, false)
    token = UUID.uuid4(:default)
    WandererApp.Cache.put(&quot;invite_#{token}&quot;, true, ttl: :timer.minutes(30))

    {:noreply, socket |&gt; push_navigate(to: ~p&quot;/auth/eve?invite=#{token}&amp;w=#{track_wallet}&quot;)}
  end

  @impl true
  def handle_event(&quot;delete&quot;, %{&quot;character_id&quot; =&gt; character_id}, socket) do
    WandererApp.Character.TrackerManager.stop_tracking(character_id)

    {:ok, map_user_settings} = WandererApp.Api.MapCharacterSettings.tracked_by_character(%{character_id: character_id})

    map_user_settings
    |&gt; Enum.each(fn settings -&gt;
      settings
      |&gt; WandererApp.Api.MapCharacterSettings.untrack()
    end)

    {:ok, updated_character} =
      socket.assigns.characters
      |&gt; Enum.find(&amp;(&amp;1.id == character_id))
      |&gt; WandererApp.Api.Character.mark_as_deleted()

    WandererApp.Character.update_character(character_id, updated_character)

    {:ok, characters} =
      WandererApp.Api.Character.active_by_user(%{user_id: socket.assigns.user_id})

    {:noreply, socket |&gt; assign(characters: characters |&gt; Enum.map(&amp;map_ui_character/1))}
  end

  @impl true
  def handle_event(&quot;show_table&quot;, %{&quot;value&quot; =&gt; &quot;on&quot;}, socket) do
    {:noreply, socket |&gt; assign(mode: :table)}
  end

  @impl true
  def handle_event(&quot;show_table&quot;, _, socket) do
    {:noreply, socket |&gt; assign(mode: :blocks)}
  end

  @impl true
  def handle_info(
        {:character_alliance, _update},
        socket
      ) do
    {:ok, characters} =
      WandererApp.Api.Character.active_by_user(%{user_id: socket.assigns.user_id})

    {:noreply, socket |&gt; assign(characters: characters |&gt; Enum.map(&amp;map_ui_character/1))}
  end

  @impl true
  def handle_info(
        {:character_corporation, _update},
        socket
      ) do
    {:ok, characters} =
      WandererApp.Api.Character.active_by_user(%{user_id: socket.assigns.user_id})

    {:noreply, socket |&gt; assign(characters: characters |&gt; Enum.map(&amp;map_ui_character/1))}
  end

  @impl true
  def handle_info(
        {:character_wallet_balance, _character_id},
        socket
      ) do
    {:ok, characters} =
      WandererApp.Api.Character.active_by_user(%{user_id: socket.assigns.user_id})

    {:noreply, socket |&gt; assign(characters: characters |&gt; Enum.map(&amp;map_ui_character/1))}
  end

  @impl true
  def handle_info(
        _event,
        socket
      ) do
    {:noreply, socket}
  end

  defp apply_action(socket, :index, _params) do
    socket
    |&gt; assign(:active_page, :characters)
    |&gt; assign(:page_title, &quot;Characters&quot;)
  end

  defp apply_action(socket, :authorize, _params) do
    socket
    |&gt; assign(:active_page, :characters)
    |&gt; assign(:page_title, &quot;Authorize Character - Characters&quot;)
    |&gt; assign(:form, to_form(%{&quot;track_wallet&quot; =&gt; false}))
  end

  defp map_ui_character(character) do
    can_track_wallet? = WandererApp.Character.can_track_wallet?(character)

    character
    |&gt; Map.take([
      :id,
      :eve_id,
      :name,
      :corporation_id,
      :corporation_name,
      :corporation_ticker,
      :alliance_id,
      :alliance_name,
      :alliance_ticker
    ])
    |&gt; Map.put_new(:show_wallet_balance?, can_track_wallet?)
    |&gt; maybe_add_wallet_balance(character, can_track_wallet?)
    |&gt; Map.put_new(:ship, WandererApp.Character.get_ship(character))
    |&gt; Map.put_new(:location, WandererApp.Character.get_location(character))
    |&gt; Map.put_new(:invalid_token, is_nil(character.access_token))
  end

  defp maybe_add_wallet_balance(map, character, true) do
    case WandererApp.Character.can_track_wallet?(character) do
      true -&gt;
        {:ok, %{eve_wallet_balance: eve_wallet_balance}} =
          character
          |&gt; Ash.load([:eve_wallet_balance])

        Map.put_new(map, :eve_wallet_balance, eve_wallet_balance)

      _ -&gt;
        Map.put_new(map, :eve_wallet_balance, 0.0)
    end
  end

  defp maybe_add_wallet_balance(map, _character, _can_track_wallet?),
    do: Map.put_new(map, :eve_wallet_balance, 0.0)
end</file><file path="lib/wanderer_app_web/live/characters/characters_live.html.heex">&lt;nav class=&quot;px-6 flex items-center justify-between w-full h-12 pointer-events-auto border-b border-stone-800  bg-opacity-70 bg-neutral-900&quot;&gt;
  &lt;span className=&quot;w-full&quot;&gt;&lt;/span&gt;
  &lt;span className=&quot;mr-2&quot;&gt;&lt;/span&gt;
  &lt;div class=&quot;flex gap-2&quot;&gt;
    &lt;div class=&quot;form-control&quot;&gt;
      &lt;label class=&quot;label cursor-pointer gap-2&quot;&gt;
        &lt;span class=&quot;label-text&quot;&gt;Show table&lt;/span&gt;
        &lt;%= if @mode == :table do %&gt;
          &lt;input type=&quot;checkbox&quot; class=&quot;checkbox&quot; checked phx-click=&quot;show_table&quot; /&gt;
        &lt;% else %&gt;
          &lt;input type=&quot;checkbox&quot; class=&quot;checkbox&quot; phx-click=&quot;show_table&quot; /&gt;
        &lt;% end %&gt;
      &lt;/label&gt;
    &lt;/div&gt;
    &lt;div :if={@wallet_tracking_enabled?} class=&quot;form-control&quot;&gt;
      &lt;label class=&quot;label cursor-pointer gap-2&quot;&gt;
        &lt;span class=&quot;label-text&quot;&gt;Show balance&lt;/span&gt;
        &lt;input
          phx-ignore
          type=&quot;checkbox&quot;
          class=&quot;checkbox&quot;
          phx-click={JS.toggle_class(&quot;show-blured&quot;, to: &quot;#characters-list&quot;)}
        /&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/nav&gt;
&lt;main
  id=&quot;characters-list&quot;
  class=&quot;w-full h-full col-span-2 lg:col-span-1 p-4 pl-20 pb-20 overflow-auto&quot;
&gt;
  &lt;div
    :if={@show_characters_add_alert}
    role=&quot;alert&quot;
    class=&quot;alert&quot;
    id=&quot;characters-add-alert&quot;
    phx-hook=&quot;ShowCharactersAddAlert&quot;
    phx-ignore
    data-key=&quot;show_characters_add_alert&quot;
  &gt;
    &lt;svg
      xmlns=&quot;http://www.w3.org/2000/svg&quot;
      fill=&quot;none&quot;
      viewBox=&quot;0 0 24 24&quot;
      class=&quot;h-6 w-6 shrink-0 stroke-current&quot;
    &gt;
      &lt;path
        stroke-linecap=&quot;round&quot;
        stroke-linejoin=&quot;round&quot;
        stroke-width=&quot;2&quot;
        d=&quot;M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z&quot;
      &gt;
      &lt;/path&gt;
    &lt;/svg&gt;
    &lt;span&gt;
      All added characters will be automatically linked to your user account. You can&apos;t have same characters linked to several accounts.
    &lt;/span&gt;
    &lt;div&gt;
      &lt;button
        class=&quot;btn btn-sm&quot;
        id=&quot;characters-add-alert-hide&quot;
        phx-click={JS.toggle_class(&quot;hidden&quot;, to: &quot;#characters-add-alert&quot;)}
      &gt;
        Hide
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div
    :if={@mode == :blocks}
    class=&quot;gap-4 grid grid-cols-1 lg:grid-cols-4 md:grid-cols-3 sm:grid-cols-2 mt-4&quot;
  &gt;
    &lt;.link patch={~p&quot;/characters/authorize&quot;}&gt;
      &lt;div class=&quot;card card-side rounded-none h-full items-center hover:text-white bg-gradient-to-l from-stone-950 to-stone-900 transform transition duration-500&quot;&gt;
        &lt;div class=&quot;card-body justify-center items-center&quot;&gt;
          &lt;.icon name=&quot;hero-squares-plus-solid&quot; class=&quot;w-20 h-20&quot; /&gt;
          &lt;h3 class=&quot;card-title text-center text-md&quot;&gt;Authorize character&lt;/h3&gt;
          &lt;p class=&quot;text-sm text-center &quot;&gt;* Using EVE-ONLINE SSO authorization&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/.link&gt;
    &lt;div
      :for={character &lt;- @characters |&gt; Enum.sort_by(&amp; &amp;1.name, :asc)}
      class=&quot;card rounded-none bg-gradient-to-l from-stone-950 to-stone-900 hover:text-white transform transition duration-500&quot;
    &gt;
      &lt;figure class=&quot;avatar&quot;&gt;
        &lt;img class=&quot;h-max-100&quot; src={member_icon_url(character.eve_id)} alt={character.name} /&gt;
        &lt;div class=&quot;absolute left-0 bottom-0 w-full h-30 bg-opacity-60 bg-gray-900&quot;&gt;
          &lt;h2 class=&quot;absolute w-full flex justify-between px-4 left-0 top-10 text-xs&quot;&gt;
            Corporation:
            &lt;span
              :if={
                is_nil(
                  character
                  |&gt; get(
                    path(:corporation_name),
                    nil
                  )
                )
              }
              class=&quot;loading loading-dots loading-xs&quot;
            /&gt;
            &lt;span&gt;
              &lt;%= character
              |&gt; get(
                path(:corporation_name),
                &quot;&quot;
              ) %&gt;
            &lt;/span&gt;
          &lt;/h2&gt;
          &lt;h2 class=&quot;absolute w-full flex justify-between px-4 left-0 top-16 text-xs&quot;&gt;
            Alliance:
            &lt;span&gt;
              &lt;%= character
              |&gt; get(path(:alliance_name), &quot;-&quot;) || &quot;-&quot; %&gt;
            &lt;/span&gt;
          &lt;/h2&gt;
          &lt;h2 class=&quot;absolute left-0 bottom-12 px-4 text-xs w-full flex justify-between&quot;&gt;
            Location:
            &lt;span
              :if={
                is_nil(
                  character
                  |&gt; get(
                    path(:location / :solar_system_info / :solar_system_name, :map),
                    nil
                  )
                )
              }
              class=&quot;loading loading-dots loading-xs&quot;
            /&gt;
            &lt;span&gt;
              &lt;%= character
              |&gt; get(path(:location / :solar_system_info / :solar_system_name, :map), &quot;&quot;) %&gt;
            &lt;/span&gt;
          &lt;/h2&gt;
          &lt;h2
            :if={@wallet_tracking_enabled? &amp;&amp; character.show_wallet_balance?}
            class=&quot;absolute w-full flex justify-between bottom-7 text-xs px-4&quot;
          &gt;
            Balance:
            &lt;span class=&quot;blur&quot;&gt;
              ISK &lt;%= (character
                       |&gt; get(path(:eve_wallet_balance, :map), 0.0) || 0.0)
              |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;]) %&gt;
            &lt;/span&gt;
          &lt;/h2&gt;
          &lt;h2 class=&quot;absolute w-full flex justify-between px-4 left-0 bottom-2 text-xs&quot;&gt;
            Ship:
            &lt;span&gt;
              &lt;%= character
              |&gt; get(path(:ship / :ship_type_info / :name, :map), &quot;-&quot;) %&gt;
            &lt;/span&gt;
          &lt;/h2&gt;
        &lt;/div&gt;
      &lt;/figure&gt;
      &lt;div class=&quot;card-body&quot;&gt;
        &lt;h2 class=&quot;card-title text-sm&quot;&gt;&lt;%= character.name %&gt;&lt;/h2&gt;
        &lt;p&gt;&lt;/p&gt;
        &lt;div class=&quot;card-actions justify-between&quot;&gt;
          &lt;div&gt;
            &lt;div
              :if={character.invalid_token}
              class=&quot;tooltip&quot;
              data-tip=&quot;Invalid token. Please refresh authorization&quot;
            &gt;
              &lt;.icon name=&quot;hero-exclamation-triangle&quot; class=&quot;text-red-500 h-4 w-4&quot; /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div class=&quot;card-actions justify-end&quot;&gt;
            &lt;.link
              patch={~p&quot;/characters/authorize&quot;}
              class=&quot;tooltip tooltip-bottom&quot;
              data-tip=&quot;Refresh Authorization&quot;
            &gt;
              &lt;.icon name=&quot;hero-arrow-path-solid&quot; class=&quot;w-4 h-4 hover:text-white &quot; /&gt;
            &lt;/.link&gt;
            &lt;button
              class=&quot;tooltip tooltip-bottom&quot;
              phx-click=&quot;delete&quot;
              phx-value-character_id={character.id}
              data={[confirm: &quot;Please confirm to delete character!&quot;]}
              data-tip=&quot;Delete Character&quot;
            &gt;
              &lt;.icon name=&quot;hero-trash-solid&quot; class=&quot;w-4 h-4 hover:text-white&quot; /&gt;
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div :if={@mode == :table} class=&quot;flex flex-col gap-4  mt-4&quot;&gt;
    &lt;.link patch={~p&quot;/characters/authorize&quot;}&gt;
      &lt;button
        type=&quot;button&quot;
        class=&quot;btn h-10 rounded-none  hover:text-white bg-gradient-to-l from-stone-950 to-stone-900 transform transition duration-500&quot;
      &gt;
        &lt;.icon name=&quot;hero-squares-plus-solid&quot; class=&quot;w-8 h-8&quot; /&gt; Authorize character
      &lt;/button&gt;
    &lt;/.link&gt;

    &lt;.table class=&quot;!max-h-[80vh] !overflow-y-auto&quot; id=&quot;characters-tbl&quot; rows={@characters}&gt;
      &lt;:col :let={character} label=&quot;Character&quot;&gt;
        &lt;figure class=&quot;avatar h-10 w-10&quot;&gt;
          &lt;img class=&quot;h-10 w-10&quot; src={member_icon_url(character.eve_id)} alt={character.name} /&gt;
        &lt;/figure&gt;
      &lt;/:col&gt;
      &lt;:col :let={character} label=&quot;Name&quot;&gt;
        &lt;%= character.name %&gt;
      &lt;/:col&gt;
      &lt;:col :let={character} label=&quot;Corporation&quot;&gt;
        &lt;%= character
        |&gt; get(path(:corporation_name), &quot;-&quot;) %&gt;
      &lt;/:col&gt;
      &lt;:col :let={character} label=&quot;Alliance&quot;&gt;
        &lt;%= character
        |&gt; get(path(:alliance_name), &quot;-&quot;) || &quot;-&quot; %&gt;
      &lt;/:col&gt;
      &lt;:col :let={character} label=&quot;Location&quot;&gt;
        &lt;%= character
        |&gt; get(path(:location / :solar_system_info / :solar_system_name, :map), &quot;-&quot;) %&gt;
      &lt;/:col&gt;
      &lt;:col :let={character} label=&quot;Ship&quot;&gt;
        &lt;%= character
        |&gt; get(path(:ship / :ship_type_info / :name, :map), &quot;-&quot;) %&gt;
      &lt;/:col&gt;
      &lt;:col :let={character} :if={@wallet_tracking_enabled?} label=&quot;Balance&quot;&gt;
        &lt;span :if={character.show_wallet_balance?} class=&quot;blur&quot;&gt;
          ISK &lt;%= (character
                   |&gt; get(path(:eve_wallet_balance, :map), 0.0) || 0.0)
          |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;]) %&gt;
        &lt;/span&gt;
      &lt;/:col&gt;
    &lt;/.table&gt;
  &lt;/div&gt;

  &lt;.modal
    :if={@live_action in [:authorize]}
    id=&quot;authorize-character-modal&quot;
    title=&quot;Authorize Character&quot;
    class=&quot;!w-[400px]&quot;
    show
    on_cancel={JS.patch(~p&quot;/characters&quot;)}
  &gt;
    &lt;.form :let={f} for={@form} phx-submit=&quot;authorize&quot;&gt;
      &lt;div :if={@wallet_tracking_enabled?} class=&quot;pb-2 -mt-8&quot;&gt;
        &lt;.input
          type=&quot;checkbox&quot;
          field={f[:track_wallet]}
          label=&quot;Access to character wallet information&quot;
        /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;modal-action mt-0&quot;&gt;
        &lt;.button type=&quot;submit&quot;&gt;AUTHORIZE&lt;/.button&gt;
      &lt;/div&gt;
    &lt;/.form&gt;
  &lt;/.modal&gt;
&lt;/main&gt;</file><file path="lib/wanderer_app_web/live/characters/characters_tracking_live.ex">defmodule WandererAppWeb.CharactersTrackingLive do
  use WandererAppWeb, :live_view

  require Logger

  @impl true
  def mount(_params, %{&quot;user_id&quot; =&gt; user_id} = _session, socket) when not is_nil(user_id) do
    {:ok, maps} = WandererApp.Maps.get_available_maps(socket.assigns.current_user)

    {:ok,
     socket
     |&gt; assign(
       all_tracked: nil,
       characters: [],
       selected_map: nil,
       selected_map_slug: nil,
       user_id: user_id,
       maps: maps |&gt; Enum.sort_by(&amp; &amp;1.name, :asc)
     )}
  end

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |&gt; assign(characters: [], selected_map: nil, maps: [])}
  end

  @impl true
  def handle_params(params, _url, socket) do
    {:noreply, apply_action(socket, socket.assigns.live_action, params)}
  end

  defp apply_action(socket, :index, _params) do
    socket
    |&gt; assign(:active_page, :characters_tracking)
    |&gt; assign(:page_title, &quot;Characters Tracking&quot;)
  end

  defp apply_action(socket, :characters, %{&quot;slug&quot; =&gt; map_slug} = _params) do
    selected_map = socket.assigns.maps |&gt; Enum.find(&amp;(&amp;1.slug == map_slug))

    {:ok, character_settings} =
      WandererApp.Character.Activity.get_map_character_settings(selected_map.id)

    user_id = socket.assigns.user_id

    socket
    |&gt; assign(:active_page, :characters_tracking)
    |&gt; assign(:page_title, &quot;Characters Tracking&quot;)
    |&gt; assign(
      selected_map: selected_map,
      selected_map_slug: map_slug,
      character_settings: character_settings
    )
    |&gt; assign_async(:characters, fn -&gt;
      WandererApp.Maps.load_characters(selected_map, character_settings, user_id)
    end)
  end

  @impl true
  def handle_event(&quot;select_map_&quot; &lt;&gt; map_slug, _, socket) do
    {:noreply,
     socket
     |&gt; push_patch(to: ~p&quot;/tracking/#{map_slug}&quot;)}
  end

  @impl true
  def handle_event(&quot;toggle_track_&quot; &lt;&gt; character_id, _, socket) do
    handle_event(&quot;toggle_track&quot;, %{&quot;character_id&quot; =&gt; character_id}, socket)
  end

  @impl true
  def handle_event(&quot;toggle_track&quot;, %{&quot;character_id&quot; =&gt; character_id}, socket) do
    selected_map = socket.assigns.selected_map
    character_settings = socket.assigns.character_settings

    case character_settings |&gt; Enum.find(&amp;(&amp;1.character_id == character_id)) do
      nil -&gt;
        WandererApp.MapCharacterSettingsRepo.create(%{
          character_id: character_id,
          map_id: selected_map.id,
          tracked: true
        })

        {:noreply, socket}

      character_setting -&gt;
        case character_setting.tracked do
          true -&gt;
            character_setting
            |&gt; WandererApp.MapCharacterSettingsRepo.untrack!()

            WandererApp.Map.Server.untrack_characters(selected_map.id, [character_setting.character_id])

          _ -&gt;
            character_setting
            |&gt; WandererApp.MapCharacterSettingsRepo.track!()
        end
    end

    %{result: characters} = socket.assigns.characters

    {:ok, character_settings} =
      WandererApp.Character.Activity.get_map_character_settings(selected_map.id)

    characters =
      characters
      |&gt; Enum.map(fn c -&gt;
        WandererApp.Maps.map_character(
          c,
          character_settings |&gt; Enum.find(&amp;(&amp;1.character_id == c.id))
        )
      end)

    {:noreply,
     socket
     |&gt; assign(character_settings: character_settings)
     |&gt; assign_async(:characters, fn -&gt;
       {:ok, %{characters: characters}}
     end)}
  end

  @impl true
  def handle_event(&quot;noop&quot;, _, socket) do
    {:noreply, socket}
  end

  @impl true
  def handle_info(_event, socket), do: {:noreply, socket}
end</file><file path="lib/wanderer_app_web/live/characters/characters_tracking_live.html.heex">&lt;div class=&quot;p-3 h-full w-full pl-20&quot;&gt;
  &lt;main class=&quot;flex gap-4 w-full h-full shadow-sm rounded-lg col-span-2 lg:col-span-1 overflow-auto p-3&quot;&gt;
    &lt;div class=&quot;flex-1 flex flex-col w-64 h-full border border-dotted border-gray-700 justify-between overflow-auto&quot;&gt;
      &lt;.table
        id=&quot;maps&quot;
        class=&quot;h-[calc(100vh-106px)] !overflow-y-auto&quot;
        rows={@maps}
        row_click={fn map -&gt; send(self(), &quot;select_map_#{map.slug}&quot;) end}
        row_selected={fn map -&gt; @selected_map_slug == map.slug end}
      &gt;
        &lt;:col :let={map} label=&quot;Map&quot;&gt;
          &lt;div class=&quot;flex items-center gap-2&quot;&gt;
            &lt;.link
              navigate={~p&quot;/#{map.slug}&quot;}
              class=&quot;hover:text-white cursor-pointer tooltip tooltip-right&quot;
              data-tip=&quot;Go to map&quot;
            &gt;
              &lt;.icon name=&quot;hero-map-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
            &lt;/.link&gt;
            &lt;%= map.name %&gt;
          &lt;/div&gt;
        &lt;/:col&gt;
        &lt;:col :let={map} label=&quot;Description&quot;&gt;
          &lt;%= map.description %&gt;
        &lt;/:col&gt;
      &lt;/.table&gt;
    &lt;/div&gt;
    &lt;div class=&quot;flex-2 w-[50%] flex flex-col h-full border border-dotted border-gray-700 justify-between&quot;&gt;
      &lt;section :if={not is_nil(@selected_map)}&gt;
        &lt;.async_result :let={characters} assign={@characters}&gt;
          &lt;:loading&gt;Loading...&lt;/:loading&gt;
          &lt;:failed :let={reason}&gt;&lt;%= reason %&gt;&lt;/:failed&gt;

          &lt;span :if={characters}&gt;
            &lt;.table
              id=&quot;characters&quot;
              class=&quot;h-[calc(100vh-106px)] !overflow-y-auto&quot;
              rows={characters}
              row_click={fn character -&gt; send(self(), &quot;toggle_track_#{character.id}&quot;) end}
            &gt;
              &lt;:col :let={character} label=&quot;Tracked&quot;&gt;
                &lt;div class=&quot;flex items-center gap-2&quot;&gt;
                  &lt;label&gt;
                    &lt;input
                      type=&quot;checkbox&quot;
                      class=&quot;checkbox&quot;
                      phx-click=&quot;toggle_track&quot;
                      phx-value-character_id={character.id}
                      id={&quot;character-track-#{character.id}&quot;}
                      checked={character.tracked}
                    /&gt;
                  &lt;/label&gt;
                  &lt;div class=&quot;flex items-center gap-2&quot;&gt;
                    &lt;.avatar url={member_icon_url(character.eve_id)} label={character.name} /&gt;
                    &lt;div&gt;
                      &lt;div&gt;
                        &lt;span class=&quot;font-bold&quot;&gt;&lt;%= character.name %&gt;&lt;/span&gt;&lt;span class=&quot;ml-1 text-gray-400&quot;&gt;[&lt;%= character.corporation_ticker %&gt;]&lt;/span&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/:col&gt;
            &lt;/.table&gt;
          &lt;/span&gt;
        &lt;/.async_result&gt;
      &lt;/section&gt;
      &lt;section
        :if={is_nil(@selected_map)}
        class=&quot;flex flex-col h-full justify-center items-center&quot;
      &gt;
        &lt;.icon name=&quot;hero-information-circle&quot; class=&quot;w-10 h-10&quot; /&gt;
        &lt;h1 class=&quot;text-xl&quot;&gt;
          Select a map to configure character tracking
        &lt;/h1&gt;
      &lt;/section&gt;
    &lt;/div&gt;
  &lt;/main&gt;
&lt;/div&gt;</file><file path="lib/wanderer_app_web/live/map/components/map_characters.ex">defmodule WandererAppWeb.MapCharacters do
  use WandererAppWeb, :live_component
  use LiveViewEvents

  @impl true
  def mount(socket) do
    {:ok, socket}
  end

  @impl true
  def update(
        assigns,
        socket
      ) do
    {:ok,
     socket
     |&gt; handle_info_or_assign(assigns)}
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div id={@id}&gt;
      &lt;ul :for={group &lt;- @groups} class=&quot;border-t border-b border-gray-200 py-0&quot;&gt;
        &lt;li :for={character &lt;- group.characters}&gt;
          &lt;div class=&quot;flex items-center justify-between w-full space-x-2 p-1 hover:bg-gray-900&quot;&gt;
            &lt;.character_entry character={character} /&gt;
            &lt;button
              :if={character.tracked}
              phx-click=&quot;untrack&quot;
              phx-value-event-data={character.id}
              class=&quot;btn btn-sm btn-icon py-1&quot;
            &gt;
              &lt;.icon name=&quot;hero-eye-slash&quot; class=&quot;h-5 w-5&quot; /&gt; Untrack
            &lt;/button&gt;

            &lt;span :if={not character.tracked} class=&quot;text-white rounded-full px-2&quot;&gt;
              Viewer
            &lt;/span&gt;
          &lt;/div&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  attr(:character, :any, required: true)

  defp character_entry(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;flex items-center gap-3 text-sm w-[450px]&quot;&gt;
      &lt;div class=&quot;flex flex-col p-4 items-center gap-2 tooltip tooltip-top&quot; data-tip=&quot;Active from&quot;&gt;
        &lt;span class=&quot;text-green-500 rounded-full px-2 py-1 whitespace-nowrap&quot;&gt;
          &lt;.local_time id={@character.id} at={@character.from} /&gt;
        &lt;/span&gt;
      &lt;/div&gt;

      &lt;div class=&quot;avatar&quot;&gt;
        &lt;div class=&quot;rounded-md w-8 h-8&quot;&gt;
          &lt;img src={member_icon_url(@character.eve_id)} alt={@character.name} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;span class=&quot;whitespace-nowrap&quot;&gt;{@character.name}&lt;/span&gt;
      &lt;span :if={@character.alliance_ticker} class=&quot;whitespace-nowrap&quot;&gt;
        [{@character.alliance_ticker}]
      &lt;/span&gt;
      &lt;span :if={@character.corporation_ticker} class=&quot;whitespace-nowrap&quot;&gt;
        [{@character.corporation_ticker}]
      &lt;/span&gt;

      &lt;span :if={is_online?(@character.id)} class=&quot;text-green-500 rounded-full px-2 py-1&quot;&gt;
        Online
      &lt;/span&gt;
      &lt;span :if={not is_online?(@character.id)} class=&quot;text-red-500 rounded-full px-2 py-1&quot;&gt;
        Offline
      &lt;/span&gt;

      &lt;span :if={@character.tracked} class=&quot;text-green-500 rounded-full px-2 py-1&quot;&gt;
        Tracked
      &lt;/span&gt;

      &lt;span :if={not @character.tracked} class=&quot;text-red-500 rounded-full px-2 py-1 whitespace-nowrap&quot;&gt;
        Not Tracked
      &lt;/span&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @impl true
  def handle_event(&quot;undo&quot;, %{&quot;event-data&quot; =&gt; _event_data} = _params, socket) do
    # notify_to(socket.assigns.notify_to, socket.assigns.event_name, map_slug)

    {:noreply, socket}
  end

  defp is_online?(character_id) do
    {:ok, state} = WandererApp.Character.get_character_state(character_id)
    state.is_online
  end
end</file><file path="lib/wanderer_app_web/live/map/components/map_loader.ex">defmodule WandererAppWeb.MapLoader do
  use WandererAppWeb, :live_component

  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div
      id=&quot;map-loader&quot;
      data-loading={show_loader(&quot;map-loader&quot;)}
      data-loaded={hide_loader(&quot;map-loader&quot;)}
      class=&quot;!z-100 w-screen h-screen hidden relative&quot;
    &gt;
      &lt;div class=&quot;hs-overlay-backdrop transition duration absolute inset-0 blur&quot; /&gt;
      &lt;div class=&quot;flex !z-[150] w-full h-full items-center justify-center&quot;&gt;
        &lt;div class=&quot;Loader&quot; data-text=&quot;Wanderer&quot;&gt;
          &lt;span class=&quot;Loader__Circle&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;Loader__Circle&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;Loader__Circle&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;Loader__Circle&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  defp show_loader(js \\ %JS{}, id),
    do:
      JS.show(js,
        to: &quot;##{id}&quot;,
        transition: {&quot;transition-opacity ease-out duration-500&quot;, &quot;opacity-0&quot;, &quot;opacity-100&quot;}
      )

  defp hide_loader(js \\ %JS{}, id),
    do:
      JS.hide(js,
        to: &quot;##{id}&quot;,
        transition: {&quot;transition-opacity ease-in duration-500&quot;, &quot;opacity-100&quot;, &quot;opacity-0&quot;}
      )
end</file><file path="lib/wanderer_app_web/live/map/components/map_picker.ex">defmodule WandererAppWeb.MapPicker do
  use WandererAppWeb, :live_component

  use LiveViewEvents

  @impl true
  def mount(socket) do
    socket =
      socket
      |&gt; assign(form: to_form(%{&quot;map_slug&quot; =&gt; nil}))

    {:ok, socket}
  end

  @impl true
  def update(
        %{
          current_user: current_user,
          map_slug: map_slug
        } = assigns,
        socket
      ) do
    socket = handle_info_or_assign(socket, assigns)

    {:ok,
     socket
     |&gt; assign(form: to_form(%{&quot;map_slug&quot; =&gt; map_slug}))
     |&gt; assign_async(:maps, fn -&gt;
       get_available_maps(current_user)
     end)}
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div id={@id}&gt;
      &lt;.form
        :let={f}
        :if={not is_nil(assigns |&gt; Map.get(:maps))}
        for={@form}
        phx-change=&quot;select&quot;
        phx-target={@myself}
      &gt;
        &lt;.async_result :let={maps} assign={@maps}&gt;
          &lt;:loading&gt;&lt;span class=&quot;loading loading-dots loading-xs&quot; /&gt;&lt;/:loading&gt;
          &lt;:failed :let={reason}&gt;&lt;%= reason %&gt;&lt;/:failed&gt;
          &lt;.input
            :if={maps}
            type=&quot;select&quot;
            field={f[:map_slug]}
            class=&quot;select h-8 min-h-[10px] !pt-1 !pb-1 text-sm bg-neutral-900&quot;
            placeholder=&quot;Select a map...&quot;
            options={Enum.map(@maps.result, fn map -&gt; {map.label, map.value} end)}
          /&gt;
        &lt;/.async_result&gt;
      &lt;/.form&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @impl true
  def handle_event(&quot;select&quot;, %{&quot;map_slug&quot; =&gt; map_slug} = _params, socket) do
    notify_to(socket.assigns.notify_to, socket.assigns.event_name, map_slug)

    {:noreply, socket}
  end

  defp get_available_maps(current_user) do
    {:ok, maps} =
      current_user
      |&gt; WandererApp.Maps.get_available_maps()

    {:ok, %{maps: maps |&gt; Enum.sort_by(&amp; &amp;1.name, :asc) |&gt; Enum.map(&amp;map_map/1)}}
  end

  defp map_map(%{name: name, slug: slug} = _map),
    do: %{label: name, value: slug}
end</file><file path="lib/wanderer_app_web/live/map/components/map_refresh.ex">defmodule WandererAppWeb.MapRefresh do
  use WandererAppWeb, :live_component

  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div id=&quot;map-refresh&quot; class=&quot;socket&quot;&gt;
      &lt;div class=&quot;flex z-100 h-full w-full items-center justify-center z-auto&quot;&gt;
        &lt;p class=&quot;text-[30px] &quot;&gt;
          &lt;span id=&quot;version-update-seconds&quot;&gt;&lt;/span&gt;
        &lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel center-gel&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c1 r1&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c2 r1&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c3 r1&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c4 r1&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c5 r1&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c6 r1&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;gel c7 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;gel c8 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c9 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c10 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c11 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c12 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c13 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c14 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c15 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c16 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c17 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c18 r2&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c19 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c20 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c21 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c22 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c23 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c24 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c25 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c26 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c28 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c29 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c30 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c31 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c32 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c33 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c34 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c35 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c36 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;gel c37 r3&quot;&gt;
        &lt;div class=&quot;hex-brick h1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;hex-brick h3&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_app_web/live/map/components/user_activity.ex">defmodule WandererAppWeb.UserActivity do
  use WandererAppWeb, :live_component
  use LiveViewEvents

  @impl true
  def mount(socket) do
    {:ok, socket}
  end

  @impl true
  def update(
        assigns,
        socket
      ) do
    {:ok,
     socket
     |&gt; handle_info_or_assign(assigns)}
  end

  # attr(:can_undo_types, :list, required: false)
  # attr(:stream, :any, required: true)
  # attr(:page, :integer, required: true)
  # attr(:end_of_stream?, :boolean, required: true)
  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div id={@id}&gt;
      &lt;ul id=&quot;events&quot; class=&quot;space-y-4&quot; phx-update=&quot;stream&quot; phx-page-loading class={[&quot;pt-10&quot;]}&gt;
        &lt;li :for={{dom_id, activity} &lt;- @stream} id={dom_id}&gt;
          &lt;.activity_entry activity={activity} can_undo_types={@can_undo_types} /&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  attr(:activity, WandererApp.Api.UserActivity, required: true)
  attr(:can_undo_types, :list, required: false)

  defp activity_entry(%{} = assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;flex items-center w-full space-x-2 p-1 hover:bg-gray-900&quot;&gt;
      &lt;div class=&quot;flex items-center text-xs w-[270px]&quot;&gt;
        &lt;p class=&quot;flex items-center space-x-1&quot;&gt;
          &lt;span class=&quot;w-[150px] line-clamp-1 block text-sm font-normal leading-none text-gray-400 dark:text-gray-500&quot;&gt;
            &lt;.local_time id={@activity.id} at={@activity.inserted_at} /&gt;
          &lt;/span&gt;
        &lt;/p&gt;
      &lt;/div&gt;

      &lt;.character_item :if={not is_nil(@activity.character)} character={@activity.character} /&gt;
      &lt;p :if={is_nil(@activity.character)} class=&quot;text-sm text-[var(--color-gray-4)] w-[150px]&quot;&gt;
        System user / Administrator
      &lt;/p&gt;

      &lt;p class=&quot;text-sm text-[var(--color-gray-4)] w-[15%]&quot;&gt;
        {get_event_name(@activity.event_type)}
      &lt;/p&gt;
      &lt;.activity_event event_type={@activity.event_type} event_data={@activity.event_data} /&gt;

      &lt;div :if={@activity.event_type in @can_undo_types}&gt;
        &lt;button
          phx-click=&quot;undo&quot;
          phx-value-event-data={@activity.event_data}
          phx-value-event-type={@activity.event_type}
          class=&quot;btn btn-sm btn-icon&quot;
        &gt;
          &lt;.icon name=&quot;hero-arrow-uturn-left-solid&quot; class=&quot;h-5 w-5&quot; /&gt; Undo
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  attr(:character, WandererApp.Api.Character, required: true)

  def character_item(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;flex items-center gap-3 text-sm w-[150px]&quot;&gt;
      &lt;div class=&quot;avatar&quot;&gt;
        &lt;div class=&quot;rounded-md w-8 h-8&quot;&gt;
          &lt;img src={member_icon_url(@character.eve_id)} alt={@character.name} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      {@character.name}
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  attr(:event_type, :string, required: true)
  attr(:event_data, :string, required: true)

  def activity_event(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;w-[40%]&quot;&gt;
      &lt;div class=&quot;flex items-center gap-1&quot;&gt;
        &lt;h6 class=&quot;text-base leading-[150%] font-semibold dark:text-white&quot;&gt;
          {get_event_data(@event_type, Jason.decode!(@event_data) |&gt; Map.drop([&quot;character_id&quot;]))}
        &lt;/h6&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @impl true
  def handle_event(&quot;undo&quot;, %{&quot;event-data&quot; =&gt; _event_data} = _params, socket) do
    # notify_to(socket.assigns.notify_to, socket.assigns.event_name, map_slug)

    {:noreply, socket}
  end

  def get_event_name(:hub_added), do: &quot;Hub Added&quot;
  def get_event_name(:hub_removed), do: &quot;Hub Removed&quot;
  def get_event_name(:map_connection_added), do: &quot;Connection Added&quot;
  def get_event_name(:map_connection_updated), do: &quot;Connection Updated&quot;
  def get_event_name(:map_connection_removed), do: &quot;Connection Removed&quot;
  def get_event_name(:map_acl_added), do: &quot;Acl Added&quot;
  def get_event_name(:map_acl_removed), do: &quot;Acl Removed&quot;
  def get_event_name(:system_added), do: &quot;System Added&quot;
  def get_event_name(:system_updated), do: &quot;System Updated&quot;
  def get_event_name(:systems_removed), do: &quot;System(s) Removed&quot;
  def get_event_name(:signatures_added), do: &quot;Signatures Added&quot;
  def get_event_name(:signatures_removed), do: &quot;Signatures Removed&quot;
  def get_event_name(name), do: name

  def get_event_data(:map_acl_added, %{&quot;acl_id&quot; =&gt; acl_id}) do
    {:ok, acl} = WandererApp.AccessListRepo.get(acl_id)
    &quot;#{acl.name}&quot;
  end

  def get_event_data(:map_acl_removed, %{&quot;acl_id&quot; =&gt; acl_id}) do
    {:ok, acl} = WandererApp.AccessListRepo.get(acl_id)
    &quot;#{acl.name}&quot;
  end

  # defp get_event_data(:map_acl_removed, data), do: data
  # defp get_event_data(:system_added, data), do: data
  #

  def get_event_data(:system_updated, %{
        &quot;key&quot; =&gt; &quot;labels&quot;,
        &quot;solar_system_id&quot; =&gt; solar_system_id,
        &quot;value&quot; =&gt; value
      }) do
    system_name = get_system_name(solar_system_id)

    try do
      %{&quot;customLabel&quot; =&gt; customLabel, &quot;labels&quot; =&gt; labels} = Jason.decode!(value)

      &quot;#{system_name}: labels - #{inspect(labels)}, customLabel - #{customLabel}&quot;
    rescue
      _ -&gt;
        &quot;#{system_name}: labels - #{inspect(value)}&quot;
    end
  end

  def get_event_data(:system_added, %{
        &quot;solar_system_id&quot; =&gt; solar_system_id
      }),
      do: get_system_name(solar_system_id)

  def get_event_data(:hub_added, %{
        &quot;solar_system_id&quot; =&gt; solar_system_id
      }),
      do: get_system_name(solar_system_id)

  def get_event_data(:hub_removed, %{
        &quot;solar_system_id&quot; =&gt; solar_system_id
      }),
      do: get_system_name(solar_system_id)

  def get_event_data(:system_updated, %{
        &quot;key&quot; =&gt; key,
        &quot;solar_system_id&quot; =&gt; solar_system_id,
        &quot;value&quot; =&gt; value
      }) do
    system_name = get_system_name(solar_system_id)
    &quot;#{system_name}: #{key} - #{inspect(value)}&quot;
  end

  def get_event_data(:systems_removed, %{
        &quot;solar_system_ids&quot; =&gt; solar_system_ids
      }),
      do:
        solar_system_ids
        |&gt; Enum.map(&amp;get_system_name/1)
        |&gt; Enum.join(&quot;, &quot;)

  def get_event_data(signatures_event, %{
        &quot;solar_system_id&quot; =&gt; solar_system_id,
        &quot;signatures&quot; =&gt; signatures
      })
      when signatures_event in [:signatures_added, :signatures_removed],
      do: &quot;#{get_system_name(solar_system_id)}: #{signatures |&gt; Enum.join(&quot;, &quot;)}&quot;

  def get_event_data(signatures_event, %{
        &quot;signatures&quot; =&gt; signatures
      })
      when signatures_event in [:signatures_added, :signatures_removed],
      do: signatures |&gt; Enum.join(&quot;, &quot;)

  def get_event_data(:map_connection_added, %{
        &quot;solar_system_source_id&quot; =&gt; solar_system_source_id,
        &quot;solar_system_target_id&quot; =&gt; solar_system_target_id
      }) do
    source_system_name = get_system_name(solar_system_source_id)
    target_system_name = get_system_name(solar_system_target_id)
    &quot;[#{source_system_name}:#{target_system_name}]&quot;
  end

  def get_event_data(:map_connection_removed, %{
        &quot;solar_system_source_id&quot; =&gt; solar_system_source_id,
        &quot;solar_system_target_id&quot; =&gt; solar_system_target_id
      }) do
    source_system_name = get_system_name(solar_system_source_id)
    target_system_name = get_system_name(solar_system_target_id)
    &quot;[#{source_system_name}:#{target_system_name}]&quot;
  end

  def get_event_data(:map_connection_updated, %{
        &quot;key&quot; =&gt; key,
        &quot;solar_system_source_id&quot; =&gt; solar_system_source_id,
        &quot;solar_system_target_id&quot; =&gt; solar_system_target_id,
        &quot;value&quot; =&gt; value
      }) do
    source_system_name = get_system_name(solar_system_source_id)
    target_system_name = get_system_name(solar_system_target_id)
    &quot;[#{source_system_name}:#{target_system_name}] #{key} - #{inspect(value)}&quot;
  end

  def get_event_data(_name, data), do: Jason.encode!(data)

  defp get_system_name(solar_system_id) do
    case WandererApp.CachedInfo.get_system_static_info(solar_system_id) do
      {:ok, nil} -&gt;
        solar_system_id

      {:ok, system_static_info} -&gt;
        Map.get(system_static_info, :solar_system_name, &quot;&quot;)

      _ -&gt;
        &quot;&quot;
    end
  end
end</file><file path="lib/wanderer_app_web/live/map/event_handlers/map_activity_event_handler.ex">defmodule WandererAppWeb.MapActivityEventHandler do
  @moduledoc &quot;&quot;&quot;
  Handles map activity events and updates for the live view.
  &quot;&quot;&quot;
  use WandererAppWeb, :live_component
  use Phoenix.Component
  require Logger

  alias WandererAppWeb.{MapEventHandler, MapCoreEventHandler}

  def handle_server_event(
        %{
          event: :character_activity_data,
          payload: activity_data
        },
        socket
      ) do
    socket
    |&gt; MapEventHandler.push_map_event(
      &quot;character_activity_data&quot;,
      %{
        activity: activity_data,
        loading: false
      }
    )
  end

  def handle_server_event(event, socket),
    do: MapCoreEventHandler.handle_server_event(event, socket)

  def handle_ui_event(
        &quot;show_activity&quot;,
        _,
        %{assigns: %{map_id: map_id, current_user: current_user}} = socket
      ) do
    Task.async(fn -&gt;
      try do
        # Get raw activity data from the domain logic
        result =
          WandererApp.Character.Activity.process_character_activity(map_id, current_user)

        # Group activities by user_id and summarize
        summarized_result =
          result
          |&gt; Enum.group_by(fn activity -&gt;
            # Get user_id from the character
            activity.character.user_id
          end)
          |&gt; Enum.map(fn {_user_id, user_activities} -&gt;
            # Get the most active or followed character for this user
            representative_activity =
              user_activities
              |&gt; Enum.max_by(fn activity -&gt;
                activity.passages + activity.connections + activity.signatures
              end)

            # Sum up all activities for this user
            total_passages = Enum.sum(Enum.map(user_activities, &amp; &amp;1.passages))
            total_connections = Enum.sum(Enum.map(user_activities, &amp; &amp;1.connections))
            total_signatures = Enum.sum(Enum.map(user_activities, &amp; &amp;1.signatures))

            # Map the character data for the UI here
            mapped_character =
              representative_activity.character
              |&gt; MapEventHandler.map_ui_character_stat()

            # Return summarized activity with the mapped character
            %{
              character: mapped_character,
              passages: total_passages,
              connections: total_connections,
              signatures: total_signatures,
              timestamp: representative_activity.timestamp
            }
          end)

        {:character_activity_data, summarized_result}
      rescue
        e -&gt;
          Logger.error(&quot;Error processing character activity: #{inspect(e)}&quot;)
          Logger.error(&quot;#{Exception.format_stacktrace()}&quot;)
          {:character_activity_data, []}
      end
    end)

    {:noreply,
     socket
     |&gt; MapEventHandler.push_map_event(
       &quot;character_activity_data&quot;,
       %{activity: [], loading: true}
     )}
  end

  def handle_ui_event(event, body, socket),
    do: MapCoreEventHandler.handle_ui_event(event, body, socket)
end</file><file path="lib/wanderer_app_web/live/map/event_handlers/map_characters_event_handler.ex">defmodule WandererAppWeb.MapCharactersEventHandler do
  @moduledoc &quot;&quot;&quot;
  Handles character-related events and UI interactions for the map live view.
  &quot;&quot;&quot;
  use WandererAppWeb, :live_component
  use Phoenix.Component
  require Logger

  alias WandererAppWeb.{MapEventHandler, MapCoreEventHandler}

  def handle_server_event(%{event: :character_added, payload: character}, socket) do
    socket
    |&gt; MapEventHandler.push_map_event(
      &quot;character_added&quot;,
      character |&gt; map_ui_character()
    )
  end

  def handle_server_event(%{event: :character_removed, payload: character}, socket) do
    socket
    |&gt; MapEventHandler.push_map_event(
      &quot;character_removed&quot;,
      character |&gt; map_ui_character()
    )
  end

  def handle_server_event(%{event: :character_updated, payload: character}, socket) do
    socket
    |&gt; MapEventHandler.push_map_event(
      &quot;character_updated&quot;,
      character |&gt; map_ui_character()
    )
  end

  def handle_server_event(%{event: :untrack_character, payload: character_id}, %{
    assigns: %{
      map_id: map_id
    }
  } = socket) do
    :ok = WandererApp.Character.TrackingUtils.untrack([%{id: character_id}], map_id, self())
    socket
  end


  def handle_server_event(
        %{event: :characters_updated},
        %{
          assigns: %{
            map_id: map_id
          }
        } = socket
      ) do
    characters =
      map_id
      |&gt; WandererApp.Map.list_characters()
      |&gt; Enum.map(&amp;map_ui_character/1)

    socket
    |&gt; MapEventHandler.push_map_event(
      &quot;characters_updated&quot;,
      characters
    )
  end

  def handle_server_event(
        %{event: :present_characters_updated, payload: present_character_eve_ids},
        socket
      ),
      do:
        socket
        |&gt; MapEventHandler.push_map_event(
          &quot;present_characters&quot;,
          present_character_eve_ids
        )

  def handle_server_event(
        %{event: :refresh_user_characters},
        %{
          assigns: %{
            map_id: map_id,
            main_character_eve_id: main_character_eve_id,
            following_character_eve_id: following_character_eve_id,
            current_user: current_user
          }
        } = socket
      ) do
    # Get tracked characters
    {:ok, tracked_characters} = WandererApp.Maps.get_tracked_map_characters(map_id, current_user)

    user_character_eve_ids = tracked_characters |&gt; Enum.map(&amp; &amp;1.eve_id)

    # Update socket assigns but don&apos;t affect followed state
    socket
    |&gt; assign(has_tracked_characters?: user_character_eve_ids |&gt; Enum.empty?() |&gt; Kernel.not())
    |&gt; MapEventHandler.push_map_event(
      &quot;map_updated&quot;,
      %{
        main_character_eve_id: main_character_eve_id,
        following_character_eve_id: following_character_eve_id,
        user_characters: user_character_eve_ids
      }
    )
  end

  def handle_server_event(%{event: :show_tracking}, socket) do
    socket
    |&gt; MapEventHandler.push_map_event(
      &quot;show_tracking&quot;,
      %{}
    )
  end

  def handle_server_event(event, socket),
    do: MapCoreEventHandler.handle_server_event(event, socket)

  # UI Event Handlers
  def handle_ui_event(
        &quot;getCharacterInfo&quot;,
        %{&quot;characterEveId&quot; =&gt; character_eve_id},
        socket
      ) do
    {:ok, character} = WandererApp.Character.get_by_eve_id(&quot;#{character_eve_id}&quot;)

    {:reply, character |&gt; MapEventHandler.map_ui_character_stat(), socket}
  end

  def handle_ui_event(
        &quot;getCharactersTrackingInfo&quot;,
        _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: %{id: current_user_id}
          }
        } = socket
      ) do
    {:ok, tracking_data} =
      WandererApp.Character.TrackingUtils.build_tracking_data(map_id, current_user_id)

    {:reply, %{data: tracking_data}, socket}
  end

  def handle_ui_event(
        &quot;updateCharacterTracking&quot;,
        %{&quot;character_eve_id&quot; =&gt; character_eve_id, &quot;track&quot; =&gt; track},
        %{
          assigns: %{
            map_id: map_id,
            current_user: %{id: current_user_id},
            only_tracked_characters: only_tracked_characters
          }
        } = socket
      ) do
    case WandererApp.Character.TrackingUtils.update_tracking(
           map_id,
           character_eve_id,
           current_user_id,
           track,
           self(),
           only_tracked_characters
         ) do
      {:ok, tracking_data, event} when not is_nil(tracking_data) -&gt;
        # Send the appropriate event based on the result
        Process.send_after(self(), event, 50)

        # Send the updated tracking data to the client
        {:reply, %{data: tracking_data}, socket}

      {:ok, nil, event} -&gt;
        # Send the appropriate event based on the result
        Process.send_after(self(), event, 50)

        # Send the updated tracking data to the client
        {:reply, %{characters: []}, socket}

      {:error, reason} -&gt;
        Logger.error(&quot;Failed to toggle track: #{inspect(reason)}&quot;)
        {:noreply, socket |&gt; put_flash(:error, &quot;Failed to toggle character tracking&quot;)}
    end
  end

  def handle_ui_event(
        &quot;updateFollowingCharacter&quot;,
        %{&quot;character_eve_id&quot; =&gt; character_eve_id},
        %{
          assigns: %{
            current_user: %{id: current_user_id},
            map_id: map_id,
            map_user_settings: map_user_settings,
            following_character_eve_id: following_character_eve_id
          }
        } = socket
      )
      when character_eve_id != following_character_eve_id do
    settings =
      case map_user_settings do
        nil -&gt; nil
        %{settings: settings} -&gt; settings
      end

    {:ok, user_settings} =
      WandererApp.MapUserSettingsRepo.create_or_update(map_id, current_user_id, settings)

    {:ok, map_user_settings} =
      user_settings
      |&gt; WandererApp.Api.MapUserSettings.update_following_character(%{
        following_character_eve_id: &quot;#{character_eve_id}&quot;
      })

    {:ok, tracking_data} =
      WandererApp.Character.TrackingUtils.build_tracking_data(map_id, current_user_id)

    Process.send_after(self(), %{event: :refresh_user_characters}, 50)

    {:reply, %{data: tracking_data},
     socket
     |&gt; assign(
       map_user_settings: map_user_settings,
       following_character_eve_id: &quot;#{character_eve_id}&quot;
     )}
  end

  def handle_ui_event(
        &quot;updateMainCharacter&quot;,
        %{&quot;character_eve_id&quot; =&gt; character_eve_id},
        %{
          assigns: %{
            current_user: %{id: current_user_id, characters: current_user_characters},
            map_id: map_id,
            map_user_settings: map_user_settings,
            main_character_eve_id: main_character_eve_id
          }
        } = socket
      )
      when not is_nil(character_eve_id) and character_eve_id != main_character_eve_id do
    settings =
      case map_user_settings do
        nil -&gt; nil
        %{settings: settings} -&gt; settings
      end

    {:ok, user_settings} =
      WandererApp.MapUserSettingsRepo.create_or_update(map_id, current_user_id, settings)

    {:ok, map_user_settings} =
      user_settings
      |&gt; WandererApp.Api.MapUserSettings.update_main_character(%{
        main_character_eve_id: &quot;#{character_eve_id}&quot;
      })

    {:ok, tracking_data} =
      WandererApp.Character.TrackingUtils.build_tracking_data(map_id, current_user_id)

    {main_character_id, main_character_eve_id} =
      WandererApp.Character.TrackingUtils.get_main_character(
        map_user_settings,
        current_user_characters,
        current_user_characters
      )
      |&gt; case do
        {:ok, main_character} when not is_nil(main_character) -&gt;
          {main_character.id, main_character.eve_id}

        _ -&gt;
          {nil, nil}
      end

    Process.send_after(self(), %{event: :refresh_user_characters}, 50)

    {:reply, %{data: tracking_data},
     socket
     |&gt; assign(
       map_user_settings: map_user_settings,
       main_character_id: main_character_id,
       main_character_eve_id: main_character_eve_id
     )}
  end

  def handle_ui_event(event, body, socket),
    do: MapCoreEventHandler.handle_ui_event(event, body, socket)

  def map_ui_character(character),
    do:
      character
      |&gt; Map.take([
        :eve_id,
        :name,
        :online,
        :corporation_id,
        :corporation_name,
        :corporation_ticker,
        :alliance_id,
        :alliance_name
      ])
      |&gt; Map.put(:alliance_ticker, Map.get(character, :alliance_ticker, &quot;&quot;))
      |&gt; Map.put_new(:ship, WandererApp.Character.get_ship(character))
      |&gt; Map.put_new(:location, get_location(character))

  defp get_location(character),
    do: %{
      solar_system_id: character.solar_system_id,
      structure_id: character.structure_id,
      station_id: character.station_id
    }

  defp get_map_with_acls(map_id) do
    with {:ok, map} &lt;- WandererApp.Api.Map.by_id(map_id) do
      {:ok, Ash.load!(map, :acls)}
    end
  end

  def needs_tracking_setup?(
        only_tracked_characters,
        characters,
        character_settings,
        user_permissions
      ) do
    tracked_count =
      characters
      |&gt; Enum.count(fn char -&gt;
        setting = Enum.find(character_settings, &amp;(&amp;1.character_id == char.id))
        setting &amp;&amp; setting.tracked
      end)

    untracked_count =
      characters
      |&gt; Enum.count(fn char -&gt;
        setting = Enum.find(character_settings, &amp;(&amp;1.character_id == char.id))
        setting == nil || !setting.tracked
      end)

    user_permissions.track_character &amp;&amp;
      ((untracked_count &gt; 0 &amp;&amp; only_tracked_characters) || tracked_count == 0)
  end

  @doc &quot;&quot;&quot;
  Handles character tracking events during map initialization.
  &quot;&quot;&quot;
  def handle_tracking_events(socket, map_id, events) do
    events
    |&gt; Enum.reduce(socket, fn event, socket -&gt;
      handle_tracking_event(event, socket, map_id)
    end)
  end

  defp handle_tracking_event({:track_characters, map_characters, track_character}, socket, map_id) do
    :ok =
      WandererApp.Character.TrackingUtils.track(
        map_characters,
        map_id,
        track_character,
        self()
      )

    socket
  end

  defp handle_tracking_event(:invalid_token_message, socket, _map_id) do
    socket
    |&gt; put_flash(
      :error,
      &quot;One of your characters has expired token. Please refresh it on characters page.&quot;
    )
  end

  defp handle_tracking_event(:map_character_limit, socket, _map_id) do
    socket
    |&gt; put_flash(
      :error,
      &quot;Map reached its character limit, your characters won&apos;t be tracked. Please contact administrator.&quot;
    )
  end

  defp handle_tracking_event(:empty_tracked_characters, socket, _map_id), do: socket
  defp handle_tracking_event(_, socket, _map_id), do: socket

  @doc &quot;&quot;&quot;
  Gets a list of characters that need tracking setup.
  &quot;&quot;&quot;
  def get_untracked_characters(characters, character_settings) do
    Enum.filter(characters, fn char -&gt;
      setting = Enum.find(character_settings, &amp;(&amp;1.character_id == char.id))
      is_tracked = setting &amp;&amp; setting.tracked
      !is_tracked
    end)
  end
end</file><file path="lib/wanderer_app_web/live/map/event_handlers/map_connections_event_handler.ex">defmodule WandererAppWeb.MapConnectionsEventHandler do
  use WandererAppWeb, :live_component
  use Phoenix.Component
  require Logger

  alias WandererAppWeb.{MapEventHandler, MapCoreEventHandler}

  def handle_server_event(%{event: :update_connection, payload: connection}, socket),
    do:
      socket
      |&gt; MapEventHandler.push_map_event(
        &quot;update_connection&quot;,
        MapEventHandler.map_ui_connection(connection)
      )

  def handle_server_event(%{event: :remove_connections, payload: connections}, socket) do
    connection_ids =
      connections |&gt; Enum.map(&amp;MapEventHandler.map_ui_connection/1) |&gt; Enum.map(&amp; &amp;1.id)

    socket
    |&gt; MapEventHandler.push_map_event(
      &quot;remove_connections&quot;,
      connection_ids
    )
  end

  def handle_server_event(%{event: :add_connection, payload: connection}, socket) do
    connections = [MapEventHandler.map_ui_connection(connection)]

    socket
    |&gt; MapEventHandler.push_map_event(
      &quot;add_connections&quot;,
      connections
    )
  end

  def handle_server_event(event, socket),
    do: MapCoreEventHandler.handle_server_event(event, socket)

  def handle_ui_event(
        &quot;manual_add_connection&quot;,
        %{&quot;source&quot; =&gt; solar_system_source_id, &quot;target&quot; =&gt; solar_system_target_id} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: %{id: current_user_id},
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{add_connection: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    map_id
    |&gt; WandererApp.Map.Server.add_connection(%{
      solar_system_source_id: solar_system_source_id |&gt; String.to_integer(),
      solar_system_target_id: solar_system_target_id |&gt; String.to_integer(),
      character_id: main_character_id
    })

    {:ok, _} =
      WandererApp.User.ActivityTracker.track_map_event(:map_connection_added, %{
        character_id: main_character_id,
        user_id: current_user_id,
        map_id: map_id,
        solar_system_source_id: &quot;#{solar_system_source_id}&quot; |&gt; String.to_integer(),
        solar_system_target_id: &quot;#{solar_system_target_id}&quot; |&gt; String.to_integer()
      })

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;manual_delete_connection&quot;,
        %{&quot;source&quot; =&gt; solar_system_source_id, &quot;target&quot; =&gt; solar_system_target_id} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: %{id: current_user_id},
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{delete_connection: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    map_id
    |&gt; WandererApp.Map.Server.delete_connection(%{
      solar_system_source_id: solar_system_source_id |&gt; String.to_integer(),
      solar_system_target_id: solar_system_target_id |&gt; String.to_integer()
    })

    {:ok, _} =
      WandererApp.User.ActivityTracker.track_map_event(:map_connection_removed, %{
        character_id: main_character_id,
        user_id: current_user_id,
        map_id: map_id,
        solar_system_source_id: &quot;#{solar_system_source_id}&quot; |&gt; String.to_integer(),
        solar_system_target_id: &quot;#{solar_system_target_id}&quot; |&gt; String.to_integer()
      })

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;update_connection_&quot; &lt;&gt; param,
        %{
          &quot;source&quot; =&gt; solar_system_source_id,
          &quot;target&quot; =&gt; solar_system_target_id,
          &quot;value&quot; =&gt; value
        } = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: %{id: current_user_id},
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    method_atom =
      case param do
        &quot;time_status&quot; -&gt; :update_connection_time_status
        &quot;type&quot; -&gt; :update_connection_type
        &quot;mass_status&quot; -&gt; :update_connection_mass_status
        &quot;ship_size_type&quot; -&gt; :update_connection_ship_size_type
        &quot;locked&quot; -&gt; :update_connection_locked
        &quot;custom_info&quot; -&gt; :update_connection_custom_info
        _ -&gt; nil
      end

    key_atom =
      case param do
        &quot;time_status&quot; -&gt; :time_status
        &quot;type&quot; -&gt; :type
        &quot;mass_status&quot; -&gt; :mass_status
        &quot;ship_size_type&quot; -&gt; :ship_size_type
        &quot;locked&quot; -&gt; :locked
        &quot;custom_info&quot; -&gt; :custom_info
        _ -&gt; nil
      end

    {:ok, _} =
      WandererApp.User.ActivityTracker.track_map_event(:map_connection_updated, %{
        character_id: main_character_id,
        user_id: current_user_id,
        map_id: map_id,
        solar_system_source_id: &quot;#{solar_system_source_id}&quot; |&gt; String.to_integer(),
        solar_system_target_id: &quot;#{solar_system_target_id}&quot; |&gt; String.to_integer(),
        key: key_atom,
        value: value
      })

    apply(WandererApp.Map.Server, method_atom, [
      map_id,
      %{
        solar_system_source_id: &quot;#{solar_system_source_id}&quot; |&gt; String.to_integer(),
        solar_system_target_id: &quot;#{solar_system_target_id}&quot; |&gt; String.to_integer()
      }
      |&gt; Map.put_new(key_atom, value)
    ])

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;get_connection_info&quot;,
        %{&quot;from&quot; =&gt; from, &quot;to&quot; =&gt; to} = _event,
        %{assigns: %{map_id: map_id}} = socket
      ) do
    {:ok, info} = map_id |&gt; get_connection_info(from, to)

    {:reply, info, socket}
  end

  def handle_ui_event(
        &quot;get_passages&quot;,
        %{&quot;from&quot; =&gt; from, &quot;to&quot; =&gt; to} = _event,
        %{assigns: %{map_id: map_id}} = socket
      ) do
    {:ok, passages} = map_id |&gt; get_connection_passages(from, to)

    {:reply, passages, socket}
  end

  def handle_ui_event(event, body, socket),
    do: MapCoreEventHandler.handle_ui_event(event, body, socket)

  defp get_connection_passages(map_id, from, to) do
    {:ok, passages} = WandererApp.MapChainPassagesRepo.by_connection(map_id, from, to)

    passages =
      passages
      |&gt; Enum.map(fn p -&gt;
        %{
          p
          | character: p.character |&gt; MapEventHandler.map_ui_character_stat()
        }
        |&gt; Map.put_new(
          :ship,
          WandererApp.Character.get_ship(%{ship: p.ship_type_id, ship_name: p.ship_name})
        )
        |&gt; Map.drop([:ship_type_id, :ship_name])
      end)

    {:ok, %{passages: passages}}
  end

  defp get_connection_info(map_id, from, to) do
    map_id
    |&gt; WandererApp.Map.Server.get_connection_info(%{
      solar_system_source_id: &quot;#{from}&quot; |&gt; String.to_integer(),
      solar_system_target_id: &quot;#{to}&quot; |&gt; String.to_integer()
    })
    |&gt; case do
      {:ok, info} -&gt;
        {:ok, info}

      _ -&gt;
        {:ok, %{}}
    end
  end
end</file><file path="lib/wanderer_app_web/live/map/event_handlers/map_core_event_handler.ex">defmodule WandererAppWeb.MapCoreEventHandler do
  use WandererAppWeb, :live_component
  use Phoenix.Component
  require Logger

  alias WandererAppWeb.{MapEventHandler, MapCharactersEventHandler, MapSystemsEventHandler}

  def handle_server_event(:update_permissions, socket) do
    DebounceAndThrottle.Debounce.apply(
      Process,
      :send_after,
      [self(), :refresh_permissions, 100],
      &quot;update_permissions_#{inspect(self())}&quot;,
      1000
    )

    socket
  end

  def handle_server_event(
        :refresh_permissions,
        %{assigns: %{current_user: current_user, map_slug: map_slug}} = socket
      ) do
    {:ok, %{id: map_id, user_permissions: user_permissions, owner_id: owner_id}} =
      map_slug
      |&gt; WandererApp.Api.Map.get_map_by_slug!()
      |&gt; Ash.load(:user_permissions, actor: current_user)

    user_permissions =
      WandererApp.Permissions.get_map_permissions(
        user_permissions,
        owner_id,
        current_user.characters |&gt; Enum.map(&amp; &amp;1.id)
      )

    case user_permissions do
      %{view_system: false} -&gt;
        socket
        |&gt; Phoenix.LiveView.put_flash(:error, &quot;Your access to the map have been revoked.&quot;)
        |&gt; Phoenix.LiveView.push_navigate(to: ~p&quot;/maps&quot;)

      %{track_character: track_character} -&gt;
        {:ok, map_characters} =
          case WandererApp.MapCharacterSettingsRepo.get_tracked_by_map_filtered(
                 map_id,
                 current_user.characters |&gt; Enum.map(&amp; &amp;1.id)
               ) do
            {:ok, settings} -&gt;
              {:ok,
               settings
               |&gt; Enum.map(fn s -&gt; s |&gt; Ash.load!(:character) |&gt; Map.get(:character) end)}

            _ -&gt;
              {:ok, []}
          end

        case track_character do
          false -&gt;
            :ok = WandererApp.Character.TrackingUtils.untrack(map_characters, map_id, self())

          _ -&gt;
            :ok =
              WandererApp.Character.TrackingUtils.track(
                map_characters,
                map_id,
                true,
                self()
              )
        end

        socket
        |&gt; assign(user_permissions: user_permissions)
        |&gt; MapEventHandler.push_map_event(
          &quot;user_permissions&quot;,
          user_permissions
        )
    end
  end

  def handle_server_event(
        %{
          event: :load_map
        },
        %{assigns: %{current_user: current_user, map_slug: map_slug}} = socket
      ) do
    ErrorTracker.set_context(%{user_id: current_user.id})

    map_slug
    |&gt; WandererApp.MapRepo.get_by_slug_with_permissions(current_user)
    |&gt; case do
      {:ok, %{deleted: false} = map} -&gt;
        socket |&gt; init_map(map)

      _ -&gt;
        socket
        |&gt; put_flash(
          :error,
          &quot;Something went wrong. Please try one more time or submit an issue.&quot;
        )
        |&gt; push_navigate(to: ~p&quot;/maps&quot;)
    end
  end

  def handle_server_event(
        %{event: :map_server_started},
        socket
      ),
      do: socket |&gt; handle_map_server_started()

  def handle_server_event(%{event: :update_map, payload: map_diff}, socket),
    do:
      socket
      |&gt; MapEventHandler.push_map_event(
        &quot;map_updated&quot;,
        map_diff
      )

  def handle_server_event(
        %{event: &quot;presence_diff&quot;},
        socket
      ),
      do: socket

  def handle_server_event(event, socket) do
    Logger.warning(fn -&gt; &quot;unhandled map core event: #{inspect(event)}&quot; end)
    socket
  end

  def handle_ui_event(
        &quot;ui_loaded&quot;,
        %{&quot;version&quot; =&gt; version},
        %{assigns: %{map_slug: map_slug, app_version: app_version} = assigns} = socket
      ) do
    is_version_valid? = to_string(version) == to_string(app_version)

    if is_version_valid? do
      assigns
      |&gt; Map.get(:map_id)
      |&gt; case do
        map_id when not is_nil(map_id) -&gt;
          maybe_start_map(map_id)

        _ -&gt;
          WandererApp.Cache.insert(&quot;map_#{map_slug}:ui_loaded&quot;, true)
      end
    end

    {:noreply, socket |&gt; assign(:is_version_valid?, is_version_valid?)}
  end

  def handle_ui_event(
        &quot;live_select_change&quot;,
        %{&quot;id&quot; =&gt; id, &quot;text&quot; =&gt; text},
        socket
      )
      when id == &quot;_system_id_live_select_component&quot; do
    options =
      WandererApp.Api.MapSolarSystem.find_by_name!(%{name: text})
      |&gt; Enum.take(100)
      |&gt; Enum.map(&amp;MapSystemsEventHandler.map_system/1)

    send_update(LiveSelect.Component, options: options, id: id)

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;get_user_settings&quot;,
        _,
        %{
          assigns: %{
            map_user_settings: map_user_settings
          }
        } = socket
      ) do
    {:ok, user_settings} =
      map_user_settings
      |&gt; WandererApp.MapUserSettingsRepo.to_form_data()

    {:reply, %{user_settings: user_settings}, socket}
  end

  def handle_ui_event(
        &quot;update_user_settings&quot;,
        user_settings_form,
        %{assigns: %{map_id: map_id, current_user: current_user}} = socket
      ) do
    settings =
      user_settings_form
      |&gt; Map.take([&quot;select_on_spash&quot;, &quot;link_signature_on_splash&quot;, &quot;delete_connection_with_sigs&quot;])
      |&gt; Jason.encode!()

    {:ok, user_settings} =
      WandererApp.MapUserSettingsRepo.create_or_update(map_id, current_user.id, settings)

    {:noreply, socket |&gt; assign(map_user_settings: user_settings)}
  end

  def handle_ui_event(
        &quot;log_map_error&quot;,
        %{&quot;componentStack&quot; =&gt; component_stack, &quot;error&quot; =&gt; error},
        socket
      ) do
    Logger.error(fn -&gt; &quot;map_ui_error: #{error}  \n#{component_stack} &quot; end)

    {:noreply,
     socket
     |&gt; put_flash(:error, &quot;Something went wrong. Please try refresh page or submit an issue.&quot;)
     |&gt; push_event(&quot;js-exec&quot;, %{
       to: &quot;#map-loader&quot;,
       attr: &quot;data-loading&quot;,
       timeout: 100
     })}
  end

  def handle_ui_event(&quot;noop&quot;, _, socket), do: {:noreply, socket}

  def handle_ui_event(
        _event,
        _body,
        %{assigns: %{has_tracked_characters?: false, can_track?: true}} =
          socket
      ) do
    Process.send_after(self(), %{event: :show_tracking}, 10)

    {:noreply,
     socket
     |&gt; put_flash(
       :error,
       &quot;You should enable tracking for at least one character!&quot;
     )}
  end

  def handle_ui_event(
        event,
        body,
        %{assigns: %{main_character_id: main_character_id, can_track?: true}} =
          socket
      )
      when is_nil(main_character_id) do
    Process.send_after(self(), :no_main_character_set, 100)

    {:noreply, socket}
  end

  def handle_ui_event(event, body, socket) do
    Logger.debug(fn -&gt; &quot;unhandled map ui event: #{inspect(event)} #{inspect(body)}&quot; end)
    {:noreply, socket}
  end

  defp maybe_start_map(map_id) do
    {:ok, map_server_started} = WandererApp.Cache.lookup(&quot;map_#{map_id}:started&quot;, false)

    if map_server_started do
      Process.send_after(self(), %{event: :map_server_started}, 50)
    else
      WandererApp.Map.Manager.start_map(map_id)
    end
  end

  defp init_map(
         %{assigns: %{current_user: current_user, map_slug: map_slug}} = socket,
         %{
           id: map_id,
           only_tracked_characters: only_tracked_characters,
           user_permissions: user_permissions,
           name: map_name,
           owner_id: owner_id
         } = map
       ) do
    with {:ok, init_data} &lt;- setup_map_data(map, current_user, user_permissions, owner_id),
         :ok &lt;- check_map_access(init_data, only_tracked_characters) do
      Phoenix.PubSub.subscribe(WandererApp.PubSub, map_id)
      {:ok, ui_loaded} = WandererApp.Cache.get_and_remove(&quot;map_#{map_slug}:ui_loaded&quot;, false)

      if ui_loaded do
        maybe_start_map(map_id)
      end

      socket
      |&gt; assign(
        map_id: map_id,
        map_user_settings: init_data.map_user_settings,
        page_title: map_name,
        user_permissions: init_data.user_permissions,
        main_character_id: init_data.main_character_id,
        main_character_eve_id: init_data.main_character_eve_id,
        following_character_eve_id: init_data.following_character_eve_id,
        tracked_characters: init_data.tracked_characters,
        has_tracked_characters?: init_data.has_tracked_characters?,
        needs_tracking_setup: init_data.needs_tracking_setup,
        only_tracked_characters: only_tracked_characters
      )
    else
      {:error, :not_all_tracked} -&gt;
        Process.send_after(self(), :not_all_characters_tracked, 10)
        socket

      _ -&gt;
        Process.send_after(self(), :no_permissions, 10)
        socket
    end
  end

  defp setup_map_data(
         %{
           id: map_id,
           only_tracked_characters: only_tracked_characters
         } = map,
         %{
           id: current_user_id,
           characters: current_user_characters
         } = current_user,
         user_permissions,
         owner_id
       ) do
    with user_permissions &lt;-
           WandererApp.Permissions.get_map_permissions(
             user_permissions,
             owner_id,
             current_user_characters |&gt; Enum.map(&amp; &amp;1.id)
           ),
         {:ok, map_user_settings} &lt;- WandererApp.MapUserSettingsRepo.get(map_id, current_user_id),
         {:ok, character_settings} &lt;-
           WandererApp.Character.Activity.get_map_character_settings(map_id),
         {:ok, %{characters: available_map_characters}} =
           WandererApp.Maps.load_characters(map, character_settings, current_user_id) do
      tracked_data =
        get_tracked_data(
          available_map_characters,
          character_settings,
          user_permissions,
          only_tracked_characters
        )

      {main_character_id, main_character_eve_id} =
        WandererApp.Character.TrackingUtils.get_main_character(
          map_user_settings,
          current_user_characters,
          available_map_characters
        )
        |&gt; case do
          {:ok, main_character} when not is_nil(main_character) -&gt;
            {main_character.id, main_character.eve_id}

          _ -&gt;
            {nil, nil}
        end

      following_character_eve_id =
        case map_user_settings do
          nil -&gt; nil
          %{following_character_eve_id: following_character_eve_id} -&gt; following_character_eve_id
        end

      {:ok,
       %{
         user_permissions: user_permissions,
         map_user_settings: map_user_settings,
         main_character_id: main_character_id,
         main_character_eve_id: main_character_eve_id,
         following_character_eve_id: following_character_eve_id,
         tracked_characters: tracked_data.tracked_characters,
         all_character_tracked?: tracked_data.all_tracked?,
         has_tracked_characters?: tracked_data.has_tracked_characters?,
         needs_tracking_setup: tracked_data.needs_tracking_setup,
         can_view?: user_permissions.view_system,
         can_track?: user_permissions.track_character
       }}
    end
  end

  defp get_tracked_data(
         available_map_characters,
         character_settings,
         user_permissions,
         only_tracked_characters
       ) do
    tracked_characters =
      available_map_characters
      |&gt; Enum.filter(fn char -&gt;
        setting = Enum.find(character_settings, &amp;(&amp;1.character_id == char.id))
        setting != nil &amp;&amp; setting.tracked == true
      end)

    all_tracked? =
      not Enum.empty?(available_map_characters) and
        Enum.count(available_map_characters) == Enum.count(tracked_characters)

    needs_tracking_setup =
      MapCharactersEventHandler.needs_tracking_setup?(
        only_tracked_characters,
        available_map_characters,
        character_settings,
        user_permissions
      )

    %{
      tracked_characters: tracked_characters,
      all_tracked?: all_tracked?,
      needs_tracking_setup: needs_tracking_setup,
      has_tracked_characters?: tracked_characters |&gt; Enum.empty?() |&gt; Kernel.not()
    }
  end

  defp check_map_access(
         %{can_view?: true, can_track?: can_track?, all_character_tracked?: all_tracked?},
         only_tracked_characters
       ) do
    cond do
      only_tracked_characters and can_track? and all_tracked? -&gt; :ok
      not only_tracked_characters -&gt; :ok
      only_tracked_characters and can_track? -&gt; {:error, :not_all_tracked}
      true -&gt; {:error, :no_permissions}
    end
  end

  defp check_map_access(_, _), do: {:error, :no_permissions}

  defp setup_map_socket(socket, map_id, map_slug, map_name, init_data, only_tracked_characters) do
  end

  defp handle_map_server_started(
         %{
           assigns: %{
             current_user: current_user,
             map_id: map_id,
             main_character_id: main_character_id,
             tracked_characters: tracked_characters,
             has_tracked_characters?: has_tracked_characters?,
             user_permissions:
               %{view_system: true, track_character: track_character} = user_permissions
           }
         } = socket
       ) do
    with {:ok, _} &lt;- current_user |&gt; WandererApp.Api.User.update_last_map(%{last_map_id: map_id}),
         {:ok, characters_limit} &lt;- map_id |&gt; WandererApp.Map.get_characters_limit(),
         {:ok, present_character_ids} &lt;-
           WandererApp.Cache.lookup(&quot;map_#{map_id}:presence_character_ids&quot;, []) do
      events =
        case tracked_characters |&gt; Enum.any?(&amp;(&amp;1.access_token == nil)) do
          true -&gt;
            [:invalid_token_message]

          _ -&gt;
            []
        end

      events =
        case track_character &amp;&amp; not has_tracked_characters? do
          true -&gt;
            events ++ [:empty_tracked_characters]

          _ -&gt;
            events
        end

      character_limit_reached? = present_character_ids |&gt; Enum.count() &gt;= characters_limit

      events =
        cond do
          # in case user has not tracked any character track his main character as viewer
          track_character &amp;&amp; not has_tracked_characters? -&gt;
            main_character = Enum.find(current_user.characters, &amp;(&amp;1.id == main_character_id))
            events ++ [{:track_characters, [main_character], false}]

          track_character &amp;&amp; not character_limit_reached? -&gt;
            events ++ [{:track_characters, tracked_characters, track_character}]

          track_character &amp;&amp; character_limit_reached? -&gt;
            events ++ [:map_character_limit]

          # in case user has view only permissions track his main character as viewer
          not track_character -&gt;
            main_character = Enum.find(current_user.characters, &amp;(&amp;1.id == main_character_id))
            events ++ [{:track_characters, [main_character], track_character}]

          true -&gt;
            events
        end

      initial_data =
        %{
          kills: nil,
          present_characters:
            present_character_ids
            |&gt; WandererApp.Character.get_character_eve_ids!(),
          user_characters: tracked_characters |&gt; Enum.map(&amp; &amp;1.eve_id),
          system_static_infos: nil,
          wormholes: nil,
          effects: nil,
          classes: nil,
          reset: false
        }

      socket
      |&gt; map_start(
        %{
          map_id: map_id,
          initial_data: initial_data,
          events: events
        },
        user_permissions
      )
    else
      error -&gt;
        Logger.error(fn -&gt; &quot;map_start_error: #{error}&quot; end)
        Process.send_after(self(), :no_access, 10)

        socket
    end
  end

  defp handle_map_server_started(socket) do
    Process.send_after(self(), :no_access, 10)
    socket
  end

  defp map_start(
         %{
           assigns: %{
             current_user: current_user,
             needs_tracking_setup: needs_tracking_setup,
             main_character_id: main_character_id,
             main_character_eve_id: main_character_eve_id,
             following_character_eve_id: following_character_eve_id
           }
         } = socket,
         %{
           map_id: map_id,
           initial_data: initial_data,
           events: events
         } = _started_data,
         user_permissions
       ) do
    socket =
      socket
      |&gt; MapCharactersEventHandler.handle_tracking_events(map_id, events)

    {:ok, options} =
      map_id
      |&gt; WandererApp.Map.get_options()

    map_characters =
      map_id
      |&gt; WandererApp.Map.list_characters()
      |&gt; filter_map_characters(initial_data.user_characters, user_permissions, options)
      |&gt; Enum.map(&amp;MapCharactersEventHandler.map_ui_character/1)

    {:ok, is_subscription_active} = map_id |&gt; WandererApp.Map.is_subscription_active?()

    map_data =
      map_id
      |&gt; get_map_data(current_user.id, is_subscription_active)

    socket =
      socket
      |&gt; assign(
        map_loaded?: true,
        is_subscription_active?: is_subscription_active
      )
      |&gt; MapEventHandler.push_map_event(
        &quot;init&quot;,
        initial_data
        |&gt; Map.merge(map_data)
        |&gt; Map.merge(%{
          main_character_eve_id: main_character_eve_id,
          following_character_eve_id: following_character_eve_id,
          is_subscription_active: is_subscription_active,
          user_permissions: user_permissions,
          characters: map_characters,
          options: options,
          classes: WandererApp.CachedInfo.get_wormhole_classes!(),
          wormholes: WandererApp.CachedInfo.get_wormhole_types!(),
          effects: WandererApp.CachedInfo.get_effects!(),
          reset: true
        })
      )
      |&gt; push_event(&quot;js-exec&quot;, %{
        to: &quot;#map-loader&quot;,
        attr: &quot;data-loaded&quot;
      })

    if is_nil(main_character_id) do
      Process.send_after(self(), :no_main_character_set, 100)
    end

    if needs_tracking_setup do
      Process.send_after(self(), %{event: :show_tracking}, 10)

      socket
    else
      socket
    end
  end

  defp get_map_data(map_id, current_user_id, is_subscription_active) do
    {:ok, hubs} = map_id |&gt; WandererApp.Map.list_hubs()
    {:ok, hubs_limit} = map_id |&gt; WandererApp.Map.get_hubs_limit()
    {:ok, connections} = map_id |&gt; WandererApp.Map.list_connections()
    {:ok, systems} = map_id |&gt; WandererApp.Map.list_systems()

    {:ok, user_hubs} =
      if is_subscription_active do
        WandererApp.MapUserSettingsRepo.get_hubs(map_id, current_user_id)
      else
        {:ok, []}
      end

    system_static_infos =
      systems
      |&gt; Enum.map(&amp;WandererApp.CachedInfo.get_system_static_info!(&amp;1.solar_system_id))

    %{
      systems:
        systems
        |&gt; Enum.map(fn system -&gt; MapEventHandler.map_ui_system(system, false) end),
      system_static_infos:
        system_static_infos |&gt; Enum.map(&amp;MapEventHandler.map_ui_system_static_info/1),
      hubs: hubs,
      hubs_limit: hubs_limit,
      user_hubs: user_hubs,
      connections: connections |&gt; Enum.map(&amp;MapEventHandler.map_ui_connection/1)
    }
  end

  defp filter_map_characters(
         characters,
         user_character_eve_ids,
         %{
           manage_map: manage_map_permission
         } = _user_permissions,
         options
       ) do
    restrict_offline_showing =
      options |&gt; Map.get(&quot;restrict_offline_showing&quot;, &quot;false&quot;) |&gt; String.to_existing_atom()

    show_offline? = not restrict_offline_showing or manage_map_permission

    characters
    |&gt; Enum.filter(fn character -&gt;
      show_offline? || character.online ||
        user_character_eve_ids |&gt; Enum.member?(character.eve_id)
    end)
  end
end</file><file path="lib/wanderer_app_web/live/map/event_handlers/map_kills_event_handler.ex">defmodule WandererAppWeb.MapKillsEventHandler do
  @moduledoc &quot;&quot;&quot;
  Handles kills-related UI/server events.
  &quot;&quot;&quot;

  use WandererAppWeb, :live_component
  require Logger

  alias WandererAppWeb.{MapEventHandler, MapCoreEventHandler}
  alias WandererApp.Zkb.KillsProvider
  alias WandererApp.Zkb.KillsProvider.KillsCache

  def handle_server_event(
        %{event: :init_kills},
        %{
          assigns: %{
            map_id: map_id
          }
        } = socket
      ) do
    {:ok, kills} = WandererApp.Cache.lookup(&quot;map_#{map_id}:zkb_kills&quot;, Map.new())

    socket
    |&gt; MapEventHandler.push_map_event(
      &quot;map_updated&quot;,
      %{
        kills:
          kills
          |&gt; Enum.filter(fn {_, kills} -&gt; kills &gt; 0 end)
          |&gt; Enum.map(&amp;map_ui_kill/1)
      }
    )
  end

  def handle_server_event(%{event: :kills_updated, payload: kills}, socket) do
    kills =
      kills
      |&gt; Enum.map(&amp;map_ui_kill/1)

    socket
    |&gt; MapEventHandler.push_map_event(
      &quot;kills_updated&quot;,
      kills
    )
  end

  def handle_server_event(
        %{event: :detailed_kills_updated, payload: payload},
        %{
          assigns: %{
            map_id: map_id
          }
        } = socket
      ) do
    case WandererApp.Map.is_subscription_active?(map_id) do
      {:ok, true} -&gt;
        socket
        |&gt; MapEventHandler.push_map_event(
          &quot;detailed_kills_updated&quot;,
          payload
        )

      _ -&gt;
        socket
    end
  end

  def handle_server_event(
        %{event: :fetch_system_kills_error, payload: {system_id, reason}},
        socket
      ) do
    Logger.warning(
      &quot;[#{__MODULE__}] fetch_kills_for_system failed for sid=#{system_id}: #{inspect(reason)}&quot;
    )

    socket
  end

  def handle_server_event(%{event: :systems_kills_error, payload: {system_ids, reason}}, socket) do
    Logger.warning(
      &quot;[#{__MODULE__}] fetch_kills_for_systems =&gt; error=#{inspect(reason)}, systems=#{inspect(system_ids)}&quot;
    )

    socket
  end

  def handle_server_event(%{event: :system_kills_error, payload: {system_id, reason}}, socket) do
    Logger.warning(
      &quot;[#{__MODULE__}] fetch_kills_for_system =&gt; error=#{inspect(reason)} for system=#{system_id}&quot;
    )

    socket
  end

  def handle_server_event(event, socket),
    do: MapCoreEventHandler.handle_server_event(event, socket)

  def handle_ui_event(
        &quot;get_system_kills&quot;,
        %{&quot;system_id&quot; =&gt; sid, &quot;since_hours&quot; =&gt; sh} = payload,
        socket
      ) do
    with {:ok, system_id} &lt;- parse_id(sid),
         {:ok, since_hours} &lt;- parse_id(sh) do
      kills_from_cache = KillsCache.fetch_cached_kills(system_id)
      reply_payload = %{&quot;system_id&quot; =&gt; system_id, &quot;kills&quot; =&gt; kills_from_cache}

      Task.async(fn -&gt;
        case KillsProvider.Fetcher.fetch_kills_for_system(system_id, since_hours, %{
               calls_count: 0
             }) do
          {:ok, fresh_kills, _new_state} -&gt;
            {:detailed_kills_updated, %{system_id =&gt; fresh_kills}}

          {:error, reason, _new_state} -&gt;
            Logger.warning(&quot;[#{__MODULE__}] fetch_kills_for_system =&gt; error=#{inspect(reason)}&quot;)
            {:system_kills_error, {system_id, reason}}
        end
      end)

      {:reply, reply_payload, socket}
    else
      :error -&gt;
        Logger.warning(&quot;[#{__MODULE__}] Invalid input to get_system_kills: #{inspect(payload)}&quot;)
        {:reply, %{&quot;error&quot; =&gt; &quot;invalid_input&quot;}, socket}
    end
  end

  def handle_ui_event(
        &quot;get_systems_kills&quot;,
        %{&quot;system_ids&quot; =&gt; sids, &quot;since_hours&quot; =&gt; sh} = payload,
        socket
      ) do
    with {:ok, since_hours} &lt;- parse_id(sh),
         {:ok, parsed_ids} &lt;- parse_system_ids(sids) do
      Logger.debug(fn -&gt;
        &quot;[#{__MODULE__}] get_systems_kills =&gt; system_ids=#{inspect(parsed_ids)}, since_hours=#{since_hours}&quot;
      end)

      # Get the cutoff time based on since_hours
      cutoff = DateTime.utc_now() |&gt; DateTime.add(-since_hours * 3600, :second)

      Logger.debug(fn -&gt;
        &quot;[#{__MODULE__}] get_systems_kills =&gt; cutoff=#{DateTime.to_iso8601(cutoff)}&quot;
      end)

      # Fetch and filter kills for each system
      cached_map =
        Enum.reduce(parsed_ids, %{}, fn sid, acc -&gt;
          # Get all cached kills for this system
          all_kills = KillsCache.fetch_cached_kills(sid)

          # Filter kills based on the cutoff time
          filtered_kills =
            Enum.filter(all_kills, fn kill -&gt;
              kill_time = kill[&quot;kill_time&quot;]

              case kill_time do
                %DateTime{} = dt -&gt;
                  # Keep kills that occurred after the cutoff
                  DateTime.compare(dt, cutoff) != :lt

                time when is_binary(time) -&gt;
                  # Try to parse the string time
                  case DateTime.from_iso8601(time) do
                    {:ok, dt, _} -&gt; DateTime.compare(dt, cutoff) != :lt
                    _ -&gt; false
                  end

                # If it&apos;s something else (nil, or a weird format), skip
                _ -&gt;
                  false
              end
            end)

          Logger.debug(fn -&gt;
            &quot;[#{__MODULE__}] get_systems_kills =&gt; system_id=#{sid}, all_kills=#{length(all_kills)}, filtered_kills=#{length(filtered_kills)}&quot;
          end)

          Map.put(acc, sid, filtered_kills)
        end)

      reply_payload = %{&quot;systems_kills&quot; =&gt; cached_map}

      Task.async(fn -&gt;
        case KillsProvider.Fetcher.fetch_kills_for_systems(parsed_ids, since_hours, %{
               calls_count: 0
             }) do
          {:ok, systems_map} -&gt;
            {:detailed_kills_updated, systems_map}

          {:error, reason} -&gt;
            Logger.warning(&quot;[#{__MODULE__}] fetch_kills_for_systems =&gt; error=#{inspect(reason)}&quot;)
            {:systems_kills_error, {parsed_ids, reason}}
        end
      end)

      {:reply, reply_payload, socket}
    else
      :error -&gt;
        Logger.warning(&quot;[#{__MODULE__}] Invalid multiple-systems input: #{inspect(payload)}&quot;)
        {:reply, %{&quot;error&quot; =&gt; &quot;invalid_input&quot;}, socket}
    end
  end

  def handle_ui_event(event, payload, socket) do
    MapCoreEventHandler.handle_ui_event(event, payload, socket)
  end

  defp parse_id(value) when is_binary(value) do
    case Integer.parse(value) do
      {int, &quot;&quot;} -&gt; {:ok, int}
      _ -&gt; :error
    end
  end

  defp parse_id(value) when is_integer(value), do: {:ok, value}
  defp parse_id(_), do: :error

  defp parse_system_ids(ids) when is_list(ids) do
    parsed =
      Enum.reduce_while(ids, [], fn sid, acc -&gt;
        case parse_id(sid) do
          {:ok, int_id} -&gt; {:cont, [int_id | acc]}
          :error -&gt; {:halt, :error}
        end
      end)

    case parsed do
      :error -&gt; :error
      list -&gt; {:ok, Enum.reverse(list)}
    end
  end

  defp parse_system_ids(_), do: :error

  defp map_ui_kill({solar_system_id, kills}),
    do: %{solar_system_id: solar_system_id, kills: kills}

  defp map_ui_kill(_kill), do: %{}
end</file><file path="lib/wanderer_app_web/live/map/event_handlers/map_routes_event_handler.ex">defmodule WandererAppWeb.MapRoutesEventHandler do
  use WandererAppWeb, :live_component
  use Phoenix.Component
  require Logger

  alias WandererAppWeb.{MapEventHandler, MapCoreEventHandler, MapSystemsEventHandler}

  def handle_server_event(
        %{
          event: :routes,
          payload: {solar_system_id, %{routes: routes, systems_static_data: systems_static_data}}
        },
        socket
      ),
      do:
        socket
        |&gt; MapEventHandler.push_map_event(
          &quot;routes&quot;,
          %{
            solar_system_id: solar_system_id,
            loading: false,
            routes: routes,
            systems_static_data: systems_static_data
          }
        )

  def handle_server_event(
        %{
          event: :user_routes,
          payload: {solar_system_id, %{routes: routes, systems_static_data: systems_static_data}}
        },
        socket
      ),
      do:
        socket
        |&gt; MapEventHandler.push_map_event(
          &quot;user_routes&quot;,
          %{
            solar_system_id: solar_system_id,
            loading: false,
            routes: routes,
            systems_static_data: systems_static_data
          }
        )

  def handle_server_event(event, socket),
    do: MapCoreEventHandler.handle_server_event(event, socket)

  def handle_ui_event(
        &quot;get_routes&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id, &quot;routes_settings&quot; =&gt; routes_settings} = _event,
        %{assigns: %{map_id: map_id, map_loaded?: true}} = socket
      ) do
    {:ok, map} = map_id |&gt; WandererApp.Map.get_map()
    hubs_limit = map |&gt; Map.get(:hubs_limit, 20)

    {:ok, hubs} = map_id |&gt; WandererApp.Map.list_hubs()

    is_hubs_limit_reached = hubs |&gt; Enum.count() &gt; hubs_limit

    Task.async(fn -&gt;
      {:ok, routes} =
        WandererApp.Maps.find_routes(
          map_id,
          hubs,
          solar_system_id,
          get_routes_settings(routes_settings),
          is_hubs_limit_reached
        )

      {:routes, {solar_system_id, routes}}
    end)

    if is_hubs_limit_reached do
      {:noreply,
       socket
       |&gt; put_flash(
         :warning,
         &quot;The Map hubs limit has been reached, please try to remove some hubs first, or contact the map administrators.&quot;
       )}
    else
      {:noreply, socket}
    end
  end

  def handle_ui_event(
        &quot;get_user_routes&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id, &quot;routes_settings&quot; =&gt; routes_settings} = _event,
        %{
          assigns: %{
            map_id: map_id,
            map_loaded?: true,
            current_user: current_user,
            is_subscription_active?: is_subscription_active?
          }
        } = socket
      ) do
    {:ok, map} = map_id |&gt; WandererApp.Map.get_map()
    hubs_limit = map |&gt; Map.get(:hubs_limit, 20)

    {:ok, hubs} = WandererApp.MapUserSettingsRepo.get_hubs(map_id, current_user.id)

    is_hubs_limit_reached = hubs |&gt; Enum.count() &gt; hubs_limit

    Task.async(fn -&gt;
      if is_subscription_active? do
        {:ok, routes} =
          WandererApp.Maps.find_routes(
            map_id,
            hubs,
            solar_system_id,
            get_routes_settings(routes_settings),
            is_hubs_limit_reached
          )

        {:user_routes, {solar_system_id, routes}}
      else
        {:user_routes, {solar_system_id, %{routes: [], systems_static_data: []}}}
      end
    end)

    if is_hubs_limit_reached do
      {:noreply,
       socket
       |&gt; put_flash(
         :warning,
         &quot;The user hubs limit has been reached, please try to remove some hubs first, or contact the map administrators.&quot;
       )}
    else
      {:noreply, socket}
    end
  end

  def handle_ui_event(
        &quot;add_hub&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    {:ok, map} = map_id |&gt; WandererApp.Map.get_map()
    hubs_limit = map |&gt; Map.get(:hubs_limit, 20)

    {:ok, hubs} = map_id |&gt; WandererApp.Map.list_hubs()

    if hubs |&gt; Enum.count() &lt; hubs_limit do
      map_id
      |&gt; WandererApp.Map.Server.add_hub(%{
        solar_system_id: solar_system_id
      })

      {:ok, _} =
        WandererApp.User.ActivityTracker.track_map_event(:hub_added, %{
          character_id: main_character_id,
          user_id: current_user.id,
          map_id: map_id,
          solar_system_id: solar_system_id
        })

      {:noreply, socket}
    else
      {:noreply,
       socket
       |&gt; put_flash(
         :warning,
         &quot;The Map hubs limit has been reached, please try to remove some hubs first, or contact the map administrators.&quot;
       )}
    end
  end

  def handle_ui_event(
        &quot;delete_hub&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    map_id
    |&gt; WandererApp.Map.Server.remove_hub(%{
      solar_system_id: solar_system_id
    })

    {:ok, _} =
      WandererApp.User.ActivityTracker.track_map_event(:hub_removed, %{
        character_id: main_character_id,
        user_id: current_user.id,
        map_id: map_id,
        solar_system_id: solar_system_id
      })

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;get_user_hubs&quot;,
        _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user
          }
        } =
          socket
      ) do
    {:ok, hubs} = WandererApp.MapUserSettingsRepo.get_hubs(map_id, current_user.id)

    {:reply, %{hubs: hubs}, socket}
  end

  def handle_ui_event(
        &quot;add_user_hub&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user
          }
        } =
          socket
      ) do
    {:ok, map} = map_id |&gt; WandererApp.Map.get_map()
    hubs_limit = map |&gt; Map.get(:hubs_limit, 20)

    {:ok, hubs} = WandererApp.MapUserSettingsRepo.get_hubs(map_id, current_user.id)

    if hubs |&gt; Enum.count() &lt; hubs_limit do
      hubs = hubs ++ [&quot;#{solar_system_id}&quot;]

      {:ok, _} =
        WandererApp.MapUserSettingsRepo.update_hubs(
          map_id,
          current_user.id,
          hubs
        )

      {:noreply,
       socket
       |&gt; MapEventHandler.push_map_event(
         &quot;map_updated&quot;,
         %{user_hubs: hubs}
       )}
    else
      {:noreply,
       socket
       |&gt; MapEventHandler.push_map_event(
         &quot;map_updated&quot;,
         %{user_hubs: hubs}
       )
       |&gt; put_flash(
         :warning,
         &quot;The user hubs limit has been reached, please try to remove some user hubs first, or contact the map administrators.&quot;
       )}
    end
  end

  def handle_ui_event(
        &quot;delete_user_hub&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user
          }
        } =
          socket
      ) do
    {:ok, hubs} = WandererApp.MapUserSettingsRepo.get_hubs(map_id, current_user.id)

    case hubs |&gt; Enum.member?(&quot;#{solar_system_id}&quot;) do
      true -&gt;
        hubs = hubs |&gt; Enum.reject(fn hub -&gt; hub == &quot;#{solar_system_id}&quot; end)

        {:ok, _} =
          WandererApp.MapUserSettingsRepo.update_hubs(
            map_id,
            current_user.id,
            hubs
          )

        {:noreply,
         socket
         |&gt; MapEventHandler.push_map_event(
           &quot;map_updated&quot;,
           %{user_hubs: hubs}
         )}

      _ -&gt;
        {:noreply,
         socket
         |&gt; MapEventHandler.push_map_event(
           &quot;map_updated&quot;,
           %{user_hubs: hubs}
         )}
    end
  end

  def handle_ui_event(
        &quot;set_autopilot_waypoint&quot;,
        %{
          &quot;character_eve_ids&quot; =&gt; character_eve_ids,
          &quot;add_to_beginning&quot; =&gt; add_to_beginning,
          &quot;clear_other_waypoints&quot; =&gt; clear_other_waypoints,
          &quot;destination_id&quot; =&gt; destination_id
        } = _event,
        %{assigns: %{current_user: current_user, has_tracked_characters?: true}} = socket
      ) do
    character_eve_ids
    |&gt; Task.async_stream(fn character_eve_id -&gt;
      set_autopilot_waypoint(
        current_user,
        character_eve_id,
        add_to_beginning,
        clear_other_waypoints,
        destination_id
      )
    end)
    |&gt; Enum.map(fn _result -&gt; :skip end)

    {:noreply, socket}
  end

  def handle_ui_event(event, body, socket),
    do: MapCoreEventHandler.handle_ui_event(event, body, socket)

  defp get_routes_settings(%{
         &quot;path_type&quot; =&gt; path_type,
         &quot;include_mass_crit&quot; =&gt; include_mass_crit,
         &quot;include_eol&quot; =&gt; include_eol,
         &quot;include_frig&quot; =&gt; include_frig,
         &quot;include_cruise&quot; =&gt; include_cruise,
         &quot;avoid_wormholes&quot; =&gt; avoid_wormholes,
         &quot;avoid_pochven&quot; =&gt; avoid_pochven,
         &quot;avoid_edencom&quot; =&gt; avoid_edencom,
         &quot;avoid_triglavian&quot; =&gt; avoid_triglavian,
         &quot;include_thera&quot; =&gt; include_thera,
         &quot;avoid&quot; =&gt; avoid
       }),
       do: %{
         path_type: path_type,
         include_mass_crit: include_mass_crit,
         include_eol: include_eol,
         include_frig: include_frig,
         include_cruise: include_cruise,
         avoid_wormholes: avoid_wormholes,
         avoid_pochven: avoid_pochven,
         avoid_edencom: avoid_edencom,
         avoid_triglavian: avoid_triglavian,
         include_thera: include_thera,
         avoid: avoid
       }

  defp get_routes_settings(_), do: %{}

  defp set_autopilot_waypoint(
         current_user,
         character_eve_id,
         add_to_beginning,
         clear_other_waypoints,
         destination_id
       ) do
    case current_user.characters
         |&gt; Enum.find(fn c -&gt; c.eve_id == character_eve_id end) do
      nil -&gt;
        :skip

      %{id: character_id} = _character -&gt;
        character_id
        |&gt; WandererApp.Character.set_autopilot_waypoint(destination_id,
          add_to_beginning: add_to_beginning,
          clear_other_waypoints: clear_other_waypoints
        )

        :skip
    end
  end
end</file><file path="lib/wanderer_app_web/live/map/event_handlers/map_signatures_event_handler.ex">defmodule WandererAppWeb.MapSignaturesEventHandler do
  use WandererAppWeb, :live_component
  use Phoenix.Component
  require Logger

  alias WandererAppWeb.{MapEventHandler, MapCoreEventHandler}

  def handle_server_event(
        %{
          event: :maybe_link_signature,
          payload: %{
            character_id: character_id,
            solar_system_source: solar_system_source,
            solar_system_target: solar_system_target
          }
        },
        %{
          assigns: %{
            current_user: current_user,
            map_id: map_id,
            map_user_settings: map_user_settings
          }
        } = socket
      ) do
    is_user_character =
      current_user.characters |&gt; Enum.map(&amp; &amp;1.id) |&gt; Enum.member?(character_id)

    is_link_signature_on_splash =
      map_user_settings
      |&gt; WandererApp.MapUserSettingsRepo.to_form_data!()
      |&gt; WandererApp.MapUserSettingsRepo.get_boolean_setting(&quot;link_signature_on_splash&quot;)

    {:ok, signatures} =
      WandererApp.Api.MapSystem.read_by_map_and_solar_system(%{
        map_id: map_id,
        solar_system_id: solar_system_source
      })
      |&gt; case do
        {:ok, system} -&gt;
          {:ok, get_system_signatures(system.id)}

        _ -&gt;
          {:ok, []}
      end

    (is_user_character &amp;&amp; is_link_signature_on_splash &amp;&amp; not (signatures |&gt; Enum.empty?()))
    |&gt; case do
      true -&gt;
        socket
        |&gt; MapEventHandler.push_map_event(&quot;link_signature_to_system&quot;, %{
          solar_system_source: solar_system_source,
          solar_system_target: solar_system_target
        })

      false -&gt;
        socket
    end
  end

  def handle_server_event(
        %{event: :signatures_updated, payload: solar_system_id},
        socket
      ),
      do:
        socket
        |&gt; MapEventHandler.push_map_event(
          &quot;signatures_updated&quot;,
          solar_system_id
        )

  def handle_server_event(event, socket),
    do: MapCoreEventHandler.handle_server_event(event, socket)

  def handle_ui_event(
        &quot;load_signatures&quot;,
        _event,
        %{
          assigns: %{
            map_id: map_id
          }
        } = socket
      ) do
    {:ok, systems} = map_id |&gt; WandererApp.Map.list_systems()

    system_signatures =
      systems
      |&gt; Enum.reduce(%{}, fn %{id: system_id, solar_system_id: solar_system_id}, acc -&gt;
        signatures =
          system_id
          |&gt; get_system_signatures()
          |&gt; Enum.filter(fn signature -&gt;
            is_nil(signature.linked_system) &amp;&amp; signature.group == &quot;Wormhole&quot;
          end)

        acc |&gt; Map.put(solar_system_id, signatures)
      end)

    {:noreply,
     socket
     |&gt; MapEventHandler.push_map_event(
       &quot;map_updated&quot;,
       %{system_signatures: system_signatures}
     )}
  end

  def handle_ui_event(
        &quot;update_signatures&quot;,
        %{
          &quot;system_id&quot; =&gt; solar_system_id,
          &quot;added&quot; =&gt; added_signatures,
          &quot;updated&quot; =&gt; updated_signatures,
          &quot;removed&quot; =&gt; removed_signatures
        },
        %{
          assigns: %{
            current_user: %{id: current_user_id},
            map_id: map_id,
            main_character_id: main_character_id,
            map_user_settings: map_user_settings,
            user_permissions: %{update_system: true}
          }
        } = socket
      )
      when not is_nil(main_character_id) do
    delete_connection_with_sigs =
      map_user_settings
      |&gt; WandererApp.MapUserSettingsRepo.to_form_data!()
      |&gt; WandererApp.MapUserSettingsRepo.get_boolean_setting(&quot;delete_connection_with_sigs&quot;)

    map_id
    |&gt; WandererApp.Map.Server.update_signatures(%{
      solar_system_id: get_integer(solar_system_id),
      character_id: main_character_id,
      user_id: current_user_id,
      delete_connection_with_sigs: delete_connection_with_sigs,
      added_signatures: added_signatures,
      updated_signatures: updated_signatures,
      removed_signatures: removed_signatures
    })

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;get_signatures&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id},
        %{
          assigns: %{
            map_id: map_id
          }
        } = socket
      ) do
    case WandererApp.Api.MapSystem.read_by_map_and_solar_system(%{
           map_id: map_id,
           solar_system_id: get_integer(solar_system_id)
         }) do
      {:ok, system} -&gt;
        {:reply, %{signatures: get_system_signatures(system.id)}, socket}

      _ -&gt;
        {:reply, %{signatures: []}, socket}
    end
  end

  def handle_ui_event(
        &quot;link_signature_to_system&quot;,
        %{
          &quot;signature_eve_id&quot; =&gt; signature_eve_id,
          &quot;solar_system_source&quot; =&gt; solar_system_source,
          &quot;solar_system_target&quot; =&gt; solar_system_target
        },
        %{
          assigns: %{
            map_id: map_id,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } = socket
      )
      when not is_nil(main_character_id) do
    solar_system_source = get_integer(solar_system_source)
    solar_system_target = get_integer(solar_system_target)

    case WandererApp.Api.MapSystem.read_by_map_and_solar_system(%{
           map_id: map_id,
           solar_system_id: solar_system_source
         }) do
      {:ok, system} -&gt;
        WandererApp.Api.MapSystemSignature.by_system_id!(system.id)
        |&gt; Enum.filter(fn s -&gt; s.eve_id == signature_eve_id end)
        |&gt; Enum.each(fn s -&gt;
          s
          |&gt; WandererApp.Api.MapSystemSignature.update_group!(%{group: &quot;Wormhole&quot;})
          |&gt; WandererApp.Api.MapSystemSignature.update_linked_system(%{
            linked_system_id: solar_system_target
          })
        end)

        map_system =
          WandererApp.Map.find_system_by_location(
            map_id,
            %{solar_system_id: solar_system_target}
          )

        if not is_nil(map_system) &amp;&amp; is_nil(map_system.linked_sig_eve_id) do
          map_id
          |&gt; WandererApp.Map.Server.update_system_linked_sig_eve_id(%{
            solar_system_id: solar_system_target,
            linked_sig_eve_id: signature_eve_id
          })
        end

        WandererApp.Map.Server.Impl.broadcast!(map_id, :signatures_updated, solar_system_source)

        {:noreply, socket}

      _ -&gt;
        {:noreply, socket}
    end
  end

  def handle_ui_event(
        &quot;unlink_signature&quot;,
        %{
          &quot;signature_eve_id&quot; =&gt; signature_eve_id,
          &quot;solar_system_source&quot; =&gt; solar_system_source
        },
        %{
          assigns: %{
            map_id: map_id,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } = socket
      )
      when not is_nil(main_character_id) do
    solar_system_source = get_integer(solar_system_source)

    case WandererApp.Api.MapSystem.read_by_map_and_solar_system(%{
           map_id: map_id,
           solar_system_id: solar_system_source
         }) do
      {:ok, system} -&gt;
        WandererApp.Api.MapSystemSignature.by_system_id!(system.id)
        |&gt; Enum.filter(fn s -&gt; s.eve_id == signature_eve_id end)
        |&gt; Enum.each(fn s -&gt;
          map_id
          |&gt; WandererApp.Map.Server.update_system_linked_sig_eve_id(%{
            solar_system_id: s.linked_system_id,
            linked_sig_eve_id: nil
          })

          s
          |&gt; WandererApp.Api.MapSystemSignature.update_linked_system(%{
            linked_system_id: nil
          })
        end)

        WandererApp.Map.Server.Impl.broadcast!(map_id, :signatures_updated, solar_system_source)

        {:noreply, socket}

      _ -&gt;
        {:noreply, socket}
    end
  end

  def handle_ui_event(
        &quot;undo_delete_signatures&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id, &quot;eve_ids&quot; =&gt; eve_ids} = payload,
        %{
          assigns: %{
            map_id: map_id,
            main_character_id: main_character_id,
            user_permissions: %{update_system: true}
          }
        } = socket
      )
      when not is_nil(main_character_id) do
    case WandererApp.Api.MapSystem.read_by_map_and_solar_system(%{
           map_id: map_id,
           solar_system_id: get_integer(solar_system_id)
         }) do
      {:ok, system} -&gt;
        restored =
          WandererApp.Api.MapSystemSignature.by_system_id_all!(system.id)
          |&gt; Enum.filter(fn s -&gt; s.eve_id in eve_ids end)
          |&gt; Enum.map(fn s -&gt;
            s |&gt; WandererApp.Api.MapSystemSignature.update!(%{deleted: false})
          end)
        Phoenix.PubSub.broadcast!(WandererApp.PubSub, map_id, %{
          event: :signatures_updated,
          payload: system.solar_system_id
        })
        {:noreply, socket}
      _ -&gt;
        {:noreply, socket}
    end
  end

  def handle_ui_event(event, body, socket),
    do: MapCoreEventHandler.handle_ui_event(event, body, socket)

  def get_system_signatures(system_id),
    do:
      system_id
      |&gt; WandererApp.Api.MapSystemSignature.by_system_id!()
      |&gt; Enum.map(fn %{
                       inserted_at: inserted_at,
                       updated_at: updated_at,
                       linked_system_id: linked_system_id
                     } = s -&gt;
        s
        |&gt; Map.take([
          :eve_id,
          :character_eve_id,
          :name,
          :description,
          :kind,
          :group,
          :type,
          :custom_info
        ])
        |&gt; Map.put(:linked_system, MapEventHandler.get_system_static_info(linked_system_id))
        |&gt; Map.put(:inserted_at, inserted_at |&gt; Calendar.strftime(&quot;%Y/%m/%d %H:%M:%S&quot;))
        |&gt; Map.put(:updated_at, updated_at |&gt; Calendar.strftime(&quot;%Y/%m/%d %H:%M:%S&quot;))
      end)

  defp get_integer(nil), do: nil
  defp get_integer(value) when is_binary(value), do: String.to_integer(value)
  defp get_integer(value), do: value
end</file><file path="lib/wanderer_app_web/live/map/event_handlers/map_structures_event_handler.ex">defmodule WandererAppWeb.MapStructuresEventHandler do
  use WandererAppWeb, :live_component
  use Phoenix.Component
  require Logger

  alias WandererApp.Api.MapSystem
  alias WandererApp.Structure

  alias WandererAppWeb. MapCoreEventHandler

  def handle_server_event(%{event: :structures_updated, payload: _solar_system_id}, socket) do
    socket
  end

  def handle_server_event(event, socket),
    do: MapCoreEventHandler.handle_server_event(event, socket)

  def handle_ui_event(
        &quot;get_structures&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id},
        %{assigns: %{map_id: map_id, map_loaded?: true}} = socket
      ) do
    case MapSystem.read_by_map_and_solar_system(%{
           map_id: map_id,
           solar_system_id: String.to_integer(solar_system_id)
         }) do
      {:ok, system} -&gt;
        {:reply, %{structures: get_system_structures(system.id)}, socket}

      _ -&gt;
        {:reply, %{structures: []}, socket}
    end
  end

  def handle_ui_event(
        &quot;get_structures&quot;,
        _event,
        socket
      ) do
    {:reply, %{structures: []}, socket}
  end

  def handle_ui_event(
        &quot;update_structures&quot;,
        %{
          &quot;system_id&quot; =&gt; solar_system_id,
          &quot;added&quot; =&gt; added_structures,
          &quot;updated&quot; =&gt; updated_structures,
          &quot;removed&quot; =&gt; removed_structures
        },
        %{
          assigns: %{
            map_id: map_id,
            main_character_id: main_character_id,
            main_character_eve_id: main_character_eve_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } = socket
      )
      when not is_nil(main_character_id) do
    with {:ok, system} &lt;- get_map_system(map_id, solar_system_id) do
      Logger.debug(fn -&gt;
        &quot;[handle_ui_event:update_structures] loaded map_system =&gt;\n&quot; &lt;&gt;
          inspect(system, pretty: true)
      end)

      Structure.update_structures(
        system,
        added_structures,
        updated_structures,
        removed_structures,
        main_character_eve_id
      )

      broadcast_structures_updated(system, map_id)

      {:reply, %{structures: get_system_structures(system.id)}, socket}
    else
      _ -&gt;
        {:noreply, socket}
    end
  end

  def handle_ui_event(
        &quot;get_corporation_names&quot;,
        %{&quot;search&quot; =&gt; search},
        %{assigns: %{current_user: current_user}} = socket
      ) do
    user_chars = current_user.characters

    case Structure.search_corporation_names(user_chars, search) do
      {:ok, results} -&gt;
        {:reply, %{results: results}, socket}

      {:error, reason} -&gt;
        Logger.warning(&quot;[MapStructuresEventHandler] corp search failed: #{inspect(reason)}&quot;)
        {:reply, %{results: []}, socket}

      _ -&gt;
        {:reply, %{results: []}, socket}
    end
  end

  def handle_ui_event(&quot;get_corporation_ticker&quot;, %{&quot;corp_id&quot; =&gt; corp_id}, socket) do
    case WandererApp.Esi.get_corporation_info(corp_id) do
      {:ok, %{&quot;ticker&quot; =&gt; ticker}} -&gt;
        {:reply, %{ticker: ticker}, socket}

      _ -&gt;
        {:reply, %{ticker: nil}, socket}
    end
  end

  defp get_map_system(map_id, solar_system_id) do
    case MapSystem.read_by_map_and_solar_system(%{
           map_id: map_id,
           solar_system_id: String.to_integer(solar_system_id)
         }) do
      {:ok, system} -&gt; {:ok, system}
      _ -&gt; :error
    end
  end

  defp broadcast_structures_updated(system, map_id) do
    Phoenix.PubSub.broadcast!(
      WandererApp.PubSub,
      map_id,
      %{event: :structures_updated, payload: system.solar_system_id}
    )
  end

  def get_system_structures(system_id) do
    results =
      WandererApp.Api.MapSystemStructure.by_system_id!(system_id)
      |&gt; Enum.map(fn record -&gt;
        record
        |&gt; Map.take([
          :id,
          :system_id,
          :solar_system_id,
          :solar_system_name,
          :structure_type_id,
          :character_eve_id,
          :name,
          :notes,
          :owner_name,
          :owner_ticker,
          :owner_id,
          :status,
          :end_time,
          :inserted_at,
          :updated_at,
          :structure_type
        ])
        |&gt; Map.update!(:inserted_at, &amp;Calendar.strftime(&amp;1, &quot;%Y/%m/%d %H:%M:%S&quot;))
        |&gt; Map.update!(:updated_at, &amp;Calendar.strftime(&amp;1, &quot;%Y/%m/%d %H:%M:%S&quot;))
      end)

    Logger.debug(fn -&gt;
      &quot;[get_system_structures] =&gt; returning:\n&quot; &lt;&gt; inspect(results, pretty: true)
    end)

    results
  end
end</file><file path="lib/wanderer_app_web/live/map/event_handlers/map_system_comments_event_handler.ex">defmodule WandererAppWeb.MapSystemCommentsEventHandler do
  use WandererAppWeb, :live_component
  use Phoenix.Component
  require Logger

  alias WandererAppWeb.{MapEventHandler, MapCoreEventHandler}

  def handle_server_event(
        %{
          event: :system_comment_added,
          payload: %{solar_system_id: solar_system_id, comment: comment}
        },
        socket
      ),
      do:
        socket
        |&gt; MapEventHandler.push_map_event(&quot;system_comment_added&quot;, %{
          solarSystemId: solar_system_id,
          comment: comment |&gt; map_system_comment()
        })

  def handle_server_event(
        %{
          event: :system_comment_removed,
          payload: %{solar_system_id: solar_system_id, comment_id: comment_id}
        },
        socket
      ),
      do:
        socket
        |&gt; MapEventHandler.push_map_event(&quot;system_comment_removed&quot;, %{
          solarSystemId: solar_system_id,
          commentId: comment_id
        })

  def handle_server_event(event, socket),
    do: MapCoreEventHandler.handle_server_event(event, socket)

  def handle_ui_event(
        &quot;addSystemComment&quot;,
        %{&quot;solarSystemId&quot; =&gt; solar_system_id, &quot;value&quot; =&gt; text} = _event,
        %{
          assigns: %{
            current_user: current_user,
            has_tracked_characters?: true,
            map_id: map_id,
            is_subscription_active?: is_subscription_active?,
            main_character_id: main_character_id,
            user_permissions: %{add_system: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    system =
      WandererApp.Map.find_system_by_location(map_id, %{
        solar_system_id: solar_system_id |&gt; String.to_integer()
      })

    comments_count =
      system.id
      |&gt; WandererApp.Maps.get_system_comments_activity()
      |&gt; case do
        [{count}] when not is_nil(count) -&gt;
          count

        _ -&gt;
          0
      end

    cond do
      (is_subscription_active? &amp;&amp; comments_count &lt; 500) || comments_count &lt; 30 -&gt;
        map_id
        |&gt; WandererApp.Map.Server.add_system_comment(
          %{
            solar_system_id: solar_system_id,
            text: text |&gt; String.slice(0..500)
          },
          current_user.id,
          main_character_id
        )

        {:noreply, socket}

      true -&gt;
        {:noreply,
         socket
         |&gt; Phoenix.LiveView.put_flash(
           :error,
           &quot;Your reach the maximum number of comments available. Please remove some comments before adding new ones.&quot;
         )}
    end
  end

  def handle_ui_event(
        &quot;getSystemComments&quot;,
        %{&quot;solarSystemId&quot; =&gt; solar_system_id} = _event,
        %{
          assigns: %{
            current_user: current_user,
            has_tracked_characters?: true,
            map_id: map_id,
            user_permissions: %{add_system: true}
          }
        } =
          socket
      ) do
    system =
      WandererApp.Map.find_system_by_location(map_id, %{
        solar_system_id: solar_system_id |&gt; String.to_integer()
      })

    {:ok, comments} = WandererApp.MapSystemCommentRepo.get_by_system(system.id)

    comments =
      comments
      |&gt; Enum.map(fn c -&gt; c |&gt; Ash.load!([:character, :system]) end)
      |&gt; Enum.map(&amp;map_system_comment/1)

    {:reply, %{comments: comments}, socket}
  end

  def handle_ui_event(
        &quot;deleteSystemComment&quot;,
        comment_id,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    map_id
    |&gt; WandererApp.Map.Server.remove_system_comment(
      comment_id,
      current_user.id,
      main_character_id
    )

    {:noreply, socket}
  end

  def handle_ui_event(event, body, socket),
    do: MapCoreEventHandler.handle_ui_event(event, body, socket)

  def map_system_comment(nil), do: nil

  def map_system_comment(
        %{
          id: id,
          character: character,
          system: system,
          text: text,
          updated_at: updated_at
        } = _comment
      ) do
    %{
      id: id,
      characterEveId: character.eve_id,
      solarSystemId: system.solar_system_id,
      text: text,
      updated_at: updated_at
    }
  end
end</file><file path="lib/wanderer_app_web/live/map/event_handlers/map_systems_event_handler.ex">defmodule WandererAppWeb.MapSystemsEventHandler do
  use WandererAppWeb, :live_component
  use Phoenix.Component
  require Logger

  alias WandererAppWeb.{MapEventHandler, MapCoreEventHandler}

  def handle_server_event(%{event: :add_system, payload: system}, socket),
    do:
      socket
      |&gt; MapEventHandler.push_map_event(&quot;add_systems&quot;, [
        MapEventHandler.map_ui_system(system)
      ])

  def handle_server_event(%{event: :update_system, payload: system}, socket),
    do:
      socket
      |&gt; MapEventHandler.push_map_event(&quot;update_systems&quot;, [
        MapEventHandler.map_ui_system(system, false)
      ])

  def handle_server_event(%{event: :systems_removed, payload: solar_system_ids}, socket),
    do:
      socket
      |&gt; MapEventHandler.push_map_event(&quot;remove_systems&quot;, solar_system_ids)

  def handle_server_event(
        %{
          event: :maybe_select_system,
          payload: %{
            character_id: character_id,
            solar_system_id: solar_system_id
          }
        },
        %{
          assigns: %{
            current_user: current_user,
            tracked_characters: tracked_characters,
            map_id: map_id,
            map_user_settings: map_user_settings
          }
        } = socket
      ) do
    character =
      tracked_characters
      |&gt; Enum.find(fn tracked_character -&gt; tracked_character.id == character_id end)

    is_user_character =
      not is_nil(character)

    is_select_on_spash =
      map_user_settings
      |&gt; WandererApp.MapUserSettingsRepo.to_form_data!()
      |&gt; WandererApp.MapUserSettingsRepo.get_boolean_setting(&quot;select_on_spash&quot;)

    is_following =
      case WandererApp.MapUserSettingsRepo.get(map_id, current_user.id) do
        {:ok, %{following_character_eve_id: following_character_eve_id}}
        when not is_nil(following_character_eve_id) -&gt;
          is_user_character &amp;&amp; following_character_eve_id == character.eve_id

        _ -&gt;
          false
      end

    must_select? = is_user_character &amp;&amp; (is_select_on_spash || is_following)

    if not must_select? do
      socket
    else
      # Check if we already selected this exact system for this char:
      last_selected =
        WandererApp.Cache.lookup!(
          &quot;char:#{character_id}:map:#{map_id}:last_selected_system_id&quot;,
          nil
        )

      if last_selected == solar_system_id do
        # same system =&gt; skip
        socket
      else
        # new system =&gt; update cache + push event
        WandererApp.Cache.put(
          &quot;char:#{character_id}:map:#{map_id}:last_selected_system_id&quot;,
          solar_system_id
        )

        socket
        |&gt; MapEventHandler.push_map_event(&quot;select_system&quot;, solar_system_id)
      end
    end
  end

  def handle_server_event(event, socket),
    do: MapCoreEventHandler.handle_server_event(event, socket)

  def handle_ui_event(
        &quot;manual_add_system&quot;,
        %{&quot;solar_system_id&quot; =&gt; solar_system_id, &quot;coordinates&quot; =&gt; coordinates} = _event,
        %{
          assigns: %{
            current_user: current_user,
            has_tracked_characters?: true,
            map_id: map_id,
            main_character_id: main_character_id,
            user_permissions: %{add_system: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    WandererApp.Map.Server.add_system(
      map_id,
      %{
        solar_system_id: solar_system_id,
        coordinates: coordinates
      },
      current_user.id,
      main_character_id
    )

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;add_hub&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    map_id
    |&gt; WandererApp.Map.Server.add_hub(%{
      solar_system_id: solar_system_id
    })

    {:ok, _} =
      WandererApp.User.ActivityTracker.track_map_event(:hub_added, %{
        character_id: main_character_id,
        user_id: current_user.id,
        map_id: map_id,
        solar_system_id: solar_system_id
      })

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;delete_hub&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    map_id
    |&gt; WandererApp.Map.Server.remove_hub(%{
      solar_system_id: solar_system_id
    })

    {:ok, _} =
      WandererApp.User.ActivityTracker.track_map_event(:hub_removed, %{
        character_id: main_character_id,
        user_id: current_user.id,
        map_id: map_id,
        solar_system_id: solar_system_id
      })

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;get_user_hubs&quot;,
        _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user
          }
        } =
          socket
      ) do
    {:ok, hubs} = WandererApp.MapUserSettingsRepo.get_hubs(map_id, current_user.id)

    {:reply, %{hubs: hubs}, socket}
  end

  def handle_ui_event(
        &quot;add_user_hub&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user
          }
        } =
          socket
      ) do
    {:ok, map} = map_id |&gt; WandererApp.Map.get_map()
    hubs_limit = map |&gt; Map.get(:hubs_limit, 20)

    {:ok, hubs} = WandererApp.MapUserSettingsRepo.get_hubs(map_id, current_user.id)

    if hubs |&gt; Enum.count() &lt; hubs_limit do
      hubs = hubs ++ [&quot;#{solar_system_id}&quot;]

      {:ok, _} =
        WandererApp.MapUserSettingsRepo.update_hubs(
          map_id,
          current_user.id,
          hubs
        )

      {:noreply, socket |&gt; MapEventHandler.push_map_event(
        &quot;map_updated&quot;,
        %{user_hubs: hubs}
      )}
    else

      {:noreply, socket |&gt; MapEventHandler.push_map_event(
        &quot;map_updated&quot;,
        %{user_hubs: hubs}
      )}
    end
  end

  def handle_ui_event(
        &quot;delete_user_hub&quot;,
        %{&quot;system_id&quot; =&gt; solar_system_id} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user
          }
        } =
          socket
      ) do
    {:ok, hubs} = WandererApp.MapUserSettingsRepo.get_hubs(map_id, current_user.id)

    case hubs |&gt; Enum.member?(&quot;#{solar_system_id}&quot;) do
      true -&gt;
        hubs = hubs |&gt; Enum.reject(fn hub -&gt; hub == &quot;#{solar_system_id}&quot; end)

        {:ok, _} =
          WandererApp.MapUserSettingsRepo.update_hubs(
            map_id,
            current_user.id,
            hubs
          )

        {:noreply, socket |&gt; MapEventHandler.push_map_event(
          &quot;map_updated&quot;,
          %{user_hubs: hubs}
        )}
      _ -&gt;
        {:noreply, socket |&gt; MapEventHandler.push_map_event(
          &quot;map_updated&quot;,
          %{user_hubs: hubs}
        )}
    end
  end

  def handle_ui_event(
        &quot;update_system_position&quot;,
        position,
        %{
          assigns: %{
            map_id: map_id,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } = socket
      )
      when not is_nil(main_character_id) do
    map_id
    |&gt; update_system_position(position)

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;update_system_positions&quot;,
        positions,
        %{
          assigns: %{
            map_id: map_id,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true}
          }
        } = socket
      )
      when not is_nil(main_character_id) do
    map_id
    |&gt; update_system_positions(positions)

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;update_system_&quot; &lt;&gt; param,
        %{&quot;system_id&quot; =&gt; solar_system_id, &quot;value&quot; =&gt; value} = _event,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{update_system: true} = user_permissions
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    method_atom =
      case param do
        &quot;name&quot; -&gt; :update_system_name
        &quot;description&quot; -&gt; :update_system_description
        &quot;labels&quot; -&gt; :update_system_labels
        &quot;locked&quot; -&gt; :update_system_locked
        &quot;tag&quot; -&gt; :update_system_tag
        &quot;temporary_name&quot; -&gt; :update_system_temporary_name
        &quot;status&quot; -&gt; :update_system_status
        _ -&gt; nil
      end

    key_atom =
      case param do
        &quot;name&quot; -&gt; :name
        &quot;description&quot; -&gt; :description
        &quot;labels&quot; -&gt; :labels
        &quot;locked&quot; -&gt; :locked
        &quot;tag&quot; -&gt; :tag
        &quot;temporary_name&quot; -&gt; :temporary_name
        &quot;status&quot; -&gt; :status
        _ -&gt; :none
      end

    if can_update_system?(key_atom, user_permissions) do
      apply(WandererApp.Map.Server, method_atom, [
        map_id,
        %{
          solar_system_id: &quot;#{solar_system_id}&quot; |&gt; String.to_integer()
        }
        |&gt; Map.put_new(key_atom, value)
      ])

      {:ok, _} =
        WandererApp.User.ActivityTracker.track_map_event(:system_updated, %{
          character_id: main_character_id,
          user_id: current_user.id,
          map_id: map_id,
          solar_system_id: &quot;#{solar_system_id}&quot; |&gt; String.to_integer(),
          key: key_atom,
          value: value
        })
    end

    {:noreply, socket}
  end

  def handle_ui_event(
        &quot;get_system_static_infos&quot;,
        %{&quot;solar_system_ids&quot; =&gt; solar_system_ids} = _event,
        socket
      ) do
    system_static_infos =
      solar_system_ids
      |&gt; Enum.map(&amp;WandererApp.CachedInfo.get_system_static_info!/1)
      |&gt; Enum.map(&amp;MapEventHandler.map_ui_system_static_info/1)

    {:reply, %{system_static_infos: system_static_infos}, socket}
  end

  def handle_ui_event(
        &quot;search_systems&quot;,
        %{&quot;text&quot; =&gt; text} = _event,
        socket
      ) do
    systems =
      WandererApp.Api.MapSolarSystem.find_by_name!(%{name: text})
      |&gt; Enum.take(100)
      |&gt; Enum.map(&amp;map_system/1)
      |&gt; Enum.filter(fn system -&gt;
        not is_nil(system) &amp;&amp; not is_nil(system.system_static_info) &amp;&amp;
          not WandererApp.Map.Server.ConnectionsImpl.is_prohibited_system_class?(
            system.system_static_info.system_class
          )
      end)

    {:reply, %{systems: systems}, socket}
  end

  def handle_ui_event(
        &quot;delete_systems&quot;,
        solar_system_ids,
        %{
          assigns: %{
            map_id: map_id,
            current_user: current_user,
            main_character_id: main_character_id,
            has_tracked_characters?: true,
            user_permissions: %{delete_system: true}
          }
        } =
          socket
      )
      when not is_nil(main_character_id) do
    map_id
    |&gt; WandererApp.Map.Server.delete_systems(
      solar_system_ids |&gt; Enum.map(&amp;String.to_integer/1),
      current_user.id,
      main_character_id
    )

    {:noreply, socket}
  end

  def handle_ui_event(event, body, socket),
    do: MapCoreEventHandler.handle_ui_event(event, body, socket)

  def map_system(
        %{
          solar_system_name: solar_system_name,
          constellation_name: constellation_name,
          region_name: region_name,
          solar_system_id: solar_system_id,
          class_title: class_title
        } = _system
      ) do
    system_static_info = MapEventHandler.get_system_static_info(solar_system_id)

    %{
      label: solar_system_name,
      value: solar_system_id,
      constellation_name: constellation_name,
      region_name: region_name,
      class_title: class_title,
      system_static_info: system_static_info
    }
  end

  defp can_update_system?(:locked, %{lock_system: false} = _user_permissions), do: false
  defp can_update_system?(_key, _user_permissions), do: true

  defp update_system_positions(_map_id, []), do: :ok

  defp update_system_positions(map_id, [position | rest]) do
    update_system_position(map_id, position)
    update_system_positions(map_id, rest)
  end

  defp update_system_position(map_id, %{
         &quot;position&quot; =&gt; %{&quot;x&quot; =&gt; x, &quot;y&quot; =&gt; y},
         &quot;solar_system_id&quot; =&gt; solar_system_id
       }),
       do:
         map_id
         |&gt; WandererApp.Map.Server.update_system_position(%{
           solar_system_id: solar_system_id |&gt; String.to_integer(),
           position_x: x,
           position_y: y
         })
end</file><file path="lib/wanderer_app_web/live/map/map_audit_live.ex">defmodule WandererAppWeb.MapAuditLive do
  use WandererAppWeb, :live_view

  require Logger

  alias WandererAppWeb.UserActivity

  @active_subscription_periods [&quot;2M&quot;, &quot;3M&quot;]

  def mount(
        %{&quot;slug&quot; =&gt; map_slug, &quot;period&quot; =&gt; period, &quot;activity&quot; =&gt; activity} = _params,
        _session,
        %{assigns: %{current_user: current_user}} = socket
      ) do
    WandererApp.Maps.check_user_can_delete_map(map_slug, current_user)
    |&gt; case do
      {:ok,
       %{
         id: map_id,
         name: map_name
       } = _map} -&gt;
        {:ok, is_subscription_active} = map_id |&gt; WandererApp.Map.is_subscription_active?()

        {:ok,
         socket
         |&gt; assign(
           map_id: map_id,
           map_name: map_name,
           map_slug: map_slug,
           map_subscription_active: is_subscription_active,
           activity: activity,
           can_undo_types: [:systems_removed],
           period: period || &quot;1H&quot;,
           page: 1,
           per_page: 25,
           end_of_stream?: false
         )
         |&gt; stream(:activity, [])}

      _ -&gt;
        {:ok,
         socket
         |&gt; put_flash(:error, &quot;You don&apos;t have an access.&quot;)
         |&gt; push_navigate(to: ~p&quot;/maps&quot;)}
    end
  end

  @impl true
  def mount(_params, _session, socket) do
    {:ok, socket |&gt; assign(user_id: nil)}
  end

  @impl true
  def handle_params(params, _url, socket) do
    apply_action(socket, socket.assigns.live_action, params)
  end

  @impl true
  def handle_info(
        _event,
        socket
      ) do
    {:noreply, socket}
  end

  @impl true
  def handle_event(
        &quot;set_period&quot;,
        %{&quot;period&quot; =&gt; period},
        %{assigns: %{map_slug: map_slug, activity: activity}} = socket
      ) do
    {:noreply,
     socket
     |&gt; push_navigate(to: ~p&quot;/#{map_slug}/audit?period=#{period}&amp;activity=#{activity}&quot;)}
  end

  def handle_event(&quot;update_filters&quot;, %{&quot;activity&quot; =&gt; activity}, socket) do
    %{period: period, map_slug: map_slug} =
      socket.assigns

    {:noreply,
     socket
     |&gt; push_navigate(to: ~p&quot;/#{map_slug}/audit?period=#{period}&amp;activity=#{activity}&quot;)}
  end

  def handle_event(
        &quot;undo&quot;,
        %{&quot;event-data&quot; =&gt; event_data, &quot;event-type&quot; =&gt; &quot;systems_removed&quot;},
        %{assigns: %{map_id: map_id, current_user: current_user}} = socket
      ) do
    {:ok, %{&quot;solar_system_ids&quot; =&gt; solar_system_ids}} = Jason.decode(event_data)

    solar_system_ids
    |&gt; Enum.each(fn solar_system_id -&gt;
      WandererApp.Map.Server.add_system(
        map_id,
        %{
          solar_system_id: solar_system_id,
          coordinates: nil,
          use_old_coordinates: true
        },
        current_user.id,
        nil
      )
    end)

    {:noreply, socket |&gt; put_flash(:info, &quot;Systems restored!&quot;)}
  end

  @impl true
  def handle_event(&quot;noop&quot;, _, socket) do
    {:noreply, socket}
  end

  @impl true
  def handle_event(event, body, socket) do
    Logger.warning(fn -&gt; &quot;unhandled event: #{event} #{inspect(body)}&quot; end)
    {:noreply, socket}
  end

  defp apply_action(socket, :index, params) do
    socket
    |&gt; assign(:active_page, :audit)
    |&gt; assign(:page_title, &quot;Map - Audit&quot;)
    |&gt; assign(:form, to_form(%{&quot;activity&quot; =&gt; socket.assigns.activity}))
    |&gt; assign(:activities, [
      {&quot;All Events&quot;, :all},
      {&quot;System Added&quot;, :system_added},
      {&quot;System Updated&quot;, :system_updated},
      {&quot;System(s) Removed&quot;, :systems_removed},
      {&quot;Hub Added&quot;, :hub_added},
      {&quot;Hub Removed&quot;, :hub_removed},
      {&quot;ACL Added&quot;, :map_acl_added},
      {&quot;ACL Removed&quot;, :map_acl_removed},
      {&quot;Connection Added&quot;, :map_connection_added},
      {&quot;Connection Updated&quot;, :map_connection_updated},
      {&quot;Connection Removed&quot;, :map_connection_removed},
      {&quot;Signatures Added&quot;, :signatures_added},
      {&quot;Signatures Removed&quot;, :signatures_removed}
    ])
    |&gt; list_activity(params)
  end

  defp list_activity(socket, params, opts \\ []) do
    %{
      activity: activity,
      map_id: map_id,
      map_slug: map_slug,
      map_subscription_active: map_subscription_active,
      period: period
    } =
      socket.assigns

    query = WandererApp.Map.Audit.get_activity_query(map_id, period, activity)

    AshPagify.validate_and_run(query, params, opts)
    |&gt; case do
      {:ok, {activity, meta}} -&gt;
        {:noreply, socket |&gt; assign(:meta, meta) |&gt; stream(:activity, activity, reset: true)}

      {:error, meta} -&gt;
        valid_path = AshPagify.Components.build_path(~p&quot;/#{map_slug}/audit&quot;, meta.params)
        {:noreply, socket |&gt; push_navigate(to: valid_path)}
    end
  end

  defp get_valid_period(period, true), do: period

  defp get_valid_period(period, _map_subscription_active) do
    if period in @active_subscription_periods do
      &quot;1H&quot;
    else
      period
    end
  end
end</file><file path="lib/wanderer_app_web/live/map/map_audit_live.html.heex">&lt;nav class=&quot;fixed top-0 z-100 px-6 pl-20 flex items-center justify-between w-full h-12 pointer-events-auto border-b border-stone-800  bg-opacity-70 bg-neutral-900&quot;&gt;
  &lt;span className=&quot;w-full font-medium text-sm&quot;&gt;
    &lt;.link navigate={~p&quot;/#{@map_slug}&quot;} class=&quot;text-neutral-100&quot;&gt;
      &lt;%= @map_name %&gt;
    &lt;/.link&gt;
    - Audit
  &lt;/span&gt;
  &lt;span className=&quot;mr-2&quot;&gt;&lt;/span&gt;
  &lt;div class=&quot;flex gap-2&quot;&gt;
    &lt;.form :let={f} for={@form} phx-change=&quot;update_filters&quot; autocomplete=&quot;off&quot;&gt;
      &lt;.input
        type=&quot;select&quot;
        field={f[:activity]}
        class=&quot;p-dropdown p-component p-inputwrapper !h-8 py-0 w-full&quot;
        placeholder=&quot;Select an activity&quot;
        options={Enum.map(@activities, fn activity -&gt; activity end)}
      /&gt;
    &lt;/.form&gt;
    &lt;div class=&quot;flex space-x-4 font-inter text-slate-700 text-navy-100&quot;&gt;
      &lt;div class=&quot;join w-full justify-between font-inter text-navy-100 sm:flex &quot;&gt;
        &lt;button
          phx-click=&quot;set_period&quot;
          phx-value-period=&quot;1H&quot;
          class={[
            &quot;btn btn-sm join-item font-sm text-neutral bg-neutral-700&quot;,
            classes(&quot; !bg-neutral-800  !text-white&quot;: @period == &quot;1H&quot;)
          ]}
        &gt;
          HOUR
        &lt;/button&gt;
        &lt;button
          phx-click=&quot;set_period&quot;
          phx-value-period=&quot;1D&quot;
          class={[
            &quot;btn btn-sm join-item font-medium text-neutral bg-neutral-700&quot;,
            classes(&quot; !bg-neutral-800  !text-white&quot;: @period == &quot;1D&quot;)
          ]}
        &gt;
          DAY
        &lt;/button&gt;
        &lt;button
          phx-click=&quot;set_period&quot;
          phx-value-period=&quot;1W&quot;
          class={[
            &quot;btn btn-sm join-item font-medium text-neutral bg-neutral-700&quot;,
            classes(&quot; !bg-neutral-800  !text-white&quot;: @period == &quot;1W&quot;)
          ]}
        &gt;
          WEEK
        &lt;/button&gt;
        &lt;button
          :if={@map_subscription_active}
          phx-click=&quot;set_period&quot;
          phx-value-period=&quot;1M&quot;
          class={[
            &quot;btn btn-sm join-item font-medium text-neutral bg-neutral-700&quot;,
            classes(&quot; !bg-neutral-800  !text-white&quot;: @period == &quot;1M&quot;)
          ]}
        &gt;
          1M
        &lt;/button&gt;
        &lt;button
          :if={@map_subscription_active}
          phx-click=&quot;set_period&quot;
          phx-value-period=&quot;2M&quot;
          class={[
            &quot;btn btn-sm join-item font-medium text-neutral bg-neutral-700&quot;,
            classes(&quot; !bg-neutral-800  !text-white&quot;: @period == &quot;2M&quot;)
          ]}
        &gt;
          2M
        &lt;/button&gt;
        &lt;button
          :if={@map_subscription_active}
          phx-click=&quot;set_period&quot;
          phx-value-period=&quot;3M&quot;
          class={[
            &quot;btn btn-sm join-item font-medium text-neutral bg-neutral-700&quot;,
            classes(&quot; !bg-neutral-800  !text-white&quot;: @period == &quot;3M&quot;)
          ]}
        &gt;
          3M
        &lt;/button&gt;
        &lt;%!--
        &lt;button
          phx-click=&quot;set_period&quot;
          phx-value-period=&quot;ALL&quot;
          class={[
            &quot;btn btn-sm join-item font-medium text-neutral bg-neutral-700&quot;,
            classes(&quot; !bg-neutral-800  !text-white&quot;: @period == &quot;ALL&quot;)
          ]}
        &gt;
          ALL
        &lt;/button&gt;--%&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/nav&gt;
&lt;main
  id=&quot;map-events-list&quot;
  class=&quot;pt-20 w-full h-full col-span-2 lg:col-span-1 p-4 pl-20 pb-20 overflow-auto&quot;
&gt;
  &lt;div class=&quot;flex flex-col gap-4 w-full&quot;&gt;
    &lt;div class=&quot;flex justify-between w-full&quot;&gt;
      &lt;div /&gt;
      &lt;AshPagify.Components.pagination meta={@meta} path={~p&quot;/#{@map_slug}/audit?period=#{@period}&amp;activity=#{@activity}&quot;} /&gt;
    &lt;/div&gt;
    &lt;.live_component
      module={UserActivity}
      id=&quot;user-activity&quot;
      notify_to={self()}
      can_undo_types={@can_undo_types}
      stream={@streams.activity}
      page={@page}
      end_of_stream?={@end_of_stream?}
      event_name=&quot;activity_event&quot;
    /&gt;

    &lt;div class=&quot;flex justify-between w-full&quot;&gt;
      &lt;div /&gt;
      &lt;AshPagify.Components.pagination meta={@meta} path={~p&quot;/#{@map_slug}/audit?period=#{@period}&amp;activity=#{@activity}&quot;} /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/main&gt;</file><file path="lib/wanderer_app_web/live/map/map_characters_live.ex">defmodule WandererAppWeb.MapCharactersLive do
  use WandererAppWeb, :live_view

  require Logger

  alias WandererAppWeb.MapCharacters

  @refresh_interval :timer.seconds(30)

  def mount(
        %{&quot;slug&quot; =&gt; map_slug} = _params,
        _session,
        %{assigns: %{current_user: current_user}} = socket
      ) do
    WandererApp.Maps.check_user_can_delete_map(map_slug, current_user)
    |&gt; case do
      {:ok,
       %{
         id: map_id,
         name: map_name
       } = _map} -&gt;
        {:ok,
         socket
         |&gt; assign(
           map_id: map_id,
           map_name: map_name,
           map_slug: map_slug
         )
         |&gt; assign(:groups, [])}

      _ -&gt;
        {:ok,
         socket
         |&gt; put_flash(:error, &quot;You don&apos;t have an access.&quot;)
         |&gt; push_navigate(to: ~p&quot;/maps&quot;)}
    end
  end

  @impl true
  def mount(_params, _session, socket) do
    {:ok, socket |&gt; assign(user_id: nil)}
  end

  @impl true
  def handle_params(params, _url, socket) do
    {:noreply, apply_action(socket, socket.assigns.live_action, params)}
  end

  @impl true
  def handle_info(
        :refresh_tracking_data,
        socket
      ) do
    Process.send_after(self(), :refresh_tracking_data, @refresh_interval)
    {:noreply, socket |&gt; load_characters()}
  end

  @impl true
  def handle_info(
        _event,
        socket
      ) do
    {:noreply, socket}
  end

  def handle_event(
        &quot;untrack&quot;,
        %{&quot;event-data&quot; =&gt; character_id},
        %{
          assigns: %{
            map_id: map_id,
            current_user: _current_user,
            character_settings: character_settings
          }
        } = socket
      ) do
    socket =
      character_settings
      |&gt; Enum.find(&amp;(&amp;1.character_id == character_id))
      |&gt; case do
        nil -&gt;
          socket

        character_setting -&gt;
          case character_setting.tracked do
            true -&gt;
              WandererApp.Map.Server.untrack_characters(map_id, [character_setting.character_id])

              socket |&gt; put_flash(:info, &quot;Character untracked!&quot;) |&gt; load_characters()

            _ -&gt;
              socket
          end
      end

    {:noreply, socket}
  end

  @impl true
  def handle_event(&quot;noop&quot;, _, socket) do
    {:noreply, socket}
  end

  @impl true
  def handle_event(event, body, socket) do
    Logger.warning(fn -&gt; &quot;unhandled event: #{event} #{inspect(body)}&quot; end)
    {:noreply, socket}
  end

  defp apply_action(socket, :index, _params) do
    Process.send_after(self(), :refresh_tracking_data, @refresh_interval)

    socket
    |&gt; assign(:active_page, :map_characters)
    |&gt; assign(:page_title, &quot;Map - Characters&quot;)
    |&gt; load_characters()
  end

  defp get_all_characters(map_id) do
    {:ok, present_characters} =
      WandererApp.Cache.lookup(
        &quot;map_#{map_id}:presence_data&quot;,
        []
      )

    present_characters =
      present_characters
      |&gt; Enum.map(fn character -&gt;
        character |&gt; Map.merge(WandererApp.Character.get_character!(character.character_id))
      end)

    present_characters
  end

  defp load_characters(%{assigns: %{map_id: map_id}} = socket) do
    map_characters =
      map_id
      |&gt; get_all_characters()
      |&gt; Enum.map(fn character -&gt; map_ui_character(map_id, character) end)

    groups =
      map_characters
      |&gt; Enum.group_by(&amp; &amp;1.user_id)
      |&gt; Enum.reduce([], fn {user_id, values}, acc -&gt;
        acc ++ [%{id: user_id, characters: values}]
      end)

    {:ok, character_settings} =
      case WandererApp.MapCharacterSettingsRepo.get_all_by_map(map_id) do
        {:ok, settings} -&gt; {:ok, settings}
        _ -&gt; {:ok, []}
      end

    socket
    |&gt; assign(:character_settings, character_settings)
    |&gt; assign(:characters_count, map_characters |&gt; length())
    |&gt; assign(:groups, groups)
  end

  defp map_ui_character(map_id, character) do
    character
    |&gt; Map.take([
      :id,
      :user_id,
      :eve_id,
      :name,
      :online,
      :corporation_id,
      :corporation_name,
      :corporation_ticker,
      :alliance_id,
      :alliance_name,
      :alliance_ticker,
      :from,
      :tracked
    ])
  end
end</file><file path="lib/wanderer_app_web/live/map/map_characters_live.html.heex">&lt;nav class=&quot;fixed top-0 z-100 px-6 pl-20 flex items-center justify-between w-full h-12 pointer-events-auto border-b border-stone-800  bg-opacity-70 bg-neutral-900&quot;&gt;
  &lt;span className=&quot;w-full font-medium text-sm&quot;&gt;
    &lt;.link navigate={~p&quot;/#{@map_slug}&quot;} class=&quot;text-neutral-100&quot;&gt;
      &lt;%= @map_name %&gt;
    &lt;/.link&gt;
    - Active Characters [&lt;%= @characters_count %&gt;]
  &lt;/span&gt;
&lt;/nav&gt;
&lt;main
  id=&quot;map-character-list&quot;
  class=&quot;pt-20 w-full h-full col-span-2 lg:col-span-1 p-4 pl-20 pb-20 overflow-auto&quot;
&gt;

&lt;div class=&quot;mb-6 p-4 border rounded-md flex gap-2 items-center&quot;&gt;
  &lt;.icon name=&quot;hero-information-circle-mini&quot; class=&quot;h-5 w-5&quot; /&gt;
  &lt;p&gt;
  &apos;Untrack&apos; characters leading to completely remove them from the map, required manually enable the tracking by users later.
  &lt;/p&gt;
&lt;/div&gt;

  &lt;div class=&quot;flex flex-col gap-4 w-full&quot;&gt;
    &lt;.live_component
      module={MapCharacters}
      id=&quot;map-characters&quot;
      notify_to={self()}
      groups={@groups}
      event_name=&quot;character_event&quot;
    /&gt;
  &lt;/div&gt;
&lt;/main&gt;</file><file path="lib/wanderer_app_web/live/map/map_event_handler.ex">defmodule WandererAppWeb.MapEventHandler do
  use WandererAppWeb, :live_component
  use Phoenix.Component
  require Logger

  alias WandererAppWeb.{
    MapActivityEventHandler,
    MapCharactersEventHandler,
    MapConnectionsEventHandler,
    MapCoreEventHandler,
    MapRoutesEventHandler,
    MapSignaturesEventHandler,
    MapSystemsEventHandler,
    MapSystemCommentsEventHandler,
    MapStructuresEventHandler,
    MapKillsEventHandler
  }

  @map_characters_events [
    :character_added,
    :character_removed,
    :character_updated,
    :characters_updated,
    :present_characters_updated,
    :refresh_user_characters,
    :show_tracking,
    :untrack_character
  ]

  @map_characters_ui_events [
    &quot;getCharacterInfo&quot;,
    &quot;getCharactersTrackingInfo&quot;,
    &quot;updateCharacterTracking&quot;,
    &quot;updateFollowingCharacter&quot;,
    &quot;updateMainCharacter&quot;
  ]

  @map_system_events [
    :add_system,
    :update_system,
    :systems_removed,
    :maybe_select_system
  ]

  @map_system_ui_events [
    &quot;delete_systems&quot;,
    &quot;get_system_static_infos&quot;,
    &quot;manual_add_system&quot;,
    &quot;search_systems&quot;,
    &quot;update_system_position&quot;,
    &quot;update_system_positions&quot;,
    &quot;update_system_name&quot;,
    &quot;update_system_description&quot;,
    &quot;update_system_labels&quot;,
    &quot;update_system_locked&quot;,
    &quot;update_system_tag&quot;,
    &quot;update_system_temporary_name&quot;,
    &quot;update_system_status&quot;
  ]

  @map_system_comments_events [
    :system_comment_added,
    :system_comment_removed
  ]

  @map_system_comments_ui_events [
    &quot;addSystemComment&quot;,
    &quot;getSystemComments&quot;,
    &quot;deleteSystemComment&quot;
  ]

  @map_connection_events [
    :add_connection,
    :remove_connections,
    :update_connection
  ]

  @map_connection_ui_events [
    &quot;manual_add_connection&quot;,
    &quot;manual_delete_connection&quot;,
    &quot;get_connection_info&quot;,
    &quot;get_passages&quot;,
    &quot;update_connection_time_status&quot;,
    &quot;update_connection_type&quot;,
    &quot;update_connection_mass_status&quot;,
    &quot;update_connection_ship_size_type&quot;,
    &quot;update_connection_locked&quot;,
    &quot;update_connection_custom_info&quot;
  ]

  @map_activity_events [
    :character_activity_data
  ]

  @map_activity_ui_events [
    &quot;show_activity&quot;
  ]

  @map_routes_events [
    :routes,
    :user_routes
  ]

  @map_routes_ui_events [
    &quot;get_routes&quot;,
    &quot;get_user_routes&quot;,
    &quot;set_autopilot_waypoint&quot;,
    &quot;add_hub&quot;,
    &quot;delete_hub&quot;,
    &quot;get_user_hubs&quot;,
    &quot;add_user_hub&quot;,
    &quot;delete_user_hub&quot;
  ]

  @map_signatures_events [
    :maybe_link_signature,
    :signatures_updated
  ]

  @map_signatures_ui_events [
    &quot;load_signatures&quot;,
    &quot;update_signatures&quot;,
    &quot;get_signatures&quot;,
    &quot;link_signature_to_system&quot;,
    &quot;unlink_signature&quot;,
    &quot;undo_delete_signatures&quot;
  ]

  @map_structures_events [
    :structures_updated
  ]

  @map_structures_ui_events [
    &quot;update_structures&quot;,
    &quot;get_structures&quot;,
    &quot;get_corporation_names&quot;,
    &quot;get_corporation_ticker&quot;
  ]

  @map_kills_events [
    :init_kills,
    :kills_updated,
    :detailed_kills_updated
  ]

  @map_kills_ui_events [
    &quot;get_system_kills&quot;,
    &quot;get_systems_kills&quot;
  ]

  def handle_event(socket, %{event: event_name} = event)
      when event_name in @map_characters_events,
      do: MapCharactersEventHandler.handle_server_event(event, socket)

  def handle_event(socket, %{event: event_name} = event)
      when event_name in @map_system_events,
      do: MapSystemsEventHandler.handle_server_event(event, socket)

  def handle_event(socket, %{event: event_name} = event)
      when event_name in @map_system_comments_events,
      do: MapSystemCommentsEventHandler.handle_server_event(event, socket)

  def handle_event(socket, %{event: event_name} = event)
      when event_name in @map_connection_events,
      do: MapConnectionsEventHandler.handle_server_event(event, socket)

  def handle_event(socket, %{event: event_name} = event)
      when event_name in @map_activity_events,
      do: MapActivityEventHandler.handle_server_event(event, socket)

  def handle_event(socket, %{event: event_name} = event)
      when event_name in @map_routes_events,
      do: MapRoutesEventHandler.handle_server_event(event, socket)

  def handle_event(socket, %{event: event_name} = event)
      when event_name in @map_structures_events,
      do: MapStructuresEventHandler.handle_server_event(event, socket)

  def handle_event(socket, %{event: event_name} = event)
      when event_name in @map_signatures_events,
      do: MapSignaturesEventHandler.handle_server_event(event, socket)

  def handle_event(socket, %{event: event_name} = event)
      when event_name in @map_kills_events,
      do: MapKillsEventHandler.handle_server_event(event, socket)

  def handle_event(socket, {ref, result}) when is_reference(ref) do
    Process.demonitor(ref, [:flush])

    case result do
      {:map_error, map_error} -&gt;
        Process.send_after(self(), map_error, 100)
        socket

      {event, payload} -&gt;
        Process.send_after(
          self(),
          %{event: event, payload: payload},
          10
        )

        socket

      _ -&gt;
        Logger.warning(&quot;Unhandled task result: #{inspect(result)}&quot;)
        socket
    end
  end

  def handle_event(socket, {:DOWN, ref, :process, _pid, reason}) when is_reference(ref) do
    # Task failed, log the error and update the client
    Logger.error(&quot;Task failed: #{inspect(reason)}&quot;)
  end

  def handle_event(socket, event),
    do: MapCoreEventHandler.handle_server_event(event, socket)

  def handle_ui_event(event, body, socket)
      when event in @map_characters_ui_events,
      do: MapCharactersEventHandler.handle_ui_event(event, body, socket)

  def handle_ui_event(event, body, socket)
      when event in @map_system_ui_events,
      do: MapSystemsEventHandler.handle_ui_event(event, body, socket)

  def handle_ui_event(event, body, socket)
      when event in @map_system_comments_ui_events,
      do: MapSystemCommentsEventHandler.handle_ui_event(event, body, socket)

  def handle_ui_event(event, body, socket)
      when event in @map_connection_ui_events,
      do: MapConnectionsEventHandler.handle_ui_event(event, body, socket)

  def handle_ui_event(event, body, socket)
      when event in @map_routes_ui_events,
      do: MapRoutesEventHandler.handle_ui_event(event, body, socket)

  def handle_ui_event(event, body, socket)
      when event in @map_signatures_ui_events,
      do: MapSignaturesEventHandler.handle_ui_event(event, body, socket)

  def handle_ui_event(event, body, socket)
      when event in @map_structures_ui_events,
      do: MapStructuresEventHandler.handle_ui_event(event, body, socket)

  def handle_ui_event(event, body, socket)
      when event in @map_activity_ui_events,
      do: MapActivityEventHandler.handle_ui_event(event, body, socket)

  def handle_ui_event(
        event,
        body,
        %{
          assigns: %{
            is_subscription_active?: true
          }
        } = socket
      )
      when event in @map_kills_ui_events,
      do: MapKillsEventHandler.handle_ui_event(event, body, socket)

  def handle_ui_event(event, body, socket),
    do: MapCoreEventHandler.handle_ui_event(event, body, socket)

  def get_system_static_info(nil), do: nil

  def get_system_static_info(solar_system_id) do
    case WandererApp.CachedInfo.get_system_static_info(solar_system_id) do
      {:ok, system_static_info} -&gt;
        map_ui_system_static_info(system_static_info)

      _ -&gt;
        %{}
    end
  end

  def push_map_event(
        %{
          assigns: %{
            is_version_valid?: true
          }
        } = socket,
        type,
        body
      ) do
    socket
    |&gt; Phoenix.LiveView.Utils.push_event(&quot;map_event&quot;, %{
      type: type,
      body: body,
      timestamp: DateTime.utc_now()
    })
  end

  def push_map_event(socket, _type, _body), do: socket

  def map_ui_character_stat(nil), do: nil

  def map_ui_character_stat(character),
    do:
      character
      |&gt; Map.take([
        :eve_id,
        :name,
        :corporation_id,
        :corporation_ticker,
        :alliance_id,
        :alliance_ticker
      ])

  def map_ui_connection(
        %{
          solar_system_source: solar_system_source,
          solar_system_target: solar_system_target,
          mass_status: mass_status,
          time_status: time_status,
          type: type,
          ship_size_type: ship_size_type,
          locked: locked
        } = _connection
      ),
      do: %{
        id: &quot;#{solar_system_source}_#{solar_system_target}&quot;,
        mass_status: mass_status,
        time_status: time_status,
        type: type,
        ship_size_type: ship_size_type,
        locked: locked,
        source: &quot;#{solar_system_source}&quot;,
        target: &quot;#{solar_system_target}&quot;
      }

  def map_ui_system(
        %{
          id: system_id,
          solar_system_id: solar_system_id,
          name: name,
          description: description,
          position_x: position_x,
          position_y: position_y,
          locked: locked,
          tag: tag,
          labels: labels,
          linked_sig_eve_id: linked_sig_eve_id,
          temporary_name: temporary_name,
          status: status,
          visible: visible
        } = _system,
        include_static_data? \\ true
      ) do
    comments_count =
      system_id
      |&gt; WandererApp.Maps.get_system_comments_activity()
      |&gt; case do
        [{count}] when not is_nil(count) -&gt;
          count

        _ -&gt;
          0
      end

    system_info =
      %{
        id: &quot;#{solar_system_id}&quot;,
        position: %{x: position_x, y: position_y},
        description: description,
        name: name,
        labels: labels,
        locked: locked,
        linked_sig_eve_id: linked_sig_eve_id,
        status: status,
        tag: tag,
        temporary_name: temporary_name,
        comments_count: comments_count,
        visible: visible
      }

    system_info =
      if include_static_data? do
        system_info |&gt; Map.merge(%{system_static_info: get_system_static_info(solar_system_id)})
      else
        system_info
      end

    system_info
  end

  def map_ui_system_static_info(nil), do: %{}

  def map_ui_system_static_info(system_static_info),
    do:
      system_static_info
      |&gt; Map.take([
        :region_id,
        :constellation_id,
        :solar_system_id,
        :solar_system_name,
        :solar_system_name_lc,
        :constellation_name,
        :region_name,
        :system_class,
        :security,
        :type_description,
        :class_title,
        :is_shattered,
        :effect_name,
        :effect_power,
        :statics,
        :wandering,
        :triglavian_invasion_status,
        :sun_type_id
      ])
end</file><file path="lib/wanderer_app_web/live/map/map_live.ex">defmodule WandererAppWeb.MapLive do
  use WandererAppWeb, :live_view
  use LiveViewEvents

  require Logger

  @server_event_unsync_timeout :timer.minutes(2)

  @impl true
  def mount(%{&quot;slug&quot; =&gt; map_slug} = _params, _session, socket) when is_connected?(socket) do
    Process.send_after(self(), %{event: :load_map}, Enum.random(10..800))

    {:ok,
     socket
     |&gt; assign(
       map_slug: map_slug,
       map_loaded?: false,
       server_online: false,
       selected_subscription: nil,
       user_permissions: nil
     )
     |&gt; push_event(&quot;js-exec&quot;, %{
       to: &quot;#map-loader&quot;,
       attr: &quot;data-loading&quot;,
       timeout: 2000
     })}
  end

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |&gt; assign(
       map_slug: nil,
       map_loaded?: false,
       server_online: false,
       selected_subscription: nil,
       user_permissions: nil
     )}
  end

  @impl true
  def handle_params(params, _url, socket),
    do: {:noreply, apply_action(socket, socket.assigns.live_action, params)}

  @impl true
  def handle_info(
        {&quot;change_map&quot;, map_slug},
        %{assigns: %{map_id: map_id}} = socket
      ) do
    Phoenix.PubSub.unsubscribe(WandererApp.PubSub, map_id)
    {:noreply, socket |&gt; push_navigate(to: ~p&quot;/#{map_slug}&quot;)}
  end

  @impl true
  def handle_info(:character_token_invalid, socket),
    do:
      {:noreply,
       socket
       |&gt; put_flash(
         :error,
         &quot;One of your characters has expired token. Please refresh it on characters page.&quot;
       )}

  def handle_info(:no_main_character_set, socket),
    do:
      {:noreply,
       socket
       |&gt; put_flash(
         :warning,
         &quot;You don&apos;t have main character set, please update it in tracking settings (top right icon).&quot;
       )}

  def handle_info(:no_access, socket),
    do:
      {:noreply,
       socket
       |&gt; put_flash(:error, &quot;You don&apos;t have an access to this map.&quot;)
       |&gt; push_navigate(to: ~p&quot;/maps&quot;)}

  def handle_info(:no_permissions, socket),
    do:
      {:noreply,
       socket
       |&gt; put_flash(:error, &quot;You don&apos;t have permissions to use this map.&quot;)
       |&gt; push_navigate(to: ~p&quot;/maps&quot;)}

  def handle_info(:not_all_characters_tracked, %{assigns: %{map_slug: map_slug}} = socket),
    do:
      {:noreply,
       socket
       |&gt; put_flash(
         :error,
         &quot;You should enable tracking for all characters that have access to this map first!&quot;
       )
       |&gt; push_navigate(to: ~p&quot;/tracking/#{map_slug}&quot;)}

  @impl true
  def handle_info(%{timestamp: timestamp} = info, %{assigns: %{map_slug: map_slug}} = socket) do
    duration = DateTime.diff(DateTime.utc_now(), timestamp, :millisecond)

    if duration &gt; @server_event_unsync_timeout do
      {:noreply, socket |&gt; push_navigate(to: ~p&quot;/#{map_slug}&quot;)}
    else
      {:noreply,
       socket
       |&gt; WandererAppWeb.MapEventHandler.handle_event(info)}
    end
  end

  @impl true
  def handle_info(info, socket),
    do:
      {:noreply,
       socket
       |&gt; WandererAppWeb.MapEventHandler.handle_event(info)}

  @impl true
  def handle_event(event, body, socket) do
    WandererAppWeb.MapEventHandler.handle_ui_event(event, body, socket)
  end

  defp apply_action(socket, :index, _params) do
    socket
    |&gt; assign(:active_page, :map)
  end
end</file><file path="lib/wanderer_app_web/live/map/map_live.html.heex">&lt;.live_component module={WandererAppWeb.MapLoader} id=&quot;map-loader&quot; /&gt;

&lt;div class=&quot;w-full h-full&quot; id=&quot;mapper&quot; phx-hook=&quot;Mapper&quot; phx-update=&quot;ignore&quot;&gt;&lt;/div&gt;

&lt;div class=&quot;absolute top-0 mt-2 left-16 flex gap-1&quot;&gt;
  &lt;.live_component
    :if={not is_nil(assigns |&gt; Map.get(:map_slug))}
    module={WandererAppWeb.MapPicker}
    id=&quot;map-picker&quot;
    notify_to={self()}
    current_user={@current_user}
    map_slug={@map_slug}
    event_name=&quot;change_map&quot;
  /&gt;

  &lt;button
    :if={(@user_permissions || %{}) |&gt; Map.get(:track_character, false)}
    id=&quot;show-activity-button&quot;
    class=&quot;h-8 w-8 hover:text-white&quot;
    phx-click=&quot;show_activity&quot;
  &gt;
    &lt;.icon name=&quot;hero-chart-bar-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
  &lt;/button&gt;

  &lt;.link
    :if={(@user_permissions || %{}) |&gt; Map.get(:delete_map, false)}
    id={&quot;map-audit-#{@map_slug}&quot;}
    class=&quot;h-8 w-8 hover:text-white&quot;
    navigate={~p&quot;/#{@map_slug}/audit?period=1H&amp;activity=all&quot;}
  &gt;
    &lt;.icon name=&quot;hero-key-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
  &lt;/.link&gt;

  &lt;.link
    :if={(@user_permissions || %{}) |&gt; Map.get(:delete_map, false)}
    id={&quot;map-characters-#{@map_slug}&quot;}
    class=&quot;h-8 w-8 hover:text-white&quot;
    navigate={~p&quot;/#{@map_slug}/characters&quot;}
  &gt;
    &lt;.icon name=&quot;hero-user-group-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
  &lt;/.link&gt;
&lt;/div&gt;</file><file path="lib/wanderer_app_web/live/maps/components/license_component.ex">defmodule WandererAppWeb.Maps.LicenseComponent do
  @moduledoc &quot;&quot;&quot;
  LiveView component for displaying and managing bot licenses.

  This component is used in the map settings page to:
  - Display license information
  - Copy license key to clipboard
  - Show license status and expiration
  &quot;&quot;&quot;

  use WandererAppWeb, :live_component
  require Logger

  alias WandererApp.License.LicenseManager

  @impl true
  def mount(socket) do
    {:ok, assign(socket, show_key: false, license: nil, loading: true, error: nil)}
  end

  @impl true
  def update(%{map_id: map_id} = assigns, socket) do
    socket =
      socket
      |&gt; assign(assigns)
      |&gt; assign(loading: true, error: nil)
      |&gt; load_license(map_id)

    {:ok, socket}
  end

  @impl true
  def handle_event(&quot;toggle_key_visibility&quot;, _, socket) do
    {:noreply, assign(socket, show_key: !socket.assigns.show_key)}
  end

  @impl true
  def handle_event(&quot;refresh_license&quot;, _, socket) do
    {:noreply,
     socket
     |&gt; assign(loading: true, error: nil)
     |&gt; load_license(socket.assigns.map_id)}
  end

  @impl true
  def handle_event(&quot;create_license&quot;, _, socket) do
    case LicenseManager.create_license_for_map(socket.assigns.map_id) do
      {:ok, license} -&gt;
        {:noreply, assign(socket, license: license, loading: false, error: nil)}

      {:error, :no_active_subscription} -&gt;
        {:noreply,
         assign(socket,
           loading: false,
           error: &quot;Cannot create license: Map does not have an active subscription&quot;
         )}

      {:error, reason} -&gt;
        Logger.error(&quot;Failed to create license: #{inspect(reason)}&quot;)

        {:noreply,
         assign(socket,
           loading: false,
           error: &quot;Failed to create license. Please try again later.&quot;
         )}
    end
  end

  defp load_license(socket, map_id) do
    case LicenseManager.get_license_by_map_id(map_id) do
      {:ok, %{license_key: license_key}} -&gt;
        case LicenseManager.validate_license(license_key) do
          {:ok, license} -&gt;
            assign(socket, license: license, loading: false, error: nil)

          {:error, reason} -&gt;
            assign(socket, license: nil, loading: false, error: reason)
        end

      {:error, :license_not_found} -&gt;
        assign(socket, license: nil, loading: false, error: nil)

      {:error, reason} -&gt;
        Logger.error(&quot;Failed to load license: #{inspect(reason)}&quot;)
        assign(socket, license: nil, loading: false, error: &quot;Failed to load license information&quot;)
    end
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;license-info&quot;&gt;
      &lt;h3 class=&quot;text-lg font-semibold mb-4&quot;&gt;Map License&lt;/h3&gt;

      &lt;%= if @loading do %&gt;
        &lt;div class=&quot;flex justify-center py-4&quot;&gt;
          &lt;div class=&quot;animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;% else %&gt;
        &lt;%= if @error do %&gt;
          &lt;div class=&quot;border border-red-400 text-red-700 px-4 py-3 rounded mb-4&quot;&gt;
            &lt;p&gt;&lt;%= @error %&gt;&lt;/p&gt;
          &lt;/div&gt;
        &lt;% end %&gt;

        &lt;%= if @license do %&gt;
          &lt;div class=&quot;mt-4 p-4 border rounded-md&quot;&gt;
            &lt;div class=&quot;flex justify-between items-center&quot;&gt;
              &lt;div class=&quot;flex items-center gap-2&quot;&gt;
                &lt;span class=&quot;font-medium&quot;&gt;License Key:&lt;/span&gt;
                &lt;span class=&quot;font-mono bg-gray-800 px-2 py-1 rounded&quot;&gt;
                  &lt;%= if @show_key,
                    do: @license.license_key,
                    else: &quot;‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢&quot; %&gt;
                &lt;/span&gt;
                &lt;button
                  type=&quot;button&quot;
                  phx-click=&quot;toggle_key_visibility&quot;
                  phx-target={@myself}
                  class=&quot;ml-2 btn&quot;
                &gt;
                  &lt;%= if @show_key, do: &quot;Hide&quot;, else: &quot;Show&quot; %&gt;
                &lt;/button&gt;
                &lt;.button
                  phx-hook=&quot;CopyToClipboard&quot;
                  id=&quot;copy-key&quot;
                  class=&quot;copy-link btn&quot;
                  data-url={@license.license_key}
                &gt;
                  Copy
                  &lt;div class=&quot;absolute w-[100px] !mr-[-170px] link-copied hidden&quot;&gt;
                    Key copied
                  &lt;/div&gt;
                &lt;/.button&gt;
                &lt;button
                  type=&quot;button&quot;
                  phx-click=&quot;refresh_license&quot;
                  phx-target={@myself}
                  class=&quot;ml-2 btn&quot;
                &gt;
                  Refresh
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;mt-3 grid grid-cols-2 gap-2&quot;&gt;
              &lt;div&gt;
                &lt;span class=&quot;font-medium&quot;&gt;Status:&lt;/span&gt;
                &lt;span class={(@license.is_valid &amp;&amp; &quot;text-green-600&quot;) || &quot;text-red-600&quot;}&gt;
                  &lt;%= (@license.is_valid &amp;&amp; &quot;Active&quot;) || &quot;Inactive&quot; %&gt;
                &lt;/span&gt;
              &lt;/div&gt;

              &lt;div&gt;
                &lt;span class=&quot;font-medium&quot;&gt;Expires:&lt;/span&gt;
                &lt;span&gt;
                  &lt;%= if @license.expire_at do %&gt;
                    &lt;%= Calendar.strftime(@license.expire_at, &quot;%Y-%m-%d&quot;) %&gt;
                  &lt;% else %&gt;
                    Never
                  &lt;% end %&gt;
                &lt;/span&gt;
              &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;mt-4 text-sm text-gray-600&quot;&gt;
              &lt;p&gt;
                This license key allows you to use bot functionality with your map. Keep it secure and do not share it with unauthorized users.
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;% else %&gt;
          &lt;div class=&quot;mt-4 p-4 border rounded-md&quot;&gt;
            &lt;p class=&quot;mb-4&quot;&gt;No license found for this map.&lt;/p&gt;

            &lt;button
              type=&quot;button&quot;
              phx-click=&quot;create_license&quot;
              phx-target={@myself}
              class=&quot;bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded&quot;
            &gt;
              Create License
            &lt;/button&gt;

            &lt;div class=&quot;mt-4 text-sm text-gray-600&quot;&gt;
              &lt;p&gt;
                A license is required to use bot functionality with your map. Creating a license requires an active map subscription.
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;% end %&gt;
      &lt;% end %&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_app_web/live/maps/components/map_balance_component.ex">defmodule WandererAppWeb.Maps.MapBalanceComponent do
  use WandererAppWeb, :live_component
  use LiveViewEvents

  require Logger

  alias BetterNumber, as: Number
  alias WandererApp.License.LicenseManager

  @impl true
  def mount(socket) do
    {:ok,
     assign(socket,
       is_topping_up?: false,
       error: nil
     )}
  end

  @impl true
  def update(%{map_id: map_id, current_user: current_user} = assigns, socket) do
    socket = handle_info_or_assign(socket, assigns)

    {:ok, map} = WandererApp.MapRepo.get(map_id)

    {:ok, map_balance} = WandererApp.Map.SubscriptionManager.get_balance(map)

    {:ok, user_balance} =
      current_user.id
      |&gt; WandererApp.User.load()
      |&gt; WandererApp.User.get_balance()

    socket =
      socket
      |&gt; assign(assigns)
      |&gt; assign(
        map_id: map_id,
        map: map,
        map_balance: map_balance,
        user_balance: user_balance,
        topup_form: %{} |&gt; to_form()
      )

    {:ok, socket}
  end

  @impl true
  def handle_event(&quot;show_topup&quot;, _, socket),
    do:
      {:noreply,
       socket
       |&gt; assign(
         :amounts,
         [
           {&quot;150M&quot;, 150_000_000},
           {&quot;300M&quot;, 300_000_000},
           {&quot;600M&quot;, 600_000_000},
           {&quot;1.2B&quot;, 1_200_000_000},
           {&quot;2.4B&quot;, 2_400_000_000},
           {&quot;5B&quot;, 5_000_000_000}
         ]
       )
       |&gt; assign(is_topping_up?: true)}

  @impl true
  def handle_event(&quot;hide_topup&quot;, _, socket),
    do: {:noreply, socket |&gt; assign(is_topping_up?: false)}

  @impl true
  def handle_event(
        &quot;topup&quot;,
        %{&quot;amount&quot; =&gt; amount} = _event,
        %{assigns: %{current_user: current_user, map: map, map_id: map_id}} = socket
      ) do
    amount = amount |&gt; Decimal.new() |&gt; Decimal.to_float()

    user =
      current_user.id
      |&gt; WandererApp.User.load()

    {:ok, user_balance} =
      user
      |&gt; WandererApp.User.get_balance()

    case amount &lt;= user_balance do
      true -&gt;
        {:ok, _t} =
          WandererApp.Api.MapTransaction.create(%{
            map_id: map_id,
            user_id: current_user.id,
            amount: amount,
            type: :in
          })

        {:ok, user} =
          user
          |&gt; WandererApp.Api.User.update_balance(%{
            balance: (user_balance || 0.0) - amount
          })

        {:ok, user_balance} =
          user
          |&gt; WandererApp.User.get_balance()

        {:ok, map_balance} = WandererApp.Map.SubscriptionManager.get_balance(map)

        {:noreply,
         socket
         |&gt; assign(is_topping_up?: false, map_balance: map_balance, user_balance: user_balance)}

      _ -&gt;
        notify_to(
          socket.assigns.notify_to,
          socket.assigns.event_name,
          {:flash, :error, &quot;You don&apos;t have enough ISK on your account balance!&quot;}
        )

        {:noreply, socket}
    end
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;map-balance-info&quot;&gt;
      &lt;div class=&quot;stats w-full bg-primary text-primary-content&quot;&gt;
        &lt;div class=&quot;stat&quot;&gt;
          &lt;div class=&quot;stat-title&quot;&gt;Account balance&lt;/div&gt;
          &lt;div class=&quot;stat-value text-white&quot;&gt;
            ISK {@user_balance
            |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;])}
          &lt;/div&gt;
          &lt;div class=&quot;stat-actions text-end&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;stat&quot;&gt;
          &lt;div class=&quot;stat-figure text-primary&quot;&gt;
            &lt;.button
              :if={not @is_topping_up?}
              class=&quot;mt-2&quot;
              type=&quot;button&quot;
              phx-click=&quot;show_topup&quot;
              phx-target={@myself}
            &gt;
              Top Up
            &lt;/.button&gt;
          &lt;/div&gt;
          &lt;div class=&quot;stat-title&quot;&gt;Map balance&lt;/div&gt;
          &lt;div class=&quot;stat-value text-white&quot;&gt;
            ISK {@map_balance
            |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;])}
          &lt;/div&gt;
          &lt;div class=&quot;stat-actions text-end&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;w-full bg-primary&quot;&gt;
        &lt;h3 class=&quot;mt-2 text-2xl font-semibold mb-4 text-white&quot;&gt;
          How to top up map balance?
        &lt;/h3&gt;
        &lt;ol class=&quot;list-decimal list-inside mb-4&quot;&gt;
          &lt;li class=&quot;mb-2&quot;&gt;
            &lt;strong&gt;Top Up your account balance:&lt;/strong&gt;
            Click on &apos;Deposit ISK&apos; button on &lt;a href={~p&quot;/profile&quot;} class=&quot;text-purple-400&quot;&gt;user profile page&lt;/a&gt;.
          &lt;/li&gt;
          &lt;li class=&quot;mb-2&quot;&gt;
            &lt;strong&gt;Wait for account balance updated:&lt;/strong&gt;
            Check transactions section on
            &lt;a href={~p&quot;/profile&quot;} class=&quot;text-purple-400&quot;&gt;user profile page&lt;/a&gt;
          &lt;/li&gt;
          &lt;li class=&quot;mb-2&quot;&gt;
            &lt;strong&gt;Use &apos;Top Up&apos; button:&lt;/strong&gt;
            Click on the &apos;Top Up&apos; button &amp; select the amount you wish to transfer to the map balance.
          &lt;/li&gt;
          &lt;li class=&quot;mb-2&quot;&gt;
            &lt;strong&gt;Accept the transfer:&lt;/strong&gt;
            Finish the transaction by clicking on the &apos;Top Up&apos; button.
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/div&gt;

      &lt;.form
        :let={f}
        :if={@is_topping_up?}
        for={@topup_form}
        class=&quot;mt-2&quot;
        phx-submit=&quot;topup&quot;
        phx-target={@myself}
      &gt;
        &lt;.input
          type=&quot;select&quot;
          field={f[:amount]}
          class=&quot;select h-8 min-h-[10px] !pt-1 !pb-1 text-sm bg-neutral-900&quot;
          label=&quot;Topup amount&quot;
          placeholder=&quot;Select topup amount&quot;
          options={@amounts}
        /&gt;
        &lt;div class=&quot;modal-action&quot;&gt;
          &lt;.button class=&quot;mt-2&quot; type=&quot;button&quot; phx-click=&quot;hide_topup&quot; phx-target={@myself}&gt;
            Cancel
          &lt;/.button&gt;
          &lt;.button class=&quot;mt-2&quot; type=&quot;submit&quot;&gt;
            Top Up
          &lt;/.button&gt;
        &lt;/div&gt;
      &lt;/.form&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_app_web/live/maps/components/map_subscriptions_component.ex">defmodule WandererAppWeb.Maps.MapSubscriptionsComponent do
  use WandererAppWeb, :live_component
  use LiveViewEvents

  require Logger

  alias BetterNumber, as: Number
  alias WandererApp.License.LicenseManager

  @impl true
  def mount(socket) do
    {:ok,
     assign(socket,
       is_adding_subscription?: false,
       map_subscriptions: [],
       selected_subscription: nil,
       subscription_periods: [
         {&quot;1 Month&quot;, &quot;1&quot;},
         {&quot;3 Months&quot;, &quot;3&quot;},
         {&quot;6 Months&quot;, &quot;6&quot;},
         {&quot;1 Year&quot;, &quot;12&quot;}
       ],
       error: nil
     )}
  end

  @impl true
  def update(%{map_id: map_id} = assigns, socket) do
    socket = handle_info_or_assign(socket, assigns)

    subscription_form = %{
      &quot;plan&quot; =&gt; &quot;omega&quot;,
      &quot;period&quot; =&gt; &quot;1&quot;,
      &quot;characters_limit&quot; =&gt; &quot;100&quot;,
      &quot;hubs_limit&quot; =&gt; &quot;10&quot;,
      &quot;auto_renew?&quot; =&gt; true
    }

    {:ok, map} = WandererApp.MapRepo.get(map_id)

    {:ok, estimated_price, discount} =
      WandererApp.Map.SubscriptionManager.estimate_price(subscription_form, false)

    {:ok, map_subscriptions} =
      WandererApp.Map.SubscriptionManager.get_map_subscriptions(map_id)

    socket =
      socket
      |&gt; assign(assigns)
      |&gt; assign(
        map: map,
        map_subscriptions: map_subscriptions,
        subscription_form: subscription_form |&gt; to_form(),
        estimated_price: estimated_price,
        discount: discount
      )

    {:ok, socket}
  end

  @impl true
  def handle_event(&quot;add_subscription&quot;, _, socket),
    do: {:noreply, socket |&gt; assign(is_adding_subscription?: true)}

  @impl true
  def handle_event(&quot;edit-subscription&quot;, %{&quot;id&quot; =&gt; subscription_id} = _event, socket) do
    {:ok, selected_subscription} =
      subscription_id
      |&gt; WandererApp.Api.MapSubscription.by_id()

    subscription_form = %{
      &quot;plan&quot; =&gt; &quot;omega&quot;,
      &quot;characters_limit&quot; =&gt; &quot;#{selected_subscription.characters_limit}&quot;,
      &quot;hubs_limit&quot; =&gt; &quot;#{selected_subscription.hubs_limit}&quot;,
      &quot;auto_renew?&quot; =&gt; selected_subscription.auto_renew?
    }

    {:ok, additional_price, discount} =
      WandererApp.Map.SubscriptionManager.calc_additional_price(
        subscription_form,
        selected_subscription
      )

    {:noreply,
     socket
     |&gt; assign(
       is_adding_subscription?: true,
       selected_subscription: selected_subscription,
       additional_price: additional_price,
       discount: discount,
       subscription_form: subscription_form |&gt; to_form()
     )}
  end

  @impl true
  def handle_event(
        &quot;cancel-subscription&quot;,
        %{&quot;id&quot; =&gt; subscription_id} = _event,
        %{assigns: %{map_id: map_id}} = socket
      ) do
    {:ok, _subscription} =
      subscription_id
      |&gt; WandererApp.Api.MapSubscription.by_id!()
      |&gt; WandererApp.Api.MapSubscription.cancel()

    {:ok, map_subscriptions} = WandererApp.Map.SubscriptionManager.get_map_subscriptions(map_id)

    Phoenix.PubSub.broadcast(
      WandererApp.PubSub,
      &quot;maps:#{map_id}&quot;,
      :subscription_settings_updated
    )

    :telemetry.execute([:wanderer_app, :map, :subscription, :cancel], %{count: 1}, %{
      map_id: map_id
    })

    case WandererApp.License.LicenseManager.get_license_by_map_id(map_id) do
      {:ok, license} -&gt;
        WandererApp.License.LicenseManager.invalidate_license(license.id)
        Logger.info(&quot;Cancelled license for map #{map_id}&quot;)

      {:error, reason} -&gt;
        Logger.error(&quot;Failed to cancel license for map #{map_id}: #{inspect(reason)}&quot;)
    end

    notify_to(
      socket.assigns.notify_to,
      socket.assigns.event_name,
      {:flash, :info, &quot;Subscription cancelled!&quot;}
    )

    {:noreply,
     socket
     |&gt; assign(is_adding_subscription?: false, map_subscriptions: map_subscriptions)}
  end

  @impl true
  def handle_event(
        &quot;validate_subscription&quot;,
        params,
        %{assigns: %{selected_subscription: selected_subscription}} = socket
      ) do
    socket =
      case is_nil(selected_subscription) do
        true -&gt;
          {:ok, estimated_price, discount} =
            WandererApp.Map.SubscriptionManager.estimate_price(params, false)

          socket
          |&gt; assign(estimated_price: estimated_price, discount: discount)

        _ -&gt;
          {:ok, additional_price, discount} =
            WandererApp.Map.SubscriptionManager.calc_additional_price(
              params,
              selected_subscription
            )

          socket |&gt; assign(additional_price: additional_price, discount: discount)
      end

    {:noreply, assign(socket, subscription_form: params)}
  end

  @impl true
  def handle_event(
        &quot;subscribe&quot;,
        %{
          &quot;period&quot; =&gt; period,
          &quot;characters_limit&quot; =&gt; characters_limit,
          &quot;hubs_limit&quot; =&gt; hubs_limit,
          &quot;auto_renew?&quot; =&gt; auto_renew?
        } = subscription_form,
        %{assigns: %{map_id: map_id, map: map, current_user: current_user}} = socket
      ) do
    period = period |&gt; String.to_integer()

    {:ok, estimated_price, discount} =
      WandererApp.Map.SubscriptionManager.estimate_price(subscription_form, false)

    active_till =
      DateTime.utc_now()
      |&gt; DateTime.to_date()
      |&gt; Date.add(period * 30)
      |&gt; WandererApp.Map.SubscriptionManager.convert_date_to_datetime()

    {:ok, map_balance} = WandererApp.Map.SubscriptionManager.get_balance(map)

    case map_balance &gt;= estimated_price - discount do
      true -&gt;
        {:ok, _t} =
          WandererApp.Api.MapTransaction.create(%{
            map_id: map_id,
            user_id: current_user.id,
            amount: estimated_price - discount,
            type: :out
          })

        {:ok, _sub} =
          WandererApp.Api.MapSubscription.create(%{
            map_id: map_id,
            plan: :omega,
            active_till: active_till,
            characters_limit: characters_limit |&gt; String.to_integer(),
            hubs_limit: hubs_limit |&gt; String.to_integer(),
            auto_renew?: auto_renew?
          })

        {:ok, map_subscriptions} =
          WandererApp.Map.SubscriptionManager.get_map_subscriptions(map_id)

        Phoenix.PubSub.broadcast(
          WandererApp.PubSub,
          &quot;maps:#{map_id}&quot;,
          :subscription_settings_updated
        )

        :telemetry.execute([:wanderer_app, :map, :subscription, :new], %{count: 1}, %{
          map_id: map_id,
          amount: estimated_price - discount
        })

        # Automatically create a license for the map
        create_map_license(socket, map_id)

        notify_to(
          socket.assigns.notify_to,
          socket.assigns.event_name,
          {:flash, :info, &quot;Subscription added!&quot;}
        )

        {:noreply,
         socket
         |&gt; assign(
           is_adding_subscription?: false,
           map_subscriptions: map_subscriptions
         )}

      _ -&gt;
        notify_to(
          socket.assigns.notify_to,
          socket.assigns.event_name,
          {:flash, :error, &quot;You have not enough ISK on Map Balance!&quot;}
        )

        {:noreply, socket}
    end
  end

  @impl true
  def handle_event(
        &quot;update_subscription&quot;,
        %{
          &quot;characters_limit&quot; =&gt; characters_limit,
          &quot;hubs_limit&quot; =&gt; hubs_limit,
          &quot;auto_renew?&quot; =&gt; auto_renew?
        } = subscription_form,
        %{
          assigns: %{
            map_id: map_id,
            map: map,
            current_user: current_user,
            selected_subscription: selected_subscription
          }
        } = socket
      ) do
    {:ok, additional_price, discount} =
      WandererApp.Map.SubscriptionManager.calc_additional_price(
        subscription_form,
        selected_subscription
      )

    {:ok, map_balance} = WandererApp.Map.SubscriptionManager.get_balance(map)

    case map_balance &gt;= additional_price - discount do
      true -&gt;
        {:ok, _t} =
          WandererApp.Api.MapTransaction.create(%{
            map_id: map_id,
            user_id: current_user.id,
            amount: additional_price - discount,
            type: :out
          })

        {:ok, _} =
          selected_subscription
          |&gt; WandererApp.Api.MapSubscription.update_characters_limit!(%{
            characters_limit: characters_limit |&gt; String.to_integer()
          })
          |&gt; WandererApp.Api.MapSubscription.update_hubs_limit!(%{
            hubs_limit: hubs_limit |&gt; String.to_integer()
          })
          |&gt; WandererApp.Api.MapSubscription.update_auto_renew(%{auto_renew?: auto_renew?})

        {:ok, map_subscriptions} =
          WandererApp.Map.SubscriptionManager.get_map_subscriptions(map_id)

        Phoenix.PubSub.broadcast(
          WandererApp.PubSub,
          &quot;maps:#{map_id}&quot;,
          :subscription_settings_updated
        )

        :telemetry.execute([:wanderer_app, :map, :subscription, :update], %{count: 1}, %{
          map_id: map_id,
          amount: additional_price - discount
        })

        # Check if a license exists, if not create one, otherwise update its expiration
        # The License Manager service will verify the subscription is active
        case WandererApp.License.LicenseManager.get_license_by_map_id(map_id) do
          {:ok, _license} -&gt;
            # License exists, update its expiration date
            case WandererApp.License.LicenseManager.update_license_expiration_from_subscription(
                   map_id
                 ) do
              {:ok, updated_license} -&gt;
                Logger.info(
                  &quot;Updated license expiration for map #{map_id} to #{updated_license.expire_at}&quot;
                )

              {:error, &quot;License not found&quot;} -&gt;
                create_map_license(socket, map_id)

              {:error, reason} -&gt;
                Logger.error(
                  &quot;Failed to update license expiration for map #{map_id}: #{inspect(reason)}&quot;
                )

                notify_to(
                  socket.assigns.notify_to,
                  socket.assigns.event_name,
                  {:flash, :error, &quot;Failed to update license expiration for map #{map_id}!&quot;}
                )
            end

          {:error, :license_not_found} -&gt;
            # No license found, create one
            create_map_license(socket, map_id)

          _ -&gt;
            # Error occurred, do nothing
            :ok
        end

        notify_to(
          socket.assigns.notify_to,
          socket.assigns.event_name,
          {:flash, :info, &quot;Subscription updated!&quot;}
        )

        {:noreply,
         socket
         |&gt; assign(
           is_adding_subscription?: false,
           selected_subscription: nil,
           map_subscriptions: map_subscriptions
         )}

      _ -&gt;
        notify_to(
          socket.assigns.notify_to,
          socket.assigns.event_name,
          {:flash, :error, &quot;You have not enough ISK on Map Balance!&quot;}
        )

        {:noreply, socket}
    end
  end

  @impl true
  def handle_event(&quot;cancel_edit_subscription&quot;, _event, socket) do
    {:noreply, socket |&gt; assign(is_adding_subscription?: false, selected_subscription: nil)}
  end

  defp create_map_license(socket, map_id) do
    # No license found, create one
    case WandererApp.License.LicenseManager.create_license_for_map(map_id) do
      {:ok, license} -&gt;
        Logger.debug(fn -&gt;
          &quot;Automatically created license #{license.license_key} for map #{map_id} during subscription update&quot;
        end)

        notify_to(
          socket.assigns.notify_to,
          socket.assigns.event_name,
          {:flash, :info, &quot;Automatically created license for map&quot;}
        )

        {:ok, license}

      {:error, reason} -&gt;
        Logger.error(
          &quot;Failed to create license for map #{map_id} during subscription update: #{inspect(reason)}&quot;
        )

        notify_to(
          socket.assigns.notify_to,
          socket.assigns.event_name,
          {:flash, :error,
           &quot;Failed to create license for map #{map_id} during subscription update: #{inspect(reason)}&quot;}
        )

        {:error, reason}
    end
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;subscriptions-info&quot;&gt;
      &lt;div
        class=&quot;tooltip&quot;
        data-tip={
          if @map_subscriptions |&gt; Enum.at(0) |&gt; Map.get(:status) == :active,
            do: &quot;You can have only one active subscription plan&quot;,
            else: &quot;&quot;
        }
      &gt;
        &lt;.button
          :if={not @is_adding_subscription?}
          type=&quot;button&quot;
          disabled={
            @map_subscriptions |&gt; Enum.at(0) |&gt; Map.get(:status) == :active &amp;&amp;
              @map_subscriptions |&gt; Enum.at(0) |&gt; Map.get(:plan) != :alpha
          }
          phx-click=&quot;add_subscription&quot;
          phx-target={@myself}
        &gt;
          Add subscription
        &lt;/.button&gt;
      &lt;/div&gt;
      &lt;.table
        class=&quot;!max-h-[200px] !overflow-y-auto&quot;
        empty_label=&quot;No active subscriptions, using alpha plan by default.&quot;
        id=&quot;active-subscriptions-tbl&quot;
        rows={@map_subscriptions}
      &gt;
        &lt;:col :let={subscription} label=&quot;Subscription Plan&quot;&gt;
          {subscription.plan}
        &lt;/:col&gt;
        &lt;:col :let={subscription} label=&quot;Status&quot;&gt;
          {subscription.status}
        &lt;/:col&gt;
        &lt;:col :let={subscription} label=&quot;Characters Limit&quot;&gt;
          {subscription.characters_limit}
        &lt;/:col&gt;
        &lt;:col :let={subscription} label=&quot;Hubs Limit&quot;&gt;
          {subscription.hubs_limit}
        &lt;/:col&gt;
        &lt;:col :let={subscription} label=&quot;Active Till&quot;&gt;
          &lt;.local_time
            :if={subscription.active_till}
            id={&quot;subscription-active-till-#{subscription.id}&quot;}
            at={subscription.active_till}
          &gt;
            {subscription.active_till}
          &lt;/.local_time&gt;
        &lt;/:col&gt;
        &lt;:col :let={subscription} label=&quot;Auto Renew&quot;&gt;
          {if subscription.auto_renew?, do: &quot;Yes&quot;, else: &quot;No&quot;}
        &lt;/:col&gt;
        &lt;:action :let={subscription}&gt;
          &lt;div class=&quot;tooltip tooltip-left&quot; data-tip=&quot;Edit subscription&quot;&gt;
            &lt;button
              :if={subscription.status == :active &amp;&amp; subscription.plan != :alpha}
              phx-click=&quot;edit-subscription&quot;
              phx-value-id={subscription.id}
              phx-target={@myself}
            &gt;
              &lt;.icon name=&quot;hero-pencil-square-solid&quot; class=&quot;w-4 h-4 hover:text-white&quot; /&gt;
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/:action&gt;
        &lt;:action :let={subscription}&gt;
          &lt;div class=&quot;tooltip tooltip-left&quot; data-tip=&quot;Cancel subscription&quot;&gt;
            &lt;button
              :if={subscription.status == :active &amp;&amp; subscription.plan != :alpha}
              phx-click=&quot;cancel-subscription&quot;
              phx-value-id={subscription.id}
              phx-target={@myself}
              data={[confirm: &quot;Please confirm to cancel subscription!&quot;]}
            &gt;
              &lt;.icon name=&quot;hero-trash-solid&quot; class=&quot;w-4 h-4 hover:text-white&quot; /&gt;
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/:action&gt;
      &lt;/.table&gt;

      &lt;.header :if={@is_adding_subscription?} class=&quot;bordered border-1 flex flex-col gap-4&quot;&gt;
        &lt;div :if={is_nil(@selected_subscription)}&gt;
          Add subscription
        &lt;/div&gt;
        &lt;div :if={not is_nil(@selected_subscription)}&gt;
          Edit subscription
        &lt;/div&gt;
        &lt;.form
          :let={f}
          for={@subscription_form}
          phx-change=&quot;validate_subscription&quot;
          phx-target={@myself}
          phx-submit={
            if is_nil(@selected_subscription),
              do: &quot;subscribe&quot;,
              else: &quot;update_subscription&quot;
          }
        &gt;
          &lt;.input
            :if={is_nil(@selected_subscription)}
            type=&quot;select&quot;
            field={f[:period]}
            class=&quot;select h-8 min-h-[10px] !pt-1 !pb-1 text-sm bg-neutral-900&quot;
            label=&quot;Subscription period&quot;
            options={@subscription_periods}
          /&gt;
          &lt;.input
            field={f[:characters_limit]}
            label=&quot;Characters limit&quot;
            show_value={true}
            type=&quot;range&quot;
            min=&quot;100&quot;
            max=&quot;5000&quot;
            step=&quot;100&quot;
            class=&quot;range range-xs&quot;
          /&gt;
          &lt;.input
            field={f[:hubs_limit]}
            label=&quot;Hubs limit&quot;
            show_value={true}
            type=&quot;range&quot;
            min=&quot;20&quot;
            max=&quot;50&quot;
            step=&quot;10&quot;
            class=&quot;range range-xs&quot;
          /&gt;
          &lt;.input field={f[:auto_renew?]} label=&quot;Auto Renew&quot; type=&quot;checkbox&quot; /&gt;
          &lt;div
            :if={is_nil(@selected_subscription)}
            class=&quot;stats w-full bg-primary text-primary-content mt-2&quot;
          &gt;
            &lt;div class=&quot;stat&quot;&gt;
              &lt;div class=&quot;stat-figure text-primary&quot;&gt;
                &lt;.button type=&quot;submit&quot;&gt;
                  Subscribe
                &lt;/.button&gt;
              &lt;/div&gt;
              &lt;div class=&quot;flex gap-8&quot;&gt;
                &lt;div&gt;
                  &lt;div class=&quot;stat-title&quot;&gt;Estimated price&lt;/div&gt;
                  &lt;div class=&quot;stat-value text-white&quot;&gt;
                    ISK {(@estimated_price - @discount)
                    |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;])}
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div&gt;
                  &lt;div class=&quot;stat-title&quot;&gt;Discount&lt;/div&gt;
                  &lt;div class=&quot;stat-value text-white relative&quot;&gt;
                    ISK {@discount
                    |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;])}
                    &lt;span class=&quot;absolute top-0 right-0 text-xs text-white discount&quot; /&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div
            :if={not is_nil(@selected_subscription)}
            class=&quot;stats w-full bg-primary text-primary-content&quot;
          &gt;
            &lt;div class=&quot;stat&quot;&gt;
              &lt;div class=&quot;stat-figure text-primary&quot;&gt;
                &lt;.button type=&quot;button&quot; phx-click=&quot;cancel_edit_subscription&quot; phx-target={@myself}&gt;
                  Cancel
                &lt;/.button&gt;
                &lt;.button type=&quot;submit&quot;&gt;
                  Update
                &lt;/.button&gt;
              &lt;/div&gt;
              &lt;div class=&quot;flex gap-8&quot;&gt;
                &lt;div&gt;
                  &lt;div class=&quot;stat-title&quot;&gt;Additional price&lt;/div&gt;
                  &lt;div class=&quot;stat-value text-white&quot;&gt;
                    ISK {(@additional_price - @discount)
                    |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;])}
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div :if={@discount &gt; 0}&gt;
                  &lt;div class=&quot;stat-title&quot;&gt;Discount&lt;/div&gt;
                  &lt;div class=&quot;stat-value text-white relative&quot;&gt;
                    ISK {@discount
                    |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;])}
                    &lt;span class=&quot;absolute top-0 right-0 text-xs text-white discount&quot; /&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/.form&gt;
      &lt;/.header&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_app_web/live/maps/maps_live.ex">defmodule WandererAppWeb.MapsLive do
  use WandererAppWeb, :live_view

  require Logger

  alias BetterNumber, as: Number
  alias WandererAppWeb.Maps.LicenseComponent

  @pubsub_client Application.compile_env(:wanderer_app, :pubsub_client)

  @impl true
  def mount(
        _params,
        _session,
        %{assigns: %{current_user: current_user}} = socket
      )
      when not is_nil(current_user) and is_connected?(socket) do
    {:ok, active_characters} =
      WandererApp.Api.Character.active_by_user(%{user_id: current_user.id})

    user_characters =
      active_characters
      |&gt; Enum.map(&amp;map_character/1)

    {:ok,
     socket
     |&gt; assign(
       characters: user_characters,
       importing: false,
       map_subscriptions_enabled?: WandererApp.Env.map_subscriptions_enabled?(),
       restrict_maps_creation?: WandererApp.Env.restrict_maps_creation?(),
       acls: [],
       location: nil,
       is_version_valid?: false
     )
     |&gt; assign_async(:maps, fn -&gt;
       load_maps(current_user)
     end)}
  end

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |&gt; assign(
       characters: [],
       location: nil,
       is_version_valid?: false,
       restrict_maps_creation?: WandererApp.Env.restrict_maps_creation?()
     )}
  end

  @impl true
  def handle_params(params, url, socket) when is_connected?(socket) do
    {:noreply,
     socket
     |&gt; assign(:is_connected?, true)
     |&gt; apply_action(socket.assigns.live_action, params, url)}
  end

  @impl true
  def handle_params(_params, _url, socket) do
    {:noreply, socket |&gt; assign(:is_connected?, false)}
  end

  defp apply_action(socket, :index, _params, _url) do
    socket
    |&gt; assign(:active_page, :maps)
    |&gt; assign(:page_title, &quot;Maps&quot;)
  end

  defp apply_action(socket, :create, _params, url) do
    allow_map_creation()
    |&gt; case do
      true -&gt;
        socket
        |&gt; assign(:active_page, :maps)
        |&gt; assign(:uri, URI.parse(url) |&gt; Map.put(:path, ~p&quot;/&quot;))
        |&gt; assign(:page_title, &quot;Maps - Create&quot;)
        |&gt; assign(:scopes, [&quot;wormholes&quot;, &quot;stargates&quot;, &quot;none&quot;, &quot;all&quot;])
        |&gt; assign(
          :form,
          AshPhoenix.Form.for_create(WandererApp.Api.Map, :new,
            forms: [
              auto?: true
            ],
            prepare_source: fn form -&gt;
              form
              |&gt; Map.put(&quot;scope&quot;, &quot;wormholes&quot;)
            end
          )
        )
        |&gt; load_access_lists()

      _ -&gt;
        socket
        |&gt; push_patch(to: ~p&quot;/maps&quot;)
    end
  end

  defp apply_action(
         %{assigns: %{current_user: current_user}} = socket,
         :edit,
         %{&quot;slug&quot; =&gt; map_slug} = _params,
         url
       )
       when not is_nil(current_user) do
    WandererApp.Maps.check_user_can_delete_map(map_slug, current_user)
    |&gt; case do
      {:ok, map} -&gt;
        map = map |&gt; map_map()

        socket
        |&gt; assign(:active_page, :maps)
        |&gt; assign(:uri, URI.parse(url) |&gt; Map.put(:path, ~p&quot;/&quot;))
        |&gt; assign(:page_title, &quot;Maps - Edit&quot;)
        |&gt; assign(:scopes, [&quot;wormholes&quot;, &quot;stargates&quot;, &quot;none&quot;, &quot;all&quot;])
        |&gt; assign(:map_slug, map_slug)
        |&gt; assign(
          :characters,
          [map.owner |&gt; map_character() | socket.assigns.characters] |&gt; Enum.uniq()
        )
        |&gt; assign(
          :form,
          map |&gt; AshPhoenix.Form.for_update(:update, forms: [auto?: true])
        )
        |&gt; load_access_lists()

      _ -&gt;
        socket
        |&gt; put_flash(:error, &quot;You don&apos;t have an access.&quot;)
        |&gt; push_navigate(to: ~p&quot;/maps&quot;)
    end
  end

  defp apply_action(
         %{assigns: %{current_user: current_user}} = socket,
         :settings,
         %{&quot;slug&quot; =&gt; map_slug} = _params,
         _url
       )
       when not is_nil(current_user) do
    WandererApp.Maps.check_user_can_delete_map(map_slug, current_user)
    |&gt; case do
      {:ok, map} -&gt;
        {:ok, export_settings} =
          map
          |&gt; WandererApp.Map.Server.get_export_settings()

        {:ok, options_form_data} = WandererApp.MapRepo.options_to_form_data(map)

        socket
        |&gt; assign(:active_page, :maps)
        |&gt; assign(:page_title, &quot;Maps - Settings&quot;)
        |&gt; assign(:map_slug, map_slug)
        |&gt; assign(:map_id, map.id)
        |&gt; assign(:public_api_key, map.public_api_key)
        |&gt; assign(:map, map)
        |&gt; assign(
          export_settings: export_settings |&gt; _get_export_map_data(),
          import_form: to_form(%{}),
          importing: false,
          show_settings?: true,
          is_topping_up?: false,
          active_settings_tab: &quot;general&quot;,
          is_adding_subscription?: false,
          selected_subscription: nil,
          options_form: options_form_data |&gt; to_form(),
          layout_options: [
            {&quot;Left To Right&quot;, &quot;left_to_right&quot;},
            {&quot;Top To Bottom&quot;, &quot;top_to_bottom&quot;}
          ]
        )
        |&gt; allow_upload(:settings,
          accept: ~w(.json),
          max_entries: 1,
          max_file_size: 10_000_000,
          auto_upload: true,
          progress: &amp;handle_progress/3
        )

      _ -&gt;
        socket
        |&gt; put_flash(:error, &quot;You don&apos;t have an access.&quot;)
        |&gt; push_navigate(to: ~p&quot;/maps&quot;)
    end
  end

  defp allow_map_creation(),
    do: not WandererApp.Env.restrict_maps_creation?() || WandererApp.Cache.take(&quot;create_map_once&quot;)

  @impl true
  def handle_event(&quot;set-default&quot;, %{&quot;id&quot; =&gt; id}, socket) do
    send_update(LiveSelect.Component, options: socket.assigns.characters, id: id)

    {:noreply, socket}
  end

  @impl true
  def handle_event(&quot;set-default-scope&quot;, %{&quot;id&quot; =&gt; id}, socket) do
    send_update(LiveSelect.Component, options: [&quot;wormholes&quot;, &quot;stargates&quot;, &quot;none&quot;, &quot;all&quot;], id: id)

    {:noreply, socket}
  end

  def handle_event(&quot;generate-map-api-key&quot;, _params, socket) do
    new_api_key = UUID.uuid4()

    map = WandererApp.Api.Map.by_id!(socket.assigns.map_id)

    {:ok, _updated_map} =
      WandererApp.Api.Map.update_api_key(map, %{public_api_key: new_api_key})

    {:noreply, assign(socket, public_api_key: new_api_key)}
  end

  @impl true
  def handle_event(
        &quot;live_select_change&quot;,
        %{&quot;id&quot; =&gt; id, &quot;text&quot; =&gt; text} = _change_event,
        socket
      ) do
    options =
      if text == &quot;&quot; do
        socket.assigns.scopes
      else
        socket.assigns.scopes
      end

    send_update(LiveSelect.Component, options: options, id: id)

    {:noreply, socket}
  end

  def handle_event(&quot;validate&quot;, %{&quot;form&quot; =&gt; form} = _params, socket) do
    form =
      AshPhoenix.Form.validate(
        socket.assigns.form,
        form
        |&gt; Map.put(&quot;acls&quot;, form[&quot;acls&quot;] || [])
        |&gt; Map.put(
          &quot;only_tracked_characters&quot;,
          (form[&quot;only_tracked_characters&quot;] || &quot;false&quot;) |&gt; String.to_existing_atom()
        )
      )

    {:noreply, socket |&gt; assign(form: form)}
  end

  def handle_event(
        &quot;create&quot;,
        %{&quot;form&quot; =&gt; form},
        %{assigns: %{current_user: current_user}} = socket
      )
      when not is_nil(current_user) do
    scope =
      form
      |&gt; Map.get(&quot;scope&quot;)
      |&gt; case do
        &quot;&quot; -&gt; &quot;wormholes&quot;
        scope -&gt; scope
      end

    form = form |&gt; Map.put(&quot;scope&quot;, scope)

    case WandererApp.Api.Map.new(form) do
      {:ok, new_map} -&gt;
        :telemetry.execute([:wanderer_app, :map, :created], %{count: 1})
        maybe_create_default_acl(form, new_map)

        {:noreply,
         socket
         |&gt; assign_async(:maps, fn -&gt;
           load_maps(current_user)
         end)
         |&gt; push_patch(to: ~p&quot;/maps&quot;)}

      {:error, %{errors: errors}} -&gt;
        error_message =
          errors
          |&gt; Enum.map(fn %{field: _field} = error -&gt;
            &quot;#{Map.get(error, :message, &quot;Field validation error&quot;)}&quot;
          end)
          |&gt; Enum.join(&quot;, &quot;)

        {:noreply,
         socket
         |&gt; put_flash(:error, &quot;Failed to create map: #{error_message}&quot;)
         |&gt; assign(error: error_message)}

      {:error, error} -&gt;
        {:noreply,
         socket
         |&gt; put_flash(:error, &quot;Failed to create map&quot;)
         |&gt; assign(error: error)}
    end
  end

  def handle_event(&quot;edit_map&quot;, %{&quot;data&quot; =&gt; slug}, socket) do
    {:noreply,
     socket
     |&gt; push_patch(to: ~p&quot;/maps/#{slug}/edit&quot;)}
  end

  def handle_event(&quot;open_audit&quot;, %{&quot;data&quot; =&gt; slug}, socket),
    do:
      {:noreply,
       socket
       |&gt; push_navigate(to: ~p&quot;/#{slug}/audit?period=1H&amp;activity=all&quot;)}

  def handle_event(&quot;open_characters&quot;, %{&quot;data&quot; =&gt; slug}, socket),
    do:
      {:noreply,
       socket
       |&gt; push_navigate(to: ~p&quot;/#{slug}/characters&quot;)}

  def handle_event(&quot;open_settings&quot;, %{&quot;data&quot; =&gt; slug}, socket) do
    {:noreply,
     socket
     |&gt; push_patch(to: ~p&quot;/maps/#{slug}/settings&quot;)}
  end

  @impl true
  def handle_event(&quot;change_settings_tab&quot;, %{&quot;tab&quot; =&gt; tab}, socket),
    do: {:noreply, socket |&gt; assign(active_settings_tab: tab)}

  def handle_event(&quot;open_acl&quot;, %{&quot;data&quot; =&gt; id}, socket) do
    {:noreply,
     socket
     |&gt; push_navigate(to: ~p&quot;/access-lists/#{id}&quot;)}
  end

  def handle_event(
        &quot;edit&quot;,
        %{&quot;form&quot; =&gt; form} = _params,
        %{assigns: %{map_slug: map_slug, current_user: current_user}} = socket
      ) do
    {:ok, map} =
      map_slug
      |&gt; WandererApp.Api.Map.get_map_by_slug!()
      |&gt; Ash.load(:acls)

    scope =
      form
      |&gt; Map.get(&quot;scope&quot;)
      |&gt; case do
        &quot;&quot; -&gt; &quot;wormholes&quot;
        scope -&gt; scope
      end

    form =
      form
      |&gt; Map.put(&quot;acls&quot;, form[&quot;acls&quot;] || [])
      |&gt; Map.put(&quot;scope&quot;, scope)
      |&gt; Map.put(
        &quot;only_tracked_characters&quot;,
        (form[&quot;only_tracked_characters&quot;] || &quot;false&quot;) |&gt; String.to_existing_atom()
      )

    map
    |&gt; WandererApp.Api.Map.update(form)
    |&gt; case do
      {:ok, _updated_map} -&gt;
        {added_acls, removed_acls} = map.acls |&gt; Enum.map(&amp; &amp;1.id) |&gt; _get_acls_diff(form[&quot;acls&quot;])

        Phoenix.PubSub.broadcast(
          WandererApp.PubSub,
          &quot;maps:#{map.id}&quot;,
          {:map_acl_updated, added_acls, removed_acls}
        )

        {:ok, tracked_characters} =
          WandererApp.Maps.get_tracked_map_characters(map.id, current_user)

        first_tracked_character_id = Enum.map(tracked_characters, &amp; &amp;1.id) |&gt; List.first()

        added_acls
        |&gt; Enum.each(fn acl_id -&gt;
          {:ok, _} =
            WandererApp.User.ActivityTracker.track_map_event(:map_acl_added, %{
              character_id: first_tracked_character_id,
              user_id: current_user.id,
              map_id: map.id,
              acl_id: acl_id
            })
        end)

        removed_acls
        |&gt; Enum.each(fn acl_id -&gt;
          {:ok, _} =
            WandererApp.User.ActivityTracker.track_map_event(:map_acl_removed, %{
              character_id: first_tracked_character_id,
              user_id: current_user.id,
              map_id: map.id,
              acl_id: acl_id
            })
        end)

        {:noreply,
         socket
         |&gt; push_navigate(to: ~p&quot;/maps&quot;)}

      {:error, error} -&gt;
        {:noreply,
         socket
         |&gt; put_flash(:error, &quot;Failed to update map&quot;)
         |&gt; assign(error: error)}
    end
  end

  def handle_event(&quot;delete&quot;, %{&quot;data&quot; =&gt; map_slug} = _params, socket) do
    map =
      map_slug
      |&gt; WandererApp.Api.Map.get_map_by_slug!()
      |&gt; WandererApp.Api.Map.mark_as_deleted!()

    Phoenix.PubSub.broadcast(
      WandererApp.PubSub,
      &quot;maps:#{map.id}&quot;,
      :map_deleted
    )

    current_user = socket.assigns.current_user

    {:noreply,
     socket
     |&gt; assign_async(:maps, fn -&gt;
       load_maps(current_user)
     end)
     |&gt; push_patch(to: ~p&quot;/maps&quot;)}
  end

  def handle_event(
        &quot;update_options&quot;,
        options_form,
        %{assigns: %{map_id: map_id, map: map}} = socket
      ) do
    options =
      options_form
      |&gt; Map.take([
        &quot;layout&quot;,
        &quot;store_custom_labels&quot;,
        &quot;show_linked_signature_id&quot;,
        &quot;show_linked_signature_id_temp_name&quot;,
        &quot;show_temp_system_name&quot;,
        &quot;restrict_offline_showing&quot;
      ])

    {:ok, updated_map} = WandererApp.MapRepo.update_options(map, options)

    @pubsub_client.broadcast(
      WandererApp.PubSub,
      &quot;maps:#{map_id}&quot;,
      {:options_updated, options}
    )

    {:noreply, socket |&gt; assign(map: updated_map, options_form: options_form)}
  end

  @impl true
  def handle_event(&quot;noop&quot;, _, socket) do
    {:noreply, socket}
  end

  @impl true
  def handle_event(&quot;import&quot;, _form, socket) do
    {:noreply, socket}
  end

  @impl true
  def handle_event(_event, _, socket) do
    {:noreply, socket}
  end

  @impl true
  def handle_info(
        {_event, {:flash, type, message}},
        socket
      ) do
    {:noreply, socket |&gt; put_flash(type, message)}
  end

  @impl true
  def handle_info(
        {ref, result},
        socket
      ) do
    Process.demonitor(ref, [:flush])

    case result do
      :imported -&gt;
        {:noreply,
         socket
         |&gt; assign(importing: false)
         |&gt; put_flash(:info, &quot;Map settings imported successfully!&quot;)}

      _ -&gt;
        {:noreply, socket}
    end
  end

  def handle_progress(
        :settings,
        entry,
        %{assigns: %{current_user: current_user, map_id: map_id}} = socket
      ) do
    if entry.done? do
      [uploaded_file_path] =
        consume_uploaded_entries(socket, :settings, fn %{path: path}, _entry -&gt;
          tmp_file_path =
            System.tmp_dir!()
            |&gt; Path.join(&quot;map_settings_&quot; &lt;&gt; to_string(:rand.uniform(256)) &lt;&gt; &quot;.json&quot;)

          File.cp!(path, tmp_file_path)
          {:ok, tmp_file_path}
        end)

      Task.async(fn -&gt;
        {:ok, data} =
          WandererApp.Utils.JSONUtil.read_json(uploaded_file_path)

        WandererApp.Map.Manager.start_map(map_id)

        :timer.sleep(1000)

        map_id
        |&gt; WandererApp.Map.Server.import_settings(data, current_user.id)

        :imported
      end)

      {:noreply,
       socket
       |&gt; assign(importing: true)
       |&gt; put_flash(:loading, &quot;Importing map settings...&quot;)}
    else
      {:noreply, socket}
    end
  end

  defp _additional_price(
         %{&quot;characters_limit&quot; =&gt; characters_limit, &quot;hubs_limit&quot; =&gt; hubs_limit},
         selected_subscription
       ) do
    %{
      extra_characters_100: extra_characters_100,
      extra_hubs_10: extra_hubs_10
    } = WandererApp.Env.subscription_settings()

    additional_price = 0

    characters_limit = characters_limit |&gt; String.to_integer()
    hubs_limit = hubs_limit |&gt; String.to_integer()
    sub_characters_limit = selected_subscription.characters_limit
    sub_hubs_limit = selected_subscription.hubs_limit

    additional_price =
      case characters_limit &gt; sub_characters_limit do
        true -&gt;
          additional_price +
            (characters_limit - sub_characters_limit) / 100 * extra_characters_100

        _ -&gt;
          additional_price
      end

    additional_price =
      case hubs_limit &gt; sub_hubs_limit do
        true -&gt;
          additional_price + (hubs_limit - sub_hubs_limit) / 10 * extra_hubs_10

        _ -&gt;
          additional_price
      end

    additional_price
  end

  defp _get_export_map_data(map) do
    %{
      systems: map.systems |&gt; Enum.map(&amp;_map_ui_system/1),
      hubs: map.hubs,
      connections: map.connections |&gt; Enum.map(&amp;_map_ui_connection/1)
    }
  end

  defp _map_ui_system(
         %{
           solar_system_id: solar_system_id,
           name: name,
           description: description,
           position_x: position_x,
           position_y: position_y,
           locked: locked,
           tag: tag,
           labels: labels,
           status: status,
           visible: visible
         } = _system
       ) do
    %{
      id: &quot;#{solar_system_id}&quot;,
      position: %{x: position_x, y: position_y},
      description: description,
      name: name,
      labels: labels,
      locked: locked,
      status: status,
      tag: tag,
      visible: visible
    }
  end

  defp _map_ui_connection(
         %{
           solar_system_source: solar_system_source,
           solar_system_target: solar_system_target,
           mass_status: mass_status,
           time_status: time_status,
           ship_size_type: ship_size_type,
           locked: locked
         } = _connection
       ),
       do: %{
         id: &quot;#{solar_system_source}_#{solar_system_target}&quot;,
         mass_status: mass_status,
         time_status: time_status,
         ship_size_type: ship_size_type,
         locked: locked,
         source: &quot;#{solar_system_source}&quot;,
         target: &quot;#{solar_system_target}&quot;
       }

  defp load_maps(current_user) do
    {:ok, maps} = WandererApp.Maps.get_available_maps(current_user)

    maps =
      maps
      |&gt; Enum.sort_by(&amp; &amp;1.name, :asc)
      |&gt; Enum.map(fn map -&gt;
        map |&gt; Ash.load!(:user_permissions, actor: current_user)
      end)
      |&gt; Enum.map(fn map -&gt;
        acls =
          map.acls
          |&gt; Enum.map(fn acl -&gt; acl |&gt; Ash.load!(:members) end)

        {:ok, characters_count} =
          map.id
          |&gt; WandererApp.MapCharacterSettingsRepo.get_tracked_by_map_all()
          |&gt; case do
            {:ok, settings} -&gt;
              {:ok,
               settings
               |&gt; Enum.count()}

            _ -&gt;
              {:ok, 0}
          end

        %{map | acls: acls} |&gt; Map.put(:characters_count, characters_count)
      end)

    {:ok, %{maps: maps}}
  end

  defp _get_acls_diff(acls, nil) do
    {[], acls}
  end

  defp _get_acls_diff(acls, new_acls) do
    removed_acls = acls -- new_acls
    added_acls = new_acls -- acls

    {added_acls, removed_acls}
  end

  defp maybe_create_default_acl(%{&quot;create_default_acl&quot; =&gt; &quot;true&quot;} = _form, new_map) do
    {:ok, acl} =
      WandererApp.Api.AccessList.new(%{
        name: &quot;#{new_map.name} ACL&quot;,
        description: &quot;Default ACL for #{new_map.name}&quot;,
        owner_id: new_map.owner_id
      })

    {:ok, _} = WandererApp.Api.Map.update_acls(new_map, %{acls: [acl.id]})
  end

  defp maybe_create_default_acl(_form, _new_map), do: :ok

  defp load_access_lists(socket) do
    {:ok, access_lists} = WandererApp.Acls.get_available_acls(socket.assigns.current_user)

    socket |&gt; assign(acls: access_lists |&gt; Enum.map(&amp;map_acl/1))
  end

  defp map_acl(%{name: name, id: id} = _acl) do
    %{label: name, value: id, id: id}
  end

  defp map_acl_value(acl) do
    acl
  end

  defp map_character(%{name: name, id: id, eve_id: eve_id} = _character) do
    %{label: name, value: id, id: id, eve_id: eve_id}
  end

  defp map_character(_character), do: nil

  defp map_map(%{acls: acls} = map) do
    map
    |&gt; Map.put(:acls, acls |&gt; Enum.map(&amp;map_acl/1))
  end
end</file><file path="lib/wanderer_app_web/live/maps/maps_live.html.heex">&lt;div class=&quot;grid grid-flow-row gap-2 p-3 h-full w-full pl-20&quot;&gt;
  &lt;main class=&quot;w-full rounded-lg shadow col-span-2 lg:col-span-1 overflow-auto p-3&quot;&gt;
    &lt;div class=&quot;gap-4 grid grid-cols-2 lg:grid-cols-5 md:grid-cols-3 sm:grid-cols-3 &quot;&gt;
      &lt;.link
        :if={not @restrict_maps_creation?}
        class=&quot;card h-[250px] rounded-none bg-gradient-to-l from-stone-950 to-stone-900 hover:text-white transform transition duration-500&quot;
        patch={~p&quot;/maps/new&quot;}
      &gt;
        &lt;div class=&quot;card-body justify-center items-center&quot;&gt;
          &lt;.icon name=&quot;hero-plus-solid&quot; class=&quot;w-20 h-20&quot; /&gt;
          &lt;h3 class=&quot;card-title text-center text-md&quot;&gt;Create Map&lt;/h3&gt;
        &lt;/div&gt;
      &lt;/.link&gt;
      &lt;.async_result :if={assigns[:maps]} :let={maps} assign={@maps}&gt;
        &lt;:loading&gt;
          &lt;div class=&quot;skeleton card rounded&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;skeleton card rounded&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;skeleton card rounded&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;skeleton card rounded&quot;&gt;&lt;/div&gt;
        &lt;/:loading&gt;
        &lt;:failed :let={reason}&gt;&lt;%= reason %&gt;&lt;/:failed&gt;
        &lt;.link
          :for={map &lt;- maps}
          navigate={~p&quot;/#{map.slug}&quot;}
          class=&quot;card h-[250px] rounded-none bg-gradient-to-l from-stone-950 to-stone-900 hover:text-white&quot;
        &gt;
          &lt;figure class=&quot;absolute z-10 h-200 avatar w-full h-full&quot;&gt;
            &lt;img :if={map.scope === :all} class=&quot;absolute h-200&quot; src=&quot;/images/all_back.webp&quot; /&gt;
            &lt;img
              :if={map.scope === :wormholes}
              class=&quot;absolute h-200&quot;
              src=&quot;/images/wh_back.jpg&quot;
            /&gt;
            &lt;img
              :if={map.scope === :stargates}
              class=&quot;absolute h-200&quot;
              src=&quot;/images/stargates_back.webp&quot;
            /&gt;
          &lt;/figure&gt;

          &lt;div class=&quot;absolute z-50 left-0 top-0 w-full h-full p-6 flex flex-col justify-between bg-opacity-70 bg-neutral-900 hover:bg-opacity-30 transform transition duration-500&quot;&gt;
            &lt;div&gt;
              &lt;h2 class=&quot;card-title text-sm&quot;&gt;
                &lt;%= map.name %&gt;
              &lt;/h2&gt;
              &lt;p title={map.description} class=&quot;text-sm mt-4 line-clamp-2&quot;&gt;
                &lt;%= map.description %&gt;
              &lt;/p&gt;
              &lt;div
                :if={WandererApp.Maps.can_view_acls?(map, @current_user)}
                class=&quot;w-full flex gap-2 mt-2 text-xs&quot;
              &gt;
                &lt;button
                  :for={acl &lt;- map.acls}
                  class=&quot;p-tag p-component rounded-none hover:text-white&quot;
                  id={&quot;map-acl-#{acl.id}&quot;}
                  type=&quot;button&quot;
                  phx-hook=&quot;MapAction&quot;
                  data-event=&quot;open_acl&quot;
                  data-data={acl.id}
                &gt;
                  &lt;div class=&quot;p-tag-value&quot;&gt;
                    &lt;%= acl.name %&gt;
                  &lt;/div&gt;
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div&gt;
              &lt;h2 class=&quot;w-full flex justify-between mb-4 text-sm&quot;&gt;
                Tracked Characters:
                &lt;span class=&quot;font-bold&quot;&gt;
                  &lt;%= map.characters_count %&gt;
                &lt;/span&gt;
              &lt;/h2&gt;
              &lt;div class=&quot;flex gap-2 justify-end&quot;&gt;
                &lt;button
                  :if={WandererApp.Maps.can_edit?(map, @current_user)}
                  id={&quot;map-characters-#{map.slug}&quot;}
                  phx-hook=&quot;MapAction&quot;
                  data-event=&quot;open_characters&quot;
                  data-data={map.slug}
                  class=&quot;h-8 w-8 hover:text-white&quot;
                &gt;
                  &lt;.icon name=&quot;hero-user-group-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
                &lt;/button&gt;
                &lt;button
                  :if={WandererApp.Maps.can_edit?(map, @current_user)}
                  id={&quot;map-audit-#{map.slug}&quot;}
                  phx-hook=&quot;MapAction&quot;
                  data-event=&quot;open_audit&quot;
                  data-data={map.slug}
                  class=&quot;h-8 w-8 hover:text-white&quot;
                &gt;
                  &lt;.icon name=&quot;hero-key-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
                &lt;/button&gt;
                &lt;button
                  :if={WandererApp.Maps.can_edit?(map, @current_user)}
                  id={&quot;map-settings-#{map.slug}&quot;}
                  phx-hook=&quot;MapAction&quot;
                  data-event=&quot;open_settings&quot;
                  data-data={map.slug}
                  class=&quot;h-8 w-8 hover:text-white&quot;
                &gt;
                  &lt;.icon name=&quot;hero-cog-6-tooth-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
                &lt;/button&gt;
                &lt;button
                  :if={WandererApp.Maps.can_edit?(map, @current_user)}
                  id={&quot;edit-map-#{map.slug}&quot;}
                  class=&quot;h-8 w-8 hover:text-white&quot;
                  type=&quot;button&quot;
                  phx-hook=&quot;MapAction&quot;
                  data-event=&quot;edit_map&quot;
                  data-data={map.slug}
                &gt;
                  &lt;.icon name=&quot;hero-pencil-square-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
                &lt;/button&gt;
                &lt;button
                  :if={WandererApp.Maps.can_edit?(map, @current_user)}
                  id={&quot;delete-map-#{map.slug}&quot;}
                  class=&quot;h-8 w-8 hover:text-white&quot;
                  phx-hook=&quot;MapAction&quot;
                  data-event=&quot;delete&quot;
                  data-data={map.slug}
                  data-confirm=&quot;Please confirm to delete map!&quot;
                &gt;
                  &lt;.icon name=&quot;hero-trash-solid&quot; class=&quot;w-6 h-6&quot; /&gt;
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/.link&gt;
      &lt;/.async_result&gt;
    &lt;/div&gt;
  &lt;/main&gt;
&lt;/div&gt;

&lt;.modal
  :if={@is_connected? &amp;&amp; @live_action in [:create, :edit]}
  title={&quot;#{(@live_action == :create &amp;&amp; &quot;Create&quot;) || &quot;Edit&quot;} Map&quot;}
  class=&quot;!w-[500px]&quot;
  id=&quot;add_map_modal&quot;
  show
  on_cancel={JS.patch(~p&quot;/maps&quot;)}
&gt;
  &lt;.form :let={f} for={@form} phx-change=&quot;validate&quot; phx-submit={@live_action} autocomplete=&quot;off&quot;&gt;
    &lt;.input type=&quot;text&quot; field={f[:name]} placeholder=&quot;Name&quot; /&gt;
    &lt;.input type=&quot;text&quot; field={f[:slug]} prefix={@uri} placeholder=&quot;map-slug&quot; /&gt;
    &lt;.input type=&quot;textarea&quot; field={f[:description]} placeholder=&quot;Public description&quot; /&gt;
    &lt;.input
      type=&quot;select&quot;
      field={f[:owner_id]}
      class=&quot;select h-8 min-h-[10px] !pt-1 !pb-1 text-sm bg-neutral-900&quot;
      wrapper_class=&quot;mt-2&quot;
      label=&quot;Map owner&quot;
      placeholder=&quot;Select a map owner&quot;
      options={Enum.map(@characters, fn character -&gt; {character.label, character.id} end)}
    /&gt;
    &lt;.input
      type=&quot;select&quot;
      field={f[:scope]}
      class=&quot;select h-8 min-h-[10px] !pt-1 !pb-1 text-sm bg-neutral-900&quot;
      wrapper_class=&quot;mt-2&quot;
      label=&quot;Map scope&quot;
      placeholder=&quot;Select a map scope&quot;
      options={Enum.map(@scopes, fn scope -&gt; {scope, scope} end)}
    /&gt;
    &lt;.input
      type=&quot;checkbox&quot;
      field={f[:only_tracked_characters]}
      label=&quot;Allow only tracked characters&quot;
    /&gt;
    &lt;.input
      :if={@live_action == :create}
      type=&quot;checkbox&quot;
      field={f[:create_default_acl]}
      label=&quot;Create default access list&quot;
    /&gt;
    &lt;.live_select
      field={f[:acls]}
      dropdown_extra_class=&quot;!h-24&quot;
      value_mapper={&amp;map_acl_value/1}
      debounce={250}
      update_min_len={2}
      mode={:tags}
      options={@acls}
      placeholder=&quot;Add an existing access list&quot;
    /&gt;
    &lt;div class=&quot;modal-action&quot;&gt;
      &lt;.button class=&quot;mt-2&quot; type=&quot;submit&quot;&gt;
        &lt;%= (@live_action == :create &amp;&amp; &quot;Create&quot;) || &quot;Save&quot; %&gt;
      &lt;/.button&gt;
    &lt;/div&gt;
  &lt;/.form&gt;
&lt;/.modal&gt;

&lt;.modal
  :if={@live_action in [:settings] &amp;&amp; not is_nil(assigns[:map])}
  title=&quot;Map Settings&quot;
  class=&quot;!min-w-[700px]&quot;
  id=&quot;map-settings-modal&quot;
  show
  on_cancel={JS.patch(~p&quot;/maps&quot;)}
&gt;
  &lt;div class=&quot;flex flex-col gap-3&quot;&gt;
    &lt;div class=&quot;flex flex-col gap-2&quot;&gt;
      &lt;div class=&quot;verticalTabsContainer&quot;&gt;
        &lt;div class=&quot;p-tabview p-component&quot; data-pc-name=&quot;tabview&quot; data-pc-section=&quot;root&quot;&gt;
          &lt;div class=&quot;p-tabview-nav-container&quot; data-pc-section=&quot;navcontainer&quot;&gt;
            &lt;div class=&quot;p-tabview-nav-content&quot; data-pc-section=&quot;navcontent&quot;&gt;
              &lt;ul class=&quot;p-tabview-nav&quot; role=&quot;tablist&quot; data-pc-section=&quot;nav&quot;&gt;
                &lt;li
                  class={[
                    &quot;p-unselectable-text&quot;,
                    classes(&quot;p-tabview-selected p-highlight&quot;: @active_settings_tab == &quot;general&quot;)
                  ]}
                  role=&quot;presentation&quot;
                  data-pc-name=&quot;&quot;
                  data-pc-section=&quot;header&quot;
                &gt;
                  &lt;a
                    role=&quot;tab&quot;
                    class=&quot;p-tabview-nav-link flex p-[10px]&quot;
                    tabindex=&quot;0&quot;
                    aria-controls=&quot;pr_id_330_content&quot;
                    aria-selected=&quot;true&quot;
                    aria-disabled=&quot;false&quot;
                    data-pc-section=&quot;headeraction&quot;
                    phx-click=&quot;change_settings_tab&quot;
                    phx-value-tab=&quot;general&quot;
                  &gt;
                    &lt;span class=&quot;p-tabview-title&quot; data-pc-section=&quot;headertitle&quot;&gt;
                      &lt;.icon name=&quot;hero-wrench-screwdriver-solid&quot; class=&quot;w-4 h-4&quot; /&gt;&amp;nbsp;General
                    &lt;/span&gt;
                  &lt;/a&gt;
                &lt;/li&gt;

                &lt;li
                  :if={@map_subscriptions_enabled?}
                  class={[
                    &quot;p-unselectable-text&quot;,
                    classes(&quot;p-tabview-selected p-highlight&quot;: @active_settings_tab == &quot;balance&quot;)
                  ]}
                  role=&quot;presentation&quot;
                  data-pc-name=&quot;&quot;
                  data-pc-section=&quot;header&quot;
                &gt;
                  &lt;a
                    role=&quot;tab&quot;
                    class=&quot;p-tabview-nav-link flex p-[10px]&quot;
                    tabindex=&quot;-1&quot;
                    aria-controls=&quot;pr_id_332_content&quot;
                    aria-selected=&quot;false&quot;
                    aria-disabled=&quot;false&quot;
                    data-pc-section=&quot;headeraction&quot;
                    phx-click=&quot;change_settings_tab&quot;
                    phx-value-tab=&quot;balance&quot;
                  &gt;
                    &lt;span class=&quot;p-tabview-title&quot; data-pc-section=&quot;headertitle&quot;&gt;
                      &lt;.icon name=&quot;hero-banknotes-solid&quot; class=&quot;w-4 h-4&quot; /&gt;&amp;nbsp;Balance
                    &lt;/span&gt;
                  &lt;/a&gt;
                &lt;/li&gt;

                &lt;li
                  :if={@map_subscriptions_enabled?}
                  class={[
                    &quot;p-unselectable-text&quot;,
                    classes(
                      &quot;p-tabview-selected p-highlight&quot;: @active_settings_tab == &quot;subscription&quot;
                    )
                  ]}
                  role=&quot;presentation&quot;
                  data-pc-name=&quot;&quot;
                  data-pc-section=&quot;header&quot;
                &gt;
                  &lt;a
                    role=&quot;tab&quot;
                    class=&quot;p-tabview-nav-link flex p-[10px]&quot;
                    tabindex=&quot;-1&quot;
                    aria-controls=&quot;pr_id_334_content&quot;
                    aria-selected=&quot;false&quot;
                    aria-disabled=&quot;false&quot;
                    data-pc-section=&quot;headeraction&quot;
                    phx-click=&quot;change_settings_tab&quot;
                    phx-value-tab=&quot;subscription&quot;
                  &gt;
                    &lt;span class=&quot;p-tabview-title&quot; data-pc-section=&quot;headertitle&quot;&gt;
                      &lt;.icon name=&quot;hero-check-badge-solid&quot; class=&quot;w-4 h-4&quot; /&gt;&amp;nbsp;Subscription
                    &lt;/span&gt;
                  &lt;/a&gt;
                &lt;/li&gt;

                &lt;li
                  class={[
                    &quot;p-unselectable-text&quot;,
                    classes(&quot;p-tabview-selected p-highlight&quot;: @active_settings_tab == &quot;import&quot;)
                  ]}
                  role=&quot;presentation&quot;
                  data-pc-name=&quot;&quot;
                  data-pc-section=&quot;header&quot;
                &gt;
                  &lt;a
                    role=&quot;tab&quot;
                    class=&quot;p-tabview-nav-link flex p-[10px]&quot;
                    tabindex=&quot;-1&quot;
                    aria-controls=&quot;pr_id_331_content&quot;
                    aria-selected=&quot;false&quot;
                    aria-disabled=&quot;false&quot;
                    data-pc-section=&quot;headeraction&quot;
                    phx-click=&quot;change_settings_tab&quot;
                    phx-value-tab=&quot;import&quot;
                  &gt;
                    &lt;span class=&quot;p-tabview-title&quot; data-pc-section=&quot;headertitle&quot;&gt;
                      &lt;.icon name=&quot;hero-document-arrow-down-solid&quot; class=&quot;w-4 h-4&quot; /&gt;&amp;nbsp;Import/Export
                    &lt;/span&gt;
                  &lt;/a&gt;
                &lt;/li&gt;
                &lt;li
                  :if={not WandererApp.Env.public_api_disabled?()}
                  class={[
                    &quot;p-unselectable-text&quot;,
                    classes(
                      &quot;p-tabview-selected p-highlight&quot;: @active_settings_tab == &quot;public_api&quot;
                    )
                  ]}
                  role=&quot;presentation&quot;
                  data-pc-name=&quot;&quot;
                  data-pc-section=&quot;header&quot;
                &gt;
                  &lt;a
                    role=&quot;tab&quot;
                    class=&quot;p-tabview-nav-link flex p-[10px]&quot;
                    tabindex=&quot;-1&quot;
                    aria-controls=&quot;pr_id_335_content&quot;
                    aria-selected=&quot;false&quot;
                    aria-disabled=&quot;false&quot;
                    data-pc-section=&quot;headeraction&quot;
                    phx-click=&quot;change_settings_tab&quot;
                    phx-value-tab=&quot;public_api&quot;
                  &gt;
                    &lt;span class=&quot;p-tabview-title&quot; data-pc-section=&quot;headertitle&quot;&gt;
                      &lt;.icon name=&quot;hero-globe-alt-solid&quot; class=&quot;w-4 h-4&quot; /&gt;&amp;nbsp;Public Api
                    &lt;/span&gt;
                  &lt;/a&gt;
                &lt;/li&gt;
                &lt;li
                :if={@map_subscriptions_enabled?}
                  class={[
                    &quot;p-unselectable-text&quot;,
                    classes(
                      &quot;p-tabview-selected p-highlight&quot;: @active_settings_tab == &quot;bot&quot;
                    )
                  ]}
                  role=&quot;presentation&quot;
                  data-pc-name=&quot;&quot;
                  data-pc-section=&quot;header&quot;
                &gt;
                  &lt;a
                    role=&quot;tab&quot;
                    class=&quot;p-tabview-nav-link flex p-[10px]&quot;
                    tabindex=&quot;-1&quot;
                    aria-controls=&quot;pr_id_335_content&quot;
                    aria-selected=&quot;false&quot;
                    aria-disabled=&quot;false&quot;
                    data-pc-section=&quot;headeraction&quot;
                    phx-click=&quot;change_settings_tab&quot;
                    phx-value-tab=&quot;bot&quot;
                  &gt;
                    &lt;span class=&quot;p-tabview-title&quot; data-pc-section=&quot;headertitle&quot;&gt;
                      &lt;.icon name=&quot;hero-puzzle-piece-solid&quot; class=&quot;w-4 h-4&quot; /&gt;&amp;nbsp;Bots
                    &lt;/span&gt;
                  &lt;/a&gt;
                &lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div class=&quot;p-tabview-panels&quot; data-pc-section=&quot;panelcontainer&quot;&gt;
            &lt;div
              id=&quot;pr_id_330_content&quot;
              class=&quot;p-tabview-panel&quot;
              role=&quot;tabpanel&quot;
              aria-labelledby=&quot;pr_id_33_header_0&quot;
              data-pc-name=&quot;&quot;
              data-pc-section=&quot;content&quot;
            &gt;
              &lt;div :if={@active_settings_tab == &quot;general&quot;}&gt;
                &lt;.form
                  :let={f}
                  :if={assigns |&gt; Map.get(:options_form, false)}
                  for={@options_form}
                  phx-change=&quot;update_options&quot;
                &gt;
                  &lt;.input
                    type=&quot;select&quot;
                    field={f[:layout]}
                    class=&quot;select h-8 min-h-[10px] !pt-1 !pb-1 text-sm bg-neutral-900&quot;
                    label=&quot;Map systems layout&quot;
                    placeholder=&quot;Map default layout&quot;
                    options={@layout_options}
                  /&gt;
                  &lt;.input
                    type=&quot;checkbox&quot;
                    field={f[:store_custom_labels]}
                    label=&quot;Store system custom labels&quot;
                  /&gt;
                  &lt;.input
                    type=&quot;checkbox&quot;
                    field={f[:show_temp_system_name]}
                    label=&quot;Allow temporary system names&quot;
                  /&gt;
                  &lt;.input
                    type=&quot;checkbox&quot;
                    field={f[:show_linked_signature_id]}
                    label=&quot;Show linked signature ID as custom label part&quot;
                  /&gt;
                  &lt;.input
                    type=&quot;checkbox&quot;
                    field={f[:show_linked_signature_id_temp_name]}
                    label=&quot;Show linked signature ID as temporary name part&quot;
                  /&gt;
                  &lt;.input
                    type=&quot;checkbox&quot;
                    field={f[:restrict_offline_showing]}
                    label=&quot;Show offline characters to admins &amp; managers only&quot;
                  /&gt;
                &lt;/.form&gt;
              &lt;/div&gt;

              &lt;div :if={@active_settings_tab == &quot;import&quot;}&gt;
                &lt;.form
                  :if={assigns |&gt; Map.get(:import_form, false)}
                  for={@import_form}
                  phx-change=&quot;import&quot;
                &gt;
                  &lt;div phx-drop-target=&quot;{@uploads.settings.ref}&quot;&gt;
                    &lt;.live_file_input upload={@uploads.settings} /&gt;
                  &lt;/div&gt;
                &lt;/.form&gt;
                &lt;progress :if={@importing} class=&quot;progress w-56&quot;&gt;&lt;/progress&gt;
                &lt;.button
                  id=&quot;export-settings-btn&quot;
                  class=&quot;mt-8&quot;
                  type=&quot;button&quot;
                  disabled={@importing}
                  phx-hook=&quot;DownloadJson&quot;
                  data-name={@map_slug}
                  data-content={Jason.encode!(assigns[:export_settings] || %{})}
                &gt;
                  &lt;.icon name=&quot;hero-document-arrow-down-solid&quot; class=&quot;w-4 h-4&quot; /&gt; Export Settings
                &lt;/.button&gt;
              &lt;/div&gt;

              &lt;div :if={@active_settings_tab == &quot;bot&quot;}&gt;
                &lt;h3 class=&quot;text-lg font-semibold mb-2&quot;&gt;Bots Integration&lt;/h3&gt;
                &lt;div class=&quot;mb-6 p-4 border rounded-md&quot;&gt;
                  &lt;p class=&quot;mb-2&quot;&gt;
                    The bot license allows you to integrate your map with automated tools and bots.
                    Here&apos;s how to use it:
                  &lt;/p&gt;
                  &lt;ol class=&quot;list-decimal pl-5 mb-4 space-y-2&quot;&gt;
                    &lt;li&gt;Create a license key below (requires an active subscription)&lt;/li&gt;
                    &lt;li&gt;Use the license key to authenticate your bot with our API&lt;/li&gt;
                    &lt;%!-- &lt;li&gt;
                      Make API calls to &lt;code class=&quot;bg-gray-800 px-1 py-0.5 rounded&quot;&gt;GET /api/license/validate&lt;/code&gt;
                      with the license key as a Bearer token in the Authorization header
                    &lt;/li&gt;
                    &lt;li&gt;
                      If valid, you&apos;ll receive the map ID which you can use for other API endpoints
                    &lt;/li&gt; --%&gt;
                  &lt;/ol&gt;
                  &lt;p class=&quot;text-sm text-gray-600&quot;&gt;
                    For detailed API documentation, please refer to our
                    &lt;a href=&quot;/license&quot; class=&quot;text-blue-600 hover:underline&quot;&gt;API documentation&lt;/a&gt;.
                  &lt;/p&gt;
                &lt;/div&gt;

                &lt;.live_component
                  module={WandererAppWeb.Maps.LicenseComponent}
                  id=&quot;license-component&quot;
                  map_id={@map.id}
                /&gt;
              &lt;/div&gt;

              &lt;div
                :if={
                  @active_settings_tab == &quot;public_api&quot; and
                    not WandererApp.Env.public_api_disabled?()
                }
                class=&quot;p-6&quot;
              &gt;
                &lt;h2 class=&quot;text-lg font-semibold mb-4&quot;&gt;Public API&lt;/h2&gt;
                &lt;div class=&quot;flex flex-col gap-3 items-start w-full&quot;&gt;
                  &lt;div&gt;
                    &lt;input
                      :if={not is_nil(@public_api_key)}
                      class=&quot;input input-bordered text-sm truncate bg-neutral-800 text-white w-[350px]&quot;
                      readonly
                      type=&quot;text&quot;
                      value={@public_api_key}
                    /&gt;
                    &lt;input
                      :if={is_nil(@public_api_key)}
                      class=&quot;input input-bordered text-sm truncate bg-neutral-800 text-gray-400 w-[350px]&quot;
                      readonly
                      type=&quot;text&quot;
                      placeholder=&quot;No Public API Key yet&quot;
                    /&gt;
                  &lt;/div&gt;
                  &lt;div class=&quot;flex items-center gap-2&quot;&gt;
                    &lt;.button
                      type=&quot;button&quot;
                      phx-click=&quot;generate-map-api-key&quot;
                      class=&quot;p-button p-component p-button-primary&quot;
                      style=&quot;min-width: 120px;&quot;
                    &gt;
                      &lt;span class=&quot;p-button-label&quot;&gt;Generate&lt;/span&gt;
                    &lt;/.button&gt;
                    &lt;.button
                      type=&quot;button&quot;
                      phx-hook=&quot;CopyToClipboard&quot;
                      id=&quot;copy-map-api-key&quot;
                      data-url={@public_api_key}
                      disabled={is_nil(@public_api_key)}
                      class={&quot;p-button p-component &quot; &lt;&gt; if(is_nil(@public_api_key), do: &quot;p-disabled&quot;, else: &quot;&quot;)}
                    &gt;
                      &lt;span class=&quot;p-button-label&quot;&gt;Copy&lt;/span&gt;
                    &lt;/.button&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;

              &lt;.live_component
                :if={@active_settings_tab == &quot;balance&quot;}
                module={WandererAppWeb.Maps.MapBalanceComponent}
                id=&quot;map-balance-component&quot;
                map_id={@map.id}
                notify_to={self()}
                event_name=&quot;balance_event&quot;
                current_user={@current_user}
              /&gt;

              &lt;.live_component
                :if={@active_settings_tab == &quot;subscription&quot;}
                module={WandererAppWeb.Maps.MapSubscriptionsComponent}
                id=&quot;map-subscriptions-component&quot;
                map_id={@map.id}
                notify_to={self()}
                event_name=&quot;subscriptions_event&quot;
                current_user={@current_user}
              /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;modal-action&quot;&gt;

  &lt;/div&gt;
&lt;/.modal&gt;</file><file path="lib/wanderer_app_web/live/profile/profile_live.ex">defmodule WandererAppWeb.ProfileLive do
  use WandererAppWeb, :live_view

  require Logger

  alias BetterNumber, as: Number

  def mount(_params, %{&quot;user_id&quot; =&gt; user_id} = _session, socket)
      when not is_nil(user_id) do
    WandererApp.Env.map_subscriptions_enabled?()
    |&gt; case do
      true -&gt;
        {:ok, characters} = WandererApp.Api.Character.active_by_user(%{user_id: user_id})

        user =
          user_id
          |&gt; WandererApp.User.load()

        {:ok, user_balance} =
          user
          |&gt; WandererApp.User.get_balance()

        {:ok, latest_transactions} =
          WandererApp.Api.CorpWalletTransaction.latest_by_characters(%{
            eve_character_ids:
              characters
              |&gt; Enum.map(&amp; &amp;1.eve_id)
              |&gt; Enum.map(&amp;String.to_integer/1)
          })

        {:ok, invoices} = WandererApp.Api.MapTransaction.by_user(%{user_id: user_id})

        Phoenix.PubSub.subscribe(
          WandererApp.PubSub,
          &quot;user:#{user_id}&quot;
        )

        {:ok,
         socket
         |&gt; assign(
           wanderer_balance: user_balance,
           characters_count: characters |&gt; Enum.count(),
           user_id: user_id,
           user_hash: user.hash,
           invoices: invoices,
           transactions: latest_transactions
         )}

      _ -&gt;
        {:ok,
         socket
         |&gt; push_navigate(to: ~p&quot;/maps&quot;)}
    end
  end

  @impl true
  def mount(_params, _session, socket) do
    {:ok, socket |&gt; assign(characters_count: 0, user_id: nil)}
  end

  @impl true
  def handle_params(params, _url, socket) do
    {:noreply, apply_action(socket, socket.assigns.live_action, params)}
  end

  @impl true
  def handle_info(
        :wanderer_balance_changed,
        socket
      ) do
    socket =
      case WandererApp.User.load(socket.assigns.current_user.id) do
        nil -&gt;
          socket
          |&gt; assign(:wanderer_balance, 0.0)

        user -&gt;
          socket
          |&gt; assign(:wanderer_balance, user.wanderer_balance)
      end

    {:noreply, socket}
  end

  attr :corporation_id, :any, default: nil
  attr :corporation_info, :any, default: nil

  def corporation_info(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div
      :if={@corporation_info}
      class=&quot;flex flex-row items-center justify-between gap-2 p-4 bg-stone-950 bg-opacity-70 rounded-lg&quot;
    &gt;
      &lt;div class=&quot;avatar&quot;&gt;
        &lt;div class=&quot;rounded-md w-12 h-12&quot;&gt;
          &lt;img
            src={member_icon_url(%{eve_corporation_id: @corporation_id})}
            alt={@corporation_info[&quot;name&quot;]}
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;span&gt;&amp;nbsp; &lt;%= @corporation_info[&quot;name&quot;] %&gt;&lt;/span&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  defp apply_action(socket, :index, _params) do
    socket
    |&gt; assign(:active_page, :profile)
    |&gt; assign(:page_title, &quot;Profile&quot;)
  end

  defp apply_action(socket, :deposit, _params) do
    socket
    |&gt; _load_corp_info(WandererApp.Env.corp_eve_id())
    |&gt; assign(:active_page, :profile)
    |&gt; assign(:page_title, &quot;Deposit ISK - Profile&quot;)
  end

  defp apply_action(socket, :subscribe, _params) do
    socket
    |&gt; assign(:active_page, :profile)
    |&gt; assign(:page_title, &quot;Subscribe - Profile&quot;)
  end

  defp _load_corp_info(socket, -1) do
    socket
    |&gt; assign(:corporation_id, nil)
    |&gt; assign(:corporation_info, nil)
  end

  defp _load_corp_info(socket, corporation_id) do
    case WandererApp.Esi.get_corporation_info(corporation_id) do
      {:ok, corporation_info} -&gt;
        socket
        |&gt; assign(:corporation_id, corporation_id)
        |&gt; assign(:corporation_info, corporation_info)

      error -&gt;
        Logger.warning(fn -&gt;
          &quot;Failed to get corporation info for #{corporation_id}: #{inspect(error)}&quot;
        end)

        socket
        |&gt; assign(:corporation_id, nil)
        |&gt; assign(:corporation_info, nil)
    end
  end
end</file><file path="lib/wanderer_app_web/live/profile/profile_live.html.heex">&lt;main class=&quot;w-full h-full col-span-2 lg:col-span-1 p-4 pl-20 overflow-auto&quot;&gt;
  &lt;div class=&quot;page-content&quot;&gt;
    &lt;div class=&quot;container-fluid px-[0.625rem]&quot;&gt;
      &lt;div class=&quot;grid grid-cols-1 pb-6&quot;&gt;
        &lt;div class=&quot;md:flex items-center justify-between px-[2px]&quot;&gt;
          &lt;h4 class=&quot;text-[18px] font-medium text-gray-800 mb-sm-0 grow dark:text-gray-100 mb-2 md:mb-0&quot;&gt;
            Profile
          &lt;/h4&gt;
          &lt;div class=&quot;flex justify-center items-center gap-2&quot;&gt;
            &lt;span class=&quot;hidden&quot;&gt;&lt;%= @user_hash %&gt;&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;grid grid-cols-1 gap-6 md:grid-cols-2 2xl:grid-cols-4 pb-6&quot;&gt;
        &lt;div class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
          &lt;div class=&quot;card-body&quot;&gt;
            &lt;div class=&quot;col-span-6&quot;&gt;
              &lt;span class=&quot;text-gray-700 dark:text-gray-400&quot;&gt;Account Balance&lt;/span&gt;
              &lt;h4 class=&quot;mt-4 font-medium text-gray-800 text-4xl dark:text-gray-100&quot;&gt;
                &lt;span class=&quot;counter-value&quot;&gt;
                  ISK &lt;%= @wanderer_balance
                  |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;]) %&gt;
                &lt;/span&gt;
              &lt;/h4&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div class=&quot;card-actions justify-end p-6&quot;&gt;
            &lt;.link class=&quot;hover:text-white&quot; patch={~p&quot;/profile/deposit&quot;}&gt;
              &lt;.button type=&quot;button&quot;&gt;Deposit ISK&lt;/.button&gt;
            &lt;/.link&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;grid grid-cols-1 gap-6 gap-y-6 2xl:gap-6 lg:grid-cols-12&quot;&gt;
        &lt;div class=&quot;col-span-12 2xl:col-span-5&quot;&gt;
          &lt;div class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
            &lt;div class=&quot;nav-tabs border-b-tabs&quot;&gt;
              &lt;div class=&quot;flex pb-0 card-body &quot;&gt;
                &lt;h5 class=&quot;flex-grow mr-2 text-gray-800 text-15 dark:text-gray-400&quot;&gt;
                  Transactions
                &lt;/h5&gt;
              &lt;/div&gt;
              &lt;div class=&quot;py-3&quot;&gt;
                &lt;div class=&quot;px-3&quot; data-simplebar=&quot;init&quot; style=&quot;max-height: 352px;&quot;&gt;
                  &lt;div class=&quot;simplebar-wrapper&quot; style=&quot;margin: 0px -12px;&quot;&gt;
                    &lt;div class=&quot;simplebar-height-auto-observer-wrapper&quot;&gt;
                      &lt;div class=&quot;simplebar-height-auto-observer&quot;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;simplebar-mask&quot;&gt;
                      &lt;div class=&quot;simplebar-offset&quot; style=&quot;right: -20px; bottom: 0px;&quot;&gt;
                        &lt;div
                          class=&quot;simplebar-content-wrapper&quot;
                          style=&quot;height: auto; padding-right: 20px; padding-bottom: 0px; overflow: hidden scroll;&quot;
                        &gt;
                          &lt;div class=&quot;simplebar-content&quot; style=&quot;padding: 0px 12px;&quot;&gt;
                            &lt;.table
                              id=&quot;transactions&quot;
                              rows={@transactions}
                              class=&quot;!max-h-[40vh] !overflow-y-auto&quot;
                            &gt;
                              &lt;:col :let={transaction}&gt;
                                &lt;div class=&quot; text-22&quot;&gt;
                                  &lt;.icon name=&quot;hero-credit-card-solid&quot; class=&quot;h-5 w-5&quot; /&gt;
                                &lt;/div&gt;
                              &lt;/:col&gt;
                              &lt;:col :let={transaction} label=&quot;Transaction&quot;&gt;
                                &lt;div&gt;
                                  &lt;h5 class=&quot;mb-1 text-sm font-medium text-gray-700 dark:text-gray-100&quot;&gt;
                                    &lt;%= transaction.reason_encoded %&gt;
                                  &lt;/h5&gt;
                                  &lt;p class=&quot;mb-0 text-xs text-gray-600 dark:text-zinc-100 whitespace-nowrap&quot;&gt;
                                    &lt;.local_time
                                      id={&quot;invoice-inserted-#{transaction.id}&quot;}
                                      at={transaction.date}
                                    &gt;
                                      &lt;%= transaction.date %&gt;
                                    &lt;/.local_time&gt;
                                  &lt;/p&gt;
                                &lt;/div&gt;
                              &lt;/:col&gt;
                              &lt;:col :let={transaction} label=&quot;Description&quot;&gt;
                                &lt;%= transaction.description %&gt;
                              &lt;/:col&gt;
                              &lt;:col :let={transaction} label=&quot;&quot;&gt;
                                &lt;div class=&quot;text-end&quot;&gt;
                                  &lt;h5 class=&quot;mb-0 text-sm text-gray-500 dark:text-zinc-100&quot;&gt;
                                    &lt;%= transaction.amount_encoded
                                    |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;]) %&gt;
                                  &lt;/h5&gt;
                                  &lt;p class=&quot;mb-0 text-xs text-gray-600 dark:text-zinc-100 whitespace-nowrap&quot;&gt;
                                    ISK
                                  &lt;/p&gt;
                                &lt;/div&gt;
                              &lt;/:col&gt;
                            &lt;/.table&gt;
                          &lt;/div&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;simplebar-placeholder&quot; style=&quot;width: auto; height: 448px;&quot;&gt;&lt;/div&gt;
                  &lt;/div&gt;
                  &lt;div class=&quot;simplebar-track simplebar-horizontal&quot; style=&quot;visibility: hidden;&quot;&gt;
                    &lt;div
                      class=&quot;simplebar-scrollbar&quot;
                      style=&quot;transform: translate3d(0px, 0px, 0px); display: none;&quot;
                    &gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                  &lt;div class=&quot;simplebar-track simplebar-vertical&quot; style=&quot;visibility: visible;&quot;&gt;
                    &lt;div
                      class=&quot;simplebar-scrollbar&quot;
                      style=&quot;height: 289px; transform: translate3d(0px, 0px, 0px); display: block;&quot;
                    &gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-span-12 2xl:col-span-5&quot;&gt;
          &lt;div class=&quot;card dark:bg-zinc-800 dark:border-zinc-600&quot;&gt;
            &lt;div class=&quot;nav-tabs border-b-tabs&quot;&gt;
              &lt;div class=&quot;flex pb-0 card-body &quot;&gt;
                &lt;h5 class=&quot;flex-grow mr-2 text-gray-800 text-15 dark:text-gray-400&quot;&gt;
                  Invoices
                &lt;/h5&gt;
              &lt;/div&gt;
              &lt;div class=&quot;py-3&quot;&gt;
                &lt;div class=&quot;px-3&quot; data-simplebar=&quot;init&quot; style=&quot;max-height: 352px;&quot;&gt;
                  &lt;div class=&quot;simplebar-wrapper&quot; style=&quot;margin: 0px -12px;&quot;&gt;
                    &lt;div class=&quot;simplebar-height-auto-observer-wrapper&quot;&gt;
                      &lt;div class=&quot;simplebar-height-auto-observer&quot;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;simplebar-mask&quot;&gt;
                      &lt;div class=&quot;simplebar-offset&quot; style=&quot;right: -20px; bottom: 0px;&quot;&gt;
                        &lt;div
                          class=&quot;simplebar-content-wrapper&quot;
                          style=&quot;height: auto; padding-right: 20px; padding-bottom: 0px; overflow: hidden scroll;&quot;
                        &gt;
                          &lt;div class=&quot;simplebar-content&quot; style=&quot;padding: 0px 12px;&quot;&gt;
                            &lt;.table
                              id=&quot;transactions&quot;
                              rows={@invoices}
                              class=&quot;!max-h-[40vh] !overflow-y-auto&quot;
                            &gt;
                              &lt;:col :let={invoice}&gt;
                                &lt;div class=&quot; text-22&quot;&gt;
                                  Map subscription
                                &lt;/div&gt;
                              &lt;/:col&gt;
                              &lt;:col :let={invoice} label=&quot;Map&quot;&gt;
                                &lt;p class=&quot;mb-0 text-xs text-gray-600 dark:text-zinc-100 whitespace-nowrap&quot;&gt;
                                  &lt;%= invoice.map.name %&gt;
                                &lt;/p&gt;
                              &lt;/:col&gt;
                              &lt;:col :let={invoice} label=&quot;Date&quot;&gt;
                                &lt;p class=&quot;mb-0 text-xs text-gray-600 dark:text-zinc-100 whitespace-nowrap&quot;&gt;
                                  &lt;.local_time
                                    id={&quot;invoice-inserted-#{invoice.id}&quot;}
                                    at={invoice.inserted_at}
                                  &gt;
                                    &lt;%= invoice.inserted_at %&gt;
                                  &lt;/.local_time&gt;
                                &lt;/p&gt;
                              &lt;/:col&gt;
                              &lt;:col :let={invoice} label=&quot;&quot;&gt;
                                &lt;div class=&quot;text-end&quot;&gt;
                                  &lt;h5 class=&quot;mb-0 text-sm text-gray-500 dark:text-zinc-100&quot;&gt;
                                    &lt;%= invoice.amount
                                    |&gt; Number.to_human(units: [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;B&quot;, &quot;T&quot;, &quot;P&quot;]) %&gt;
                                  &lt;/h5&gt;
                                  &lt;p class=&quot;mb-0 text-xs text-gray-600 dark:text-zinc-100 whitespace-nowrap&quot;&gt;
                                    ISK
                                  &lt;/p&gt;
                                &lt;/div&gt;
                              &lt;/:col&gt;
                            &lt;/.table&gt;
                          &lt;/div&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;simplebar-placeholder&quot; style=&quot;width: auto; height: 448px;&quot;&gt;&lt;/div&gt;
                  &lt;/div&gt;
                  &lt;div class=&quot;simplebar-track simplebar-horizontal&quot; style=&quot;visibility: hidden;&quot;&gt;
                    &lt;div
                      class=&quot;simplebar-scrollbar&quot;
                      style=&quot;transform: translate3d(0px, 0px, 0px); display: none;&quot;
                    &gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                  &lt;div class=&quot;simplebar-track simplebar-vertical&quot; style=&quot;visibility: visible;&quot;&gt;
                    &lt;div
                      class=&quot;simplebar-scrollbar&quot;
                      style=&quot;height: 289px; transform: translate3d(0px, 0px, 0px); display: block;&quot;
                    &gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;.modal
    :if={@live_action in [:subscribe]}
    title=&quot;Subscription Plans&quot;
    id=&quot;subscribe-modal&quot;
    show
    on_cancel={JS.patch(~p&quot;/profile&quot;)}
  &gt;
    &lt;div class=&quot;w-full px-4 py-4 mx-auto sm:py-8&quot;&gt;
      &lt;div class=&quot;sm:flex sm:flex-col sm:align-center&quot;&gt;
        &lt;div class=&quot;relative self-center mt-0 bg-zinc-900 rounded-lg p-0.5 flex sm:mt-8 border border-zinc-800&quot;&gt;
          &lt;button
            type=&quot;button&quot;
            class=&quot;relative w-1/2 bg-zinc-700 border-zinc-800 shadow-sm text-white rounded-md m-1 py-2 text-sm font-medium whitespace-nowrap focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-50 focus:z-10 sm:w-auto sm:px-8&quot;
          &gt;
            Monthly billing
          &lt;/button&gt;
          &lt;button
            type=&quot;button&quot;
            class=&quot;ml-0.5 relative w-1/2 border border-transparent text-zinc-400 rounded-md m-1 py-2 text-sm font-medium whitespace-nowrap focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-50 focus:z-10 sm:w-auto sm:px-8&quot;
          &gt;
            Yearly billing
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;mt-4 space-y-0 sm:mt-16 flex items-center justify-center gap-6 w-full lg:mx-auto xl:mx-0&quot;&gt;
        &lt;div class=&quot;flex flex-col rounded-lg shadow-sm divide-y divide-zinc-600 bg-zinc-900 flex-1 basis-1/3 max-w-xs&quot;&gt;
          &lt;div class=&quot;p-6 flex flex-col items-center justify-between h-full&quot;&gt;
            &lt;h2 class=&quot;text-2xl font-semibold leading-6 text-white&quot;&gt;1 month&lt;/h2&gt;
            &lt;p class=&quot;pt-8&quot;&gt;
              &lt;span class=&quot;text-3xl font-extrabold white&quot;&gt;12M&lt;/span&gt;&lt;span class=&quot;mx-2 text-base font-medium text-zinc-100&quot;&gt;ISK/&lt;!-- --&gt;month&lt;/span&gt;
            &lt;/p&gt;
            &lt;button
              data-variant=&quot;slim&quot;
              class=&quot;block w-full py-2 mt-8 text-sm font-semibold text-center text-white rounded-md hover:bg-zinc-900&quot;
              type=&quot;button&quot;
            &gt;
              Subscribe
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;flex flex-col rounded-lg shadow-sm divide-y divide-zinc-600 bg-zinc-900 border border-pink-500 flex-1 basis-1/3 max-w-xs&quot;&gt;
          &lt;div class=&quot;p-6 flex flex-col items-center justify-between h-full&quot;&gt;
            &lt;h2 class=&quot;text-2xl font-semibold leading-6 text-white&quot;&gt;3 months&lt;/h2&gt;
            &lt;p class=&quot;mt-8&quot;&gt;
              &lt;span class=&quot;text-3xl font-extrabold white&quot;&gt;10M&lt;/span&gt;&lt;span class=&quot;mx-2 text-base font-medium text-zinc-100&quot;&gt;ISK/&lt;!-- --&gt;month&lt;/span&gt;
            &lt;/p&gt;
            &lt;button
              data-variant=&quot;slim&quot;
              class=&quot;block w-full py-2 mt-8 text-sm font-semibold text-center text-white rounded-md hover:bg-zinc-900&quot;
              type=&quot;button&quot;
            &gt;
              Subscribe
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;flex flex-col rounded-lg shadow-sm divide-y divide-zinc-600 bg-zinc-900 flex-1 basis-1/3 max-w-xs&quot;&gt;
          &lt;div class=&quot;p-6 flex flex-col items-center justify-between h-full&quot;&gt;
            &lt;h2 class=&quot;text-2xl font-semibold leading-6 text-white&quot;&gt;6 months&lt;/h2&gt;
            &lt;p class=&quot;mt-8&quot;&gt;
              &lt;span class=&quot;text-3xl font-extrabold white&quot;&gt;8M&lt;/span&gt;&lt;span class=&quot;mx-2 text-base font-medium text-zinc-100&quot;&gt;ISK/&lt;!-- --&gt;month&lt;/span&gt;
            &lt;/p&gt;
            &lt;button
              data-variant=&quot;slim&quot;
              class=&quot;Button_root__3fIL8 Button_slim__eaYER block w-full py-2 mt-8 text-sm font-semibold text-center text-white rounded-md hover:bg-zinc-900&quot;
              type=&quot;button&quot;
            &gt;
              Subscribe
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/.modal&gt;

  &lt;.modal
    :if={@live_action in [:deposit]}
    title=&quot;Deposit ISK&quot;
    id=&quot;deposit-modal&quot;
    class=&quot;!w-[700px]&quot;
    show
    on_cancel={JS.patch(~p&quot;/profile&quot;)}
  &gt;
    &lt;div :if={is_nil(@corporation_info)} class=&quot;w-full max-h-[80vh] overflow-y-auto mx-auto&quot;&gt;
      It&apos;s not available yet :(
    &lt;/div&gt;
    &lt;div :if={@corporation_info} class=&quot;w-full max-h-[80vh] overflow-y-auto mx-auto&quot;&gt;
      &lt;div class=&quot;mx-auto p-4 rounded-lg shadow-md&quot;&gt;
        &lt;div
          :if={@corporation_info}
          class=&quot;w-full flex flex-row items-center justify-between gap-2 p-4 bg-stone-950 bg-opacity-70 rounded-lg&quot;
        &gt;
          Wanderer EVE Corporation:
          &lt;.corporation_info
            corporation_id={@corporation_id}
            corporation_info={@corporation_info}
          /&gt;
        &lt;/div&gt;
        &lt;h2 class=&quot;mt-2 text-2xl font-semibold mb-4 text-white-800&quot;&gt;
          How to Deposit ISK to a Wanderer Account in Eve Online
        &lt;/h2&gt;
        &lt;ol class=&quot;list-decimal list-inside mb-4&quot;&gt;
          &lt;li class=&quot;mb-2&quot;&gt;
            &lt;strong&gt;Open corporations overview:&lt;/strong&gt;
            Click on the &apos;Social&apos; and then on &apos;Corporation&apos; in the Neocom menu to access corporations search.
          &lt;/li&gt;
          &lt;li class=&quot;mb-2&quot;&gt;
            &lt;strong&gt;Search for a Corporation:&lt;/strong&gt;
            Type in the search bar the name: &lt;b&gt;&lt;%= @corporation_info[&quot;name&quot;] %&gt;&lt;/b&gt;.
          &lt;/li&gt;
          &lt;li class=&quot;mb-2&quot;&gt;
            &lt;strong&gt;Choose &apos;Give Money&apos;:&lt;/strong&gt;
            Select the &apos;Give Money&apos; in the context menu to initiate the transfer.
          &lt;/li&gt;

          &lt;li class=&quot;mb-2&quot;&gt;
            &lt;strong&gt;Specify the Amount:&lt;/strong&gt;
            Input the amount of ISK you wish to transfer to the corporate account.
          &lt;/li&gt;
          &lt;li class=&quot;mb-2&quot;&gt;
            &lt;strong&gt;Add a Reason (Optional):&lt;/strong&gt;
            Include a short note or reason for the transfer if desired.
          &lt;/li&gt;
          &lt;li class=&quot;mb-2&quot;&gt;
            &lt;strong&gt;Confirm the Transfer:&lt;/strong&gt;
            Double-check the recipient&apos;s name and the amount, then click &apos;OK&apos; to complete the transaction.
          &lt;/li&gt;
        &lt;/ol&gt;
        &lt;p&gt;
          The ISK will be transferred instantly to the Wanderer&apos;s account. Ensure you enter the correct recipient name to avoid any errors. Fly safe and enjoy your time in Eve Online!
        &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/.modal&gt;
&lt;/main&gt;</file><file path="lib/wanderer_app_web/live/coming_live.ex">defmodule WandererAppWeb.ComingLive do
  use WandererAppWeb, :live_view

  require Logger

  @impl true
  def mount(_params, %{&quot;user_id&quot; =&gt; user_id} = _session, socket) when not is_nil(user_id) do
    {:ok, socket}
  end

  @impl true
  def mount(_params, _session, socket) do
    {:ok, socket}
  end

  @impl true
  def handle_params(params, _url, socket) do
    {:noreply, apply_action(socket, socket.assigns.live_action, params)}
  end

  defp apply_action(socket, :index, _params) do
    socket
    |&gt; assign(:active_page, :index)
    |&gt; assign(:page_title, &quot;Coming Soon&quot;)
  end

  @impl true
  def handle_event(&quot;noop&quot;, _, socket) do
    {:noreply, socket}
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;flex grid grid-flow-row gap-2 p-3 h-full w-full pl-20&quot;&gt;
      &lt;main class=&quot;w-full shadow-sm rounded-lg shadow col-span-2 lg:col-span-1 overflow-auto p-3&quot;&gt;
        &lt;dotlottie-player
          src=&quot;/lottie/coming_soon.lottie&quot;
          background=&quot;transparent&quot;
          speed=&quot;1&quot;
          style=&quot;width: 100%; height: 100%&quot;
          direction=&quot;1&quot;
          playMode=&quot;normal&quot;
          loop
          autoplay
        &gt;
        &lt;/dotlottie-player&gt;
      &lt;/main&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_app_web/live/nav.ex">defmodule WandererAppWeb.Nav do
  @moduledoc false

  import Phoenix.LiveView
  use Phoenix.Component

  alias WandererAppWeb.{
    AccessListsLive,
    MapLive,
    MapsLive,
    CharactersLive,
    CharactersTrackingLive
  }

  def on_mount(_scope, _params, _session, socket) do
    show_admin =
      socket.assigns.current_user_role == :admin

    {:cont,
     socket
     |&gt; attach_hook(:active_tab, :handle_params, &amp;set_active_tab/3)
     |&gt; attach_hook(:ping, :handle_event, &amp;handle_event/3)
     |&gt; assign(
       rtt_class: _rtt_class(),
       show_admin: show_admin,
       map_subscriptions_enabled?: WandererApp.Env.map_subscriptions_enabled?(),
       app_version: WandererApp.Env.vsn()
     )}
  end

  defp handle_event(&quot;ping&quot;, %{&quot;rtt&quot; =&gt; rtt}, socket) do
    {:halt,
     socket
     |&gt; rate_limited_ping_broadcast(socket.assigns.current_user, rtt)
     |&gt; push_event(&quot;pong&quot;, %{})
     |&gt; assign(:rtt_class, _rtt_class(rtt))}
  end

  defp handle_event(_, _, socket), do: {:cont, socket}

  defp set_active_tab(_params, _url, socket) do
    active_tab =
      case {socket.view, socket.assigns.live_action} do
        {AccessListsLive, _} -&gt;
          :access_lists

        {MapLive, _} -&gt;
          :map

        {MapsLive, _} -&gt;
          :maps

        {MapAuditLive, _} -&gt;
          :maps

        {CharactersLive, _} -&gt;
          :characters

        {CharactersTrackingLive, _} -&gt;
          :characters_tracking

        {_, _} -&gt;
          nil
      end

    {:cont, socket |&gt; assign(active_tab: active_tab)}
  end

  defp rate_limited_ping_broadcast(socket, %{} = _user, rtt) when is_integer(rtt) do
    now = System.system_time(:millisecond)
    last_ping_at = socket.assigns[:last_ping_at]

    if is_nil(last_ping_at) || now - last_ping_at &gt; 1000 do
      socket |&gt; assign(:last_ping_at, now)
    else
      socket
    end
  end

  defp rate_limited_ping_broadcast(socket, _user, _rtt), do: socket

  defp _rtt_class(rtt \\ 0)

  defp _rtt_class(rtt) when is_integer(rtt) do
    cond do
      rtt &lt; 100 -&gt; &quot;&quot;
      rtt &lt; 200 -&gt; &quot;text-yellow-500&quot;
      true -&gt; &quot;text-red-500&quot;
    end
  end

  defp _rtt_class(_), do: &quot;&quot;
end</file><file path="lib/wanderer_app_web/live/server_status_live.ex">defmodule WandererAppWeb.ServerStatusLive do
  use WandererAppWeb, :live_view

  require Logger

  @impl true
  def mount(_params, _session, socket) do
    :ok =
      Phoenix.PubSub.subscribe(
        WandererApp.PubSub,
        &quot;server_status&quot;
      )

    {:ok, status} = WandererApp.Server.ServerStatusTracker.get_status()

    {:ok, socket |&gt; assign(server_online: not status.vip)}
  end

  @impl true
  def handle_info({:server_status, status}, socket) do
    {:noreply, socket |&gt; assign(server_online: not status.vip)}
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;.server_status online={@server_online} /&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_app_web/schemas/api_schemas.ex">defmodule WandererAppWeb.Schemas.ApiSchemas do
  @moduledoc &quot;&quot;&quot;
  Shared OpenAPI schema definitions for the Wanderer API.

  This module defines common schema components that can be reused
  across different controller specifications.
  &quot;&quot;&quot;

  alias OpenApiSpex.Schema

  # Standard response wrappers
  def data_wrapper(schema) do
    %Schema{
      type: :object,
      properties: %{
        data: schema
      },
      required: [&quot;data&quot;]
    }
  end

  # Standard error responses
  def error_response(description \\ &quot;Error&quot;) do
    %Schema{
      type: :object,
      properties: %{
        error: %Schema{type: :string, description: &quot;Brief error message&quot;},
        details: %Schema{type: :string, description: &quot;Detailed explanation&quot;, nullable: true},
        code: %Schema{type: :string, description: &quot;Optional error code&quot;, nullable: true}
      },
      required: [&quot;error&quot;],
      example: %{&quot;error&quot; =&gt; description, &quot;details&quot; =&gt; &quot;Additional information about the error&quot;}
    }
  end

  # Common entity schemas
  def character_schema do
    %Schema{
      type: :object,
      properties: %{
        id: %Schema{type: :string, description: &quot;Character UUID&quot;},
        eve_id: %Schema{type: :string, description: &quot;EVE Online character ID&quot;},
        name: %Schema{type: :string, description: &quot;Character name&quot;},
        online: %Schema{type: :boolean, description: &quot;Online status&quot;},
        corporation_id: %Schema{type: :integer, description: &quot;Corporation ID&quot;},
        corporation_name: %Schema{type: :string, description: &quot;Corporation name&quot;},
        corporation_ticker: %Schema{type: :string, description: &quot;Corporation ticker&quot;},
        alliance_id: %Schema{type: :integer, description: &quot;Alliance ID&quot;},
        alliance_name: %Schema{type: :string, description: &quot;Alliance name&quot;},
        alliance_ticker: %Schema{type: :string, description: &quot;Alliance ticker&quot;},
        solar_system_id: %Schema{type: :integer, description: &quot;Current solar system ID&quot;},
        ship: %Schema{type: :integer, description: &quot;Current ship type ID&quot;},
        ship_name: %Schema{type: :string, description: &quot;Current ship name&quot;},
        inserted_at: %Schema{type: :string, format: :date_time, description: &quot;Creation timestamp&quot;},
        updated_at: %Schema{type: :string, format: :date_time, description: &quot;Last update timestamp&quot;}
      },
      required: ~w(eve_id name)a
    }
  end

  # Common system schema based on what we&apos;ve seen in controllers
  def solar_system_basic_schema do
    %Schema{
      type: :object,
      properties: %{
        solar_system_id: %Schema{type: :integer},
        solar_system_name: %Schema{type: :string},
        region_id: %Schema{type: :integer},
        region_name: %Schema{type: :string},
        constellation_id: %Schema{type: :integer},
        constellation_name: %Schema{type: :string},
        security: %Schema{type: :string}
      },
      required: [&quot;solar_system_id&quot;, &quot;solar_system_name&quot;]
    }
  end

  # Map schema with common fields
  def map_basic_schema do
    %Schema{
      type: :object,
      properties: %{
        id: %Schema{type: :string},
        name: %Schema{type: :string},
        slug: %Schema{type: :string},
        description: %Schema{type: :string},
        owner_id: %Schema{type: :string},
        inserted_at: %Schema{type: :string, format: :date_time},
        updated_at: %Schema{type: :string, format: :date_time}
      },
      required: [&quot;id&quot;, &quot;name&quot;, &quot;slug&quot;]
    }
  end

  # License schema
  def license_schema do
    %Schema{
      type: :object,
      properties: %{
        id: %Schema{type: :string},
        license_key: %Schema{type: :string},
        is_valid: %Schema{type: :boolean},
        expire_at: %Schema{type: :string, format: :date_time},
        map_id: %Schema{type: :string}
      },
      required: [&quot;id&quot;, &quot;license_key&quot;, &quot;is_valid&quot;, &quot;map_id&quot;]
    }
  end

  # Access list schema
  def access_list_schema do
    %Schema{
      type: :object,
      properties: %{
        id: %Schema{type: :string},
        name: %Schema{type: :string},
        description: %Schema{type: :string},
        owner_id: %Schema{type: :string},
        api_key: %Schema{type: :string},
        inserted_at: %Schema{type: :string, format: :date_time},
        updated_at: %Schema{type: :string, format: :date_time}
      },
      required: [&quot;id&quot;, &quot;name&quot;]
    }
  end

  # Access list member schema
  def access_list_member_schema do
    %Schema{
      type: :object,
      properties: %{
        id: %Schema{type: :string},
        name: %Schema{type: :string},
        role: %Schema{type: :string},
        eve_character_id: %Schema{type: :string},
        eve_corporation_id: %Schema{type: :string},
        eve_alliance_id: %Schema{type: :string},
        inserted_at: %Schema{type: :string, format: :date_time},
        updated_at: %Schema{type: :string, format: :date_time}
      },
      required: [&quot;id&quot;, &quot;name&quot;, &quot;role&quot;]
    }
  end

  # Common paginated response wrapper
  def paginated_response(items_schema) do
    %Schema{
      type: :object,
      properties: %{
        data: items_schema,
        pagination: %Schema{
          type: :object,
          properties: %{
            page: %Schema{type: :integer},
            page_size: %Schema{type: :integer},
            total_pages: %Schema{type: :integer},
            total_count: %Schema{type: :integer}
          },
          required: [&quot;page&quot;, &quot;page_size&quot;, &quot;total_count&quot;]
        }
      },
      required: [&quot;data&quot;, &quot;pagination&quot;]
    }
  end
end</file><file path="lib/wanderer_app_web/schemas/response_schemas.ex">defmodule WandererAppWeb.Schemas.ResponseSchemas do
  @moduledoc &quot;&quot;&quot;
  Standard response schema definitions for API responses.

  This module provides helper functions to create standardized
  HTTP response schemas for OpenAPI documentation.
  &quot;&quot;&quot;

  alias WandererAppWeb.Schemas.ApiSchemas

  # Standard response status codes
  def ok(schema, description \\ &quot;Successful operation&quot;) do
    {
      description,
      &quot;application/json&quot;,
      schema
    }
  end

  def created(schema, description \\ &quot;Resource created&quot;) do
    {
      description,
      &quot;application/json&quot;,
      schema
    }
  end

  def bad_request(description \\ &quot;Bad request&quot;) do
    {
      description,
      &quot;application/json&quot;,
      ApiSchemas.error_response(description)
    }
  end

  def not_found(description \\ &quot;Resource not found&quot;) do
    {
      description,
      &quot;application/json&quot;,
      ApiSchemas.error_response(description)
    }
  end

  def internal_server_error(description \\ &quot;Internal server error&quot;) do
    {
      description,
      &quot;application/json&quot;,
      ApiSchemas.error_response(description)
    }
  end

  def unauthorized(description \\ &quot;Unauthorized&quot;) do
    {
      description,
      &quot;application/json&quot;,
      ApiSchemas.error_response(description)
    }
  end

  def forbidden(description \\ &quot;Forbidden&quot;) do
    {
      description,
      &quot;application/json&quot;,
      ApiSchemas.error_response(description)
    }
  end

  # Helper for common response patterns
  def standard_responses(success_schema, success_description \\ &quot;Successful operation&quot;) do
    [
      ok: ok(success_schema, success_description),
      bad_request: bad_request(),
      not_found: not_found(),
      internal_server_error: internal_server_error()
    ]
  end

  # Helper for create operation responses
  def create_responses(created_schema, created_description \\ &quot;Resource created&quot;) do
    [
      created: created(created_schema, created_description),
      bad_request: bad_request(),
      internal_server_error: internal_server_error()
    ]
  end

  # Helper for update operation responses
  def update_responses(updated_schema, updated_description \\ &quot;Resource updated&quot;) do
    [
      ok: ok(updated_schema, updated_description),
      bad_request: bad_request(),
      not_found: not_found(),
      internal_server_error: internal_server_error()
    ]
  end

  # Helper for delete operation responses
  def delete_responses(deleted_schema \\ nil, deleted_description \\ &quot;Resource deleted&quot;) do
    if deleted_schema do
      [
        ok: ok(deleted_schema, deleted_description),
        not_found: not_found(),
        internal_server_error: internal_server_error()
      ]
    else
      [
        no_content:
          {deleted_description &lt;&gt; &quot; (no content)&quot;, nil, nil},
        not_found: not_found(),
        internal_server_error: internal_server_error()
      ]
    end
  end
end</file><file path="lib/wanderer_app_web/api_spec.ex">defmodule WandererAppWeb.ApiSpec do
  @behaviour OpenApiSpex.OpenApi

  alias OpenApiSpex.{OpenApi, Info, Paths, Components, SecurityScheme, Server}
  alias WandererAppWeb.{Endpoint, Router}

  @impl OpenApiSpex.OpenApi
  def spec do
    %OpenApi{
      info: %Info{
        title: &quot;WandererApp API&quot;,
        version: &quot;1.0.0&quot;,
        description: &quot;API documentation for WandererApp&quot;
      },
      servers: [
        Server.from_endpoint(Endpoint)
      ],
      paths: Paths.from_router(Router),
      components: %Components{
        securitySchemes: %{
          &quot;bearerAuth&quot; =&gt; %SecurityScheme{
            type: &quot;http&quot;,
            scheme: &quot;bearer&quot;,
            bearerFormat: &quot;JWT&quot;
          }
        }
      },
      security: [%{&quot;bearerAuth&quot; =&gt; []}]
    }
  end
end</file><file path="lib/wanderer_app_web/endpoint_metrics.ex">defmodule WandererAppWeb.EndpointMetrics do
  use Phoenix.Endpoint, otp_app: :wanderer_app

  plug PromEx.Plug, prom_ex_module: WandererApp.PromEx
end</file><file path="lib/wanderer_app_web/endpoint.ex">defmodule WandererAppWeb.Endpoint do
  use Phoenix.Endpoint,
    otp_app: :wanderer_app

  import PlugDynamic.Builder

  # The session will be stored in the cookie and signed,
  # this means its contents can be read but not tampered with.
  # Set :encryption_salt if you would also like to encrypt it.
  @session_options [
    store: :cookie,
    key: &quot;_wanderer_app_key&quot;,
    signing_salt: &quot;bMq3QgFG&quot;,
    same_site: &quot;Lax&quot;,
    max_age: 24 * 60 * 60 * 180
  ]

  # @impl SiteEncrypt
  # def certification do
  #   SiteEncrypt.configure(
  #     client: :native,
  #     mode: :auto,
  #     days_to_renew: 30,
  #     domains: [&quot;dev.wanderer.deadly-w.space&quot;],
  #     emails: [&quot;dmitriypopovsamara@gmail.com&quot;],
  #     db_folder: System.get_env(&quot;SITE_ENCRYPT_DB&quot;, Path.join(&quot;tmp&quot;, &quot;site_encrypt_db&quot;)),
  #     backup: Path.join(Path.join(&quot;tmp&quot;, &quot;site_encrypt_db&quot;), &quot;site_encrypt_backup.tgz&quot;),
  #     directory_url:
  #       case System.get_env(&quot;CERT_MODE&quot;, &quot;local&quot;) do
  #         &quot;local&quot; -&gt;
  #           {:internal, port: 4001}

  #         &quot;staging&quot; -&gt;
  #           &quot;https://acme-staging-v02.api.letsencrypt.org/directory&quot;

  #         &quot;production&quot; -&gt;
  #           &quot;https://acme-v02.api.letsencrypt.org/directory&quot;
  #       end
  #   )
  # end

  socket &quot;/live&quot;, Phoenix.LiveView.Socket,
    websocket: [compress: true, connect_info: [session: @session_options]]

  plug PhoenixDDoS

  # Serve at &quot;/&quot; the static files from &quot;priv/static&quot; directory.
  #
  # You should set gzip to true if you are running phx.digest
  # when deploying your static files in production.
  plug Plug.Static,
    at: &quot;/&quot;,
    from: :wanderer_app,
    gzip: false,
    only: WandererAppWeb.static_paths()

  # Code reloading can be explicitly enabled under the
  # :code_reloader configuration of your endpoint.
  if code_reloading? do
    socket &quot;/phoenix/live_reload/socket&quot;, Phoenix.LiveReloader.Socket
    plug Phoenix.LiveReloader
    plug Phoenix.CodeReloader
    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :wanderer_app
  end

  plug Phoenix.LiveDashboard.RequestLogger,
    param_key: &quot;request_logger&quot;,
    cookie_key: &quot;request_logger&quot;

  plug PromEx.Plug, prom_ex_module: WandererApp.PromEx
  plug Plug.RequestId
  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

  plug Plug.Parsers,
    parsers: [:urlencoded, :multipart, :json],
    pass: [&quot;*/*&quot;],
    json_decoder: Phoenix.json_library()

  plug Plug.MethodOverride
  plug Plug.Head

  dynamic_plug Plug.Session, reevaluate: :first_usage do
    :wanderer_app
    |&gt; Application.fetch_env!(WandererAppWeb.Endpoint)
    |&gt; Keyword.get(:url)
    |&gt; Keyword.get(:scheme)
    |&gt; case do
      &quot;https&quot; -&gt; @session_options ++ [secure: true]
      _other -&gt; @session_options
    end
  end

  plug WandererAppWeb.Router
end</file><file path="lib/wanderer_app_web/gettext.ex">defmodule WandererAppWeb.Gettext do
  @moduledoc &quot;&quot;&quot;
  A module providing Internationalization with a gettext-based API.

  By using [Gettext](https://hexdocs.pm/gettext),
  your module gains a set of macros for translations, for example:

      import WandererAppWeb.Gettext

      # Simple translation
      gettext(&quot;Here is the string to translate&quot;)

      # Plural translation
      ngettext(&quot;Here is the string to translate&quot;,
               &quot;Here are the strings to translate&quot;,
               3)

      # Domain-based translation
      dgettext(&quot;errors&quot;, &quot;Here is the error message to translate&quot;)

  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.
  &quot;&quot;&quot;
  use Gettext, otp_app: :wanderer_app
end</file><file path="lib/wanderer_app_web/presence.ex">defmodule WandererAppWeb.Presence do
  @moduledoc false

  use Phoenix.Presence, otp_app: :wanderer_app, pubsub_server: WandererApp.PubSub

  def init(_opts), do: {:ok, %{}}

  def fetch(_topic, presences) do
    presences
  end

  def handle_metas(map_id, %{joins: _joins, leaves: _leaves}, presences, state) do
    presence_data =
      presences
      |&gt; Enum.map(fn {character_id, meta} -&gt;
        from =
          meta
          |&gt; Enum.map(&amp; &amp;1.from)
          |&gt; Enum.sort(&amp;(DateTime.compare(&amp;1, &amp;2) != :gt))
          |&gt; List.first()

        any_tracked = Enum.any?(meta, fn %{tracked: tracked} -&gt; tracked end)

        %{character_id: character_id, tracked: any_tracked, from: from}
      end)

    presence_tracked_character_ids =
      presence_data
      |&gt; Enum.filter(fn %{tracked: tracked} -&gt; tracked end)
      |&gt; Enum.map(fn %{character_id: character_id} -&gt;
        character_id
      end)

    WandererApp.Cache.insert(&quot;map_#{map_id}:presence_updated&quot;, true)

    WandererApp.Cache.insert(
      &quot;map_#{map_id}:presence_character_ids&quot;,
      presence_tracked_character_ids
    )

    WandererApp.Cache.insert(
      &quot;map_#{map_id}:presence_data&quot;,
      presence_data
    )

    {:ok, state}
  end
end</file><file path="lib/wanderer_app_web/router.ex">defmodule WandererAppWeb.Router do
  use WandererAppWeb, :router
  use ErrorTracker.Web, :router
  use Plug.ErrorHandler

  import PlugDynamic.Builder

  import WandererAppWeb.UserAuth,
    warn: false,
    only: [redirect_if_user_is_authenticated: 2]

  import WandererAppWeb.BasicAuth,
    warn: false,
    only: [admin_basic_auth: 2]

  # import WandererAppWeb.Plugs.LicenseAuth,
  #   warn: false,
  #   only: [authenticate_lm: 2, authenticate_license: 2]

  @code_reloading Application.compile_env(
                    :wanderer_app,
                    [WandererAppWeb.Endpoint, :code_reloader],
                    false
                  )
  @frame_src_values if(@code_reloading, do: [&quot;&apos;self&apos;&quot;], else: [])

  # Define style sources individually to ensure proper spacing
  @style_src_values [
    &quot;&apos;self&apos;&quot;,
    &quot;&apos;unsafe-inline&apos;&quot;,
    &quot;https://fonts.googleapis.com&quot;,
    &quot;https://cdn.jsdelivr.net/npm/&quot;,
    &quot;https://cdnjs.cloudflare.com/ajax/libs/&quot;
  ]

  # Define image sources individually to ensure proper spacing
  @img_src_values [
    &quot;&apos;self&apos;&quot;,
    &quot;data:&quot;,
    &quot;https://images.evetech.net&quot;,
    &quot;https://web.ccpgamescdn.com&quot;,
    &quot;https://images.ctfassets.net&quot;,
    &quot;https://w.appzi.io&quot;
  ]

  # Define font sources individually to ensure proper spacing
  @font_src_values [
    &quot;&apos;self&apos;&quot;,
    &quot;https://fonts.gstatic.com&quot;,
    &quot;data:&quot;,
    &quot;https://web.ccpgamescdn.com&quot;,
    &quot;https://w.appzi.io&quot;
  ]

  # Define script sources individually to ensure proper spacing
  @script_src_values [
    &quot;&apos;self&apos;&quot;,
    &quot;&apos;unsafe-inline&apos;&quot;,
    &quot;https://cdn.jsdelivr.net/npm/&quot;,
    &quot;https://cdnjs.cloudflare.com/ajax/libs/&quot;,
    &quot;https://unpkg.com&quot;,
    &quot;https://cdn.jsdelivr.net&quot;,
    &quot;https://w.appzi.io&quot;,
    &quot;https://www.googletagmanager.com&quot;,
    &quot;https://cdnjs.cloudflare.com&quot;
  ]

  # Define connect sources individually to ensure proper spacing
  @connect_src_values [
    &quot;&apos;self&apos;&quot;,
    &quot;https://api.appzi.io&quot;,
    &quot;https://www.googletagmanager.com&quot;,
    &quot;https://www.google-analytics.com&quot;
  ]

  # Define sandbox values individually to ensure proper spacing
  @sandbox_values [
    &quot;allow-forms&quot;,
    &quot;allow-scripts&quot;,
    &quot;allow-modals&quot;,
    &quot;allow-same-origin&quot;,
    &quot;allow-downloads&quot;,
    &quot;allow-popups&quot;
  ]

  pipeline :admin_bauth do
    plug :admin_basic_auth
  end

  pipeline :browser do
    plug :accepts, [&quot;html&quot;]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {WandererAppWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers

    dynamic_plug PlugContentSecurityPolicy, reevaluate: :first_usage do
      URI.default_port(&quot;wss&quot;, 443)
      URI.default_port(&quot;ws&quot;, 80)

      home_url = URI.parse(WandererAppWeb.Endpoint.url())

      ws_url =
        home_url
        |&gt; Map.update!(:scheme, fn
          &quot;http&quot; -&gt; &quot;ws&quot;
          &quot;https&quot; -&gt; &quot;wss&quot;
        end)
        |&gt; Map.put(:path, &quot;&quot;)
        |&gt; URI.to_string()

      # Get the HTTP URL from home_url
      http_url = URI.to_string(home_url)

      # Only add script-src-elem when in development mode
      script_src_elem =
        if(@code_reloading,
          do: @script_src_values ++ [ws_url, http_url],
          else: @script_src_values
        )

      directives = %{
        default_src: ~w(&apos;none&apos;),
        script_src: @script_src_values ++ [ws_url],
        style_src: @style_src_values,
        img_src: @img_src_values,
        font_src: @font_src_values,
        connect_src: @connect_src_values ++ [ws_url],
        media_src: ~w(&apos;none&apos;),
        object_src: ~w(&apos;none&apos;),
        child_src: ~w(&apos;none&apos;),
        frame_src: @frame_src_values,
        worker_src: ~w(&apos;none&apos;),
        frame_ancestors: ~w(&apos;none&apos;),
        form_action: ~w(&apos;self&apos;),
        block_all_mixed_content: ~w(),
        sandbox: @sandbox_values,
        base_uri: ~w(&apos;none&apos;),
        manifest_src: ~w(&apos;self&apos;)
      }

      # Only add script-src-elem to directives when in development mode
      directives = Map.put(directives, :script_src_elem, script_src_elem)

      directives =
        case home_url do
          %URI{scheme: &quot;http&quot;} -&gt; directives
          %URI{scheme: &quot;https&quot;} -&gt; Map.put(directives, :upgrade_insecure_requests, ~w())
        end

      [
        directives: directives
      ]
    end

    plug WandererAppWeb.Plugs.SetUser
  end

  pipeline :blog do
    plug :put_layout, html: {WandererAppWeb.Layouts, :blog}
  end

  pipeline :api do
    plug :accepts, [&quot;json&quot;]
    plug WandererAppWeb.Plugs.CheckApiDisabled
  end

  pipeline :api_map do
    plug WandererAppWeb.Plugs.CheckMapApiKey
    plug WandererAppWeb.Plugs.CheckMapSubscription
    plug WandererAppWeb.Plugs.AssignMapOwner
  end

  pipeline :api_kills do
    plug WandererAppWeb.Plugs.CheckApiDisabled
  end

  pipeline :api_character do
    plug WandererAppWeb.Plugs.CheckCharacterApiDisabled
  end

  pipeline :api_acl do
    plug WandererAppWeb.Plugs.CheckAclApiKey
  end

  pipeline :api_spec do
    plug OpenApiSpex.Plug.PutApiSpec,
      otp_app: :wanderer_app,
      module: WandererAppWeb.ApiSpec
  end

  # pipeline :api_license_management do
  #   plug :authenticate_lm
  # end

  # pipeline :api_license_validation do
  #   plug :authenticate_license
  # end

  scope &quot;/api/map/systems-kills&quot;, WandererAppWeb do
    pipe_through [:api, :api_map, :api_kills]

    get &quot;/&quot;, MapAPIController, :list_systems_kills
  end

  scope &quot;/api/map&quot;, WandererAppWeb do
    pipe_through [:api, :api_map]
    get &quot;/audit&quot;, MapAuditAPIController, :index
    # Deprecated routes - use /api/maps/:map_identifier/systems instead
    get &quot;/systems&quot;, MapSystemAPIController, :list_systems
    get &quot;/system&quot;, MapSystemAPIController, :show_system
    get &quot;/connections&quot;, MapConnectionAPIController, :list_all_connections
    get &quot;/characters&quot;, MapAPIController, :list_tracked_characters
    get &quot;/structure-timers&quot;, MapAPIController, :show_structure_timers
    get &quot;/character-activity&quot;, MapAPIController, :character_activity
    get &quot;/user_characters&quot;, MapAPIController, :user_characters

    get &quot;/acls&quot;, MapAccessListAPIController, :index
    post &quot;/acls&quot;, MapAccessListAPIController, :create
  end

  #
  # Unified RESTful routes for systems &amp; connections by slug or ID
  #
  scope &quot;/api/maps/:map_identifier&quot;, WandererAppWeb do
    pipe_through [:api, :api_map]

    patch &quot;/connections&quot;, MapConnectionAPIController, :update
    delete &quot;/connections&quot;, MapConnectionAPIController, :delete
    delete &quot;/systems&quot;, MapSystemAPIController, :delete
    resources &quot;/systems&quot;, MapSystemAPIController, only: [:index, :show, :create, :update, :delete]
    resources &quot;/connections&quot;, MapConnectionAPIController, only: [:index, :show, :create, :update, :delete], param: &quot;id&quot;
    resources &quot;/structures&quot;, MapSystemStructureAPIController, except: [:new, :edit]
    get &quot;/structure-timers&quot;, MapSystemStructureAPIController, :structure_timers
    resources &quot;/signatures&quot;, MapSystemSignatureAPIController, except: [:new, :edit]
    get &quot;/user-characters&quot;, MapAPIController, :show_user_characters
    get &quot;/tracked-characters&quot;, MapAPIController, :show_tracked_characters
  end



  #
  # Other API routes
  #
  scope &quot;/api/characters&quot;, WandererAppWeb do
    pipe_through [:api, :api_character]
    get &quot;/&quot;, CharactersAPIController, :index
  end

  scope &quot;/api/acls&quot;, WandererAppWeb do
    pipe_through [:api, :api_acl]

    get &quot;/:id&quot;, MapAccessListAPIController, :show
    put &quot;/:id&quot;, MapAccessListAPIController, :update
    post &quot;/:acl_id/members&quot;, AccessListMemberAPIController, :create
    put &quot;/:acl_id/members/:member_id&quot;, AccessListMemberAPIController, :update_role
    delete &quot;/:acl_id/members/:member_id&quot;, AccessListMemberAPIController, :delete
  end

  scope &quot;/api/common&quot;, WandererAppWeb do
    pipe_through [:api]
    get &quot;/system-static-info&quot;, CommonAPIController, :show_system_static
  end

  scope &quot;/api&quot; do
    pipe_through [:browser, :api, :api_spec]
    get &quot;/openapi&quot;, OpenApiSpex.Plug.RenderSpec, :show
  end

  # scope &quot;/api/licenses&quot;, WandererAppWeb do
  #   pipe_through [:api, :api_license_management]

  #   post &quot;/&quot;, LicenseApiController, :create
  #   put &quot;/:id/validity&quot;, LicenseApiController, :update_validity
  #   put &quot;/:id/expiration&quot;, LicenseApiController, :update_expiration
  #   get &quot;/map/:map_id&quot;, LicenseApiController, :get_by_map_id
  # end

  # scope &quot;/api/license&quot;, WandererAppWeb do
  #   pipe_through [:api, :api_license_validation]

  #   get &quot;/validate&quot;, LicenseApiController, :validate
  # end

  #
  # Browser / blog stuff
  #
  scope &quot;/&quot;, WandererAppWeb do
    pipe_through [:browser, :blog, :redirect_if_user_is_authenticated]
    get &quot;/welcome&quot;, BlogController, :index
  end

  scope &quot;/contacts&quot;, WandererAppWeb do
    pipe_through [:browser, :blog]
    get &quot;/&quot;, BlogController, :contacts
  end

  scope &quot;/changelog&quot;, WandererAppWeb do
    pipe_through [:browser, :blog]
    get &quot;/&quot;, BlogController, :changelog
  end

  scope &quot;/news&quot;, WandererAppWeb do
    pipe_through [:browser, :blog]
    get &quot;/:slug&quot;, BlogController, :show
    get &quot;/&quot;, BlogController, :list
  end

  scope &quot;/license&quot;, WandererAppWeb do
    pipe_through [:browser, :blog]
    get &quot;/&quot;, BlogController, :license
  end

  scope &quot;/swaggerui&quot; do
    pipe_through [:browser, :api, :api_spec]

    get &quot;/&quot;, OpenApiSpex.Plug.SwaggerUI,
      path: &quot;/api/openapi&quot;,
      title: &quot;WandererApp API Docs&quot;,
      css_urls: [
        # Standard Swagger UI CSS
        &quot;https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.5.0/swagger-ui.min.css&quot;,
        # Material theme from swagger-ui-themes (v3.x):
        &quot;https://cdn.jsdelivr.net/npm/swagger-ui-themes@3.0.0/themes/3.x/theme-material.css&quot;
      ],
      js_urls: [
        # We need both main JS &amp; standalone preset for full styling
        &quot;https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.5.0/swagger-ui-bundle.min.js&quot;,
        &quot;https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.5.0/swagger-ui-standalone-preset.min.js&quot;
      ],
      swagger_ui_config: %{
        &quot;docExpansion&quot; =&gt; &quot;none&quot;,
        &quot;deepLinking&quot; =&gt; true
      }
  end

  #
  # Auth
  #
  scope &quot;/auth&quot;, WandererAppWeb do
    pipe_through :browser
    get &quot;/signout&quot;, AuthController, :signout
    get &quot;/:provider&quot;, AuthController, :request
    get &quot;/:provider/callback&quot;, AuthController, :callback
  end

  #
  # Admin
  #
  scope &quot;/admin&quot;, WandererAppWeb do
    pipe_through(:browser)
    pipe_through(:admin_bauth)

    live_session :admin,
      on_mount: [
        {WandererAppWeb.UserAuth, :ensure_authenticated},
        {WandererAppWeb.UserAuth, :ensure_admin},
        WandererAppWeb.Nav
      ] do
      live(&quot;/&quot;, AdminLive, :index)
    end

    error_tracker_dashboard(&quot;/errors&quot;,
      on_mount: [
        {WandererAppWeb.UserAuth, :ensure_authenticated},
        {WandererAppWeb.UserAuth, :ensure_admin}
      ]
    )
  end

  #
  # Additional routes / Live sessions
  #
  scope &quot;/&quot;, WandererAppWeb do
    pipe_through(:browser)

    get &quot;/&quot;, RedirectController, :redirect_authenticated
    get &quot;/last&quot;, MapsController, :last

    live_session :authenticated,
      on_mount: [
        {WandererAppWeb.UserAuth, :ensure_authenticated},
        WandererAppWeb.Nav
      ] do
      live &quot;/access-lists/new&quot;, AccessListsLive, :create
      live &quot;/access-lists/:id/edit&quot;, AccessListsLive, :edit
      live &quot;/access-lists/:id/add-members&quot;, AccessListsLive, :add_members
      live &quot;/access-lists/:id&quot;, AccessListsLive, :members
      live &quot;/access-lists&quot;, AccessListsLive, :index

      live &quot;/coming-soon&quot;, ComingLive, :index
      live &quot;/tracking/:slug&quot;, CharactersTrackingLive, :characters
      live &quot;/tracking&quot;, CharactersTrackingLive, :index
      live &quot;/characters&quot;, CharactersLive, :index
      live &quot;/characters/authorize&quot;, CharactersLive, :authorize
      live &quot;/maps/new&quot;, MapsLive, :create
      live &quot;/maps/:slug/edit&quot;, MapsLive, :edit
      live &quot;/maps/:slug/settings&quot;, MapsLive, :settings
      live &quot;/maps&quot;, MapsLive, :index
      live &quot;/profile&quot;, ProfileLive, :index
      live &quot;/profile/deposit&quot;, ProfileLive, :deposit
      live &quot;/profile/subscribe&quot;, ProfileLive, :subscribe
      live &quot;/:slug/audit&quot;, MapAuditLive, :index
      live &quot;/:slug/characters&quot;, MapCharactersLive, :index
      live &quot;/:slug&quot;, MapLive, :index
    end
  end

  if Application.compile_env(:wanderer_app, :dev_routes) do
    import Phoenix.LiveDashboard.Router

    scope &quot;/dev&quot; do
      pipe_through(:browser)
      error_tracker_dashboard(&quot;/errors&quot;, as: :error_tracker_dev_dashboard)
      live_dashboard(&quot;/dashboard&quot;, metrics: WandererAppWeb.Telemetry)
    end
  end
end</file><file path="lib/wanderer_app_web/telemetry.ex">defmodule WandererAppWeb.Telemetry do
  use Supervisor
  import Telemetry.Metrics

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  @impl true
  def init(_arg) do
    children = [
      # Telemetry poller will execute the given period measurements
      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics
      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
      # Add reporters as children of your supervision tree.
      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end

  def metrics do
    [
      # Phoenix Metrics
      summary(&quot;phoenix.endpoint.start.system_time&quot;,
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.endpoint.stop.duration&quot;,
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.router_dispatch.start.system_time&quot;,
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.router_dispatch.exception.duration&quot;,
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.router_dispatch.stop.duration&quot;,
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.socket_connected.duration&quot;,
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.channel_joined.duration&quot;,
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.channel_handled_in.duration&quot;,
        tags: [:event],
        unit: {:native, :millisecond}
      ),

      # Database Metrics
      summary(&quot;wanderer_app.repo.query.total_time&quot;,
        unit: {:native, :millisecond},
        description: &quot;The sum of the other measurements&quot;
      ),
      summary(&quot;wanderer_app.repo.query.decode_time&quot;,
        unit: {:native, :millisecond},
        description: &quot;The time spent decoding the data received from the database&quot;
      ),
      summary(&quot;wanderer_app.repo.query.query_time&quot;,
        unit: {:native, :millisecond},
        description: &quot;The time spent executing the query&quot;
      ),
      summary(&quot;wanderer_app.repo.query.queue_time&quot;,
        unit: {:native, :millisecond},
        description: &quot;The time spent waiting for a database connection&quot;
      ),
      summary(&quot;wanderer_app.repo.query.idle_time&quot;,
        unit: {:native, :millisecond},
        description:
          &quot;The time the connection spent waiting before being checked out for the query&quot;
      ),

      # VM Metrics
      summary(&quot;vm.memory.total&quot;, unit: {:byte, :kilobyte}),
      summary(&quot;vm.total_run_queue_lengths.total&quot;),
      summary(&quot;vm.total_run_queue_lengths.cpu&quot;),
      summary(&quot;vm.total_run_queue_lengths.io&quot;)
    ]
  end

  defp periodic_measurements do
    [
      # A module, function and arguments to be invoked periodically.
      # This function must call :telemetry.execute/3 and a metric must be added above.
      # {WandererAppWeb, :count_users, []}
    ]
  end
end</file><file path="lib/wanderer_app_web.ex">defmodule WandererAppWeb do
  @moduledoc &quot;&quot;&quot;
  The entrypoint for defining your web interface, such
  as controllers, components, channels, and so on.

  This can be used in your application as:

      use WandererAppWeb, :controller
      use WandererAppWeb, :html

  The definitions below will be executed for every controller,
  component, etc, so keep them short and clean, focused
  on imports, uses and aliases.

  Do NOT define functions inside the quoted expressions
  below. Instead, define additional modules and import
  those modules here.
  &quot;&quot;&quot;

  def static_paths, do: ~w(assets fonts images icons favicon.ico robots.txt woff woff2 lottie)

  def router do
    quote do
      use Phoenix.Router, helpers: false

      # Import common connection and controller functions to use in pipelines
      import Plug.Conn
      import Phoenix.Controller
      import Phoenix.LiveView.Router
    end
  end

  def channel do
    quote do
      use Phoenix.Channel
    end
  end

  def controller do
    quote do
      use Phoenix.Controller,
        formats: [:html, :json],
        layouts: [html: WandererAppWeb.Layouts]

      import Phoenix.LiveView.Controller
      import Plug.Conn
      import WandererAppWeb.Gettext

      unquote(verified_routes())
    end
  end

  def live_view(opts \\ []) do
    quote do
      @opts Keyword.merge(
              [
                layout: {WandererAppWeb.Layouts, :live},
                container: {:div, class: &quot;relative h-screen flex overflow-hidden bg-white&quot;}
              ],
              unquote(opts)
            )
      use Phoenix.LiveView, @opts

      unquote(html_helpers())
      defguard is_connected?(socket) when socket.transport_pid != nil
    end
  end

  def live_component do
    quote do
      use Phoenix.LiveComponent

      unquote(html_helpers())
    end
  end

  def html do
    quote do
      use Phoenix.Component

      # Import convenience functions from controllers
      import Phoenix.Controller,
        only: [get_csrf_token: 0, view_module: 1, view_template: 1, current_url: 1]

      # Include general helpers for rendering HTML
      unquote(html_helpers())
    end
  end

  defp html_helpers do
    quote do
      # HTML escaping functionality
      import Phoenix.HTML
      # Core UI components and translation
      import WandererAppWeb.CoreComponents
      import WandererAppWeb.Gettext
      import WandererAppWeb.Helpers.CSP

      # Shortcut for generating JS commands
      alias Phoenix.LiveView.JS

      # Routes generation with the ~p sigil
      unquote(verified_routes())
    end
  end

  def verified_routes do
    quote do
      use Phoenix.VerifiedRoutes,
        endpoint: WandererAppWeb.Endpoint,
        router: WandererAppWeb.Router,
        statics: WandererAppWeb.static_paths()
    end
  end

  @doc &quot;&quot;&quot;
  When used, dispatch to the appropriate controller/view/etc.
  &quot;&quot;&quot;
  defmacro __using__(which) when is_atom(which) do
    apply(__MODULE__, which, [])
  end
end</file><file path="lib/wanderer_app.ex">defmodule WandererApp do
  @moduledoc &quot;&quot;&quot;
  WandererApp keeps the contexts that define your domain
  and business logic.

  Contexts are also responsible for managing your data, regardless
  if it comes from the database, an external API or others.
  &quot;&quot;&quot;

  require Logger

  @doc &quot;&quot;&quot;
  When used, dispatch to the appropriate domain service
  &quot;&quot;&quot;
  def domain_service do
    quote do
    end
  end

  def application_service do
    quote do
    end
  end

  def repository do
    quote do
    end
  end

  def check(), do: {:ok, :ok}

  defmacro __using__(which) when is_atom(which) do
    apply(__MODULE__, which, [])
  end

  def log_exception(kind, reason, stacktrace) do
    reason = Exception.normalize(kind, reason, stacktrace)

    crash_reason =
      case kind do
        :throw -&gt; {{:nocatch, reason}, stacktrace}
        _ -&gt; {reason, stacktrace}
      end

    Logger.error(
      Exception.format(kind, reason, stacktrace),
      crash_reason: crash_reason
    )
  end
end</file><file path="rel/overlays/bin/createdb.sh">#!/bin/sh
set -eu

BIN_DIR=$(dirname &quot;$0&quot;)

&quot;${BIN_DIR}&quot;/wanderer_app eval WandererApp.Release.createdb</file><file path="rel/overlays/bin/migrate.bat">call &quot;%~dp0\wanderer_app&quot; eval WandererApp.ReleaseTasks.migrate</file><file path="rel/overlays/bin/migrate.sh">#!/bin/sh
set -eu

BIN_DIR=$(dirname &quot;$0&quot;)

&quot;${BIN_DIR}&quot;/wanderer_app eval WandererApp.Release.interweave_migrate</file><file path="rel/overlays/bin/rollback.sh">#!/bin/sh

BIN_DIR=$(dirname &quot;$0&quot;)

&quot;${BIN_DIR}&quot;/wanderer_app eval WandererApp.Release.rollback</file><file path="rel/overlays/bin/server">#!/bin/sh
set -eu

cd -P -- &quot;$(dirname -- &quot;$0&quot;)&quot;
PHX_SERVER=true exec ./wanderer_app start</file><file path="rel/overlays/bin/server.bat">set PHX_SERVER=true
call &quot;%~dp0\wanderer_app&quot; start</file><file path="rel/docker-entrypoint.sh">#!/bin/sh
set -e

if [ &quot;$1&quot; = &apos;run&apos; ]; then
      exec /app/bin/wanderer_app start

elif [ &quot;$1&quot; = &apos;db&apos; ]; then
      exec /app/bin/&quot;$2&quot;.sh
 else
      exec &quot;$@&quot;

fi

exec &quot;$@&quot;</file><file path="rel/env.sh.eex">#!/bin/sh

export ERL_AFLAGS=&quot;-proto_dist inet6_tcp&quot;
export RELEASE_DISTRIBUTION=&quot;name&quot;
export RELEASE_NODE=&quot;${FLY_APP_NAME}-${FLY_IMAGE_REF##*-}@${FLY_PRIVATE_IP}&quot;</file><file path="test/manual/api/map_api_backup_restore_test.sh">#!/bin/bash
# test/manual/api/backup_restore_test.sh
# ‚îÄ‚îÄ‚îÄ Backup and Restore Test for Map Systems and Connections ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#
# Usage:
#   ./backup_restore_test.sh          # Run with default settings
#   ./backup_restore_test.sh -v       # Run in verbose mode
#   ./backup_restore_test.sh -h       # Show help
#
source &quot;$(dirname &quot;$0&quot;)/utils.sh&quot;

# Set to &quot;true&quot; to see detailed output, &quot;false&quot; for minimal output
VERBOSE=${VERBOSE:-false}

# Parse command line options
while getopts &quot;vh&quot; opt; do
  case $opt in
    v)
      VERBOSE=true
      ;;
    h)
      echo &quot;Usage: $0 [-v] [-h]&quot;
      echo &quot;  -v  Verbose mode (show detailed output)&quot;
      echo &quot;  -h  Show this help message&quot;
      exit 0
      ;;
    \?)
      echo &quot;Invalid option: -$OPTARG&quot; &gt;&amp;2
      echo &quot;Use -h for help&quot;
      exit 1
      ;;
  esac
done

shift $((OPTIND-1))

# File to store backup data
BACKUP_FILE=&quot;/tmp/wanderer_map_backup.json&quot;

# ‚îÄ‚îÄ‚îÄ UTILITY FUNCTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# Function to backup current map state
backup_map_state() {
  echo &quot;==== Backing Up Map State ====&quot;
  
  echo &quot;Fetching current map state...&quot;
  local raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local response=$(parse_response &quot;$raw&quot;)
    echo &quot;$response&quot; &gt; &quot;$BACKUP_FILE&quot;
    
    local system_count=$(echo &quot;$response&quot; | jq &apos;.data.systems | length&apos;)
    local conn_count=$(echo &quot;$response&quot; | jq &apos;.data.connections | length&apos;)
    
    echo &quot;‚úÖ Backed up $system_count systems and $conn_count connections to $BACKUP_FILE&quot;
    [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Backup data:&quot; &amp;&amp; cat &quot;$BACKUP_FILE&quot; | jq &apos;.&apos;
    return 0
  else
    echo &quot;‚ùå Failed to backup map state. Status: $status&quot;
    return 1
  fi
}

# Function to delete all systems (which will cascade to connections)
delete_all() {
  echo &quot;==== Deleting All Systems ====&quot;
  
  # Get current systems
  local raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local response=$(parse_response &quot;$raw&quot;)
    local system_ids=$(echo &quot;$response&quot; | jq -r &apos;.data.systems[].solar_system_id&apos;)
    
    if [ -z &quot;$system_ids&quot; ]; then
      echo &quot;No systems to delete.&quot;
      return 0
    fi
    
    # Convert system IDs to JSON array and create payload
    local system_ids_json=$(echo &quot;$system_ids&quot; | jq -R . | jq -s .)
    local payload=$(jq -n --argjson system_ids &quot;$system_ids_json&quot; &apos;{system_ids: $system_ids}&apos;)
    
    # Send batch delete request
    local raw=$(make_request DELETE &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot; &quot;$payload&quot;)
    local status=$(parse_status &quot;$raw&quot;)
    
    if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
      echo &quot;‚úÖ Successfully deleted all systems and their connections&quot;
      return 0
    else
      echo &quot;‚ùå Failed to delete systems. Status: $status&quot;
      [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot;
      return 1
    fi
  else
    echo &quot;‚ùå Failed to fetch systems for deletion. Status: $status&quot;
    return 1
  fi
}

# Function to restore map state from backup
restore_map_state() {
  echo &quot;==== Restoring Map State ====&quot;
  
  if [ ! -f &quot;$BACKUP_FILE&quot; ]; then
    echo &quot;‚ùå No backup file found at $BACKUP_FILE&quot;
    return 1
  fi
  
  local backup_data=$(cat &quot;$BACKUP_FILE&quot;)
  local systems=$(echo &quot;$backup_data&quot; | jq &apos;.data.systems&apos;)
  local connections=$(echo &quot;$backup_data&quot; | jq &apos;.data.connections&apos;)
  
  # Create payload for batch upsert
  local payload=&quot;{\&quot;systems\&quot;: $systems, \&quot;connections\&quot;: $connections}&quot;
  
  # Send batch upsert request
  local raw=$(make_request POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot; &quot;$payload&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local response=$(parse_response &quot;$raw&quot;)
    local systems_created=$(echo &quot;$response&quot; | jq &apos;.data.systems.created&apos;)
    local systems_updated=$(echo &quot;$response&quot; | jq &apos;.data.systems.updated&apos;)
    local conns_created=$(echo &quot;$response&quot; | jq &apos;.data.connections.created&apos;)
    local conns_updated=$(echo &quot;$response&quot; | jq &apos;.data.connections.updated&apos;)
    
    echo &quot;‚úÖ Restore successful:&quot;
    echo &quot;   Systems: $systems_created created, $systems_updated updated&quot;
    echo &quot;   Connections: $conns_created created, $conns_updated updated&quot;
    return 0
  else
    echo &quot;‚ùå Failed to restore map state. Status: $status&quot;
    [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot;
    return 1
  fi
}

# ‚îÄ‚îÄ‚îÄ MAIN EXECUTION FLOW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

echo &quot;Starting backup/restore test sequence...&quot;

# Step 1: Backup current state
backup_map_state || { echo &quot;Backup failed, aborting.&quot;; exit 1; }

echo -e &quot;\nBackup complete. Press Enter to proceed with deletion...&quot;
read -r

# Step 2: Delete everything
delete_all || { echo &quot;Deletion failed, aborting.&quot;; exit 1; }

echo -e &quot;\nDeletion complete. Press Enter to proceed with restore...&quot;
read -r

# Step 3: Restore from backup
restore_map_state || { echo &quot;Restore failed.&quot;; exit 1; }

echo -e &quot;\nTest sequence completed.&quot;
exit 0</file><file path="test/manual/api/structure_signature_api_tests.sh">#!/bin/bash
# test/manual/api/structure_signature_api_tests.sh
# ‚îÄ‚îÄ‚îÄ Manual API Tests for Map Structure and Signature APIs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#
# Usage:
#   ./structure_signature_api_tests.sh          # Run all tests with menu selection
#   ./structure_signature_api_tests.sh create   # Run only creation tests
#   ./structure_signature_api_tests.sh update   # Run only update tests
#   ./structure_signature_api_tests.sh delete   # Run only deletion tests
#   ./structure_signature_api_tests.sh -v       # Run in verbose mode
#
source &quot;$(dirname &quot;$0&quot;)/utils.sh&quot;

echo &quot;DEBUG: Script started&quot;

#set -x  # Enable shell debug output

VERBOSE=${VERBOSE:-false}

trap &apos;echo -e &quot;\n‚ùå ERROR: Script failed at line $LINENO. Last command: $BASH_COMMAND&quot; &gt;&amp;2&apos; ERR

while getopts &quot;vh&quot; opt; do
  case $opt in
    v)
      VERBOSE=true
      ;;
    h)
      echo &quot;Usage: $0 [-v] [-h] [all|create|update|delete]&quot;
      echo &quot;  -v  Verbose mode (show detailed test output)&quot;
      echo &quot;  -h  Show this help message&quot;
      echo &quot;  all     Run all tests (default with menu)&quot;
      echo &quot;  create  Run only creation tests&quot;
      echo &quot;  update  Run only update tests&quot;
      echo &quot;  delete  Run only deletion tests&quot;
      exit 0
      ;;
    \?)
      echo &quot;Invalid option: -$OPTARG&quot; &gt;&amp;2
      echo &quot;Use -h for help&quot;
      exit 1
      ;;
  esac
done
shift $((OPTIND-1))
COMMAND=${1:-&quot;all&quot;}

STRUCTURES_FILE=&quot;/tmp/wanderer_test_structures.txt&quot;
SIGNATURES_FILE=&quot;/tmp/wanderer_test_signatures.txt&quot;
CREATED_STRUCTURE_IDS=&quot;&quot;
CREATED_SIGNATURE_IDS=&quot;&quot;

save_structures() {
  echo &quot;DEBUG: Entering save_structures&quot;
  if ! echo &quot;$CREATED_STRUCTURE_IDS&quot; &gt; &quot;$STRUCTURES_FILE&quot;; then
    echo &quot;ERROR: Failed to write to $STRUCTURES_FILE&quot; &gt;&amp;2
    exit 1
  fi
  echo &quot;DEBUG: Successfully wrote to $STRUCTURES_FILE&quot;
  if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Saved $(wc -w &lt; &quot;$STRUCTURES_FILE&quot;) structures to $STRUCTURES_FILE&quot;; fi
}
load_structures() {
  if [ -f &quot;$STRUCTURES_FILE&quot; ]; then
    CREATED_STRUCTURE_IDS=$(cat &quot;$STRUCTURES_FILE&quot;)
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Loaded $(wc -w &lt; &quot;$STRUCTURES_FILE&quot;) structures from $STRUCTURES_FILE&quot;; fi
  else
    CREATED_STRUCTURE_IDS=&quot;&quot;
  fi
}
save_signatures() {
  echo &quot;$CREATED_SIGNATURE_IDS&quot; &gt; &quot;$SIGNATURES_FILE&quot;
  if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Saved $(wc -w &lt; &quot;$SIGNATURES_FILE&quot;) signatures to $SIGNATURES_FILE&quot;; fi
}
load_signatures() {
  if [ -f &quot;$SIGNATURES_FILE&quot; ]; then
    CREATED_SIGNATURE_IDS=$(cat &quot;$SIGNATURES_FILE&quot;)
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Loaded $(wc -w &lt; &quot;$SIGNATURES_FILE&quot;) signatures from $SIGNATURES_FILE&quot;; fi
  else
    CREATED_SIGNATURE_IDS=&quot;&quot;
  fi
}
add_to_list() {
  local list=&quot;$1&quot;
  local item=&quot;$2&quot;
  if [ -z &quot;$list&quot; ]; then
    echo &quot;$item&quot;
  else
    echo &quot;$list $item&quot;
  fi
}

# Fetch the first available system (ID and name) from the API
get_first_system() {
  local raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local response=$(parse_response &quot;$raw&quot;)
    # Try .data as array
    local count=$(echo &quot;$response&quot; | jq -er &apos;if (.data | type == &quot;array&quot;) then (.data | length) else 0 end&apos; 2&gt;/dev/null)
    for i in $(seq 0 $((count-1))); do
      local uuid=$(echo &quot;$response&quot; | jq -er &quot;.data[$i].id // empty&quot; 2&gt;/dev/null)
      local eve_id=$(echo &quot;$response&quot; | jq -er &quot;.data[$i].solar_system_id // empty&quot; 2&gt;/dev/null)
      local name=$(echo &quot;$response&quot; | jq -er &quot;.data[$i].name // .data[$i].solar_system_name // empty&quot; 2&gt;/dev/null)
      if [[ -n &quot;$uuid&quot; &amp;&amp; -n &quot;$eve_id&quot; &amp;&amp; -n &quot;$name&quot; ]]; then
        echo &quot;$uuid:$eve_id:$name&quot;
        return 0
      fi
    done
    # Try .data.systems as array
    local count2=$(echo &quot;$response&quot; | jq -er &apos;if (.data.systems | type == &quot;array&quot;) then (.data.systems | length) else 0 end&apos; 2&gt;/dev/null)
    for i in $(seq 0 $((count2-1))); do
      local uuid=$(echo &quot;$response&quot; | jq -er &quot;.data.systems[$i].id // empty&quot; 2&gt;/dev/null)
      local eve_id=$(echo &quot;$response&quot; | jq -er &quot;.data.systems[$i].solar_system_id // empty&quot; 2&gt;/dev/null)
      local name=$(echo &quot;$response&quot; | jq -er &quot;.data.systems[$i].name // .data.systems[$i].solar_system_name // empty&quot; 2&gt;/dev/null)
      if [[ -n &quot;$uuid&quot; &amp;&amp; -n &quot;$eve_id&quot; &amp;&amp; -n &quot;$name&quot; ]]; then
        echo &quot;$uuid:$eve_id:$name&quot;
        return 0
      fi
    done
    echo &quot;ERROR: No valid system found in API response. Available systems:&quot; &gt;&amp;2
    echo &quot;$response&quot; | jq &apos;.&apos; &gt;&amp;2
    exit 1
  else
    echo &quot;ERROR: Failed to fetch systems (status $status)&quot; &gt;&amp;2
    exit 1
  fi
}

# ‚îÄ‚îÄ‚îÄ STRUCTURE TESTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
create_structure() {
  local sys_info=$(get_first_system)
  local system_uuid=$(echo &quot;$sys_info&quot; | cut -d: -f1)
  local eve_system_id=$(echo &quot;$sys_info&quot; | cut -d: -f2)
  local system_name=$(echo &quot;$sys_info&quot; | cut -d: -f3-)
  echo &quot;==== Creating Structure in system $system_name ($eve_system_id, $system_uuid) ====&quot;
  local payload=$(jq -n --arg sid &quot;$eve_system_id&quot; --arg name &quot;$system_name&quot; &apos;{
    system_id: &quot;sys-uuid-1&quot;,
    solar_system_name: $name,
    solar_system_id: ($sid|tonumber),
    structure_type_id: &quot;35832&quot;,
    structure_type: &quot;Astrahus&quot;,
    character_eve_id: &quot;123456789&quot;,
    name: &quot;Jita Trade Hub&quot;,
    notes: &quot;Main market structure&quot;,
    owner_name: &quot;Wanderer Corp&quot;,
    owner_ticker: &quot;WANDR&quot;,
    owner_id: &quot;corp-uuid-1&quot;,
    status: &quot;anchoring&quot;,
    end_time: &quot;2025-05-05T12:00:00Z&quot;
  }&apos;)
  local raw=$(make_request POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/structures&quot; &quot;$payload&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local id=$(parse_response &quot;$raw&quot; | jq -r &apos;.data.id&apos;)
    CREATED_STRUCTURE_IDS=$(add_to_list &quot;$CREATED_STRUCTURE_IDS&quot; &quot;$id&quot;)
    echo &quot;‚úÖ Created structure with ID: $id&quot;
  else
    echo -e &quot;\n‚ùå ERROR: Failed to create structure. Status: $status&quot; &gt;&amp;2
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot; &gt;&amp;2; fi
    exit 1
  fi
  save_structures
  echo &quot;DEBUG: End of create_structure, about to return&quot;
}

list_structures() {
  echo &quot;==== Listing Structures ====&quot;
  local raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/structures&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local count=$(parse_response &quot;$raw&quot; | jq &apos;.data | length&apos;)
    echo &quot;‚úÖ Listed $count structures&quot;
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;$(parse_response &quot;$raw&quot;)&quot; | jq &apos;.&apos;; fi
  else
    echo -e &quot;\n‚ùå ERROR: Failed to list structures. Status: $status&quot; &gt;&amp;2
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot; &gt;&amp;2; fi
    exit 1
  fi
}

show_structure() {
  load_structures
  local id=$(echo &quot;$CREATED_STRUCTURE_IDS&quot; | awk &apos;{print $1}&apos;)
  if [ -z &quot;$id&quot; ]; then
    echo -e &quot;\n‚ùå ERROR: No structure ID found. Run creation first.&quot; &gt;&amp;2
    exit 1
  fi
  echo &quot;==== Show Structure $id ====&quot;
  local raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/structures/$id&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local data=$(parse_response &quot;$raw&quot;)
    local name=$(echo &quot;$data&quot; | jq -r &apos;.data.name&apos;)
    local status_val=$(echo &quot;$data&quot; | jq -r &apos;.data.status&apos;)
    local notes=$(echo &quot;$data&quot; | jq -r &apos;.data.notes&apos;)
    echo &quot;‚úÖ Showed structure $id: name=&apos;$name&apos;, status=&apos;$status_val&apos;, notes=&apos;$notes&apos;&quot;
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;$data&quot; | jq &apos;.&apos;; fi
  else
    echo -e &quot;\n‚ùå ERROR: Failed to show structure $id. Status: $status&quot; &gt;&amp;2
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot; &gt;&amp;2; fi
    exit 1
  fi
}

update_structure() {
  load_structures
  local id=$(echo &quot;$CREATED_STRUCTURE_IDS&quot; | awk &apos;{print $1}&apos;)
  if [ -z &quot;$id&quot; ]; then
    echo -e &quot;\n‚ùå ERROR: No structure ID found. Run creation first.&quot; &gt;&amp;2
    exit 1
  fi
  echo &quot;==== Updating Structure $id ====&quot;
  local payload=$(jq -n &apos;{status: &quot;anchored&quot;, notes: &quot;Updated via test&quot;}&apos;)
  local raw=$(make_request PUT &quot;$API_BASE_URL/api/maps/$MAP_SLUG/structures/$id&quot; &quot;$payload&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    echo &quot;‚úÖ Updated structure $id&quot;
  else
    echo -e &quot;\n‚ùå ERROR: Failed to update structure $id. Status: $status&quot; &gt;&amp;2
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot; &gt;&amp;2; fi
    exit 1
  fi
}

delete_structure() {
  load_structures
  local id=$(echo &quot;$CREATED_STRUCTURE_IDS&quot; | awk &apos;{print $1}&apos;)
  if [ -z &quot;$id&quot; ]; then
    echo -e &quot;\n‚ùå ERROR: No structure ID found. Run creation first.&quot; &gt;&amp;2
    exit 1
  fi
  echo &quot;==== Deleting Structure $id ====&quot;
  local raw=$(make_request DELETE &quot;$API_BASE_URL/api/maps/$MAP_SLUG/structures/$id&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    echo &quot;‚úÖ Deleted structure $id&quot;
    CREATED_STRUCTURE_IDS=&quot;&quot;
    save_structures
  else
    echo -e &quot;\n‚ùå ERROR: Failed to delete structure $id. Status: $status&quot; &gt;&amp;2
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot; &gt;&amp;2; fi
    exit 1
  fi
}

# ‚îÄ‚îÄ‚îÄ SIGNATURE TESTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
create_signature() {
  local sys_info=$(get_first_system)
  echo &quot;DEBUG: sys_info=&apos;$sys_info&apos;&quot;
  local system_uuid=$(echo &quot;$sys_info&quot; | cut -d: -f1)
  local system_id=$(echo &quot;$sys_info&quot; | cut -d: -f2)
  local system_name=$(echo &quot;$sys_info&quot; | cut -d: -f3-)
  echo &quot;DEBUG: system_id=&apos;$system_id&apos; (should be a number like 31001394)&quot;
  if [[ -z &quot;$system_id&quot; ]]; then
    echo &quot;ERROR: system_id is empty. sys_info=&apos;$sys_info&apos;&quot; &gt;&amp;2
    exit 1
  fi
  # Generate a unique, valid-looking eve_id (e.g., ABC-123)
  local eve_id=$(cat /dev/urandom | tr -dc &apos;A-Z&apos; | fold -w 3 | head -n 1)-$(shuf -i 100-999 -n 1)
  echo &quot;==== Creating Signature in system $system_name ($system_id, $system_uuid) with eve_id $eve_id ====&quot;
  local payload=$(jq -n --arg sid &quot;$system_id&quot; --arg name &quot;$system_name&quot; --arg eve_id &quot;$eve_id&quot; &apos;{
    eve_id: $eve_id,
    name: &quot;Wormhole K162&quot;,
    description: &quot;Leads to unknown space&quot;,
    type: &quot;Wormhole&quot;,
    linked_system_id: 30000144,
    kind: &quot;cosmic_signature&quot;,
    group: &quot;wormhole&quot;,
    custom_info: &quot;Fresh&quot;,
    solar_system_id: ($sid|tonumber),
    solar_system_name: $name
  }&apos;)
  echo &quot;DEBUG: payload=$payload&quot;
  local raw=$(make_request POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/signatures&quot; &quot;$payload&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    # Now list signatures and find the one with this eve_id
    local list_raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/signatures&quot;)
    local id=$(parse_response &quot;$list_raw&quot; | jq -r --arg eve_id &quot;$eve_id&quot; &apos;.data[] | select(.eve_id == $eve_id) | .id&apos; | head -n 1)
    if [[ -z &quot;$id&quot; ]]; then
      echo &quot;‚ùå ERROR: Created signature not found in list (eve_id: $eve_id)&quot; &gt;&amp;2
      exit 1
    fi
    CREATED_SIGNATURE_IDS=$(add_to_list &quot;$CREATED_SIGNATURE_IDS&quot; &quot;$id&quot;)
    save_signatures
    echo &quot;‚úÖ Created signature with eve_id: $eve_id and ID: $id&quot;
  else
    echo &quot;‚ùå ERROR: Failed to create signature (status $status)&quot; &gt;&amp;2
    echo &quot;$raw&quot; | parse_response | jq . &gt;&amp;2
    exit 1
  fi
}

list_signatures() {
  echo &quot;==== Listing Signatures ====&quot;
  local raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/signatures&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local count=$(parse_response &quot;$raw&quot; | jq &apos;.data | length&apos;)
    echo &quot;‚úÖ Listed $count signatures&quot;
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;$(parse_response &quot;$raw&quot;)&quot; | jq &apos;.&apos;; fi
  else
    echo -e &quot;\n‚ùå ERROR: Failed to list signatures. Status: $status&quot; &gt;&amp;2
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot; &gt;&amp;2; fi
    exit 1
  fi
}

show_signature() {
  load_signatures
  local id=$(echo &quot;$CREATED_SIGNATURE_IDS&quot; | awk &apos;{print $1}&apos;)
  if [ -z &quot;$id&quot; ]; then
    echo -e &quot;\n‚ùå ERROR: No signature ID found. Run creation first.&quot; &gt;&amp;2
    exit 1
  fi
  echo &quot;==== Show Signature $id ====&quot;
  local raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/signatures/$id&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local data=$(parse_response &quot;$raw&quot;)
    local eve_id=$(echo &quot;$data&quot; | jq -r &apos;.data.eve_id&apos;)
    local name=$(echo &quot;$data&quot; | jq -r &apos;.data.name&apos;)
    local description=$(echo &quot;$data&quot; | jq -r &apos;.data.description&apos;)
    local custom_info=$(echo &quot;$data&quot; | jq -r &apos;.data.custom_info&apos;)
    echo &quot;‚úÖ Showed signature $id: eve_id=&apos;$eve_id&apos;, name=&apos;$name&apos;, description=&apos;$description&apos;, custom_info=&apos;$custom_info&apos;&quot;
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;$data&quot; | jq &apos;.&apos;; fi
  else
    echo -e &quot;\n‚ùå ERROR: Failed to show signature $id. Status: $status&quot; &gt;&amp;2
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot; &gt;&amp;2; fi
    exit 1
  fi
}

update_signature() {
  load_signatures
  local id=$(echo &quot;$CREATED_SIGNATURE_IDS&quot; | awk &apos;{print $1}&apos;)
  if [ -z &quot;$id&quot; ]; then
    echo -e &quot;\n‚ùå ERROR: No signature ID found. Run creation first.&quot; &gt;&amp;2
    exit 1
  fi
  # Get the EVE system ID for the update payload
  local sys_info=$(get_first_system)
  local system_id=$(echo &quot;$sys_info&quot; | cut -d: -f2)
  echo &quot;==== Updating Signature $id ====&quot;
  local payload=$(jq -n --arg sid &quot;$system_id&quot; &apos;{description: &quot;Updated via test&quot;, custom_info: &quot;Updated info&quot;, solar_system_id: ($sid|tonumber) }&apos;)
  local raw=$(make_request PUT &quot;$API_BASE_URL/api/maps/$MAP_SLUG/signatures/$id&quot; &quot;$payload&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    echo &quot;‚úÖ Updated signature $id&quot;
  else
    echo -e &quot;\n‚ùå ERROR: Failed to update signature $id. Status: $status&quot; &gt;&amp;2
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot; &gt;&amp;2; fi
    exit 1
  fi
}

delete_signature() {
  load_signatures
  local id=$(echo &quot;$CREATED_SIGNATURE_IDS&quot; | awk &apos;{print $1}&apos;)
  if [ -z &quot;$id&quot; ]; then
    echo -e &quot;\n‚ùå ERROR: No signature ID found. Run creation first.&quot; &gt;&amp;2
    exit 1
  fi
  echo &quot;==== Deleting Signature $id ====&quot;
  local raw=$(make_request DELETE &quot;$API_BASE_URL/api/maps/$MAP_SLUG/signatures/$id&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    echo &quot;‚úÖ Deleted signature $id&quot;
    CREATED_SIGNATURE_IDS=&quot;&quot;
    save_signatures
  else
    echo -e &quot;\n‚ùå ERROR: Failed to delete signature $id. Status: $status&quot; &gt;&amp;2
    if [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]]; then echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot; &gt;&amp;2; fi
    exit 1
  fi
}

show_menu() {
  echo &quot;===== Map Structure &amp; Signature API Tests =====&quot;
  echo &quot;1. Run all tests in sequence (with pauses)&quot;
  echo &quot;2. Create structure&quot;
  echo &quot;3. List structures&quot;
  echo &quot;4. Show structure&quot;
  echo &quot;5. Update structure&quot;
  echo &quot;6. Delete structure&quot;
  echo &quot;7. Create signature&quot;
  echo &quot;8. List signatures&quot;
  echo &quot;9. Show signature&quot;
  echo &quot;10. Update signature&quot;
  echo &quot;11. Delete signature&quot;
  echo &quot;12. Exit&quot;
  echo &quot;===============================================&quot;
  echo &quot;Enter your choice [1-12]: &quot;
}

case &quot;$COMMAND&quot; in
  &quot;all&quot;)
    if [ -t 0 ]; then
      while true; do
        show_menu
        read -r choice
        case $choice in
          1)
            create_structure
            echo &quot;DEBUG: After calling create_structure in menu, exit code $?&quot;
            echo &quot;DEBUG: After create_structure, exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            list_structures; echo &quot;DEBUG: After list_structures, exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            show_structure; echo &quot;DEBUG: After show_structure, exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            update_structure; echo &quot;DEBUG: After update_structure, exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            show_structure; echo &quot;DEBUG: After show_structure (post-update), exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            delete_structure; echo &quot;DEBUG: After delete_structure, exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            create_signature; echo &quot;DEBUG: After create_signature, exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            list_signatures; echo &quot;DEBUG: After list_signatures, exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            show_signature; echo &quot;DEBUG: After show_signature, exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            update_signature; echo &quot;DEBUG: After update_signature, exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            show_signature; echo &quot;DEBUG: After show_signature (post-update), exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            delete_signature; echo &quot;DEBUG: After delete_signature, exit code $?&quot;; read -p &quot;Press Enter to continue...&quot;
            echo &quot;All tests completed.&quot;
            show_menu
            read -r choice
            continue
            ;;
          2) create_structure ;;
          3) list_structures ;;
          4) show_structure ;;
          5) update_structure ;;
          6) delete_structure ;;
          7) create_signature ;;
          8) list_signatures ;;
          9) show_signature ;;
          10) update_signature ;;
          11) delete_signature ;;
          12)
            read -p &quot;Clean up any remaining test data before exiting? (y/n): &quot; confirm
            if [[ &quot;$confirm&quot; =~ ^[Yy] ]]; then
              delete_structure
              delete_signature
            fi
            exit 0
            ;;
          *) echo &quot;Invalid option. Please try again.&quot; ;;
        esac
      done
    else
      create_structure; list_structures; show_structure; update_structure; show_structure; delete_structure
      create_signature; list_signatures; show_signature; update_signature; show_signature; delete_signature
    fi
    ;;
  &quot;create&quot;)
    create_structure; create_signature ;;
  &quot;update&quot;)
    update_structure; update_signature ;;
  &quot;delete&quot;)
    delete_structure; delete_signature ;;
  *)
    echo &quot;Invalid command: $COMMAND&quot;
    echo &quot;Use -h for help&quot;
    exit 1
    ;;
esac

exit 0 
echo &quot;DEBUG: End of script reached&quot;</file><file path="test/manual/api/system_api_legacy_tests.sh">#!/usr/bin/env bash
# ‚îÄ‚îÄ‚îÄ Legacy Map endpoint tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
source &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)/utils.sh&quot;

# Track created IDs for cleanup - use space-delimited strings to match utils.sh
CREATED_SYSTEM_IDS=&quot;&quot;
CREATED_CONNECTION_IDS=&quot;&quot;

# Optional environment variables to control verbosity:
# VERBOSE_LOGGING=1 - Show full API responses
QUIET_MODE=1 # Show minimal output (just test names and results)

# DUMP RESPONSE - Call this to see the complete raw API response
dump_complete_response() {
  local url=&quot;$1&quot;
  
  # Only show full response dumps if VERBOSE_LOGGING is set
  if [ &quot;${VERBOSE_LOGGING:-0}&quot; -eq 1 ]; then
    echo &quot;&quot;
    echo &quot;üîç DUMPING COMPLETE RESPONSE FOR: $url&quot;
    echo &quot;‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ&quot;
    curl -s -H &quot;Authorization: Bearer $API_TOKEN&quot; &quot;$url&quot;
    echo &quot;&quot;
    echo &quot;‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ&quot;
    echo &quot;&quot;
  else
    # In non-verbose mode, just do the curl but don&apos;t show output
    curl -s -H &quot;Authorization: Bearer $API_TOKEN&quot; &quot;$url&quot; &gt; /dev/null
  fi
}

# Initial test to show raw API response structure for system endpoint
test_dump_system_response() {
  # If verbose logging is not enabled, skip this test
  if [ &quot;${VERBOSE_LOGGING:-0}&quot; -ne 1 ]; then
    #echo &quot;Skipping raw response dump (enable with VERBOSE_LOGGING=1)&quot;
    return 0
  fi
  
  local id=&quot;30000142&quot;  # Jita
  echo &quot;Getting complete raw API response for system ID $id...&quot;
  dump_complete_response &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems/$id&quot;
  return 0
}

# Helper function to add element to space-delimited string list
add_to_list() {
  local list=&quot;$1&quot;
  local item=&quot;$2&quot;
  if [ -z &quot;$list&quot; ]; then
    echo &quot;$item&quot;
  else
    echo &quot;$list $item&quot;
  fi
}

# Helper function to count items in a space-delimited list
count_items() {
  local list=&quot;$1&quot;
  if [ -z &quot;$list&quot; ]; then
    echo &quot;0&quot;
  else
    echo &quot;$list&quot; | wc -w
  fi
}

# Parse JSON response with error handling
parse_response() {
  local raw=&quot;$1&quot;
  
  # Skip HTTP headers and get the JSON body
  local json_body=$(echo &quot;$raw&quot; | sed &apos;1,/^\s*$/d&apos;)
  
  # If JSON is valid, return it. Otherwise, return empty object
  if echo &quot;$json_body&quot; | jq . &gt;/dev/null 2&gt;&amp;1; then
    echo &quot;$json_body&quot;
  else
    echo &quot;{}&quot;
  fi
}

# Function to get and display detailed system information including visibility
fetch_system_details() {
  local system_id=$1
  local verbose=${2:-0}  # Default to non-verbose mode
  
  # Skip detailed output in quiet mode
  if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;Fetching system details for ID $system_id...&quot;
  fi
  
  # Get the complete raw response
  local raw
  raw=$(curl -s -H &quot;Authorization: Bearer $API_TOKEN&quot; &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems/$system_id&quot;)
  
  # Only show raw response in verbose mode
  if [ &quot;$verbose&quot; -eq 1 ] &amp;&amp; [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;Raw response from curl:&quot;
    echo &quot;$raw&quot; | jq &apos;.&apos; 2&gt;/dev/null || echo &quot;$raw&quot;
  fi
  
  # Extract key information
  local name=&quot;&quot;
  local visible=&quot;&quot;
  
  # First attempt to extract from data wrapper
  if echo &quot;$raw&quot; | jq -e &apos;.data&apos; &gt;/dev/null 2&gt;&amp;1; then
    name=$(echo &quot;$raw&quot; | jq -r &apos;.data.name // .data.solar_system_name // &quot;&quot;&apos;)
    visible=$(echo &quot;$raw&quot; | jq -r &apos;.data.visible // &quot;&quot;&apos;)
  else
    # Use grep as a last resort
    if echo &quot;$raw&quot; | grep -q &apos;&quot;visible&quot;:true&apos;; then
      visible=&quot;true&quot;
    elif echo &quot;$raw&quot; | grep -q &apos;&quot;visible&quot;:false&apos;; then
      visible=&quot;false&quot;
    fi
    
    if echo &quot;$raw&quot; | grep -q &apos;&quot;name&quot;:&quot;[^&quot;]*&quot;&apos;; then
      name=$(echo &quot;$raw&quot; | grep -o &apos;&quot;name&quot;:&quot;[^&quot;]*&quot;&apos; | head -1 | cut -d&apos;:&apos; -f2 | tr -d &apos;&quot;&apos;)
    fi
  fi
  
  # Show results only if not in quiet mode
  if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;SYSTEM NAME: $name&quot;
    echo &quot;VISIBILITY: $visible&quot;
  fi
  
  # Return success if we found both name and visibility
  if [ ! -z &quot;$name&quot; ] &amp;&amp; [ ! -z &quot;$visible&quot; ]; then
    return 0
  else
    return 1
  fi
}

test_direct_api_access() {
  local raw status
  raw=$(make_request GET &quot;$API_BASE_URL/api/map/systems?slug=$MAP_SLUG&quot;)
  status=$(parse_status &quot;$raw&quot;)
  [[ &quot;$status&quot; =~ ^2[0-9]{2}$ ]]
}

test_missing_params() {
  local raw status
  raw=$(make_request GET &quot;$API_BASE_URL/api/map/systems&quot;)
  status=$(parse_status &quot;$raw&quot;)
  [[ &quot;$status&quot; =~ ^4[0-9]{2}$ ]]
}

test_invalid_auth() {
  local old=&quot;$API_TOKEN&quot; raw status
  API_TOKEN=&quot;invalid-token&quot;
  raw=$(make_request GET &quot;$API_BASE_URL/api/map/systems?slug=$MAP_SLUG&quot;)
  status=$(parse_status &quot;$raw&quot;)
  API_TOKEN=&quot;$old&quot;
  [[ &quot;$status&quot; == &quot;401&quot; || &quot;$status&quot; == &quot;403&quot; ]]
}

test_invalid_slug() {
  local raw status
  raw=$(make_request GET &quot;$API_BASE_URL/api/map/systems?slug=nonexistent&quot;)
  status=$(parse_status &quot;$raw&quot;)
  [[ &quot;$status&quot; =~ ^4[0-9]{2}$ ]]
}

# Create and then show systems for legacy API
test_show_systems() {
  # Use two well-known systems (use actual EVE IDs for clarity)
  local jita_id=30000142  # Jita
  local amarr_id=30002187 # Amarr
  local success_count=0
  
  if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;Creating and verifying systems: Jita and Amarr&quot;
  fi
  
  # Create first system - Jita with coordinates
  local payload raw status response
  payload=$(jq -n \
    --argjson sid &quot;$jita_id&quot; \
    --argjson visible true \
    &apos;{solar_system_id:$sid,solar_system_name:&quot;Jita&quot;,coordinates:{&quot;x&quot;:100,&quot;y&quot;:200},visible:$visible}&apos;)
    
  # Create the system using the RESTful API 
  raw=$(make_request POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot; &quot;$payload&quot;)
  status=$(parse_status &quot;$raw&quot;)
  
  if [[ &quot;$status&quot; == &quot;201&quot; || &quot;$status&quot; == &quot;200&quot; ]]; then
    success_count=$((success_count + 1))
    CREATED_SYSTEM_IDS=$(add_to_list &quot;$CREATED_SYSTEM_IDS&quot; &quot;$jita_id&quot;)
    
    if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
      echo &quot;‚úì Created Jita system (ID: $jita_id)&quot;
      echo &quot;Verifying system $jita_id is visible after creation...&quot;
    fi
    
    # Allow a moment for system to be registered
    sleep 1
    
    # Verify the system is visible
    fetch_system_details &quot;$jita_id&quot;
  else
    echo &quot;Warning: Couldn&apos;t create Jita system, status: $status&quot;
  fi
  
  # Create second system - Amarr with coordinates
  payload=$(jq -n \
    --argjson sid &quot;$amarr_id&quot; \
    --argjson visible true \
    &apos;{solar_system_id:$sid,solar_system_name:&quot;Amarr&quot;,coordinates:{&quot;x&quot;:300,&quot;y&quot;:400},visible:$visible}&apos;)
    
  # Create the system using the RESTful API
  raw=$(make_request POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot; &quot;$payload&quot;)
  status=$(parse_status &quot;$raw&quot;)
  
  if [[ &quot;$status&quot; == &quot;201&quot; || &quot;$status&quot; == &quot;200&quot; ]]; then
    success_count=$((success_count + 1))
    CREATED_SYSTEM_IDS=$(add_to_list &quot;$CREATED_SYSTEM_IDS&quot; &quot;$amarr_id&quot;)
    
    if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
      echo &quot;‚úì Created Amarr system (ID: $amarr_id)&quot;
      echo &quot;Verifying system $amarr_id is visible after creation...&quot;
    fi
    
    # Allow a moment for system to be registered
    sleep 1
    
    # Verify the system is visible
    fetch_system_details &quot;$amarr_id&quot;
  else
    echo &quot;Warning: Couldn&apos;t create Amarr system, status: $status&quot;
  fi
  
  # If we couldn&apos;t create any systems, test fails
  if [ $success_count -eq 0 ]; then
    echo &quot;Couldn&apos;t create any test systems for legacy API&quot;
    return 1
  fi
  
  # Verify systems are in the list API
  if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;Checking if systems appear in the list API after creation...&quot;
  fi
  
  raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
  status=$(parse_status &quot;$raw&quot;)
  response_body=$(echo &quot;$raw&quot; | sed &apos;1,/^\s*$/d&apos;)
  
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    # Parse the response appropriately depending on structure
    local data_array=&quot;&quot;
    
    # Check if the response has data array structure
    if echo &quot;$response_body&quot; | jq -e &apos;.data&apos; &gt;/dev/null 2&gt;&amp;1; then
      data_array=$(echo &quot;$response_body&quot; | jq &apos;.data&apos;)
    else
      data_array=&quot;$response_body&quot;
    fi
    
    # Check each created system
    local all_systems_in_list=true
    for sid in $CREATED_SYSTEM_IDS; do
      if echo &quot;$data_array&quot; | jq -e &quot;.[] | select(.solar_system_id == $sid)&quot; &gt;/dev/null 2&gt;&amp;1; then
        if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
          echo &quot;‚úì System $sid appears in list API after creation&quot;
        fi
      else
        all_systems_in_list=false
        echo &quot;‚ö† WARNING: System $sid does not appear in list API after creation&quot;
      fi
    done
  else
    echo &quot;ERROR: Failed to get systems list: status $status&quot;
  fi
  
  # Now test the legacy API endpoint for each created system
  if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;Verifying systems are accessible via legacy API...&quot;
  fi
  
  local legacy_success=true
  
  for sid in $CREATED_SYSTEM_IDS; do
    local raw status
    raw=$(make_request GET &quot;$API_BASE_URL/api/map/system?id=$sid&amp;slug=$MAP_SLUG&quot;)
    status=$(parse_status &quot;$raw&quot;)
    
    if [[ ! &quot;$status&quot; =~ ^2[0-9]{2}$ ]]; then
      echo &quot;Failed to retrieve system $sid via legacy API: status $status&quot;
      legacy_success=false
    fi
  done
  
  if [ &quot;$legacy_success&quot; = &quot;true&quot; ] &amp;&amp; [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;‚úì All systems accessible via legacy API&quot;
  fi
  
  return 0
}

test_verify_connections() {
  # Even if we don&apos;t have systems, we can still test the legacy connections API endpoint
  # by checking that it returns a valid response
  local raw status response
  
  # Try to check all connections via legacy API
  raw=$(make_request GET &quot;$API_BASE_URL/api/map/connections?slug=$MAP_SLUG&quot;)
  status=$(parse_status &quot;$raw&quot;)
  
  # If the endpoint exists and returns a success status, the test passes
  if [[ &quot;$status&quot; =~ ^2[0-9]{2}$ ]]; then
    return 0
  fi

  return 1
}

test_delete_systems() {
  # If we don&apos;t have system IDs, skip the test
  if [ $(count_items &quot;$CREATED_SYSTEM_IDS&quot;) -eq 0 ]; then
    echo &quot;No systems to delete, skipping&quot;
    return 0
  fi
  
  local success_count=0
  local total_systems=$(count_items &quot;$CREATED_SYSTEM_IDS&quot;)
  local deleted_ids=&quot;&quot;
  
  if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;TEST: Delete Systems API&quot;
    echo &quot;------------------------&quot;
    echo &quot;Testing system deletion for existing systems in map $MAP_SLUG&quot;
    echo &quot;Systems to delete: $CREATED_SYSTEM_IDS&quot;
  fi
  
  # Try batch delete first
  if [ $(count_items &quot;$CREATED_SYSTEM_IDS&quot;) -gt 1 ]; then
    if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
      echo &quot;Attempting batch delete of systems: $CREATED_SYSTEM_IDS&quot;
    fi
    
    local payload=$(echo &quot;$CREATED_SYSTEM_IDS&quot; | tr &apos; &apos; &apos;\n&apos; | jq -R . | jq -s &apos;{system_ids: .}&apos;)
    local raw status
    
    raw=$(make_request POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems/batch_delete&quot; &quot;$payload&quot;)
    status=$(parse_status &quot;$raw&quot;)
    
    if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
      if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
        echo &quot;‚úì Batch delete successful&quot;
      fi
      
      # Verify systems are gone from the list
      sleep 1
      local list_response
      list_response=$(curl -s -H &quot;Authorization: Bearer $API_TOKEN&quot; &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
      
      # Check if all systems are gone
      local all_deleted=1
      for system_id in $CREATED_SYSTEM_IDS; do
        if echo &quot;$list_response&quot; | jq -e --arg id &quot;$system_id&quot; &apos;.data[] | select(.solar_system_id == ($id|tonumber) and .visible == true)&apos; &gt;/dev/null 2&gt;&amp;1; then
          all_deleted=0
        else
          success_count=$((success_count + 1))
          deleted_ids=$(add_to_list &quot;$deleted_ids&quot; &quot;$system_id&quot;)
          if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
            echo &quot;‚úì System $system_id no longer visible in list API after batch deletion&quot;
          fi
        fi
      done
      
      if [ $all_deleted -eq 1 ]; then
        # Update the list of created systems to remove successfully deleted ones
        for id in $deleted_ids; do
          CREATED_SYSTEM_IDS=$(echo &quot;$CREATED_SYSTEM_IDS&quot; | sed &quot;s/\b$id\b//g&quot; | tr -s &apos; &apos; | sed &apos;s/^ //g&apos; | sed &apos;s/ $//g&apos;)
        done
        
        # If batch delete worked for all systems, we&apos;re done
        if [ $success_count -eq $total_systems ]; then
          if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
            echo &quot;‚úÖ All systems successfully deleted via batch delete&quot;
          fi
          return 0
        fi
      fi
    else
      if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
        echo &quot;Batch delete failed with status $status, trying individual deletes&quot;
      fi
    fi
  fi
  
  # If batch delete didn&apos;t work, try individual deletes
  for system_id in $CREATED_SYSTEM_IDS; do
    if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
      echo &quot;Attempting to delete system with ID: $system_id&quot;
    fi
    
    local raw status
    
    # Use the RESTful DELETE endpoint
    raw=$(make_request DELETE &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems/$system_id&quot;)
    status=$(parse_status &quot;$raw&quot;)
    
    if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
      if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
        echo &quot;‚úì Delete API call successful for system $system_id&quot;
      fi
      
      # Allow time for change to propagate
      sleep 1
      
      # Get the complete system list after deletion
      local list_response
      list_response=$(curl -s -H &quot;Authorization: Bearer $API_TOKEN&quot; &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
      
      # Check if the system appears in the list (deleted systems shouldn&apos;t appear or should be invisible)
      local system_still_visible=0
      
      if echo &quot;$list_response&quot; | jq -e --arg id &quot;$system_id&quot; &apos;.data[] | select(.solar_system_id == ($id|tonumber) and .visible == true)&apos; &gt;/dev/null 2&gt;&amp;1; then
        system_still_visible=1
      fi
      
      if [ $system_still_visible -eq 0 ]; then
        if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
          echo &quot;‚úì System $system_id no longer visible in list API after deletion&quot;
        fi
        success_count=$((success_count + 1))
        deleted_ids=$(add_to_list &quot;$deleted_ids&quot; &quot;$system_id&quot;)
      fi
    else
      echo &quot;‚ùå Failed to delete system $system_id: status $status&quot;
    fi
  done
  
  # Update the list of created systems to remove successfully deleted ones
  for id in $deleted_ids; do
    CREATED_SYSTEM_IDS=$(echo &quot;$CREATED_SYSTEM_IDS&quot; | sed &quot;s/\b$id\b//g&quot; | tr -s &apos; &apos; | sed &apos;s/^ //g&apos; | sed &apos;s/ $//g&apos;)
  done
  
  # Report results
  if [ $success_count -eq $total_systems ]; then
    if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
      echo &quot;‚úÖ All systems successfully deleted (no longer visible in list API): $success_count / $total_systems&quot;
    fi
    return 0
  else
    echo &quot;‚ö† Some systems still appear visible in list API after deletion: $success_count / $total_systems deleted&quot;
    return 1
  fi
}

# Test the system list API endpoint
test_system_list() {
  if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;Testing system list API endpoint...&quot;
  fi
  
  local raw status
  raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
  status=$(parse_status &quot;$raw&quot;)
  
  if [[ &quot;$status&quot; != &quot;200&quot; ]]; then
    echo &quot;ERROR: Failed to get system list: status $status&quot;
    return 1
  fi
  
  # Test legacy system list endpoint too
  if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;Testing legacy system list API endpoint...&quot;
  fi
  
  raw=$(make_request GET &quot;$API_BASE_URL/api/map/systems?slug=$MAP_SLUG&quot;)
  status=$(parse_status &quot;$raw&quot;)
  
  if [[ &quot;$status&quot; != &quot;200&quot; ]]; then
    echo &quot;ERROR: Failed to get legacy system list: status $status&quot;
    return 1
  fi
  
  # Check that both APIs return the same number of systems
  local restful_count=$(echo &quot;$raw&quot; | sed &apos;1,/^\s*$/d&apos; | jq &apos;.data | length // length&apos;)
  raw=$(make_request GET &quot;$API_BASE_URL/api/map/systems?slug=$MAP_SLUG&quot;)
  local legacy_count=$(echo &quot;$raw&quot; | sed &apos;1,/^\s*$/d&apos; | jq &apos;.data | length // length&apos;)
  
  if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo &quot;RESTful API returned $restful_count systems, Legacy API returned $legacy_count systems&quot;
  fi
  
  if [[ &quot;$restful_count&quot; == &quot;$legacy_count&quot; ]]; then
    if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
      echo &quot;‚úì Both APIs return the same number of systems&quot;
    fi
  else
    echo &quot;WARNING: APIs return different numbers of systems&quot;
  fi
  
  return 0
}

# ‚îÄ‚îÄ‚îÄ Execute Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Function to run a test and report success/failure
run_test() {
  local name=&quot;$1&quot;
  local func=&quot;$2&quot;
  
  # Only print test name if not in quiet mode
  if [ &quot;${QUIET_MODE:-0}&quot; -ne 1 ]; then
    echo -n &quot;Testing: $name... &quot;
  fi
  
  # Run the test function
  if $func; then
    echo &quot;‚úÖ $name&quot;
    return 0
  else
    echo &quot;‚ùå $name&quot;
    return 1
  fi
}

run_test &quot;Dump Raw API Response&quot; test_dump_system_response
run_test &quot;Direct API access&quot; test_direct_api_access
run_test &quot;Missing params (4xx)&quot; test_missing_params
run_test &quot;Invalid auth (401/403)&quot; test_invalid_auth
run_test &quot;Invalid slug on GET&quot; test_invalid_slug
run_test &quot;Show systems&quot; test_show_systems
run_test &quot;System list&quot; test_system_list
run_test &quot;Verify connections&quot; test_verify_connections
run_test &quot;Delete systems&quot; test_delete_systems</file><file path="test/manual/api/system_api_tests.sh">#!/bin/bash
# test/manual/api/improved_api_tests.sh
# ‚îÄ‚îÄ‚îÄ Improved API Tests for Map System and Connection APIs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# 
# Usage:
#   ./improved_api_tests.sh          # Run all tests with menu selection
#   ./improved_api_tests.sh create   # Run only creation tests
#   ./improved_api_tests.sh update   # Run only update tests
#   ./improved_api_tests.sh delete   # Run only deletion tests
#   ./improved_api_tests.sh -v       # Run in verbose mode
#
source &quot;$(dirname &quot;$0&quot;)/utils.sh&quot;

# Set to &quot;true&quot; to see detailed output, &quot;false&quot; for minimal output
VERBOSE=${VERBOSE:-false}

# Parse command line options
while getopts &quot;vh&quot; opt; do
  case $opt in
    v)
      VERBOSE=true
      ;;
    h)
      echo &quot;Usage: $0 [-v] [-h] [all|create|update|delete]&quot;
      echo &quot;  -v  Verbose mode (show detailed test output)&quot;
      echo &quot;  -h  Show this help message&quot;
      echo &quot;  all     Run all tests (default with menu)&quot;
      echo &quot;  create  Run only creation tests&quot;
      echo &quot;  update  Run only update tests&quot; 
      echo &quot;  delete  Run only deletion tests&quot;
      exit 0
      ;;
    \?)
      echo &quot;Invalid option: -$OPTARG&quot; &gt;&amp;2
      echo &quot;Use -h for help&quot;
      exit 1
      ;;
  esac
done

shift $((OPTIND-1))
COMMAND=${1:-&quot;all&quot;}

# File to store system and connection IDs for persistence between command runs
SYSTEMS_FILE=&quot;/tmp/wanderer_test_systems.txt&quot;
CONNECTIONS_FILE=&quot;/tmp/wanderer_test_connections.txt&quot;

# Track created IDs for cleanup
CREATED_SYSTEM_IDS=&quot;&quot;
CREATED_CONNECTION_IDS=&quot;&quot;

# Array of valid EVE system IDs and names (first 5 for individual creation)
declare -a EVE_SYSTEMS=(
  &quot;30005304:Alentene&quot;
  &quot;30003380:Alf&quot;
  &quot;30003811:Algasienan&quot;
  &quot;30004972:Algogille&quot;
  &quot;30002698:Aliette&quot;
)

# Next 5 for batch upsert
declare -a BATCH_EVE_SYSTEMS=(
  &quot;30002754:Alikara&quot;
  &quot;30002712:Alillere&quot;
  &quot;30003521:Alkabsi&quot;
  &quot;30000034:Alkez&quot;
  &quot;30004995:Allamotte&quot;
)

# ‚îÄ‚îÄ‚îÄ UTILITY FUNCTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# Function to save created system IDs to file
save_systems() {
  echo &quot;$CREATED_SYSTEM_IDS&quot; &gt; &quot;$SYSTEMS_FILE&quot;
  [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Saved $(wc -w &lt; &quot;$SYSTEMS_FILE&quot;) systems to $SYSTEMS_FILE&quot;
}

# Function to load system IDs from file
load_systems() {
  if [ -f &quot;$SYSTEMS_FILE&quot; ]; then
    CREATED_SYSTEM_IDS=$(cat &quot;$SYSTEMS_FILE&quot;)
    [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Loaded $(wc -w &lt; &quot;$SYSTEMS_FILE&quot;) systems from $SYSTEMS_FILE&quot;
  else
    echo &quot;No systems file found at $SYSTEMS_FILE. Run creation tests first.&quot;
    CREATED_SYSTEM_IDS=&quot;&quot;
  fi
}

# Function to save created connection IDs to file
save_connections() {
  echo &quot;$CREATED_CONNECTION_IDS&quot; &gt; &quot;$CONNECTIONS_FILE&quot;
  [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Saved $(wc -w &lt; &quot;$CONNECTIONS_FILE&quot;) connections to $CONNECTIONS_FILE&quot;
}

# Function to load connection IDs from file
load_connections() {
  if [ -f &quot;$CONNECTIONS_FILE&quot; ]; then
    CREATED_CONNECTION_IDS=$(cat &quot;$CONNECTIONS_FILE&quot;)
    [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Loaded $(wc -w &lt; &quot;$CONNECTIONS_FILE&quot;) connections from $CONNECTIONS_FILE&quot;
  else
    echo &quot;No connections file found at $CONNECTIONS_FILE. Run creation tests first.&quot;
    CREATED_CONNECTION_IDS=&quot;&quot;
  fi
}

# Function to add item to space-delimited list
add_to_list() {
  local list=&quot;$1&quot;
  local item=&quot;$2&quot;
  if [ -z &quot;$list&quot; ]; then
    echo &quot;$item&quot;
  else
    echo &quot;$list $item&quot;
  fi
}

# ‚îÄ‚îÄ‚îÄ TEST FUNCTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# FUNCTION: Create systems
create_systems() {
  echo &quot;==== Creating Systems ====&quot;
  local system_count=0
  local center_x=500
  local center_y=500
  local radius=250

  # Only clear the systems file if we&apos;re starting fresh
  &gt; &quot;$SYSTEMS_FILE&quot;
  CREATED_SYSTEM_IDS=&quot;&quot;

  # Build all system payloads as a JSON array
  local systems_payload=&quot;[&quot;
  local num_systems=${#EVE_SYSTEMS[@]}
  for i in $(seq 0 $((num_systems-1))); do
    IFS=&apos;:&apos; read -r system_id system_name &lt;&lt;&lt; &quot;${EVE_SYSTEMS[$i]}&quot;
    local angle=$(echo &quot;scale=6; $i * 6.28318 / $num_systems&quot; | bc -l)
    local x=$(echo &quot;scale=2; $center_x + $radius * c($angle)&quot; | bc -l)
    local y=$(echo &quot;scale=2; $center_y + $radius * s($angle)&quot; | bc -l)
    local system_json=$(jq -n \
      --argjson sid &quot;$system_id&quot; \
      --arg name &quot;$system_name&quot; \
      --argjson x &quot;$x&quot; \
      --argjson y &quot;$y&quot; \
      &apos;{
        solar_system_id: $sid,
        solar_system_name: $name,
        position_x: $x,
        position_y: $y,
        status: &quot;clear&quot;,
        visible: true,
        description: &quot;Test system&quot;,
        tag: &quot;TEST&quot;,
        locked: false
      }&apos;)
    systems_payload+=&quot;$system_json&quot;
    if [ $i -lt $((num_systems-1)) ]; then
      systems_payload+=&quot;,&quot; 
    fi
  done
  systems_payload+=&quot;]&quot;

  # Wrap in the &apos;systems&apos; key
  local payload=&quot;{\&quot;systems\&quot;: $systems_payload}&quot;

  # Send the batch create request
  local raw=$(make_request POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot; &quot;$payload&quot;)
  local status=$(parse_status &quot;$raw&quot;)

  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    echo &quot;‚úÖ Created all systems in batch&quot;
    # Track the system IDs for later cleanup
    for i in $(seq 0 $((num_systems-1))); do
      IFS=&apos;:&apos; read -r system_id _ &lt;&lt;&lt; &quot;${EVE_SYSTEMS[$i]}&quot;
      CREATED_SYSTEM_IDS=$(add_to_list &quot;$CREATED_SYSTEM_IDS&quot; &quot;$system_id&quot;)
      system_count=$((system_count+1))
    done
  else
    echo &quot;‚ùå Failed to create systems in batch. Status: $status&quot;
    [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot;
  fi

  echo &quot;Total systems created: $system_count/$num_systems&quot;
  save_systems

  # Validate actual state after creation
  echo &quot;Validating systems after dedicated creation:&quot;
  list_systems_and_connections
}

# FUNCTION: Create connections
create_connections() {
  echo &quot;==== Creating Connections ====&quot;
  load_systems
  if [ -z &quot;$CREATED_SYSTEM_IDS&quot; ]; then
    echo &quot;No systems available. Run system creation first.&quot;
    return 1
  fi
  &gt; &quot;$CONNECTIONS_FILE&quot;
  CREATED_CONNECTION_IDS=&quot;&quot;
  local connection_count=0
  local total_connections=0
  local system_array=($CREATED_SYSTEM_IDS)

  echo &quot;Testing dedicated connection endpoints...&quot;
  # Create connections one by one using the dedicated endpoint
  for i in $(seq 0 $((${#system_array[@]}-1))); do
    local source=${system_array[$i]}
    local target=${system_array[$(( (i+1) % ${#system_array[@]} ))]}
    total_connections=$((total_connections+1))
    
    # Create single connection payload
    local payload=$(jq -n \
      --argjson source &quot;$source&quot; \
      --argjson target &quot;$target&quot; \
      &apos;{
        solar_system_source: $source,
        solar_system_target: $target,
        type: 0,
        mass_status: 0,
        time_status: 0,
        ship_size_type: 1,
        wormhole_type: &quot;K162&quot;,
        count_of_passage: 0
      }&apos;)
    
    # Send create request to dedicated endpoint
    local raw=$(make_request POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/connections&quot; &quot;$payload&quot;)
    local status=$(parse_status &quot;$raw&quot;)
    
    if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
      echo &quot;‚úÖ Created connection from $source to $target&quot;
      local response=$(parse_response &quot;$raw&quot;)
      # Store source and target for later use
      CREATED_CONNECTION_IDS=$(add_to_list &quot;$CREATED_CONNECTION_IDS&quot; &quot;${source}:${target}&quot;)
      connection_count=$((connection_count+1))
    else
      echo &quot;‚ùå Failed to create connection from $source to $target. Status: $status&quot;
      [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot;
    fi
  done
  
  echo &quot;Total connections created via dedicated endpoint: $connection_count/$total_connections&quot;
  save_connections

  # Always validate actual state after connection creation
  echo &quot;Validating connections after dedicated creation:&quot;
  list_systems_and_connections

  echo -e &quot;\nTesting batch upsert functionality...&quot;
  # Build batch upsert payload using BATCH_EVE_SYSTEMS
  local batch_systems_json=&quot;[&quot;
  local batch_connections_json=&quot;[&quot;
  local num_batch_systems=${#BATCH_EVE_SYSTEMS[@]}
  for i in $(seq 0 $((num_batch_systems-1))); do
    IFS=&apos;:&apos; read -r system_id system_name &lt;&lt;&lt; &quot;${BATCH_EVE_SYSTEMS[$i]}&quot;
    local angle=$(echo &quot;scale=6; $i * 6.28318 / $num_batch_systems&quot; | bc -l)
    local x=$(echo &quot;scale=2; 500 + 250 * c($angle)&quot; | bc -l)
    local y=$(echo &quot;scale=2; 500 + 250 * s($angle)&quot; | bc -l)
    local system_json=$(jq -n \
      --argjson sid &quot;$system_id&quot; \
      --arg name &quot;$system_name&quot; \
      --argjson x &quot;$x&quot; \
      --argjson y &quot;$y&quot; \
      &apos;{
        solar_system_id: $sid,
        solar_system_name: $name,
        position_x: $x,
        position_y: $y,
        status: &quot;clear&quot;,
        visible: true,
        description: &quot;Test system (batch)&quot;,
        tag: &quot;BATCH&quot;,
        locked: false
      }&apos;)
    batch_systems_json+=&quot;$system_json&quot;
    if [ $i -lt $((num_batch_systems-1)) ]; then
      batch_systems_json+=&quot;,&quot; 
    fi
    # Build connections in a ring
    local source=$system_id
    local next_index=$(( (i+1) % num_batch_systems ))
    IFS=&apos;:&apos; read -r target_id _ &lt;&lt;&lt; &quot;${BATCH_EVE_SYSTEMS[$next_index]}&quot;
    batch_connections_json+=&quot;{\&quot;solar_system_source\&quot;:$source,\&quot;solar_system_target\&quot;:$target_id,\&quot;mass_status\&quot;:0,\&quot;ship_size_type\&quot;:1,\&quot;type\&quot;:0}&quot;
    if [ $i -lt $((num_batch_systems-1)) ]; then
      batch_connections_json+=&quot;,&quot; 
    fi
  done
  batch_systems_json+=&quot;]&quot;
  batch_connections_json+=&quot;]&quot;

  echo &quot;[SCRIPT] Batch upsert systems: $batch_systems_json&quot;
  echo &quot;[SCRIPT] Batch upsert connections: $batch_connections_json&quot;

  # Check for API_TOKEN
  if [ -z &quot;$API_TOKEN&quot; ]; then
    echo &quot;‚ùå API_TOKEN is not set. Please export API_TOKEN before running the script.&quot;
    return 1
  fi

  # Send batch upsert request
  local response=$(curl -s -X POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot; \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Authorization: Bearer $API_TOKEN&quot; \
    -d &quot;{\&quot;systems\&quot;:$batch_systems_json,\&quot;connections\&quot;:$batch_connections_json}&quot;)

  echo &quot;[SCRIPT] Batch upsert response: $response&quot;
  
  # Debug: List all connections after batch upsert
  echo &quot;[SCRIPT] Listing all connections after batch upsert:&quot;
  local list_raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
  local list_status=$(parse_status &quot;$list_raw&quot;)
  if [[ &quot;$list_status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local list_response=$(parse_response &quot;$list_raw&quot;)
    echo &quot;$list_response&quot; | jq -c &apos;.data.connections[] | {id: .id, source: .solar_system_source, target: .solar_system_target, mass_status: .mass_status, ship_size_type: .ship_size_type, type: .type}&apos;
  else
    echo &quot;[SCRIPT] Failed to list connections after batch upsert. Status: $list_status&quot;
  fi

  # Add batch system IDs to CREATED_SYSTEM_IDS
  for i in $(seq 0 $((num_batch_systems-1))); do
    IFS=&apos;:&apos; read -r system_id _ &lt;&lt;&lt; &quot;${BATCH_EVE_SYSTEMS[$i]}&quot;
    CREATED_SYSTEM_IDS=$(add_to_list &quot;$CREATED_SYSTEM_IDS&quot; &quot;$system_id&quot;)
  done

  # Add batch connection pairs to CREATED_CONNECTION_IDS
  for i in $(seq 0 $((num_batch_systems-1))); do
    IFS=&apos;:&apos; read -r source _ &lt;&lt;&lt; &quot;${BATCH_EVE_SYSTEMS[$i]}&quot;
    next_index=$(( (i+1) % num_batch_systems ))
    IFS=&apos;:&apos; read -r target _ &lt;&lt;&lt; &quot;${BATCH_EVE_SYSTEMS[$next_index]}&quot;
    CREATED_CONNECTION_IDS=$(add_to_list &quot;$CREATED_CONNECTION_IDS&quot; &quot;${source}:${target}&quot;)
  done
  save_systems
  save_connections

  list_systems_and_connections
  
  echo &quot;Total connections updated: $connection_count/${#system_array[@]}&quot;
}

# FUNCTION: Update systems
update_systems() {
  echo &quot;==== Updating Systems ====&quot;
  load_systems
  
  if [ -z &quot;$CREATED_SYSTEM_IDS&quot; ]; then
    echo &quot;No systems available. Run system creation first.&quot;
    return 1
  fi
  
  local update_count=0
  local system_array=($CREATED_SYSTEM_IDS)
  local num_systems=${#system_array[@]}
  
  for i in $(seq 0 $((num_systems-1))); do
    local system_id=${system_array[$i]}
    
    # Get system name from EVE_SYSTEMS array if available
    local system_name=&quot;System $system_id&quot;
    for j in $(seq 0 $((${#EVE_SYSTEMS[@]}-1))); do
      IFS=&apos;:&apos; read -r curr_id curr_name &lt;&lt;&lt; &quot;${EVE_SYSTEMS[$j]}&quot;
      if [ &quot;$curr_id&quot; = &quot;$system_id&quot; ]; then
        system_name=$curr_name
        break
      fi
    done
    
    echo &quot;Updating system $((i+1))/$num_systems: $system_name (ID: $system_id)&quot;
    
    # Create update payload with new values
    local status_values=(&quot;clear&quot; &quot;friendly&quot; &quot;hostile&quot; &quot;occupied&quot;)
    local status=${status_values[$((RANDOM % 4))]}
    local desc=&quot;Updated description for $system_name&quot;
    local tag=&quot;UPDATED&quot;
    
    local payload=$(jq -n \
      --arg status &quot;$status&quot; \
      --arg desc &quot;$desc&quot; \
      --arg tag &quot;$tag&quot; \
      &apos;{
        status: $status,
        description: $desc,
        tag: $tag,
        locked: false
      }&apos;)
    
    # Send the update request
    local raw=$(make_request PUT &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems/$system_id&quot; &quot;$payload&quot;)
    local status_code=$(parse_status &quot;$raw&quot;)
    
    if [[ &quot;$status_code&quot; =~ ^2[0-9][0-9]$ ]]; then
      echo &quot;‚úÖ Updated system $system_name with status: $status&quot;
      update_count=$((update_count+1))
    else
      echo &quot;‚ùå Failed to update system $system_name. Status: $status_code&quot;
      [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot;
    fi
  done
  
  echo &quot;Total systems updated: $update_count/$num_systems&quot;
}

# FUNCTION: Update connections
update_connections() {
  echo &quot;==== Updating Connections ====&quot;
  load_systems
  load_connections
  
  if [ -z &quot;$CREATED_SYSTEM_IDS&quot; ] || [ -z &quot;$CREATED_CONNECTION_IDS&quot; ]; then
    echo &quot;No systems or connections available. Run creation tests first.&quot;
    return 1
  fi

  echo &quot;Testing connection updates...&quot;
  local update_count=0
  local conn_array=($CREATED_CONNECTION_IDS)
  
  for triple in &quot;${conn_array[@]}&quot;; do
    local source=$(echo $triple | cut -d: -f1)
    local target=$(echo $triple | cut -d: -f2)
    
    # Create update payload
    local mass_values=(0 1 2)
    local ship_values=(0 1 2 3)
    local mass=${mass_values[$((RANDOM % 3))]}
    local ship=${ship_values[$((RANDOM % 4))]}
    local payload=$(jq -n \
      --argjson mass &quot;$mass&quot; \
      --argjson ship &quot;$ship&quot; \
      &apos;{
        mass_status: $mass,
        ship_size_type: $ship
      }&apos;)
    
    # Try source/target update
    local raw=$(make_request PATCH &quot;$API_BASE_URL/api/maps/$MAP_SLUG/connections?solar_system_source=$source&amp;solar_system_target=$target&quot; &quot;$payload&quot;)
    local status_code=$(parse_status &quot;$raw&quot;)
    
    if [[ &quot;$status_code&quot; =~ ^2[0-9][0-9]$ ]]; then
      echo &quot;‚úÖ Updated connection $source-&gt;$target&quot;
      update_count=$((update_count+1))
    else
      echo &quot;‚ùå Failed to update connection $source-&gt;$target. Status: $status_code&quot;
      [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot;
    fi
  done
  
  echo &quot;Total connections updated: $update_count/${#conn_array[@]}&quot;
  
  echo -e &quot;\nTesting batch connection updates...&quot;
  # Create batch update payload for all connections
  local batch_connections=&quot;[&quot;
  local first=true
  for triple in &quot;${conn_array[@]}&quot;; do
    local source=$(echo $triple | cut -d: -f1)
    local target=$(echo $triple | cut -d: -f2)
    
    local mass=${mass_values[$((RANDOM % 3))]}
    local ship=${ship_values[$((RANDOM % 4))]}
    
    if [ &quot;$first&quot; = true ]; then
      first=false
    else
      batch_connections+=&quot;,&quot;
    fi
    
    batch_connections+=$(jq -n \
      --argjson source &quot;$source&quot; \
      --argjson target &quot;$target&quot; \
      --argjson mass &quot;$mass&quot; \
      --argjson ship &quot;$ship&quot; \
      &apos;{
        solar_system_source: $source,
        solar_system_target: $target,
        mass_status: $mass,
        ship_size_type: $ship
      }&apos;)
  done
  batch_connections+=&quot;]&quot;
  
  local batch_payload=&quot;{\&quot;connections\&quot;: $batch_connections}&quot;
  local raw=$(make_request POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot; &quot;$batch_payload&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local response=$(parse_response &quot;$raw&quot;)
    local updated_count=$(echo &quot;$response&quot; | jq &apos;.data.connections.updated&apos;)
    if [ &quot;$updated_count&quot; != &quot;null&quot; ]; then
      echo &quot;‚úÖ Batch update successful - Updated connections: $updated_count&quot;
    else
      echo &quot;‚ùå Batch update returned null for updated count&quot;
    fi
  else
    echo &quot;‚ùå Batch update failed. Status: $status&quot;
    [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot;
  fi
}

# FUNCTION: List systems and connections
list_systems_and_connections() {
  echo &quot;==== Listing Systems and Connections ====&quot;
  load_systems
  if [ -z &quot;$CREATED_SYSTEM_IDS&quot; ]; then
    echo &quot;No systems available. Run system creation first.&quot;
    return 1
  fi
  echo &quot;Testing list all systems and connections endpoint&quot;
  local raw=$(make_request GET &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    local response=$(parse_response &quot;$raw&quot;)
    local system_count=$(echo &quot;$response&quot; | jq &apos;.data.systems | length&apos;)
    local conn_count=$(echo &quot;$response&quot; | jq &apos;.data.connections | length&apos;)
    echo &quot;‚úÖ Listed $system_count systems and $conn_count connections&quot;
    [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;$response&quot; | jq &apos;.&apos;
    return 0
  else
    echo &quot;‚ùå Failed to list systems and connections. Status: $status&quot;
    return 1
  fi
}

# FUNCTION: Delete connections and systems
delete_everything() {
  echo &quot;==== Deleting Connections and Systems ====&quot;
  load_connections
  load_systems

  echo &quot;Cleaning up connections...&quot;
  # Delete connections using source/target pairs
  local conn_array=($CREATED_CONNECTION_IDS)
  for triple in &quot;${conn_array[@]}&quot;; do
    local source=$(echo $triple | cut -d: -f1)
    local target=$(echo $triple | cut -d: -f2)
    
    local raw=$(make_request DELETE &quot;$API_BASE_URL/api/maps/$MAP_SLUG/connections?solar_system_source=$source&amp;solar_system_target=$target&quot;)
    local status=$(parse_status &quot;$raw&quot;)
    if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
      echo &quot;‚úÖ Deleted connection $source-&gt;$target&quot;
    else
      echo &quot;‚ùå Failed to delete connection $source-&gt;$target. Status: $status&quot;
      [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot;
    fi
  done

  echo &quot;Cleaning up systems...&quot;
  # Use batch delete for systems
  local system_array=($CREATED_SYSTEM_IDS)
  echo &quot;Attempting batch delete of systems...&quot;
  echo &quot;System ${system_array[@]}&quot;
  
  local system_ids_json=$(printf &apos;%s\n&apos; &quot;${system_array[@]}&quot; | jq -R . | jq -s .)
  local payload=$(jq -n --argjson system_ids &quot;$system_ids_json&quot; &apos;{system_ids: $system_ids}&apos;)
  local raw=$(make_request DELETE &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot; &quot;$payload&quot;)
  local status=$(parse_status &quot;$raw&quot;)
  
  if [[ &quot;$status&quot; =~ ^2[0-9][0-9]$ ]]; then
    echo &quot;‚úÖ Batch delete successful for all systems&quot;
    &gt; &quot;$SYSTEMS_FILE&quot;
    &gt; &quot;$CONNECTIONS_FILE&quot;
    CREATED_SYSTEM_IDS=&quot;&quot;
    CREATED_CONNECTION_IDS=&quot;&quot;
  else
    echo &quot;‚ùå Batch delete failed. Status: $status&quot;
    [[ &quot;$VERBOSE&quot; == &quot;true&quot; ]] &amp;&amp; echo &quot;Response: $(parse_response &quot;$raw&quot;)&quot;
  fi
}

# ‚îÄ‚îÄ‚îÄ MENU AND INTERACTION LOGIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

show_menu() {
  echo &quot;===== Map System and Connection API Tests =====&quot;
  echo &quot;1. Run all tests in sequence (with pauses)&quot;
  echo &quot;2. Create systems&quot;
  echo &quot;3. Create connections&quot;
  echo &quot;4. Update systems&quot;
  echo &quot;5. Update connections&quot;
  echo &quot;6. List systems and connections&quot;
  echo &quot;7. Delete everything&quot;
  echo &quot;8. Exit&quot;
  echo &quot;================================================&quot;
  echo &quot;Enter your choice [1-8]: &quot;
}

# ‚îÄ‚îÄ‚îÄ MAIN EXECUTION FLOW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# Main execution based on command
case &quot;$COMMAND&quot; in
  &quot;all&quot;)
    # If no specific command was provided, show the menu
    if [ -t 0 ]; then  # Only show menu if running interactively
      # Interactive mode with menu
      while true; do
        show_menu
        read -r choice
        
        case $choice in
          1)
            # Run all tests in sequence with pauses
            create_systems || echo &quot;System creation failed/skipped&quot;
            echo &quot;Press Enter to continue with connection creation...&quot;
            read -r
            
            create_connections || echo &quot;Connection creation failed/skipped&quot;
            echo &quot;Press Enter to continue with system updates...&quot;
            read -r
            
            update_systems || echo &quot;System update failed/skipped&quot;
            echo &quot;Press Enter to continue with connection updates...&quot;
            read -r
            
            update_connections || echo &quot;Connection update failed/skipped&quot;
            echo &quot;Press Enter to continue with listing tests...&quot;
            read -r
            
            list_systems_and_connections || echo &quot;Listing failed/skipped&quot;
            echo &quot;Press Enter to continue with deletion...&quot;
            read -r
            
            delete_everything || echo &quot;Cleanup failed/skipped&quot;
            echo &quot;All tests completed.&quot;
            ;;
          2)
            create_systems
            ;;
          3)
            create_connections
            ;;
          4)
            update_systems
            ;;
          5)
            update_connections
            ;;
          6)
            list_systems_and_connections
            ;;
          7)
            delete_everything
            ;;
          8)
            # Offer to clean up before exiting
            read -p &quot;Clean up any remaining test data before exiting? (y/n): &quot; confirm
            if [[ &quot;$confirm&quot; =~ ^[Yy] ]]; then
              delete_everything
            fi
            exit 0
            ;;
          *)
            echo &quot;Invalid option. Please try again.&quot;
            ;;
        esac
      done
    else
      # Non-interactive mode, run all tests in sequence
      create_systems || echo &quot;System creation failed/skipped&quot;
      create_connections || echo &quot;Connection creation failed/skipped&quot;
      update_systems || echo &quot;System update failed/skipped&quot;
      update_connections || echo &quot;Connection update failed/skipped&quot;
      list_systems_and_connections || echo &quot;Listing failed/skipped&quot;
      delete_everything || echo &quot;Cleanup failed/skipped&quot;
    fi
    ;;
  &quot;create&quot;)
    create_systems
    create_connections
    ;;
  &quot;update&quot;)
    update_systems
    update_connections
    list_systems_and_connections
    ;;
  &quot;delete&quot;)
    delete_everything
    ;;
  *)
    echo &quot;Invalid command: $COMMAND&quot;
    echo &quot;Use -h for help&quot;
    exit 1
    ;;
esac

exit 0</file><file path="test/manual/api/utils.sh">#!/bin/bash
set -eu

# ‚îÄ‚îÄ‚îÄ Dependencies ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
for cmd in curl jq; do
  if ! command -v &quot;$cmd&quot; &gt; /dev/null 2&gt;&amp;1; then
    echo &quot;Error: &apos;$cmd&apos; is required&quot; &gt;&amp;2
    exit 1
  fi
done


# ‚îÄ‚îÄ‚îÄ Load .env if present ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
load_env_file() {
  echo &quot;üìÑ Loading env file: $1&quot;
  set -o allexport
  source &quot;$1&quot;
  set +o allexport
}

SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;$0&quot;)&quot; &amp;&amp; pwd)&quot;

if [ -f &quot;$SCRIPT_DIR/.env&quot; ]; then
  load_env_file &quot;$SCRIPT_DIR/.env&quot;
fi

# Check if API_TOKEN is set
: &quot;${API_TOKEN:?Error: API_TOKEN environment variable not set}&quot;

# ‚îÄ‚îÄ‚îÄ HTTP Request Helper ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
make_request() {
  local method=$1 url=$2 data=${3:-}
  local curl_cmd=(curl -s -w $&apos;\n%{http_code}&apos; -H &quot;Authorization: Bearer $API_TOKEN&quot;)

  if [ &quot;$method&quot; != &quot;GET&quot; ]; then
    curl_cmd+=(-X &quot;$method&quot; -H &quot;Content-Type: application/json&quot;)
  fi

  if [ -n &quot;$data&quot; ]; then
    curl_cmd+=(-d &quot;$data&quot;)
  fi

  &quot;${curl_cmd[@]}&quot; &quot;$url&quot;
}

# ‚îÄ‚îÄ‚îÄ Response Parsers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
parse_response() {   # strips the final newline+status line
  local raw=&quot;$1&quot;
  echo &quot;${raw%$&apos;\n&apos;*}&quot;
}

parse_status() {     # returns only the status code (last line)
  local raw=&quot;$1&quot;
  echo &quot;${raw##*$&apos;\n&apos;}&quot;
}

# ‚îÄ‚îÄ‚îÄ Assertion Helper ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
verify_http_code() {
  local got=$1 want=$2 label=$3
  if [ &quot;$got&quot; -eq &quot;$want&quot; ]; then
    return 0
  else
    echo &quot;üö´ $label: expected HTTP $want, got $got&quot; &gt;&amp;2
    return 1
  fi
}

# ‚îÄ‚îÄ‚îÄ Test Runner &amp; Summary ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Only initialize counters once to accumulate across multiple suite sources
if [ -z &quot;${TOTAL_TESTS+x}&quot; ]; then
  TOTAL_TESTS=0
  PASSED_TESTS=0
  FAILED_TESTS=0
  FAILED_LIST=&quot;&quot;
fi

run_test() {
  local label=$1 fn=$2
  TOTAL_TESTS=$((TOTAL_TESTS+1))
  if &quot;$fn&quot;; then
    echo &quot;‚úÖ $label&quot;
    PASSED_TESTS=$((PASSED_TESTS+1))
  else
    echo &quot;‚ùå $label&quot;
    FAILED_TESTS=$((FAILED_TESTS+1))
    FAILED_LIST=&quot;$FAILED_LIST $label&quot;
  fi
}

# ‚îÄ‚îÄ‚îÄ Cleanup on Exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
CREATED_SYSTEM_IDS=&quot;&quot;
CREATED_CONNECTION_IDS=&quot;&quot;

cleanup_map_systems() {
  # First delete connections
  if [ -n &quot;$CREATED_CONNECTION_IDS&quot; ]; then
    echo &quot;Cleaning up connections...&quot;
    for conn_id in $CREATED_CONNECTION_IDS; do
      # Try with a direct DELETE request to the connection endpoint
      make_request DELETE &quot;$API_BASE_URL/api/maps/$MAP_SLUG/connections/$conn_id&quot; &gt; /dev/null 2&gt;&amp;1 || true
    done
  fi
  
  # Then delete systems
  if [ -n &quot;$CREATED_SYSTEM_IDS&quot; ]; then
    echo &quot;Cleaning up systems...&quot;
    
    # First try batch delete if we have multiple systems
    if [ $(echo &quot;$CREATED_SYSTEM_IDS&quot; | wc -w) -gt 1 ]; then
      echo &quot;Attempting batch delete of systems...&quot;
      
      # Use the official batch_delete endpoint
      local payload=$(echo &quot;$CREATED_SYSTEM_IDS&quot; | tr &apos; &apos; &apos;\n&apos; | jq -R . | jq -s &apos;{system_ids: .}&apos;)
      local raw
      raw=$(make_request POST &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems/batch_delete&quot; &quot;$payload&quot; 2&gt;/dev/null) || true
      
      # Check if batch delete was successful by looking for systems
      sleep 1
      local success=1
      
      for sys_id in $CREATED_SYSTEM_IDS; do
        # Check if system still exists and is visible
        local check=$(curl -s -H &quot;Authorization: Bearer $API_TOKEN&quot; &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
        if echo &quot;$check&quot; | grep -q &quot;\&quot;solar_system_id\&quot;:$sys_id&quot;; then
          if echo &quot;$check&quot; | grep -q &quot;\&quot;solar_system_id\&quot;:$sys_id.*\&quot;visible\&quot;:true&quot;; then
            success=0
          else
            echo &quot;System $sys_id exists but is not visible (batch delete worked)&quot;
          fi
        else
          echo &quot;System $sys_id no longer found (batch delete worked)&quot;
        fi
      done
      
      # If batch delete was successful for all systems, we&apos;re done
      if [ $success -eq 1 ]; then
        echo &quot;‚úÖ Batch delete successful for all systems&quot;
        return 0
      fi
    fi
    
    # If batch delete failed or we have only one system, try individual deletes
    echo &quot;Performing individual system deletions...&quot;
    
    for sys_id in $CREATED_SYSTEM_IDS; do
      echo &quot;Deleting system $sys_id...&quot;
      
      # Try standard DELETE request
      make_request DELETE &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems/$sys_id&quot; &gt; /dev/null 2&gt;&amp;1 || true
      
      # Verify the system was deleted or at least made invisible
      sleep 1
      local check=$(curl -s -H &quot;Authorization: Bearer $API_TOKEN&quot; &quot;$API_BASE_URL/api/maps/$MAP_SLUG/systems&quot;)
      
      if echo &quot;$check&quot; | grep -q &quot;\&quot;solar_system_id\&quot;:$sys_id&quot;; then
        if echo &quot;$check&quot; | grep -q &quot;\&quot;solar_system_id\&quot;:$sys_id.*\&quot;visible\&quot;:true&quot;; then
          echo &quot;‚ö†Ô∏è System $sys_id is still visible after all deletion attempts&quot;
        else
          echo &quot;System $sys_id exists but is not visible (deletion worked)&quot;
        fi
      else
        echo &quot;System $sys_id no longer found (deletion worked)&quot;
      fi
    done
  fi
}
#trap cleanup_map_systems EXIT</file><file path="test/support/conn_case.ex">defmodule WandererAppWeb.ConnCase do
  @moduledoc &quot;&quot;&quot;
  This module defines the test case to be used by
  tests that require setting up a connection.

  Such tests rely on `Phoenix.ConnTest` and also
  import other functionality to make it easier
  to build common data structures and query the data layer.

  Finally, if the test case interacts with the database,
  we enable the SQL sandbox, so changes done to the database
  are reverted at the end of every test. If you are using
  PostgreSQL, you can even run database tests asynchronously
  by setting `use WandererAppWeb.ConnCase, async: true`, although
  this option is not recommended for other databases.
  &quot;&quot;&quot;

  use ExUnit.CaseTemplate

  using do
    quote do
      # The default endpoint for testing
      @endpoint WandererAppWeb.Endpoint

      use WandererAppWeb, :verified_routes

      # Import conveniences for testing with connections
      import Plug.Conn
      import Phoenix.ConnTest
      import WandererAppWeb.ConnCase
    end
  end

  setup tags do
    WandererApp.DataCase.setup_sandbox(tags)
    {:ok, conn: Phoenix.ConnTest.build_conn()}
  end
end</file><file path="test/support/data_case.ex">defmodule WandererApp.DataCase do
  @moduledoc &quot;&quot;&quot;
  This module defines the setup for tests requiring
  access to the application&apos;s data layer.

  You may define functions here to be used as helpers in
  your tests.

  Finally, if the test case interacts with the database,
  we enable the SQL sandbox, so changes done to the database
  are reverted at the end of every test. If you are using
  PostgreSQL, you can even run database tests asynchronously
  by setting `use WandererApp.DataCase, async: true`, although
  this option is not recommended for other databases.
  &quot;&quot;&quot;

  use ExUnit.CaseTemplate

  using do
    quote do
      alias WandererApp.Repo

      import Ecto
      import Ecto.Changeset
      import Ecto.Query
      import WandererApp.DataCase
    end
  end

  setup tags do
    WandererApp.DataCase.setup_sandbox(tags)
    :ok
  end

  @doc &quot;&quot;&quot;
  Sets up the sandbox based on the test tags.
  &quot;&quot;&quot;
  def setup_sandbox(tags) do
    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(WandererApp.Repo, shared: not tags[:async])
    on_exit(fn -&gt; Ecto.Adapters.SQL.Sandbox.stop_owner(pid) end)
  end

  @doc &quot;&quot;&quot;
  A helper that transforms changeset errors into a map of messages.

      assert {:error, changeset} = Accounts.create_user(%{password: &quot;short&quot;})
      assert &quot;password is too short&quot; in errors_on(changeset).password
      assert %{password: [&quot;password is too short&quot;]} = errors_on(changeset)

  &quot;&quot;&quot;
  def errors_on(changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {message, opts} -&gt;
      Regex.replace(~r&quot;%{(\w+)}&quot;, message, fn _, key -&gt;
        opts |&gt; Keyword.get(String.to_existing_atom(key), key) |&gt; to_string()
      end)
    end)
  end
end</file><file path="test/unit/character_api_controller_test.exs"># Standalone test for the CharacterAPIController
#
# This file can be run directly with:
#   elixir test/standalone/character_api_controller_test.exs
#
# It doesn&apos;t require any database connections or external dependencies.

# Start ExUnit
ExUnit.start()

defmodule CharacterAPIControllerTest do
  use ExUnit.Case

  # Mock modules to simulate the behavior of the controller&apos;s dependencies
  defmodule MockUtil do
    def require_param(params, key) do
      case params[key] do
        nil -&gt; {:error, &quot;Missing required param: #{key}&quot;}
        &quot;&quot;  -&gt; {:error, &quot;Param #{key} cannot be empty&quot;}
        val -&gt; {:ok, val}
      end
    end

    def parse_int(str) do
      case Integer.parse(str) do
        {num, &quot;&quot;} -&gt; {:ok, num}
        _         -&gt; {:error, &quot;Invalid integer for param id=#{str}&quot;}
      end
    end

    def parse_bool(str) do
      case str do
        &quot;true&quot;  -&gt; {:ok, true}
        &quot;false&quot; -&gt; {:ok, false}
        _       -&gt; {:error, &quot;Invalid boolean value: #{str}&quot;}
      end
    end
  end

  defmodule MockCharacterRepo do
    # In-memory storage for character tracking data
    def init_storage do
      :ets.new(:character_tracking, [:set, :public, :named_table])

      # Initialize with some test data
      :ets.insert(:character_tracking, {&quot;user1&quot;, [
        %{eve_id: &quot;123456&quot;, name: &quot;Character One&quot;, tracked: true, followed: true},
        %{eve_id: &quot;234567&quot;, name: &quot;Character Two&quot;, tracked: true, followed: false},
        %{eve_id: &quot;345678&quot;, name: &quot;Character Three&quot;, tracked: false, followed: false}
      ]})

      :ets.insert(:character_tracking, {&quot;user2&quot;, [
        %{eve_id: &quot;456789&quot;, name: &quot;Character Four&quot;, tracked: true, followed: true}
      ]})
    end

    def get_tracking_data(user_id) do
      case :ets.lookup(:character_tracking, user_id) do
        [{^user_id, data}] -&gt; {:ok, data}
        [] -&gt; {:ok, []}
      end
    end

    def update_tracking_data(user_id, new_data) do
      :ets.insert(:character_tracking, {user_id, new_data})
      {:ok, new_data}
    end

    def toggle_character_follow(user_id, character_id, follow_state) do
      case get_tracking_data(user_id) do
        {:ok, data} -&gt;
          # Find the character and update its followed state
          updated_data = Enum.map(data, fn char -&gt;
            if char.eve_id == character_id do
              %{char | followed: follow_state}
            else
              char
            end
          end)

          # Update the storage
          update_tracking_data(user_id, updated_data)

          # Return the updated character
          updated_char = Enum.find(updated_data, fn char -&gt; char.eve_id == character_id end)
          {:ok, updated_char}

        error -&gt; error
      end
    end

    def toggle_character_track(user_id, character_id, track_state) do
      case get_tracking_data(user_id) do
        {:ok, data} -&gt;
          # Find the character and update its tracked state
          updated_data = Enum.map(data, fn char -&gt;
            if char.eve_id == character_id do
              %{char | tracked: track_state}
            else
              char
            end
          end)

          # Update the storage
          update_tracking_data(user_id, updated_data)

          # Return the updated character
          updated_char = Enum.find(updated_data, fn char -&gt; char.eve_id == character_id end)
          {:ok, updated_char}

        error -&gt; error
      end
    end
  end

  defmodule MockTrackingUtils do
    def check_tracking_consistency(tracking_data) do
      # Log warnings for characters that are followed but not tracked
      inconsistent_chars = Enum.filter(tracking_data, fn char -&gt;
        char[:followed] == true &amp;&amp; char[:tracked] == false
      end)

      if length(inconsistent_chars) &gt; 0 do
        Enum.each(inconsistent_chars, fn char -&gt;
          eve_id = Map.get(char, :eve_id, &quot;unknown&quot;)
          name = Map.get(char, :name, &quot;Unknown Character&quot;)
          IO.puts(&quot;WARNING: Inconsistent state detected - Character (ID: #{eve_id}, Name: #{name}) is followed but not tracked&quot;)
        end)
      end

      # Return the original data unchanged
      tracking_data
    end
  end

  # Mock controller that uses our mock dependencies
  defmodule MockCharacterAPIController do
    # Simplified version of toggle_follow from CharacterAPIController
    def toggle_follow(params, user_id) do
      with {:ok, character_id} &lt;- MockUtil.require_param(params, &quot;character_id&quot;),
           {:ok, follow_str} &lt;- MockUtil.require_param(params, &quot;follow&quot;),
           {:ok, follow} &lt;- MockUtil.parse_bool(follow_str) do

        case MockCharacterRepo.toggle_character_follow(user_id, character_id, follow) do
          {:ok, updated_char} -&gt;
            # Get all tracking data to check consistency
            {:ok, all_tracking} = MockCharacterRepo.get_tracking_data(user_id)

            # Check for inconsistencies (characters followed but not tracked)
            MockTrackingUtils.check_tracking_consistency(all_tracking)

            # Return the updated character
            {:ok, %{data: updated_char}}

          {:error, reason} -&gt;
            {:error, :internal_server_error, &quot;Failed to update character: #{reason}&quot;}
        end
      else
        {:error, msg} -&gt;
          {:error, :bad_request, msg}
      end
    end

    # Simplified version of toggle_track from CharacterAPIController
    def toggle_track(params, user_id) do
      with {:ok, character_id} &lt;- MockUtil.require_param(params, &quot;character_id&quot;),
           {:ok, track_str} &lt;- MockUtil.require_param(params, &quot;track&quot;),
           {:ok, track} &lt;- MockUtil.parse_bool(track_str) do

        # If we&apos;re untracking a character, we should also unfollow it
        result = if track == false do
          # First unfollow if needed
          MockCharacterRepo.toggle_character_follow(user_id, character_id, false)
          # Then untrack
          MockCharacterRepo.toggle_character_track(user_id, character_id, false)
        else
          # Just track
          MockCharacterRepo.toggle_character_track(user_id, character_id, true)
        end

        case result do
          {:ok, updated_char} -&gt;
            # Get all tracking data to check consistency
            {:ok, all_tracking} = MockCharacterRepo.get_tracking_data(user_id)

            # Check for inconsistencies (characters followed but not tracked)
            MockTrackingUtils.check_tracking_consistency(all_tracking)

            # Return the updated character
            {:ok, %{data: updated_char}}

          {:error, reason} -&gt;
            {:error, :internal_server_error, &quot;Failed to update character: #{reason}&quot;}
        end
      else
        {:error, msg} -&gt;
          {:error, :bad_request, msg}
      end
    end

    # Simplified version of list_tracking from CharacterAPIController
    def list_tracking(user_id) do
      case MockCharacterRepo.get_tracking_data(user_id) do
        {:ok, tracking_data} -&gt;
          # Check for inconsistencies
          checked_data = MockTrackingUtils.check_tracking_consistency(tracking_data)

          # Return the data
          {:ok, %{data: checked_data}}

        {:error, reason} -&gt;
          {:error, :internal_server_error, &quot;Failed to get tracking data: #{reason}&quot;}
      end
    end
  end

  # Setup for tests
  setup do
    # Initialize the mock storage
    MockCharacterRepo.init_storage()
    :ok
  end

  describe &quot;toggle_follow/2&quot; do
    test &quot;follows a character successfully&quot; do
      params = %{&quot;character_id&quot; =&gt; &quot;345678&quot;, &quot;follow&quot; =&gt; &quot;true&quot;}
      result = MockCharacterAPIController.toggle_follow(params, &quot;user1&quot;)

      assert {:ok, %{data: data}} = result
      assert data.eve_id == &quot;345678&quot;
      assert data.name == &quot;Character Three&quot;
      assert data.followed == true
      assert data.tracked == false

      # This should have created an inconsistency (followed but not tracked)
      # The check_tracking_consistency function should have logged a warning
    end

    test &quot;unfollows a character successfully&quot; do
      params = %{&quot;character_id&quot; =&gt; &quot;123456&quot;, &quot;follow&quot; =&gt; &quot;false&quot;}
      result = MockCharacterAPIController.toggle_follow(params, &quot;user1&quot;)

      assert {:ok, %{data: data}} = result
      assert data.eve_id == &quot;123456&quot;
      assert data.followed == false
      assert data.tracked == true
    end

    test &quot;returns error when character_id is missing&quot; do
      params = %{&quot;follow&quot; =&gt; &quot;true&quot;}
      result = MockCharacterAPIController.toggle_follow(params, &quot;user1&quot;)

      assert {:error, :bad_request, message} = result
      assert message == &quot;Missing required param: character_id&quot;
    end

    test &quot;returns error when follow is not a valid boolean&quot; do
      params = %{&quot;character_id&quot; =&gt; &quot;123456&quot;, &quot;follow&quot; =&gt; &quot;not-a-boolean&quot;}
      result = MockCharacterAPIController.toggle_follow(params, &quot;user1&quot;)

      assert {:error, :bad_request, message} = result
      assert message =~ &quot;Invalid boolean value&quot;
    end
  end

  describe &quot;toggle_track/2&quot; do
    test &quot;tracks a character successfully&quot; do
      params = %{&quot;character_id&quot; =&gt; &quot;345678&quot;, &quot;track&quot; =&gt; &quot;true&quot;}
      result = MockCharacterAPIController.toggle_track(params, &quot;user1&quot;)

      assert {:ok, %{data: data}} = result
      assert data.eve_id == &quot;345678&quot;
      assert data.tracked == true
    end

    test &quot;untracks and unfollows a character&quot; do
      # First, make sure the character is followed
      follow_params = %{&quot;character_id&quot; =&gt; &quot;123456&quot;, &quot;follow&quot; =&gt; &quot;true&quot;}
      MockCharacterAPIController.toggle_follow(follow_params, &quot;user1&quot;)

      # Now untrack the character
      params = %{&quot;character_id&quot; =&gt; &quot;123456&quot;, &quot;track&quot; =&gt; &quot;false&quot;}
      result = MockCharacterAPIController.toggle_track(params, &quot;user1&quot;)

      assert {:ok, %{data: data}} = result
      assert data.eve_id == &quot;123456&quot;
      assert data.tracked == false
      assert data.followed == false  # Should also be unfollowed
    end

    test &quot;returns error when character_id is missing&quot; do
      params = %{&quot;track&quot; =&gt; &quot;true&quot;}
      result = MockCharacterAPIController.toggle_track(params, &quot;user1&quot;)

      assert {:error, :bad_request, message} = result
      assert message == &quot;Missing required param: character_id&quot;
    end

    test &quot;returns error when track is not a valid boolean&quot; do
      params = %{&quot;character_id&quot; =&gt; &quot;123456&quot;, &quot;track&quot; =&gt; &quot;not-a-boolean&quot;}
      result = MockCharacterAPIController.toggle_track(params, &quot;user1&quot;)

      assert {:error, :bad_request, message} = result
      assert message =~ &quot;Invalid boolean value&quot;
    end
  end

  describe &quot;list_tracking/1&quot; do
    test &quot;returns tracking data for a user&quot; do
      result = MockCharacterAPIController.list_tracking(&quot;user1&quot;)

      assert {:ok, %{data: data}} = result
      assert length(data) == 3

      # Check that the data contains the expected characters
      char_one = Enum.find(data, fn char -&gt; char.eve_id == &quot;123456&quot; end)
      assert char_one.name == &quot;Character One&quot;
      assert char_one.tracked == true
      assert char_one.followed == true

      char_two = Enum.find(data, fn char -&gt; char.eve_id == &quot;234567&quot; end)
      assert char_two.name == &quot;Character Two&quot;
      assert char_two.tracked == true
      assert char_two.followed == false
    end

    test &quot;returns empty list for user with no tracking data&quot; do
      result = MockCharacterAPIController.list_tracking(&quot;non-existent-user&quot;)

      assert {:ok, %{data: data}} = result
      assert data == []
    end
  end
end</file><file path="test/unit/common_api_controller_test.exs"># Standalone test for the CommonAPIController
#
# This file can be run directly with:
#   elixir test/standalone/common_api_controller_test.exs
#
# It doesn&apos;t require any database connections or external dependencies.

# Start ExUnit
ExUnit.start()

defmodule CommonAPIControllerTest do
  use ExUnit.Case

  # Mock modules to simulate the behavior of the controller&apos;s dependencies
  defmodule MockUtil do
    def require_param(params, key) do
      case params[key] do
        nil -&gt; {:error, &quot;Missing required param: #{key}&quot;}
        &quot;&quot;  -&gt; {:error, &quot;Param #{key} cannot be empty&quot;}
        val -&gt; {:ok, val}
      end
    end

    def parse_int(str) do
      case Integer.parse(str) do
        {num, &quot;&quot;} -&gt; {:ok, num}
        _         -&gt; {:error, &quot;Invalid integer for param id=#{str}&quot;}
      end
    end
  end

  defmodule MockCachedInfo do
    def get_system_static_info(30000142) do
      {:ok, %{
        solar_system_id: 30000142,
        region_id: 10000002,
        constellation_id: 20000020,
        solar_system_name: &quot;Jita&quot;,
        solar_system_name_lc: &quot;jita&quot;,
        constellation_name: &quot;Kimotoro&quot;,
        region_name: &quot;The Forge&quot;,
        system_class: 0,
        security: &quot;0.9&quot;,
        type_description: &quot;High Security&quot;,
        class_title: &quot;High Sec&quot;,
        is_shattered: false,
        effect_name: nil,
        effect_power: nil,
        statics: [],
        wandering: [],
        triglavian_invasion_status: nil,
        sun_type_id: 45041
      }}
    end

    def get_system_static_info(31000005) do
      {:ok, %{
        solar_system_id: 31000005,
        region_id: 11000000,
        constellation_id: 21000000,
        solar_system_name: &quot;J123456&quot;,
        solar_system_name_lc: &quot;j123456&quot;,
        constellation_name: &quot;Unknown&quot;,
        region_name: &quot;Wormhole Space&quot;,
        system_class: 1,
        security: &quot;-0.9&quot;,
        type_description: &quot;Wormhole&quot;,
        class_title: &quot;Class 1&quot;,
        is_shattered: false,
        effect_name: &quot;Wolf-Rayet Star&quot;,
        effect_power: 1,
        statics: [&quot;N110&quot;],
        wandering: [&quot;K162&quot;],
        triglavian_invasion_status: nil,
        sun_type_id: 45042
      }}
    end

    def get_system_static_info(_) do
      {:error, :not_found}
    end

    def get_wormhole_types do
      {:ok, [
        %{
          name: &quot;N110&quot;,
          dest: 1,
          lifetime: &quot;16h&quot;,
          total_mass: 500000000,
          max_mass_per_jump: 20000000,
          mass_regen: 0
        }
      ]}
    end

    def get_wormhole_classes! do
      [
        %{
          id: 1,
          title: &quot;Class 1 Wormhole&quot;,
          short_name: &quot;C1&quot;
        }
      ]
    end
  end

  # Mock controller that uses our mock dependencies
  defmodule MockCommonAPIController do
    # Simplified version of show_system_static from CommonAPIController
    def show_system_static(params) do
      with {:ok, solar_system_str} &lt;- MockUtil.require_param(params, &quot;id&quot;),
           {:ok, solar_system_id} &lt;- MockUtil.parse_int(solar_system_str) do
        case MockCachedInfo.get_system_static_info(solar_system_id) do
          {:ok, system} -&gt;
            # Get basic system data
            data = static_system_to_json(system)

            # Enhance with wormhole type information if statics exist
            enhanced_data = enhance_with_static_details(data)

            # Return the enhanced data
            {:ok, %{data: enhanced_data}}

          {:error, :not_found} -&gt;
            {:error, :not_found, &quot;System not found&quot;}
        end
      else
        {:error, msg} -&gt;
          {:error, :bad_request, msg}
      end
    end

    # Helper function to convert a system to JSON format
    defp static_system_to_json(system) do
      system
      |&gt; Map.take([
        :solar_system_id,
        :region_id,
        :constellation_id,
        :solar_system_name,
        :solar_system_name_lc,
        :constellation_name,
        :region_name,
        :system_class,
        :security,
        :type_description,
        :class_title,
        :is_shattered,
        :effect_name,
        :effect_power,
        :statics,
        :wandering,
        :triglavian_invasion_status,
        :sun_type_id
      ])
    end

    # Helper function to enhance system data with wormhole type information
    defp enhance_with_static_details(data) do
      if data[:statics] &amp;&amp; length(data[:statics]) &gt; 0 do
        # Add the enhanced static details to the response
        Map.put(data, :static_details, get_static_details(data[:statics]))
      else
        # No statics, return the original data
        data
      end
    end

    # Helper function to get detailed information for each static wormhole
    defp get_static_details(statics) do
      # Get wormhole data from CachedInfo
      {:ok, wormhole_types} = MockCachedInfo.get_wormhole_types()
      wormhole_classes = MockCachedInfo.get_wormhole_classes!()

      # Create a map of wormhole classes by ID for quick lookup
      classes_by_id = Enum.reduce(wormhole_classes, %{}, fn class, acc -&gt;
        Map.put(acc, class.id, class)
      end)

      # Find detailed information for each static
      Enum.map(statics, fn static_name -&gt;
        # Find the wormhole type by name
        wh_type = Enum.find(wormhole_types, fn type -&gt; type.name == static_name end)

        if wh_type do
          create_wormhole_details(wh_type, classes_by_id)
        else
          create_fallback_wormhole_details(static_name)
        end
      end)
    end

    # Helper function to create detailed wormhole information
    defp create_wormhole_details(wh_type, classes_by_id) do
      # Get destination class info
      dest_class = Map.get(classes_by_id, wh_type.dest)

      # Create enhanced static info
      %{
        name: wh_type.name,
        destination: %{
          id: to_string(wh_type.dest),
          name: (if dest_class, do: dest_class.title, else: wh_type.dest),
          short_name: (if dest_class, do: dest_class.short_name, else: wh_type.dest)
        },
        properties: %{
          lifetime: wh_type.lifetime,
          max_mass: wh_type.total_mass,
          max_jump_mass: wh_type.max_mass_per_jump,
          mass_regeneration: wh_type.mass_regen
        }
      }
    end

    # Helper function to create fallback information
    defp create_fallback_wormhole_details(static_name) do
      %{
        name: static_name,
        destination: %{
          id: nil,
          name: &quot;Unknown&quot;,
          short_name: &quot;?&quot;
        },
        properties: %{
          lifetime: nil,
          max_mass: nil,
          max_jump_mass: nil,
          mass_regeneration: nil
        }
      }
    end
  end

  describe &quot;show_system_static/1&quot; do
    test &quot;returns system static info for a high-sec system&quot; do
      params = %{&quot;id&quot; =&gt; &quot;30000142&quot;}
      result = MockCommonAPIController.show_system_static(params)

      assert {:ok, %{data: data}} = result
      assert data.solar_system_id == 30000142
      assert data.solar_system_name == &quot;Jita&quot;
      assert data.region_name == &quot;The Forge&quot;
      assert data.security == &quot;0.9&quot;
      assert data.type_description == &quot;High Security&quot;
      refute Map.has_key?(data, :static_details)
    end

    test &quot;returns system static info with static details for a wormhole system&quot; do
      params = %{&quot;id&quot; =&gt; &quot;31000005&quot;}
      result = MockCommonAPIController.show_system_static(params)

      assert {:ok, %{data: data}} = result
      assert data.solar_system_id == 31000005
      assert data.solar_system_name == &quot;J123456&quot;
      assert data.region_name == &quot;Wormhole Space&quot;
      assert data.system_class == 1
      assert data.security == &quot;-0.9&quot;
      assert data.type_description == &quot;Wormhole&quot;
      assert data.effect_name == &quot;Wolf-Rayet Star&quot;

      # Check static details
      assert Map.has_key?(data, :static_details)
      assert length(data.static_details) == 1

      static = List.first(data.static_details)
      assert static.name == &quot;N110&quot;
      assert static.destination.id == &quot;1&quot;
      assert static.destination.name == &quot;Class 1 Wormhole&quot;
      assert static.destination.short_name == &quot;C1&quot;
      assert static.properties.lifetime == &quot;16h&quot;
      assert static.properties.max_mass == 500000000
    end

    test &quot;returns error when system is not found&quot; do
      params = %{&quot;id&quot; =&gt; &quot;99999999&quot;}
      result = MockCommonAPIController.show_system_static(params)

      assert {:error, :not_found, &quot;System not found&quot;} = result
    end

    test &quot;returns error when system_id is not provided&quot; do
      params = %{}
      result = MockCommonAPIController.show_system_static(params)

      assert {:error, :bad_request, message} = result
      assert message == &quot;Missing required param: id&quot;
    end

    test &quot;returns error when system_id is not a valid integer&quot; do
      params = %{&quot;id&quot; =&gt; &quot;not-an-integer&quot;}
      result = MockCommonAPIController.show_system_static(params)

      assert {:error, :bad_request, message} = result
      assert message =~ &quot;Invalid integer for param id&quot;
    end
  end
end</file><file path="test/unit/map_api_controller_test.exs"># Standalone test for the MapAPIController
#
# This file can be run directly with:
#   elixir test/standalone/map_api_controller_test.exs
#
# It doesn&apos;t require any database connections or external dependencies.

# Start ExUnit
ExUnit.start()

defmodule MapAPIControllerTest do
  use ExUnit.Case

  # Mock modules to simulate the behavior of the controller&apos;s dependencies
  defmodule MockUtil do
    def require_param(params, key) do
      case params[key] do
        nil -&gt; {:error, &quot;Missing required param: #{key}&quot;}
        &quot;&quot;  -&gt; {:error, &quot;Param #{key} cannot be empty&quot;}
        val -&gt; {:ok, val}
      end
    end

    def parse_int(str) do
      case Integer.parse(str) do
        {num, &quot;&quot;} -&gt; {:ok, num}
        _         -&gt; {:error, &quot;Invalid integer for param id=#{str}&quot;}
      end
    end

    def fetch_map_id(params) do
      cond do
        params[&quot;map_id&quot;] -&gt;
          case parse_int(params[&quot;map_id&quot;]) do
            {:ok, map_id} -&gt; {:ok, map_id}
            {:error, _} -&gt; {:error, &quot;Invalid map_id format&quot;}
          end
        params[&quot;slug&quot;] -&gt;
          # In a real app, this would look up the map by slug
          # For testing, we&apos;ll just use a simple mapping
          case params[&quot;slug&quot;] do
            &quot;test-map&quot; -&gt; {:ok, 1}
            &quot;another-map&quot; -&gt; {:ok, 2}
            _ -&gt; {:error, &quot;Map not found&quot;}
          end
        true -&gt;
          {:error, &quot;Missing required param: map_id or slug&quot;}
      end
    end
  end

  defmodule MockMapSystemRepo do
    def get_visible_systems_by_map_id(1) do
      [
        %{id: 30000142, name: &quot;Jita&quot;, security: 0.9, region_id: 10000002},
        %{id: 30002659, name: &quot;Dodixie&quot;, security: 0.9, region_id: 10000032},
        %{id: 30002187, name: &quot;Amarr&quot;, security: 1.0, region_id: 10000043}
      ]
    end

    def get_visible_systems_by_map_id(_) do
      []
    end

    def get_system_by_id(1, 30000142) do
      %{id: 30000142, name: &quot;Jita&quot;, security: 0.9, region_id: 10000002}
    end

    def get_system_by_id(1, 30002659) do
      %{id: 30002659, name: &quot;Dodixie&quot;, security: 0.9, region_id: 10000032}
    end

    def get_system_by_id(1, 30002187) do
      %{id: 30002187, name: &quot;Amarr&quot;, security: 1.0, region_id: 10000043}
    end

    def get_system_by_id(_, _) do
      nil
    end
  end

  defmodule MockMapSolarSystem do
    def get_name_by_id(30000142), do: &quot;Jita&quot;
    def get_name_by_id(30002659), do: &quot;Dodixie&quot;
    def get_name_by_id(30002187), do: &quot;Amarr&quot;
    def get_name_by_id(_), do: nil
  end

  # Mock controller that uses our mock dependencies
  defmodule MockMapAPIController do
    # Simplified version of list_systems from MapAPIController
    def list_systems(params) do
      with {:ok, map_id} &lt;- MockUtil.fetch_map_id(params) do
        systems = MockMapSystemRepo.get_visible_systems_by_map_id(map_id)

        if systems == [] do
          {:error, :not_found, &quot;No systems found for this map&quot;}
        else
          # Format the response
          formatted_systems = Enum.map(systems, fn system -&gt;
            %{
              id: system.id,
              name: system.name,
              security: system.security
            }
          end)

          {:ok, %{data: formatted_systems}}
        end
      else
        {:error, msg} -&gt;
          {:error, :bad_request, msg}
      end
    end

    # Simplified version of show_system from MapAPIController
    def show_system(params) do
      with {:ok, map_id} &lt;- MockUtil.fetch_map_id(params),
           {:ok, system_id_str} &lt;- MockUtil.require_param(params, &quot;id&quot;),
           {:ok, system_id} &lt;- MockUtil.parse_int(system_id_str) do

        system = MockMapSystemRepo.get_system_by_id(map_id, system_id)

        if system == nil do
          {:error, :not_found, &quot;System not found&quot;}
        else
          # Format the response
          formatted_system = %{
            id: system.id,
            name: system.name,
            security: system.security
          }

          {:ok, %{data: formatted_system}}
        end
      else
        {:error, msg} -&gt;
          {:error, :bad_request, msg}
      end
    end
  end

  describe &quot;list_systems/1&quot; do
    test &quot;returns systems with valid map_id&quot; do
      params = %{&quot;map_id&quot; =&gt; &quot;1&quot;}
      result = MockMapAPIController.list_systems(params)

      assert {:ok, %{data: data}} = result
      assert length(data) == 3

      # Check that the data contains the expected systems
      jita = Enum.find(data, fn system -&gt; system.id == 30000142 end)
      assert jita.name == &quot;Jita&quot;
      assert jita.security == 0.9

      dodixie = Enum.find(data, fn system -&gt; system.id == 30002659 end)
      assert dodixie.name == &quot;Dodixie&quot;
      assert dodixie.security == 0.9
    end

    test &quot;returns systems with valid slug&quot; do
      params = %{&quot;slug&quot; =&gt; &quot;test-map&quot;}
      result = MockMapAPIController.list_systems(params)

      assert {:ok, %{data: data}} = result
      assert length(data) == 3
    end

    test &quot;returns error when no systems found&quot; do
      params = %{&quot;map_id&quot; =&gt; &quot;2&quot;}
      result = MockMapAPIController.list_systems(params)

      assert {:error, :not_found, message} = result
      assert message == &quot;No systems found for this map&quot;
    end

    test &quot;returns error when map_id is missing&quot; do
      params = %{}
      result = MockMapAPIController.list_systems(params)

      assert {:error, :bad_request, message} = result
      assert message == &quot;Missing required param: map_id or slug&quot;
    end

    test &quot;returns error when invalid map_id is provided&quot; do
      params = %{&quot;slug&quot; =&gt; &quot;non-existent-map&quot;}
      result = MockMapAPIController.list_systems(params)

      assert {:error, :bad_request, message} = result
      assert message == &quot;Map not found&quot;
    end
  end

  describe &quot;show_system/1&quot; do
    test &quot;returns system with valid parameters&quot; do
      params = %{&quot;map_id&quot; =&gt; &quot;1&quot;, &quot;id&quot; =&gt; &quot;30000142&quot;}
      result = MockMapAPIController.show_system(params)

      assert {:ok, %{data: data}} = result
      assert data.id == 30000142
      assert data.name == &quot;Jita&quot;
      assert data.security == 0.9
    end

    test &quot;returns error when system is not found&quot; do
      params = %{&quot;map_id&quot; =&gt; &quot;1&quot;, &quot;id&quot; =&gt; &quot;99999999&quot;}
      result = MockMapAPIController.show_system(params)

      assert {:error, :not_found, message} = result
      assert message == &quot;System not found&quot;
    end
  end
end</file><file path="test/unit/map_route_api_controller_test.exs"># Standalone test for the MapAPIController route functionality
#
# This file can be run directly with:
#   elixir test/standalone/map_route_api_controller_test.exs
#
# It doesn&apos;t require any database connections or external dependencies.

# Start ExUnit
ExUnit.start()

defmodule MapRouteAPIControllerTest do
  use ExUnit.Case

  # Mock modules to simulate the behavior of the controller&apos;s dependencies
  defmodule MockUtil do
    def require_param(params, key) do
      case params[key] do
        nil -&gt; {:error, &quot;Missing required param: #{key}&quot;}
        &quot;&quot;  -&gt; {:error, &quot;Param #{key} cannot be empty&quot;}
        val -&gt; {:ok, val}
      end
    end

    def parse_int(str) do
      case Integer.parse(str) do
        {num, &quot;&quot;} -&gt; {:ok, num}
        _         -&gt; {:error, &quot;Invalid integer for param id=#{str}&quot;}
      end
    end

    def fetch_map_id(params) do
      cond do
        params[&quot;map_id&quot;] -&gt;
          case parse_int(params[&quot;map_id&quot;]) do
            {:ok, map_id} -&gt; {:ok, map_id}
            {:error, _} -&gt; {:error, &quot;Invalid map_id format&quot;}
          end
        params[&quot;slug&quot;] -&gt;
          # In a real app, this would look up the map by slug
          # For testing, we&apos;ll just use a simple mapping
          case params[&quot;slug&quot;] do
            &quot;test-map&quot; -&gt; {:ok, 1}
            &quot;another-map&quot; -&gt; {:ok, 2}
            _ -&gt; {:error, &quot;Map not found&quot;}
          end
        true -&gt;
          {:error, &quot;Missing required param: map_id or slug&quot;}
      end
    end
  end

  defmodule MockMapSystemRepo do
    # Mock data for systems
    def get_systems_by_ids(map_id, system_ids) when map_id == 1 do
      systems = %{
        30000142 =&gt; %{id: 30000142, name: &quot;Jita&quot;, security: 0.9, region_id: 10000002},
        30002659 =&gt; %{id: 30002659, name: &quot;Dodixie&quot;, security: 0.9, region_id: 10000032},
        30002187 =&gt; %{id: 30002187, name: &quot;Amarr&quot;, security: 1.0, region_id: 10000043}
      }

      Enum.map(system_ids, fn id -&gt; Map.get(systems, id) end)
      |&gt; Enum.filter(&amp;(&amp;1 != nil))
    end

    def get_systems_by_ids(_, _), do: []

    # Mock data for connections
    def get_connections_between(map_id, _system_ids) when map_id == 1 do
      [
        %{source_id: 30000142, target_id: 30002659, distance: 15},
        %{source_id: 30002659, target_id: 30002187, distance: 12},
        %{source_id: 30000142, target_id: 30002187, distance: 20}
      ]
    end

    def get_connections_between(_, _), do: []
  end

  defmodule MockRouteCalculator do
    # Simplified route calculator that just returns a predefined route
    def calculate_route(systems, _connections, source_id, target_id, _options \\ []) do
      cond do
        source_id == 30000142 and target_id == 30002187 -&gt;
          # Direct route from Jita to Amarr
          route = [
            Enum.find(systems, fn s -&gt; s.id == 30000142 end),
            Enum.find(systems, fn s -&gt; s.id == 30002187 end)
          ]
          {:ok, %{route: route, jumps: 1, distance: 20}}

        source_id == 30000142 and target_id == 30002659 -&gt;
          # Direct route from Jita to Dodixie
          route = [
            Enum.find(systems, fn s -&gt; s.id == 30000142 end),
            Enum.find(systems, fn s -&gt; s.id == 30002659 end)
          ]
          {:ok, %{route: route, jumps: 1, distance: 15}}

        source_id == 30002659 and target_id == 30002187 -&gt;
          # Direct route from Dodixie to Amarr
          route = [
            Enum.find(systems, fn s -&gt; s.id == 30002659 end),
            Enum.find(systems, fn s -&gt; s.id == 30002187 end)
          ]
          {:ok, %{route: route, jumps: 1, distance: 12}}

        source_id == 30002659 and target_id == 30000142 -&gt;
          # Direct route from Dodixie to Jita
          route = [
            Enum.find(systems, fn s -&gt; s.id == 30002659 end),
            Enum.find(systems, fn s -&gt; s.id == 30000142 end)
          ]
          {:ok, %{route: route, jumps: 1, distance: 15}}

        true -&gt;
          {:error, &quot;No route found&quot;}
      end
    end
  end

  # Mock controller that uses our mock dependencies
  defmodule MockMapAPIController do
    # Simplified version of calculate_route from MapAPIController
    def calculate_route(params) do
      with {:ok, map_id} &lt;- MockUtil.fetch_map_id(params),
           {:ok, source_id_str} &lt;- MockUtil.require_param(params, &quot;source&quot;),
           {:ok, source_id} &lt;- MockUtil.parse_int(source_id_str),
           {:ok, target_id_str} &lt;- MockUtil.require_param(params, &quot;target&quot;),
           {:ok, target_id} &lt;- MockUtil.parse_int(target_id_str) do

        # Get the systems involved in the route
        systems = MockMapSystemRepo.get_systems_by_ids(map_id, [source_id, target_id])

        # Check if both systems exist
        source_system = Enum.find(systems, fn s -&gt; s.id == source_id end)
        target_system = Enum.find(systems, fn s -&gt; s.id == target_id end)

        if source_system == nil do
          {:error, :not_found, &quot;Source system not found&quot;}
        else
          if target_system == nil do
            {:error, :not_found, &quot;Target system not found&quot;}
          else
            # Get connections between systems
            connections = MockMapSystemRepo.get_connections_between(map_id, [source_id, target_id])

            # Calculate the route
            case MockRouteCalculator.calculate_route(systems, connections, source_id, target_id) do
              {:ok, route_data} -&gt;
                # Format the response
                formatted_route = format_route_response(route_data)
                {:ok, %{data: formatted_route}}

              {:error, reason} -&gt;
                {:error, :not_found, reason}
            end
          end
        end
      else
        {:error, msg} -&gt;
          {:error, :bad_request, msg}
      end
    end

    # Helper function to format the route response
    defp format_route_response(route_data) do
      %{
        route: Enum.map(route_data.route, fn system -&gt;
          %{
            id: system.id,
            name: system.name,
            security: system.security
          }
        end),
        jumps: route_data.jumps,
        distance: route_data.distance
      }
    end
  end

  describe &quot;calculate_route/1&quot; do
    test &quot;calculates route between two systems successfully&quot; do
      params = %{
        &quot;map_id&quot; =&gt; &quot;1&quot;,
        &quot;source&quot; =&gt; &quot;30000142&quot;,  # Jita
        &quot;target&quot; =&gt; &quot;30002187&quot;   # Amarr
      }

      result = MockMapAPIController.calculate_route(params)

      assert {:ok, %{data: data}} = result
      assert length(data.route) == 2
      assert Enum.at(data.route, 0).id == 30000142
      assert Enum.at(data.route, 0).name == &quot;Jita&quot;
      assert Enum.at(data.route, 1).id == 30002187
      assert Enum.at(data.route, 1).name == &quot;Amarr&quot;
      assert data.jumps == 1
      assert data.distance == 20
    end

    test &quot;calculates route using map slug&quot; do
      params = %{
        &quot;slug&quot; =&gt; &quot;test-map&quot;,
        &quot;source&quot; =&gt; &quot;30000142&quot;,  # Jita
        &quot;target&quot; =&gt; &quot;30002659&quot;   # Dodixie
      }

      result = MockMapAPIController.calculate_route(params)

      assert {:ok, %{data: data}} = result
      assert length(data.route) == 2
      assert Enum.at(data.route, 0).id == 30000142
      assert Enum.at(data.route, 0).name == &quot;Jita&quot;
      assert Enum.at(data.route, 1).id == 30002659
      assert Enum.at(data.route, 1).name == &quot;Dodixie&quot;
      assert data.jumps == 1
      assert data.distance == 15
    end

    test &quot;returns error when source system is not found&quot; do
      params = %{
        &quot;map_id&quot; =&gt; &quot;1&quot;,
        &quot;source&quot; =&gt; &quot;99999999&quot;,  # Non-existent system
        &quot;target&quot; =&gt; &quot;30002187&quot;   # Amarr
      }

      result = MockMapAPIController.calculate_route(params)

      assert {:error, :not_found, message} = result
      assert message == &quot;Source system not found&quot;
    end

    test &quot;returns error when target system is not found&quot; do
      params = %{
        &quot;map_id&quot; =&gt; &quot;1&quot;,
        &quot;source&quot; =&gt; &quot;30000142&quot;,  # Jita
        &quot;target&quot; =&gt; &quot;99999999&quot;   # Non-existent system
      }

      result = MockMapAPIController.calculate_route(params)

      assert {:error, :not_found, message} = result
      assert message == &quot;Target system not found&quot;
    end

    test &quot;returns error when map is not found&quot; do
      params = %{
        &quot;slug&quot; =&gt; &quot;non-existent-map&quot;,
        &quot;source&quot; =&gt; &quot;30000142&quot;,  # Jita
        &quot;target&quot; =&gt; &quot;30002187&quot;   # Amarr
      }

      result = MockMapAPIController.calculate_route(params)

      assert {:error, :bad_request, message} = result
      assert message == &quot;Map not found&quot;
    end

    test &quot;returns error when source parameter is missing&quot; do
      params = %{
        &quot;map_id&quot; =&gt; &quot;1&quot;,
        &quot;target&quot; =&gt; &quot;30002187&quot;   # Amarr
      }

      result = MockMapAPIController.calculate_route(params)

      assert {:error, :bad_request, message} = result
      assert message == &quot;Missing required param: source&quot;
    end

    test &quot;returns error when target parameter is missing&quot; do
      params = %{
        &quot;map_id&quot; =&gt; &quot;1&quot;,
        &quot;source&quot; =&gt; &quot;30000142&quot;  # Jita
      }

      result = MockMapAPIController.calculate_route(params)

      assert {:error, :bad_request, message} = result
      assert message == &quot;Missing required param: target&quot;
    end

    test &quot;returns error when map_id and slug are both missing&quot; do
      params = %{
        &quot;source&quot; =&gt; &quot;30000142&quot;,  # Jita
        &quot;target&quot; =&gt; &quot;30002187&quot;   # Amarr
      }

      result = MockMapAPIController.calculate_route(params)

      assert {:error, :bad_request, message} = result
      assert message == &quot;Missing required param: map_id or slug&quot;
    end

    test &quot;returns error when source is not a valid integer&quot; do
      params = %{
        &quot;map_id&quot; =&gt; &quot;1&quot;,
        &quot;source&quot; =&gt; &quot;not-an-integer&quot;,
        &quot;target&quot; =&gt; &quot;30002187&quot;   # Amarr
      }

      result = MockMapAPIController.calculate_route(params)

      assert {:error, :bad_request, message} = result
      assert message =~ &quot;Invalid integer for param id&quot;
    end

    test &quot;returns error when target is not a valid integer&quot; do
      params = %{
        &quot;map_id&quot; =&gt; &quot;1&quot;,
        &quot;source&quot; =&gt; &quot;30000142&quot;,  # Jita
        &quot;target&quot; =&gt; &quot;not-an-integer&quot;
      }

      result = MockMapAPIController.calculate_route(params)

      assert {:error, :bad_request, message} = result
      assert message =~ &quot;Invalid integer for param id&quot;
    end
  end
end</file><file path="test/unit/tracking_utils_test.exs"># Test for the check_tracking_consistency function in WandererApp.Character.TrackingUtils
#
# This file can be run directly with:
#   elixir test/unit/tracking_consistency_test.exs
#
# It doesn&apos;t require any database connections or external dependencies.

# Start ExUnit
ExUnit.start()

defmodule WandererApp.Character.TrackingConsistencyTest do
  use ExUnit.Case
  require Logger
  import ExUnit.CaptureIO

  # This is a copy of the function from TrackingUtils
  def check_tracking_consistency(tracking_data) do
    # Find any characters that are followed but not tracked
    inconsistent_characters = Enum.filter(tracking_data, fn data -&gt;
      data.followed &amp;&amp; !data.tracked
    end)

    # Log a warning for each inconsistent character
    Enum.each(inconsistent_characters, fn data -&gt;
      character = data.character
      # Use IO.puts instead of Logger to avoid dependencies
      eve_id = Map.get(character, :eve_id, &quot;unknown&quot;)
      name = Map.get(character, :name, &quot;unknown&quot;)
      IO.puts(&quot;WARNING: Inconsistent state detected: Character is followed but not tracked. Character ID: #{eve_id}, Name: #{name}&quot;)
    end)

    # Return the original tracking data
    tracking_data
  end

  describe &quot;check_tracking_consistency/1&quot; do
    test &quot;logs a warning when a character is followed but not tracked&quot; do
      # Create test data with inconsistent state
      tracking_data = [
        %{
          character: %{eve_id: &quot;test-eve-id&quot;, name: &quot;Test Character&quot;},
          tracked: false,
          followed: true
        }
      ]

      # Call the function and capture output
      output = capture_io(fn -&gt;
        check_tracking_consistency(tracking_data)
      end)

      # Assert that the warning was logged
      assert output =~ &quot;Inconsistent state detected: Character is followed but not tracked&quot;
      assert output =~ &quot;test-eve-id&quot;
      assert output =~ &quot;Test Character&quot;
    end

    test &quot;does not log a warning when all followed characters are also tracked&quot; do
      # Create test data with consistent state
      tracking_data = [
        %{
          character: %{eve_id: &quot;test-eve-id&quot;, name: &quot;Test Character&quot;},
          tracked: true,
          followed: true
        }
      ]

      # Call the function and capture output
      output = capture_io(fn -&gt;
        check_tracking_consistency(tracking_data)
      end)

      # Assert that no warning was logged
      refute output =~ &quot;Inconsistent state detected&quot;
    end

    test &quot;does not log a warning when no characters are followed&quot; do
      # Create test data with no followed characters
      tracking_data = [
        %{
          character: %{eve_id: &quot;test-eve-id&quot;, name: &quot;Test Character&quot;},
          tracked: true,
          followed: false
        }
      ]

      # Call the function and capture output
      output = capture_io(fn -&gt;
        check_tracking_consistency(tracking_data)
      end)

      # Assert that no warning was logged
      refute output =~ &quot;Inconsistent state detected&quot;
    end

    test &quot;handles multiple characters with mixed states correctly&quot; do
      # Create test data with multiple characters in different states
      tracking_data = [
        %{
          character: %{eve_id: &quot;character-1&quot;, name: &quot;Character 1&quot;},
          tracked: true,
          followed: true
        },
        %{
          character: %{eve_id: &quot;character-2&quot;, name: &quot;Character 2&quot;},
          tracked: false,
          followed: true
        },
        %{
          character: %{eve_id: &quot;character-3&quot;, name: &quot;Character 3&quot;},
          tracked: true,
          followed: false
        },
        %{
          character: %{eve_id: &quot;character-4&quot;, name: &quot;Character 4&quot;},
          tracked: false,
          followed: false
        }
      ]

      # Call the function and capture output
      output = capture_io(fn -&gt;
        check_tracking_consistency(tracking_data)
      end)

      # Assert that only the inconsistent character triggered a warning
      assert output =~ &quot;Inconsistent state detected: Character is followed but not tracked&quot;
      assert output =~ &quot;character-2&quot;
      assert output =~ &quot;Character 2&quot;
      refute output =~ &quot;character-1&quot;
      refute output =~ &quot;character-3&quot;
      refute output =~ &quot;character-4&quot;
    end

    test &quot;returns the original tracking data unchanged&quot; do
      # Create test data
      tracking_data = [
        %{
          character: %{eve_id: &quot;test-eve-id&quot;, name: &quot;Test Character&quot;},
          tracked: false,
          followed: true
        }
      ]

      # Call the function and get the result
      result = check_tracking_consistency(tracking_data)

      # Assert that the returned data is the same as the input data
      assert result == tracking_data
    end

    test &quot;handles empty tracking data without errors&quot; do
      # Create empty tracking data
      tracking_data = []

      # Call the function and capture output
      output = capture_io(fn -&gt;
        result = check_tracking_consistency(tracking_data)
        # Assert that the returned data is the same as the input data
        assert result == tracking_data
      end)

      # Assert that no warning was logged
      refute output =~ &quot;Inconsistent state detected&quot;
    end

    test &quot;handles multiple inconsistent characters correctly&quot; do
      # Create test data with multiple inconsistent characters
      tracking_data = [
        %{
          character: %{eve_id: &quot;character-1&quot;, name: &quot;Character 1&quot;},
          tracked: false,
          followed: true
        },
        %{
          character: %{eve_id: &quot;character-2&quot;, name: &quot;Character 2&quot;},
          tracked: false,
          followed: true
        },
        %{
          character: %{eve_id: &quot;character-3&quot;, name: &quot;Character 3&quot;},
          tracked: true,
          followed: true
        }
      ]

      # Call the function and capture output
      output = capture_io(fn -&gt;
        check_tracking_consistency(tracking_data)
      end)

      # Assert that warnings were logged for both inconsistent characters
      assert output =~ &quot;Character ID: character-1&quot;
      assert output =~ &quot;Name: Character 1&quot;
      assert output =~ &quot;Character ID: character-2&quot;
      assert output =~ &quot;Name: Character 2&quot;
      refute output =~ &quot;Character ID: character-3&quot;
    end

    test &quot;handles characters with missing fields gracefully&quot; do
      # Create test data with missing fields
      tracking_data = [
        %{
          character: %{eve_id: &quot;character-1&quot;}, # Missing name
          tracked: false,
          followed: true
        },
        %{
          character: %{name: &quot;Character 2&quot;}, # Missing eve_id
          tracked: false,
          followed: true
        }
      ]

      # Call the function and capture output
      output = capture_io(fn -&gt;
        result = check_tracking_consistency(tracking_data)
        # Assert that the returned data is the same as the input data
        assert result == tracking_data
      end)

      # Assert that warnings were logged with available information
      assert output =~ &quot;Character ID: character-1&quot;
      assert output =~ &quot;Name: unknown&quot;
      assert output =~ &quot;Character ID: unknown&quot;
      assert output =~ &quot;Name: Character 2&quot;
    end

    test &quot;handles characters with nil tracked or followed values&quot; do
      # Create test data with nil values
      tracking_data = [
        %{
          character: %{eve_id: &quot;character-1&quot;, name: &quot;Character 1&quot;},
          tracked: nil,
          followed: true
        },
        %{
          character: %{eve_id: &quot;character-2&quot;, name: &quot;Character 2&quot;},
          tracked: false,
          followed: nil
        }
      ]

      # Call the function and capture output
      output = capture_io(fn -&gt;
        result = check_tracking_consistency(tracking_data)
        # Assert that the returned data is the same as the input data
        assert result == tracking_data
      end)

      # Assert that a warning was logged for the first character (nil tracked is treated as false)
      assert output =~ &quot;Character ID: character-1&quot;
      assert output =~ &quot;Name: Character 1&quot;
      # No warning for the second character (nil followed is treated as false)
      refute output =~ &quot;Character ID: character-2&quot;
    end

    test &quot;handles malformed tracking data gracefully&quot; do
      # Create malformed tracking data (missing required fields)
      tracking_data = [
        %{
          # Missing character field
          tracked: false,
          followed: true
        }
      ]

      # Call the function and capture output, expecting it to handle errors gracefully
      assert_raise(KeyError, fn -&gt;
        check_tracking_consistency(tracking_data)
      end)
    end
  end

  # Additional tests for edge cases in the filter logic
  describe &quot;filter logic in check_tracking_consistency/1&quot; do
    test &quot;correctly identifies characters that are followed but not tracked&quot; do
      # Create test data with various combinations
      tracking_data = [
        %{
          character: %{eve_id: &quot;char-1&quot;, name: &quot;Character 1&quot;},
          tracked: false,
          followed: true
        },
        %{
          character: %{eve_id: &quot;char-2&quot;, name: &quot;Character 2&quot;},
          tracked: true,
          followed: true
        },
        %{
          character: %{eve_id: &quot;char-3&quot;, name: &quot;Character 3&quot;},
          tracked: false,
          followed: false
        },
        %{
          character: %{eve_id: &quot;char-4&quot;, name: &quot;Character 4&quot;},
          tracked: true,
          followed: false
        }
      ]

      # Extract the filter logic from the function
      inconsistent_characters = Enum.filter(tracking_data, fn data -&gt;
        data.followed &amp;&amp; !data.tracked
      end)

      # Assert that only the first character is identified as inconsistent
      assert length(inconsistent_characters) == 1
      assert hd(inconsistent_characters).character.eve_id == &quot;char-1&quot;
    end

    test &quot;handles boolean-like values correctly in filter logic&quot; do
      # Create test data with various boolean-like values
      tracking_data = [
        %{
          character: %{eve_id: &quot;char-1&quot;, name: &quot;Character 1&quot;},
          tracked: false,
          followed: &quot;true&quot; # String instead of boolean - in Elixir, only false and nil are falsy
        }
      ]

      # Extract the filter logic from the function
      inconsistent_characters = Enum.filter(tracking_data, fn data -&gt;
        data.followed &amp;&amp; !data.tracked
      end)

      # Assert that the character is identified as inconsistent
      # (since in Elixir, only false and nil are falsy, everything else is truthy)
      assert length(inconsistent_characters) == 1
    end
  end
end</file><file path="test/unit/util_api_controller_test.exs"># Standalone test for the UtilAPIController
#
# This file can be run directly with:
#   elixir test/standalone/util_api_controller_test.exs
#
# It doesn&apos;t require any database connections or external dependencies.

# Start ExUnit
ExUnit.start()

defmodule UtilAPIControllerTest do
  use ExUnit.Case

  # Mock controller that implements the functions we want to test
  defmodule MockUtilAPIController do
    # Simplified version of fetch_map_id from UtilAPIController
    def fetch_map_id(params) do
      cond do
        params[&quot;map_id&quot;] -&gt;
          case Integer.parse(params[&quot;map_id&quot;]) do
            {map_id, &quot;&quot;} -&gt; {:ok, map_id}
            _ -&gt; {:error, &quot;Invalid map_id format&quot;}
          end
        params[&quot;slug&quot;] -&gt;
          # In a real app, this would look up the map by slug
          # For testing, we&apos;ll just use a simple mapping
          case params[&quot;slug&quot;] do
            &quot;test-map&quot; -&gt; {:ok, 1}
            &quot;another-map&quot; -&gt; {:ok, 2}
            _ -&gt; {:error, &quot;Map not found&quot;}
          end
        true -&gt;
          {:error, &quot;Missing required param: map_id or slug&quot;}
      end
    end

    # Simplified version of require_param from UtilAPIController
    def require_param(params, key) do
      case params[key] do
        nil -&gt; {:error, &quot;Missing required param: #{key}&quot;}
        &quot;&quot;  -&gt; {:error, &quot;Param #{key} cannot be empty&quot;}
        val -&gt; {:ok, val}
      end
    end

    # Simplified version of parse_int from UtilAPIController
    def parse_int(str) do
      case Integer.parse(str) do
        {num, &quot;&quot;} -&gt; {:ok, num}
        _         -&gt; {:error, &quot;Invalid integer for param id=#{str}&quot;}
      end
    end
  end

  describe &quot;fetch_map_id/1&quot; do
    test &quot;returns map_id when valid map_id is provided&quot; do
      params = %{&quot;map_id&quot; =&gt; &quot;123&quot;}
      result = MockUtilAPIController.fetch_map_id(params)

      assert {:ok, 123} = result
    end

    test &quot;returns map_id when valid slug is provided&quot; do
      params = %{&quot;slug&quot; =&gt; &quot;test-map&quot;}
      result = MockUtilAPIController.fetch_map_id(params)

      assert {:ok, 1} = result
    end

    test &quot;returns error when map_id is invalid format&quot; do
      params = %{&quot;map_id&quot; =&gt; &quot;not-a-number&quot;}
      result = MockUtilAPIController.fetch_map_id(params)

      assert {:error, &quot;Invalid map_id format&quot;} = result
    end

    test &quot;returns error when slug is not found&quot; do
      params = %{&quot;slug&quot; =&gt; &quot;non-existent-map&quot;}
      result = MockUtilAPIController.fetch_map_id(params)

      assert {:error, &quot;Map not found&quot;} = result
    end

    test &quot;returns error when neither map_id nor slug is provided&quot; do
      params = %{}
      result = MockUtilAPIController.fetch_map_id(params)

      assert {:error, &quot;Missing required param: map_id or slug&quot;} = result
    end

    test &quot;prioritizes map_id over slug when both are provided&quot; do
      params = %{&quot;map_id&quot; =&gt; &quot;123&quot;, &quot;slug&quot; =&gt; &quot;test-map&quot;}
      result = MockUtilAPIController.fetch_map_id(params)

      assert {:ok, 123} = result
    end
  end

  describe &quot;require_param/2&quot; do
    test &quot;returns value when param exists&quot; do
      params = %{&quot;key&quot; =&gt; &quot;value&quot;}
      result = MockUtilAPIController.require_param(params, &quot;key&quot;)

      assert {:ok, &quot;value&quot;} = result
    end

    test &quot;returns error when param is missing&quot; do
      params = %{}
      result = MockUtilAPIController.require_param(params, &quot;key&quot;)

      assert {:error, &quot;Missing required param: key&quot;} = result
    end

    test &quot;returns error when param is empty string&quot; do
      params = %{&quot;key&quot; =&gt; &quot;&quot;}
      result = MockUtilAPIController.require_param(params, &quot;key&quot;)

      assert {:error, &quot;Param key cannot be empty&quot;} = result
    end
  end

  describe &quot;parse_int/1&quot; do
    test &quot;returns integer when string is valid integer&quot; do
      result = MockUtilAPIController.parse_int(&quot;123&quot;)

      assert {:ok, 123} = result
    end

    test &quot;returns error when string is not a valid integer&quot; do
      result = MockUtilAPIController.parse_int(&quot;not-an-integer&quot;)

      assert {:error, message} = result
      assert message =~ &quot;Invalid integer for param id&quot;
    end

    test &quot;returns error when string contains integer with extra characters&quot; do
      result = MockUtilAPIController.parse_int(&quot;123abc&quot;)

      assert {:error, message} = result
      assert message =~ &quot;Invalid integer for param id&quot;
    end
  end
end</file><file path="test/wanderer_app/test.ex">defmodule WandererApp.Test do
  defmodule PubSub do
    @type t :: atom
    @type topic :: binary
    @type message :: term

    @callback subscribe(t, topic) :: :ok | {:error, term}
    @callback broadcast(t, topic, message) :: :ok | {:error, term}
  end

  defmodule Logger do
    @type message :: binary

    @callback info(message) :: :ok
    @callback debug(message) :: :ok
    @callback error(message) :: :ok
  end

  defmodule DDRT do
    @type id :: number() | String.t()
    @type coord_range :: {number(), number()}
    @type bounding_box :: list(coord_range())
    @type leaf :: {id(), bounding_box()}

    @callback delete(ids :: id() | [id()], name :: GenServer.name()) ::
                {:ok, map()} | {:badtree, map()}
    @callback insert(leaves :: leaf() | [leaf()], name :: GenServer.name()) ::
                {:ok, map()} | {:badtree, map()}
    @callback update(
                ids :: id(),
                box :: bounding_box() | {bounding_box(), bounding_box()},
                name :: GenServer.name()
              ) :: {:ok, map()} | {:badtree, map()}
  end
end</file><file path="test/wanderer_app_web/controllers/error_html_test.exs">defmodule WandererAppWeb.ErrorHTMLTest do
  use WandererAppWeb.ConnCase, async: true

  # Bring render_to_string/4 for testing custom views
  import Phoenix.Template

  test &quot;renders 404.html&quot; do
    assert render_to_string(WandererAppWeb.ErrorHTML, &quot;404&quot;, &quot;html&quot;, []) == &quot;Not Found&quot;
  end

  test &quot;renders 500.html&quot; do
    assert render_to_string(WandererAppWeb.ErrorHTML, &quot;500&quot;, &quot;html&quot;, []) ==
             &quot;Internal Server Error&quot;
  end
end</file><file path="test/wanderer_app_web/controllers/error_json_test.exs">defmodule WandererAppWeb.ErrorJSONTest do
  use WandererAppWeb.ConnCase, async: true

  test &quot;renders 404&quot; do
    assert WandererAppWeb.ErrorJSON.render(&quot;404.json&quot;, %{}) == %{errors: %{detail: &quot;Not Found&quot;}}
  end

  test &quot;renders 500&quot; do
    assert WandererAppWeb.ErrorJSON.render(&quot;500.json&quot;, %{}) ==
             %{errors: %{detail: &quot;Internal Server Error&quot;}}
  end
end</file><file path="test/wanderer_app_web/controllers/page_controller_test.exs">defmodule WandererAppWeb.PageControllerTest do
  use WandererAppWeb.ConnCase

  test &quot;GET /&quot;, %{conn: conn} do
    conn = get(conn, ~p&quot;/&quot;)
    assert html_response(conn, 200) =~ &quot;Peace of mind from prototype to production&quot;
  end
end</file><file path="test/test_helper.exs">ExUnit.start()
Ecto.Adapters.SQL.Sandbox.mode(WandererApp.Repo, :manual)
Application.ensure_all_started(:mox)

Mox.defmock(Test.PubSubMock, for: WandererApp.Test.PubSub)
Mox.defmock(Test.LoggerMock, for: WandererApp.Test.Logger)
Mox.defmock(Test.DDRTMock, for: WandererApp.Test.DDRT)</file><file path=".check.exs">[
  ## don&apos;t run tools concurrently
  # parallel: false,

  ## don&apos;t print info about skipped tools
  # skipped: false,

  ## always run tools in fix mode (put it in ~/.check.exs locally, not in project config)
  # fix: true,

  ## don&apos;t retry automatically even if last run resulted in failures
  # retry: false,

  ## list of tools (see `mix check` docs for a list of default curated tools)
  tools: [
    ## curated tools may be disabled (e.g. the check for compilation warnings)
    {:compiler, false},

    ## ...or have command &amp; args adjusted (e.g. enable skip comments for sobelow)
    # {:sobelow, &quot;mix sobelow --exit --skip&quot;},

    ## ...or reordered (e.g. to see output from dialyzer before others)
    # {:dialyzer, order: -1},

    ## ...or reconfigured (e.g. disable parallel execution of ex_unit in umbrella)

    {:doctor, false},
    {:ex_unit, false},
    {:npm_test, false},
    {:sobelow, false}

    ## custom new tools may be added (Mix tasks or arbitrary commands)
    # {:my_task, &quot;mix my_task&quot;, env: %{&quot;MIX_ENV&quot; =&gt; &quot;prod&quot;}},
    # {:my_tool, [&quot;my_tool&quot;, &quot;arg with spaces&quot;]}
  ]
]</file><file path=".coderabbit.yaml"># yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json

language: &quot;en-US&quot;
early_access: true  
reviews:
  profile: &quot;assertive&quot;
  request_changes_workflow: true 
  high_level_summary: true
  poem: true                      
  review_status: true              
  collapse_walkthrough: false      
  path_filters:
    - &quot;!node_modules/**&quot;   # Ignore dependencies
    - &quot;!dist/**&quot;           # Ignore build output
    - &quot;!**/*.min.js&quot;       # Ignore minified files
    - &quot;!**/*.bundle.js&quot;    # Ignore bundled assets
    - &quot;!.notes/**&quot;
    - &quot;!.cursor/**&quot;

  path_instructions:
    # Global project guidelines (apply to all files)
    - path: &quot;**/*&quot;
      instructions: |
        **General Code Quality** ‚Äì Ensure the code follows global best practices:
        - Keep functions and modules small and focused (single responsibility).
        - Use consistent naming conventions and meaningful identifiers for clarity.
        - Look for unused code or files that can be removed
        - Avoid duplicate code ‚Äì refactor common logic into reusable functions.
        - Maintain code readability (proper indentation, avoid deep nesting of code).
        - Write comments where necessary to explain intent, but keep code self-explanatory.
        - Use early exit strategy, avoid else use pattern matching

  auto_review:
    enabled: true        # Enable automatic AI review on pull requests
    drafts: false        # Skip reviews on draft PRs (only review ready PRs)
    base_branches: [&quot;main&quot;, &quot;develop&quot;]  # Only run auto-reviews for PRs targeting these branches (adjust to your workflow)

chat:
  auto_reply: true  # Enable the AI to answer follow-up questions in PR comments</file><file path=".credo.exs"># This file contains the configuration for Credo and you are probably reading
# this after creating it with `mix credo.gen.config`.
#
# If you find anything wrong or unclear in this file, please report an
# issue on GitHub: https://github.com/rrrene/credo/issues
#
%{
  #
  # You can have as many configs as you like in the `configs:` field.
  configs: [
    %{
      #
      # Run any config using `mix credo -C &lt;name&gt;`. If no config name is given
      # &quot;default&quot; is used.
      #
      name: &quot;default&quot;,
      #
      # These are the files included in the analysis:
      files: %{
        #
        # You can give explicit globs or simply directories.
        # In the latter case `**/*.{ex,exs}` will be used.
        #
        included: [
          &quot;lib/&quot;,
          &quot;src/&quot;,
          &quot;test/&quot;,
          &quot;web/&quot;,
          &quot;apps/*/lib/&quot;,
          &quot;apps/*/src/&quot;,
          &quot;apps/*/test/&quot;,
          &quot;apps/*/web/&quot;
        ],
        excluded: [~r&quot;/_build/&quot;, ~r&quot;/deps/&quot;, ~r&quot;/node_modules/&quot;]
      },
      #
      # Load and configure plugins here:
      #
      plugins: [],
      #
      # If you create your own checks, you must specify the source files for
      # them here, so they can be loaded by Credo before running the analysis.
      #
      requires: [],
      #
      # If you want to enforce a style guide and need a more traditional linting
      # experience, you can change `strict` to `true` below:
      #
      strict: false,
      #
      # To modify the timeout for parsing files, change this value:
      #
      parse_timeout: 5000,
      #
      # If you want to use uncolored output by default, you can change `color`
      # to `false` below:
      #
      color: true,
      #
      # You can customize the parameters of any check by adding a second element
      # to the tuple.
      #
      # To disable a check put `false` as second element:
      #
      #     {Credo.Check.Design.DuplicatedCode, false}
      #
      checks: %{
        enabled: [
          #
          ## Consistency Checks
          #
          {Credo.Check.Consistency.ExceptionNames, []},
          {Credo.Check.Consistency.LineEndings, []},
          {Credo.Check.Consistency.ParameterPatternMatching, []},
          {Credo.Check.Consistency.SpaceAroundOperators, []},
          {Credo.Check.Consistency.SpaceInParentheses, []},
          {Credo.Check.Consistency.TabsOrSpaces, []},

          #
          ## Design Checks
          #
          # You can customize the priority of any check
          # Priority values are: `low, normal, high, higher`
          #
          {Credo.Check.Design.AliasUsage,
           [priority: :low, if_nested_deeper_than: 2, if_called_more_often_than: 0]},
          # You can also customize the exit_status of each check.
          # If you don&apos;t want TODO comments to cause `mix credo` to fail, just
          # set this value to 0 (zero).
          #
          {Credo.Check.Design.TagTODO, [exit_status: 2]},
          {Credo.Check.Design.TagFIXME, []},

          #
          ## Readability Checks
          #
          {Credo.Check.Readability.AliasOrder, []},
          {Credo.Check.Readability.FunctionNames, []},
          {Credo.Check.Readability.LargeNumbers, []},
          {Credo.Check.Readability.MaxLineLength, [priority: :low, max_length: 120]},
          {Credo.Check.Readability.ModuleAttributeNames, []},
          {Credo.Check.Readability.ModuleDoc, []},
          {Credo.Check.Readability.ModuleNames, []},
          {Credo.Check.Readability.ParenthesesInCondition, []},
          {Credo.Check.Readability.ParenthesesOnZeroArityDefs, []},
          {Credo.Check.Readability.PipeIntoAnonymousFunctions, []},
          {Credo.Check.Readability.PredicateFunctionNames, []},
          {Credo.Check.Readability.PreferImplicitTry, []},
          {Credo.Check.Readability.RedundantBlankLines, []},
          {Credo.Check.Readability.Semicolons, []},
          {Credo.Check.Readability.SpaceAfterCommas, []},
          {Credo.Check.Readability.StringSigils, []},
          {Credo.Check.Readability.TrailingBlankLine, []},
          {Credo.Check.Readability.TrailingWhiteSpace, []},
          {Credo.Check.Readability.UnnecessaryAliasExpansion, []},
          {Credo.Check.Readability.VariableNames, []},
          {Credo.Check.Readability.WithSingleClause, []},

          #
          ## Refactoring Opportunities
          #
          {Credo.Check.Refactor.Apply, []},
          {Credo.Check.Refactor.CondStatements, []},
          {Credo.Check.Refactor.CyclomaticComplexity, []},
          {Credo.Check.Refactor.FunctionArity, []},
          {Credo.Check.Refactor.LongQuoteBlocks, []},
          {Credo.Check.Refactor.MatchInCondition, []},
          {Credo.Check.Refactor.MapJoin, []},
          {Credo.Check.Refactor.NegatedConditionsInUnless, []},
          {Credo.Check.Refactor.NegatedConditionsWithElse, []},
          {Credo.Check.Refactor.Nesting, []},
          {Credo.Check.Refactor.UnlessWithElse, []},
          {Credo.Check.Refactor.WithClauses, []},
          {Credo.Check.Refactor.FilterFilter, []},
          {Credo.Check.Refactor.RejectReject, []},
          {Credo.Check.Refactor.RedundantWithClauseResult, []},

          #
          ## Warnings
          #
          {Credo.Check.Warning.ApplicationConfigInModuleAttribute, []},
          {Credo.Check.Warning.BoolOperationOnSameValues, []},
          {Credo.Check.Warning.ExpensiveEmptyEnumCheck, []},
          {Credo.Check.Warning.IExPry, []},
          {Credo.Check.Warning.IoInspect, []},
          {Credo.Check.Warning.OperationOnSameValues, []},
          {Credo.Check.Warning.OperationWithConstantResult, []},
          {Credo.Check.Warning.RaiseInsideRescue, []},
          {Credo.Check.Warning.SpecWithStruct, []},
          {Credo.Check.Warning.WrongTestFileExtension, []},
          {Credo.Check.Warning.UnusedEnumOperation, []},
          {Credo.Check.Warning.UnusedFileOperation, []},
          {Credo.Check.Warning.UnusedKeywordOperation, []},
          {Credo.Check.Warning.UnusedListOperation, []},
          {Credo.Check.Warning.UnusedPathOperation, []},
          {Credo.Check.Warning.UnusedRegexOperation, []},
          {Credo.Check.Warning.UnusedStringOperation, []},
          {Credo.Check.Warning.UnusedTupleOperation, []},
          {Credo.Check.Warning.UnsafeExec, []}
        ],
        disabled: [
          #
          # Checks scheduled for next check update (opt-in for now, just replace `false` with `[]`)

          #
          # Controversial and experimental checks (opt-in, just move the check to `:enabled`
          #   and be sure to use `mix credo --strict` to see low priority checks)
          #
          {Credo.Check.Consistency.MultiAliasImportRequireUse, []},
          {Credo.Check.Consistency.UnusedVariableNames, []},
          {Credo.Check.Design.DuplicatedCode, []},
          {Credo.Check.Design.SkipTestWithoutComment, []},
          {Credo.Check.Readability.AliasAs, []},
          {Credo.Check.Readability.BlockPipe, []},
          {Credo.Check.Readability.ImplTrue, []},
          {Credo.Check.Readability.MultiAlias, []},
          {Credo.Check.Readability.NestedFunctionCalls, []},
          {Credo.Check.Readability.SeparateAliasRequire, []},
          {Credo.Check.Readability.SingleFunctionToBlockPipe, []},
          {Credo.Check.Readability.SinglePipe, []},
          {Credo.Check.Readability.Specs, []},
          {Credo.Check.Readability.StrictModuleLayout, []},
          {Credo.Check.Readability.WithCustomTaggedTuple, []},
          {Credo.Check.Refactor.ABCSize, []},
          {Credo.Check.Refactor.AppendSingleItem, []},
          {Credo.Check.Refactor.DoubleBooleanNegation, []},
          {Credo.Check.Refactor.FilterReject, []},
          {Credo.Check.Refactor.IoPuts, []},
          {Credo.Check.Refactor.MapMap, []},
          {Credo.Check.Refactor.ModuleDependencies, []},
          {Credo.Check.Refactor.NegatedIsNil, []},
          {Credo.Check.Refactor.PipeChainStart, []},
          {Credo.Check.Refactor.RejectFilter, []},
          {Credo.Check.Refactor.VariableRebinding, []},
          {Credo.Check.Warning.LazyLogging, []},
          {Credo.Check.Warning.LeakyEnvironment, []},
          {Credo.Check.Warning.MapGetUnsafePass, []},
          {Credo.Check.Warning.MixEnv, []},
          {Credo.Check.Warning.UnsafeToAtom, []}

          # {Credo.Check.Refactor.MapInto, []},

          #
          # Custom checks can be created using `mix credo.gen.check`.
          #
        ]
      }
    }
  ]
}</file><file path=".cursorrules"># .cursorrules

################################################################################
# Combined Cursor Rules for Elixir/Phoenix (Ash) and React/Frontend
#
# This file consolidates best practices, code style guidelines, operational
# protocols, and project directives into a single source of truth.
#
# Adhere to these rules to maintain a clean, consistent, and efficient codebase.
################################################################################


################################################################################
# AREAS OF EXPERTISE
################################################################################
Areas of Expertise:
  - You are an expert in Elixir (Ash Framework, Phoenix, Ecto)
  - You are an expert in modern web frontends (JavaScript/TypeScript, React, Node.js)
  - Follow best practices from both ecosystems throughout this codebase


################################################################################
# CODE STYLE AND STRUCTURE (ELIXIR &amp; PHOENIX)
################################################################################
Code Style and Structure (Elixir &amp; Phoenix):
  - Write concise, idiomatic Elixir code leveraging functional programming
    and immutability.
  - Avoid imperative loops; prefer recursion or higher-order functions for clarity.
  - Follow Phoenix conventions for project structure and code organization.
    - Keep controllers thin
    - Use contexts (or Ash domains) to encapsulate business logic
    - Adhere to Phoenix&apos;s directory structure (controllers, contexts, schemas, etc.)
  - Use descriptive names for modules, functions, and variables.
    - Modules in PascalCase, functions/variables in snake_case.
    - Make code self-documenting and easy to understand.


################################################################################
# CODE STYLE AND STRUCTURE (REACT &amp; FRONTEND)
################################################################################
Code Style and Structure (React &amp; Frontend):
  - Write clean, modular JavaScript/TypeScript following a consistent style.
  - Use functional and declarative patterns; avoid class-based components.
  - Prefer composition and reusable functions over duplication.
  - Use descriptive naming in frontend code.
    - Use camelCase for variables/functions
    - Use PascalCase for React components
    - Use UPPER_SNAKE_CASE for constants
  - Organize files so each component has its logic, styles, and assets grouped logically.
    - Follow the component folder structure pattern:
      MyComponent/
      ‚îú‚îÄ‚îÄ index.ts
      ‚îú‚îÄ‚îÄ MyComponent.tsx
      ‚îú‚îÄ‚îÄ MyComponent.module.scss (optional)
      ‚îú‚îÄ‚îÄ components/ (optional)
      ‚îú‚îÄ‚îÄ helpers/ (optional)
      ‚îú‚îÄ‚îÄ hooks/ (optional)
      ‚îú‚îÄ‚îÄ types.ts (optional)
      ‚îî‚îÄ‚îÄ constants.ts (optional)
  - Use SCSS modules (*.module.scss) for component-specific styles.
    - Each component should have its own module file if needed.
    - Use :global block for accessing global styles.
  - Use PrimeReact for UI components and Tailwind for styling.
    - Check Tailwind classes before creating custom styles.
  - Enforce a consistent code format and linting (e.g., Prettier, ESLint).
    - Apply autofix for all modified files.
  - Keep components under 250 lines; extract logic to separate files if needed.


################################################################################
# FRAMEWORK BEST PRACTICES (ELIXIR/ASH)
################################################################################
Framework Best Practices (Elixir/Ash):
  - Leverage Ash Framework to eliminate boilerplate CRUD code.
  - Define resources, actions, and validations in Ash to focus on business logic
    rather than repetitive patterns.
  - Use Ecto (via Ash) effectively for database operations.
    - Rely on Ash&apos;s query and changeset DSL for validations and data manipulation
    - Use preloading to avoid N+1 queries for performance
  - Embrace Elixir/OTP principles with supervision trees and the &quot;let it crash&quot;
    philosophy for fault-tolerance.
  - Handle errors gracefully (e.g., use changesets for validation and user-friendly
    error messages).
  - Follow Phoenix&apos;s and Ash&apos;s security best practices.
    - Validate all inputs (strong parameters or Ash validations)
    - Guard against XSS/CSRF
    - Implement authentication/authorization as needed


################################################################################
# FRAMEWORK BEST PRACTICES (REACT)
################################################################################
Framework Best Practices (React):
  - Use functional React components with Hooks for state and side effects.
    - Follow the Rules of Hooks ‚Äì only call hooks at the top level of components or custom hooks.
    - Always use `export const MyComponent = () =&gt; {...}` for components.
  - Create custom hooks to abstract reusable logic.
  - Manage state thoughtfully.
    - Lift state up when necessary
    - Use Context or state libraries (if needed) instead of excessive prop-drilling
    - Use useMapRootProvider for accessing global state in MapInterface
    - Use useMapProvider for accessing map-specific state in MapWrapper
    - DO NOT use useMapRootProvider inside Map.tsx or its children
  - Optimize rendering performance:
    - Use React.memo for memoizing pure components
    - Use useCallback/useMemo to avoid re-calculating values or recreating functions unnecessarily
    - Avoid defining inline functions/objects in JSX (can trigger unnecessary re-renders)
    - For large lists, consider virtualization
  - Prefer composition over inheritance for reusable components.
  - Ensure components are resilient and user-friendly:
    - Implement error boundaries to catch UI errors
    - Clean up side effects in useEffect to prevent memory leaks
    - Use conditional rendering (ternaries or short-circuit logic) for clarity
    - Avoid multi-line ternary operators
    - Use early returns for conditions to improve readability
  - Follow frontend accessibility and responsiveness best practices:
    - Use semantic HTML and ARIA as needed
    - Implement responsive design with Tailwind CSS for cross-device compatibility
  - Do not declare pure functions or type guards inside component bodies.
  - Check existing components in PrimeReact and Wanderer UI-Kit before creating new ones.
  - Minimize use of `any` type in TypeScript.


################################################################################
# SELF-DOCUMENTATION AND CLARITY
################################################################################
Self-Documentation and Clarity:
  - Write self-documenting code:
    - Choose clear, intention-revealing names
    - Keep logic straightforward
  - When the purpose isn&apos;t obvious, add comments or docstrings:
    - Elixir: @doc for functions
    - JS/TS: JSDoc/TS doc comments
  - Use type annotations to improve clarity and safety:
    - In Elixir, add @spec typespecs for public functions and consider Dialyzer
    - In React, prefer TypeScript or PropTypes for component contracts
  - Maintain comprehensive tests for both backend and frontend:
    - ExUnit (and helpers like ExMachina) for Ash/Phoenix
    - Jest with React Testing Library for frontend components


################################################################################
# CONTINUOUS IMPROVEMENT
################################################################################
Continuous Improvement:
  - Treat these rules as a living document. Review and refine regularly as the
    project grows and new best practices emerge.
  - Coordinate changes in one stack with the other (e.g., if API endpoints change,
    update frontend usage accordingly).
  - Aim for a harmonious backend-frontend workflow that maximizes development
    speed without sacrificing code quality.


################################################################################
# CURSOR PROJECT RULES
################################################################################
# These rules govern the day-to-day operational protocols for the entire codebase.

Cursor Project Rules:

  ##############################################################################
  # CONTEXT INITIALIZATION
  ##############################################################################
  Context Initialization:
    - ALWAYS read `.notes/project_overview.md` and `.notes/task_list.md`
    - ALWAYS read `.notes/conversation_summary.md` for context
    - ALWAYS read `.notes/code_style_guide`, `.notes/frontend_guidelines`, and `.note/directory_structure.md` for project specific context
    - PERIODICALLY update `.notes/conversation_summary.md` with key
      discussion points and decisions

  ##############################################################################
  # DOCUMENTATION REFERENCE PROTOCOL
  ##############################################################################
  Documentation Reference Protocol:
    - When to reference specific documentation:
      - `.notes/project_overview.md`: Start of new features, clarifying scope,
        architectural discussions
      - `.notes/architecture.md`: Design decisions, new components, or major
        architecture modifications
      - `.notes/task_list.md`: Before starting tasks, prioritizing work, or
        updating task status
      - `.notes/conversation_summary.md`: For context from previous discussions,
        major decisions, or when resuming work
      - `.notes/directory_structure.md`: Navigating the codebase, understanding
        file organization, planning file additions
    - Documentation update requirements:
      - Update `.notes/conversation_summary.md` after significant decisions,
        completed tasks, or architectural changes
      - Reference relevant documentation sections when answering questions
      - Cite specific sections of documentation when making recommendations
      - Maintain documentation consistency across all updates

  ##############################################################################
  # OPERATIONAL PROTOCOL
  ##############################################################################
  Operational Protocol:
    How to approach tasks:

    ### Before Action
    - Create a MECE (Mutually Exclusive, Collectively Exhaustive) task breakdown
    - Think step-by-step and describe plans in pseudocode
    - Confirm approach before implementation

    ### Code Changes
    - Read relevant code sections before editing
    - Preserve existing functionality
    - Maintain type safety
    - Follow DRY principles
    - Focus on readability over performance
    - Leave no TODOs or placeholders

    ### Development Environment
    - DO NOT run `npm run` or `mix` commands manually; an automatic watcher
      recompiles code after changes
    - Code changes will be automatically detected and recompiled
    - Focus on making the code changes; avoid worrying about compilation steps

  ##############################################################################
  # TECHNOLOGY-SPECIFIC GUIDELINES
  ##############################################################################
  Technology-Specific Guidelines:

    ### Backend (Elixir/Phoenix)
    - Write idiomatic Elixir code following functional programming patterns
    - Use snake_case for files, functions, variables
    - Use PascalCase for module names
    - Leverage pattern matching and guards
    - Follow &quot;let it crash&quot; philosophy with proper supervision
    - Use Ecto changesets for validation
    - Implement proper caching strategies
    - Follow Phoenix conventions for contexts, schemas, controllers

    ### Frontend (React/Next.js)
    - Use functional components with TypeScript
    - Implement early returns for readability
    - Use descriptive names with proper prefixes (handle- for events)
    - Follow accessibility best practices
    - Use Tailwind classes for styling
    - Prefer named exports
    - Use PrimeReact for UI components (buttons, checkboxes, etc.)
    - Use SCSS modules (*.module.scss) for component-specific styles
    - Keep components under 250 lines
    - Apply ESLint autofix for all modified files
    - Use UPPER_SNAKE_CASE for constants
    - Place globally used types in assets/js/hooks/Mapper/types
    - Place globally used constants in assets/js/hooks/Mapper/constants.ts

    ### UI/UX
    - Implement responsive design with Tailwind
    - Use PrimeReact as the primary component library
    - Check Tailwind classes before creating custom styles
    - Ensure proper z-index hierarchy for overlays and dialogs

  ##############################################################################
  # SAFETY REQUIREMENTS
  ##############################################################################
  Safety Requirements:
    - NEVER break type safety
    - ALWAYS maintain proper error handling
    - ALWAYS document new code
    - Implement proper authentication/authorization
    - Protect against common web vulnerabilities
    - Use environment variables for sensitive data

  ##############################################################################
  # Global Changes
  ##############################################################################
    4. **Global Changes**:
       - Ask for explicit permission before making global styling changes
       - Test changes in isolation before applying globally
       - Document any global changes for future reference
       - Prefer component-specific styling over global styling

  ##############################################################################
  # DIRECTORY STRUCTURE MAINTENANCE
  ##############################################################################
  Directory Structure Maintenance:
    - Run `.notes/dir_script.sh` after significant file additions or reorganizations
    - Reference `.notes/directory_structure.md` when navigating the codebase
    - Maintain the directory structure script to ensure accurate representation
    - Exclude non-essential files/directories from the structure (build artifacts, deps)
    - Keep the structure focused on user-written code for readability
    - Update the structure before starting major new features or components

  ##############################################################################
  # PRIORITIES
  ##############################################################################
  Priorities:
    - Source: .notes/
    - Weight: 1.0

  ##############################################################################
  # MODES
  ##############################################################################
  Modes:

    ### Base Mode
    - For routine tasks, bug fixes, and minor enhancements
    - Reference essential documentation (project_overview.md, task_list.md)
    - Focus on minimal complexity
    - Prioritize readability and maintainability
    - Use standard patterns and approaches

    ### Enhanced Mode
    - For complex problems, architectural changes, and new features
    - Reference comprehensive documentation (all .notes/ files)
    - Perform deeper analysis of the codebase
    - Consider multiple approaches with pros/cons
    - Prioritize long-term maintainability and scalability
    - Document design decisions and rationale

  ##############################################################################
  # PROJECT DIRECTIVES
  ##############################################################################
  Project Directives:
    - Project Name: wanderer
    - AI First: true

  ##############################################################################
  # NEW RULES TO ADDRESS OVERZEALOUS AGENTIC FUNCTIONS
  ##############################################################################
  New Rules to Address Overzealous Agentic Functions:

    ### Pacing and Scope Control
    1. **Explicit Checkpoint Requirements**
       - Pause after completing each logical unit of work and wait for explicit approval
         before continuing.
       - Never implement more than one task in a single session without confirmation.

    2. **Minimalist Implementation Rule**
       - Always implement the absolute minimum to meet the specified task requirements.
       - When in doubt about scope, choose the narrower interpretation.

    3. **Staged Development Protocol**
       - Follow a strict &quot;propose ‚Üí approve ‚Üí implement ‚Üí review&quot; cycle for every change.
       - After implementing each component, stop and provide a clear summary of changes
         and what remains.

    4. **Scope Boundary Enforcement**
       - If a task requires changes outside the initially identified files, pause and
         request explicit permission.
       - Never perform &quot;while I&apos;m at it&quot; improvements without approval.

    ### Communications
    1. **Mandatory Checkpoints**
       - After every change, pause and summarize what you&apos;ve done and what you plan next.
       - Mark each implemented feature as [COMPLETE] and ask if you should continue.

    2. **Complexity Warning System**
       - If implementation requires touching more than 3 files, flag as [COMPLEX CHANGE]
         and wait for confirmation.
       - Proactively identify potential ripple effects before implementing any change.

    3. **Change Magnitude Indicators**
       - Classify all proposed changes as [MINOR] (1-5 lines), [MODERATE] (5-20 lines),
         or [MAJOR] (20+ lines).
       - For [MAJOR] changes, provide a detailed plan and wait for explicit approval.

    4. **Testability Focus**
       - Pause at the earliest point where testing is possible.
       - Never proceed past a testable checkpoint without confirmation that current
         implementation works.


################################################################################
# END OF .cursorrules
################################################################################</file><file path=".dockerignore"># This file excludes paths from the Docker build context.
#
# By default, Docker&apos;s build context includes all files (and folders) in the
# current directory. Even if a file isn&apos;t copied into the container it is still sent to
# the Docker daemon.
#
# There are multiple reasons to exclude files from the build context:
#
# 1. Prevent nested folders from being copied into the container (ex: exclude
#    /assets/node_modules when copying /assets)
# 2. Reduce the size of the build context and improve build time (ex. /build, /deps, /doc)
# 3. Avoid sending files containing sensitive information
#
# More information on using .dockerignore is available here:
# https://docs.docker.com/engine/reference/builder/#dockerignore-file

.dockerignore

# Ignore git, but keep git HEAD and refs to access current commit hash if needed:
#
# $ cat .git/HEAD | awk &apos;{print &quot;.git/&quot;$2}&apos; | xargs cat
# d0b8727759e1e0e7aa3d41707d12376e373d5ecc
.git
!.git/HEAD
!.git/refs

# Common development/test artifacts
/cover/
/doc/
/test/
/tmp/
.elixir_ls

# Mix artifacts
*.ez

# Generated on crash by the VM
erl_crash.dump

# Static artifacts - These should be fetched and built inside the Docker image
/priv/static/assets/
/priv/static/cache_manifest.json</file><file path=".editorconfig">root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.{md, markdown, eex, adoc, asciidoc}]
trim_trailing_whitespace = false

[Makefile]
indent_size = 2
indent_style = tab
end_of_line = lf</file><file path=".env.example">export WEB_APP_URL=&quot;http://localhost:8000&quot;
export RELEASE_COOKIE=&quot;PDpbnyo6mEI_0T4ZsHH_ESmi1vT1toQ8PTc0vbfg5FIT4Ih-Lh98mw==&quot;
export EVE_CLIENT_ID=&quot;&lt;EVE_CLIENT_ID&gt;&quot;
export EVE_CLIENT_SECRET=&quot;&lt;EVE_CLIENT_SECRET&gt;&quot;
export EVE_CLIENT_WITH_WALLET_ID=&quot;&lt;EVE_CLIENT_WITH_WALLET_ID&gt;&quot;
export EVE_CLIENT_WITH_WALLET_SECRET=&quot;&lt;EVE_CLIENT_WITH_WALLET_SECRET&gt;&quot;
export GIT_SHA=&quot;1111&quot;
export WANDERER_INVITES=&quot;false&quot;
export WANDERER_PUBLIC_API_DISABLED=&quot;false&quot;
export WANDERER_CHARACTER_API_DISABLED=&quot;false&quot;
export WANDERER_ZKILL_PRELOAD_DISABLED=&quot;false&quot;</file><file path=".envrc">use flake
source .env</file><file path=".formatter.exs">[
  import_deps: [:ecto, :ecto_sql, :phoenix, :ash, :ash_phoenix, :ash_postgres],
  subdirectories: [&quot;priv/*/migrations&quot;],
  plugins: [Phoenix.LiveView.HTMLFormatter],
  inputs: [&quot;*.{heex,ex,exs}&quot;, &quot;{config,lib,test}/**/*.{heex,ex,exs}&quot;, &quot;priv/*/seeds.exs&quot;]
]</file><file path=".gitignore"># Also ignore archive artifacts (built via &quot;mix archive.build&quot;).
*.ez

*.iml

*.key

/.idea/
/node_modules/
/assets/node_modules/
/assets/lib/ui-kit/dist/

# Ignore assets that are produced by build tools.
/priv/static/assets/
/priv/static/icons/
/priv/static/images/
/priv/static/*.js
/priv/static/*.css

.DS_Store
**/.DS_Store

# Temporary files, for example, from tests.
/tmp/


.env
*.local.env
test/manual/.auto*

.direnv/
.cache/
.nix-shell/
.lexical/

/_build
/cover
/deps
/doc
/.fetch
erl_crash.dump
*.ez
*.beam
/config/*.secret.exs
.elixir_ls/

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?</file><file path=".gitmessage">&lt;type&gt;(&lt;scope&gt;): &lt;summary&gt;

&lt;Describe the motivation behind this change - explain WHY you are making this change. Wrap all lines
at 100 characters.&gt;

Fixes #&lt;issue number&gt;

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 100 chars ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§


# Example Commit Messages
# =======================


# ‚îÄ‚îÄ‚îÄ Example: Simple refactor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
# refactor(core): rename refreshDynamicEmbeddedViews to refreshEmbeddedViews
#
# Improve code readability. The original name no longer matches how the function is used.
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§


# ‚îÄ‚îÄ‚îÄ Example: Simple docs change ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
# docs: clarify the service limitation in providers.md guide
#
# Fixes #36332
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§


# ‚îÄ‚îÄ‚îÄ Example: A bug fix ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
# fix(ngcc): ensure lockfile is removed when `analyzeFn` fails
#
# Previously an error thrown in the `analyzeFn` would cause the ngcc process to exit immediately
# without removing the lockfile, and potentially before the unlocker process had been successfully
# spawned resulting in the lockfile being orphaned and left behind.
#
# Now we catch these errors and remove the lockfile as needed.
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§


# ‚îÄ‚îÄ‚îÄ Example: Breaking change ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
# feat(bazel): simplify ng_package by dropping esm5 and fesm5
#
# BREAKING CHANGE: 
#
#
# Fixes #1234
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§



# Commit Message Format
# =============================
#
# The full specification of the Angular Commit Message Format can be found at
# https://github.com/angular/angular/blob/main/CONTRIBUTING.md#commit
#
# The following is an excerpt of the specification with the most commonly needed info.
#
# Each commit message consists of a *header*, a *body*, and a *footer*.
#
# &lt;header&gt;
# &lt;BLANK LINE&gt;
# &lt;body&gt;
# &lt;BLANK LINE&gt;
# &lt;footer&gt;
#
# The header is mandatory.
#
# The body is mandatory for all commits except for those of scope &quot;docs&quot;. When the body is required
# it must be at least 20 characters long.
#
# The footer is optional.
#
# Any line of the commit message cannot be longer than 100 characters.
#
#
# Commit Message Header
# ---------------------
#
# &lt;type&gt;(&lt;scope&gt;): &lt;short summary&gt;
#   ‚îÇ       ‚îÇ             ‚îÇ
#   ‚îÇ       ‚îÇ             ‚îî‚îÄ‚´∏ Summary in present tense. Not capitalized. No period at the end.
#   ‚îÇ       ‚îÇ
#   ‚îÇ       ‚îî‚îÄ‚´∏ Commit Scope: animations|bazel|benchpress|common|compiler|compiler-cli|core|
#   ‚îÇ                          elements|forms|http|language-service|localize|platform-browser|
#   ‚îÇ                          platform-browser-dynamic|platform-server|router|service-worker|
#   ‚îÇ                          upgrade|zone.js|packaging|changelog|docs-infra|migrations|ngcc|ve|
#   ‚îÇ                          devtools
#   ‚îÇ                          https://github.com/angular/angular/blob/main/CONTRIBUTING.md#scope
#   ‚îÇ
#   ‚îî‚îÄ‚´∏ Commit Type: build|ci|docs|feat|fix|perf|refactor|style|test
#                     https://github.com/angular/angular/blob/main/CONTRIBUTING.md#type
#
#
# Commit Message Body
# ---------------------
#
# Just as in the summary, use the imperative, present tense: &quot;fix&quot; not &quot;fixed&quot; nor &quot;fixes&quot;.
#
# Explain the motivation for the change in the commit message body. This commit message should
# explain WHY you are making the change. You can include a comparison of the previous behavior with
# the new behavior in order to illustrate the impact of the change.
#
#
# Commit Message Footer
# ---------------------
#
# The footer can contain information about breaking changes and is also the place to reference
# GitHub issues, Jira tickets, and other PRs that this commit closes or is related to.
#
# ```
# BREAKING CHANGE: &lt;breaking change summary&gt;
# &lt;BLANK LINE&gt;
# &lt;breaking change description + migration instructions&gt;
# &lt;BLANK LINE&gt;
# &lt;BLANK LINE&gt;
# Fixes #&lt;issue number&gt;
# ```
#
# Breaking Change section should start with the phrase &quot;BREAKING CHANGE: &quot; followed by a summary of
# the breaking change, a blank line, and a detailed description of the breaking change that also
# includes migration instructions.
#</file><file path=".tool-versions">erlang 26.2.5.5
elixir 1.17.3-otp-26
nodejs 18.0.0</file><file path="default.nix">with import &lt;nixpkgs&gt; { };
let
  pname = &quot;wanderer&quot;;
  version = &quot;0.0.0&quot;;
  src = ./.; #FIXME once uploaded to repository, change the source
  packages = beam.packagesWith beam.interpreters.erlang_25;
  erlang = beam.interpreters.erlang_25;
  elixir = beam.packages.erlang_25.elixir_1_16;

  mixFodDeps = packages.fetchMixDeps {
    pname = &quot;mix-deps-${pname}&quot;;
    inherit src version elixir;
    hash = &quot;sha256-rILIBMHOHGyCuog8ZtmQAVCiHqn6b7CBrSMNBeSycNM=&quot;;
  };

  # yarnDeps = mkYarnModules {
  #   pname = &quot;${pname}-yarn-deps&quot;;
  #   inherit version;
  #   packageJSON = ./apps/portal_web/assets/package.json;
  #   yarnLock = ./apps/portal_web/assets/yarn.lock;
  #   yarnNix = ./yarn.nix;
  #   preBuild = &apos;&apos;
  #     mkdir -p tmp/deps
  #     cp -r ${mixFodDeps}/phoenix tmp/deps/phoenix
  #     cp -r ${mixFodDeps}/phoenix_html tmp/deps/phoenix_html
  #   &apos;&apos;;
  # };
in
packages.mixRelease {
  inherit pname version src elixir erlang mixFodDeps;

  nativeBuildInputs = [ nodejs ];

  # tportal is an umbrella app
  # override configurePhase to not skip umbrella children
  configurePhase = &apos;&apos;
    runHook preConfigure
    mix deps.compile --no-deps-check
    runHook postConfigure
  &apos;&apos;;

  postBuild = &apos;&apos;
    # for external task you need a workaround for the no deps check flag
    # https://github.com/phoenixframework/phoenix/issues/2690
    mix do deps.loadpaths --no-deps-check, phx.digest
    mix phx.digest --no-deps-check
  &apos;&apos;;
}</file><file path="Dockerfile">ARG BUILDER_IMAGE=&quot;wandererltd/build-base:latest&quot;
ARG RUNNER_IMAGE=&quot;wandererltd/runner-base:latest&quot;

FROM ${BUILDER_IMAGE} as builder

# prepare build dir
WORKDIR /app

# set build ENV
ENV MIX_ENV=&quot;prod&quot;

# Set ERL_FLAGS for ARM compatibility
ENV ERL_FLAGS=&quot;+JPperf true&quot;

# install mix dependencies
COPY mix.exs mix.lock ./
RUN rm -Rf _build deps &amp;&amp; mix deps.get --only $MIX_ENV
RUN mkdir config

# copy compile-time config files before we compile dependencies
# to ensure any relevant config change will trigger the dependencies
# to be re-compiled.
COPY config/config.exs config/${MIX_ENV}.exs config/

COPY priv priv

COPY lib lib

COPY assets assets

RUN mix compile

RUN mix assets.deploy

# Changes to config/runtime.exs don&apos;t require recompiling the code
COPY config/runtime.exs config/

COPY rel rel
RUN mix release

# start a new build stage so that the final image will only contain
# the compiled release and other runtime necessities
FROM ${RUNNER_IMAGE}

WORKDIR &quot;/app&quot;
COPY --chmod=755 ./rel/docker-entrypoint.sh /app/entrypoint.sh
RUN chown nobody /app

# set runner ENV
ENV MIX_ENV=&quot;prod&quot;

# Only copy the final release from the build stage
COPY --from=builder --chown=nobody:root /app/_build/${MIX_ENV}/rel/wanderer_app ./

USER nobody

ENTRYPOINT [&quot;/app/entrypoint.sh&quot;]

CMD [&quot;run&quot;]</file><file path="elixir_buildpack.config"># Elixir version
elixir_version=1.17.2

# Erlang version
# https://github.com/HashNuke/heroku-buildpack-elixir-otp-builds/blob/master/otp-versions
erlang_version=27.0.1

always_rebuild=false

# Invoke assets.deploy defined in your mix.exs to deploy assets with esbuild
# Note we nuke the esbuild executable from the image
# hook_post_compile=&quot;eval mix assets.deploy &amp;&amp; rm -f _build/esbuild&quot;</file><file path="flake.lock">{
  &quot;nodes&quot;: {
    &quot;flake-utils&quot;: {
      &quot;inputs&quot;: {
        &quot;systems&quot;: &quot;systems&quot;
      },
      &quot;locked&quot;: {
        &quot;lastModified&quot;: 1726560853,
        &quot;narHash&quot;: &quot;sha256-X6rJYSESBVr3hBoH0WbKE5KvhPU5bloyZ2L4K60/fPQ=&quot;,
        &quot;owner&quot;: &quot;numtide&quot;,
        &quot;repo&quot;: &quot;flake-utils&quot;,
        &quot;rev&quot;: &quot;c1dfcf08411b08f6b8615f7d8971a2bfa81d5e8a&quot;,
        &quot;type&quot;: &quot;github&quot;
      },
      &quot;original&quot;: {
        &quot;owner&quot;: &quot;numtide&quot;,
        &quot;repo&quot;: &quot;flake-utils&quot;,
        &quot;type&quot;: &quot;github&quot;
      }
    },
    &quot;nixpkgs&quot;: {
      &quot;locked&quot;: {
        &quot;lastModified&quot;: 1726871744,
        &quot;narHash&quot;: &quot;sha256-V5LpfdHyQkUF7RfOaDPrZDP+oqz88lTJrMT1+stXNwo=&quot;,
        &quot;owner&quot;: &quot;nixos&quot;,
        &quot;repo&quot;: &quot;nixpkgs&quot;,
        &quot;rev&quot;: &quot;a1d92660c6b3b7c26fb883500a80ea9d33321be2&quot;,
        &quot;type&quot;: &quot;github&quot;
      },
      &quot;original&quot;: {
        &quot;owner&quot;: &quot;nixos&quot;,
        &quot;ref&quot;: &quot;nixpkgs-unstable&quot;,
        &quot;repo&quot;: &quot;nixpkgs&quot;,
        &quot;type&quot;: &quot;github&quot;
      }
    },
    &quot;root&quot;: {
      &quot;inputs&quot;: {
        &quot;flake-utils&quot;: &quot;flake-utils&quot;,
        &quot;nixpkgs&quot;: &quot;nixpkgs&quot;
      }
    },
    &quot;systems&quot;: {
      &quot;locked&quot;: {
        &quot;lastModified&quot;: 1681028828,
        &quot;narHash&quot;: &quot;sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=&quot;,
        &quot;owner&quot;: &quot;nix-systems&quot;,
        &quot;repo&quot;: &quot;default&quot;,
        &quot;rev&quot;: &quot;da67096a3b9bf56a91d16901293e51ba5b49a27e&quot;,
        &quot;type&quot;: &quot;github&quot;
      },
      &quot;original&quot;: {
        &quot;owner&quot;: &quot;nix-systems&quot;,
        &quot;repo&quot;: &quot;default&quot;,
        &quot;type&quot;: &quot;github&quot;
      }
    }
  },
  &quot;root&quot;: &quot;root&quot;,
  &quot;version&quot;: 7
}</file><file path="flake.nix">{
  description = &quot;Main flake&quot;;

  nixConfig.bash-prompt = &quot;\\e[0;32m[nix-develop@\\h] \\W&gt;\\e[m &quot;;

  inputs = {
    nixpkgs = { url = &quot;github:nixos/nixpkgs/nixpkgs-unstable&quot;; };
    flake-utils = { url = &quot;github:numtide/flake-utils&quot;; };
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        LANG = &quot;C.UTF-8&quot;;
        # LANG= &quot;en_US.UTF-8&quot;;
        root = ./.;
        inherit (pkgs.lib) optional optionals;

        overlay = (final: prev: {
          yarn = prev.yarn.override {
                  nodejs = final.pkgs.nodejs-18_x;
                };
        });

        pkgs = import nixpkgs {
          inherit system;
          overlays = [ overlay ];
        };

        pname = &quot;wanderer&quot;;

        erlang = pkgs.beam.interpreters.erlang_27;
        elixir = pkgs.beam.packages.erlang_27.elixir_1_17;
        elixir-ls = pkgs.beam.packages.erlang_27.elixir_ls;
        packages = pkgs.beam.packagesWith erlang;
        nodejs = pkgs.nodejs-18_x;
        postgresql = pkgs.postgresql_14;
        yarn = pkgs.yarn;

        # This is opinionated instead of simple using:
        # pkgs.beam.packages.erlang.hex;
        hex = packages.hex;
        MIX_PATH = &quot;${hex}/archives/hex-${hex.version}/hex-${hex.version}/ebin&quot;;

        # This is opinionated instead of simple using:
        # pkgs.beam.packages.erlang.rebar3;
        rebar3 = pkgs.beam.packages.erlang_27.rebar3;

        MIX_REBAR3 = &quot;${rebar3}/bin/rebar3&quot;;
      in
      with pkgs;
      {
        devShells.default = pkgs.mkShell {
          inherit LANG MIX_PATH MIX_REBAR3 elixir erlang nodejs yarn;
          # use local HOME to avoid global things
          MIX_HOME = &quot;.cache/mix&quot;;
          HEX_HOME = &quot;.cache/hex&quot;;
          MIX_ENV = &quot;dev&quot;;
          # enable IEx shell history
          ERL_AFLAGS = &quot;-kernel shell_history enabled&quot;;

          shellHook = &apos;&apos;
          # this allows mix to work on the local directory
          if ! test -d .nix-shell; then
            mkdir .nix-shell
          fi

          export NIX_SHELL_DIR=$PWD/.nix-shell
          # Put the PostgreSQL databases in the project directory.
          export PGDATA=$NIX_SHELL_DIR/db
          export MIX_HOME=$NIX_SHELL_DIR/.mix
          export MIX_ARCHIVES=$MIX_HOME/archives
          export HEX_HOME=$NIX_SHELL_DIR/.hex

          export PATH=$MIX_HOME/bin:$PATH
          export PATH=$HEX_HOME/bin:$PATH
          export PATH=$MIX_HOME/escripts:$PATH
          export LIVEBOOK_HOME=$PWD

          # make hex from Nixpkgs available
          # `mix local.hex` will install hex into MIX_HOME and should take precedence
          export LANG=C.UTF-8
          # keep your shell history in iex
          export ERL_AFLAGS=&quot;-kernel shell_history enabled&quot;

          # add your project env vars here, word readable in the nix store.
          # export ENV_VAR=&quot;your_env_var&quot;
          ${elixir}/bin/mix --version
          ${elixir}/bin/iex --version
        &apos;&apos;;

          buildInputs = [
            nodejs
            yarn
            git
            postgresql
            elixir
            elixir_ls
            pgcli
            flyctl
            glibcLocales
            nixpkgs-fmt
            (pkgs.writeShellScriptBin &quot;pg-stop&quot; &apos;&apos;
              pg_ctl -D $PGDATA -U postgres stop
            &apos;&apos;)
            (pkgs.writeShellScriptBin &quot;pg-reset&quot; &apos;&apos;
              rm -rf $PGDATA
            &apos;&apos;)
            (pkgs.writeShellScriptBin &quot;pg-setup&quot; &apos;&apos;
              ####################################################################
              # If database is not initialized (i.e., $PGDATA directory does not
              # exist), then set it up. Seems superfluous given the cleanup step
              # above, but handy when one gets to force reboot the iron.
              ####################################################################
              if ! test -d $PGDATA; then
                ######################################################
                # Init PostgreSQL
                ######################################################
                pg_ctl initdb -D  $PGDATA -o &quot;--no-locale --encoding=UTF8&quot;
                #### initdb --locale=C --encoding=UTF8 --auth-local=peer --auth-host=scram-sha-256 &gt; /dev/null || exit
                # initdb --encoding=UTF8 --no-locale --no-instructions -U postgres
                ######################################################
                # PORT ALREADY IN USE
                ######################################################
                # If another `nix-shell` is  running with a PostgreSQL
                # instance,  the logs  will show  complaints that  the
                # default port 5432  is already in use.  Edit the line
                # below with  a different  port number,  uncomment it,
                # and try again.
                ######################################################
                if [[ &quot;$PGPORT&quot; ]]; then
                  sed -i &quot;s|^#port.*$|port = $PGPORT|&quot; $PGDATA/postgresql.conf
                fi
                echo &quot;listen_addresses = ${&quot;&apos;&quot;}${&quot;&apos;&quot;}&quot; &gt;&gt; $PGDATA/postgresql.conf
                echo &quot;unix_socket_directories = &apos;$PGDATA&apos;&quot; &gt;&gt; $PGDATA/postgresql.conf
                echo &quot;CREATE USER postgres WITH PASSWORD &apos;postgres&apos; CREATEDB SUPERUSER;&quot; | postgres --single -E postgres
              fi
            &apos;&apos;)
            (pkgs.writeShellScriptBin &quot;pg-start&quot; &apos;&apos;
              ## # Postgres Fallback using docker
              ## docker run -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -p 5432:5432 postgres:14

              [ ! -d $PGDATA ] &amp;&amp; pg-setup

              ####################################################################
              # Start PostgreSQL
              # ==================================================================
              # Setting all  necessary configuration  options via  `pg_ctl` (which
              # is  basically  a wrapper  around  `postgres`)  instead of  editing
              # `postgresql.conf` directly with `sed`. See docs:
              #
              # + https://www.postgresql.org/docs/current/app-pg-ctl.html
              # + https://www.postgresql.org/docs/current/app-postgres.html
              #
              # See more on the caveats at
              # https://discourse.nixos.org/t/how-to-configure-postgresql-declaratively-nixos-and-non-nixos/4063/1
              # but recapping out of paranoia:
              #
              # &gt; use `SHOW`  commands to  check the  options because  `postgres -C`
              # &gt; &quot;_returns values  from postgresql.conf_&quot; (which is  not changed by
              # &gt; supplying  the  configuration options  on  the  command line)  and
              # &gt; &quot;_it does  not reflect  parameters supplied  when the  cluster was
              # &gt; started._&quot;
              #
              # OPTION SUMMARY
              # --------------------------------------------------------------------
              #
              #  + `unix_socket_directories`
              #
              #    &gt; PostgreSQL  will  attempt  to create  a  pidfile  in
              #    &gt; `/run/postgresql` by default, but it will fail as it
              #    &gt; doesn&apos;t exist. By  changing the configuration option
              #    &gt; below, it will get created in $PGDATA.
              #
              #   + `listen_addresses`
              #
              #     &gt; In   tandem  with   edits   in  `pg_hba.conf`   (see
              #     &gt; `HOST_COMMON`  below), it  configures PostgreSQL  to
              #     &gt; allow remote connections (otherwise only `localhost`
              #     &gt; will get  authenticated and the rest  of the traffic
              #     &gt; discarded).
              #     &gt;
              #     &gt; NOTE: the  edit  to  `pga_hba.conf`  needs  to  come
              #     &gt;       **before**  `pg_ctl  start`  (or  the  service
              #     &gt;       needs to be restarted otherwise), because then
              #     &gt;       the changes are not being reloaded.
              #     &gt;
              #     &gt; More info  on setting up and  troubleshooting remote
              #     &gt; PosgreSQL connections (these are  all mirrors of the
              #     &gt; same text; again, paranoia):
              #     &gt;
              #     &gt;   + https://stackoverflow.com/questions/24504680/connect-to-postgres-server-on-google-compute-engine
              #     &gt;   + https://stackoverflow.com/questions/47794979/connecting-to-postgres-server-on-google-compute-engine
              #     &gt;   + https://medium.com/scientific-breakthrough-of-the-afternoon/configure-postgresql-to-allow-remote-connections-af5a1a392a38
              #     &gt;   + https://gist.github.com/toraritte/f8c7fe001365c50294adfe8509080201#file-configure-postgres-to-allow-remote-connection-md
              HOST_COMMON=&quot;host\s\+all\s\+all&quot;
              sed -i &quot;s|^$HOST_COMMON.*127.*$|host all all 0.0.0.0/0 trust|&quot; $PGDATA/pg_hba.conf
              sed -i &quot;s|^$HOST_COMMON.*::1.*$|host all all ::/0 trust|&quot;      $PGDATA/pg_hba.conf
              #  + `log*`
              #
              #    &gt; Setting up basic logging,  to see remote connections
              #    &gt; for example.
              #    &gt;
              #    &gt; See the docs for more:
              #    &gt; https://www.postgresql.org/docs/current/runtime-config-logging.html

              pg_ctl                                                  \
                -D $PGDATA                                            \
                -l $PGDATA/postgres.log                               \
                -o &quot;-c unix_socket_directories=&apos;$PGDATA&apos;&quot;             \
                -o &quot;-c listen_addresses=&apos;*&apos;&quot;                          \
                -o &quot;-c log_destination=&apos;stderr&apos;&quot;                      \
                -o &quot;-c logging_collector=on&quot;                          \
                -o &quot;-c log_directory=&apos;log&apos;&quot;                           \
                -o &quot;-c log_filename=&apos;postgresql-%Y-%m-%d_%H%M%S.log&apos;&quot; \
                -o &quot;-c log_min_messages=info&quot;                         \
                -o &quot;-c log_min_error_statement=info&quot;                  \
                -o &quot;-c log_connections=on&quot;                            \
                start
            &apos;&apos;)
            (pkgs.writeShellScriptBin &quot;pg-console&quot; &apos;&apos;
              psql --host $PGDATA -U postgres
            &apos;&apos;)
          ] ++ optional stdenv.isLinux inotify-tools
            ++ optional stdenv.isDarwin terminal-notifier
            ++ optionals stdenv.isDarwin (with darwin.apple_sdk.frameworks; [
              CoreFoundation
              CoreServices
            ]);

          packages = with pkgs; [ nodejs yarn ];
        };
      });
}</file><file path="fly.toml"># fly.toml app configuration file generated for wanderer-test on 2024-05-31T22:56:48+04:00
#
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.
#

app = &apos;wanderer-test&apos;
primary_region = &apos;ams&apos;
kill_signal = &apos;SIGTERM&apos;
swap_size_mb = 512

[build]

[deploy]
  release_command = &apos;/app/bin/migrate.sh&apos;

[env]
  PHX_HOST = &apos;wanderer-test.fly.dev&apos;
  PHX_SERVER = &apos;true&apos;
  PORT = &apos;8080&apos;

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = &apos;off&apos;
  auto_start_machines = false
  min_machines_running = 0
  processes = [&apos;app&apos;]

  [http_service.concurrency]
    type = &apos;connections&apos;
    hard_limit = 1000
    soft_limit = 1000

[[vm]]
  size = &apos;shared-cpu-1x&apos;

[[metrics]]
  port = 4021
  path = &apos;/metrics&apos;
  https = false</file><file path="m">#!/bin/bash

set -e

COMMAND=$1

case $COMMAND in
  e|env)
    export ERL_AFLAGS=&quot;-kernel shell_history enabled&quot;
    ;;
  i|install)
    MIX_ENV=dev mix deps.get
    cd assets &amp;&amp; yarn install
    ;;
  deps)
    MIX_ENV=dev mix deps.get
    ;;
  setup)
    MIX_ENV=dev mix setup
    ;;
  createdb)
    MIX_ENV=dev mix ecto.create
    ;;
  testdb)
    MIX_ENV=dev mix ash.codegen test111
    ;;
  depsf)
    MIX_ENV=dev mix deps.compile syslog --force
    ;;
  d|deploy)
    mix assets.build &amp;&amp; mix assets.deploy
    ;;
  c|cleanup)
    pkill -SIGTERM -f &apos;tailwind&apos; || true
    ;;
  y|yarn)
    cd assets &amp;&amp; yarn
    ;;
  w|watch)
    cd assets &amp;&amp; yarn watch
    ;;
  s|server|start)
    source .env &amp;&amp; MIX_ENV=dev iex -S mix phx.server
    ;;
  m|migrate)
    MIX_ENV=dev mix ash.migrate
    ;;
  r|reset)
    MIX_ENV=dev mix ecto.reset
    ;;
  si|seeds)
    MIX_ENV=dev mix run priv/repo/seeds.exs
    ;;
  f|format)
    mix format
    ;;
  t|test)
    mix test
    ;;
  cover|coverage|co)
    mix test --cover
    ;;
  v|versions)
    echo &quot;Tool Versions&quot;
    cat .tool-versions
    cat Aptfile
    echo
    ;;
  *)
    echo &quot;Usage: $0 {e|env|i|install|dg|deps|depsf|d|deploy|c|cleanup|y|yarn|s|server|start|m|migrate|f|format|t|test|cover|coverage|co|v|versions|watch|seeds}&quot;
    exit 1
    ;;
esac</file><file path="Makefile">.PHONY: deploy install cleanup start yarn migrate format test coverage versions standalone-tests

ROOT_DIR:=$(shell dirname $(realpath $(firstword $(MAKEFILE_LIST))))
SHELL := /bin/bash

evn e:
	export ERL_AFLAGS=&quot;-kernel shell_history enabled&quot;

install i:
	mix deps.get
	cd assets &amp;&amp; yarn install

deploy d:
	mix assets.build &amp;&amp; mix assets.deploy

cleanup c:
	-pkill -SIGTERM -f &apos;tailwind&apos;

yarn y:
	cd assets &amp;&amp; yarn

start server s:
	make cleanup
	source .env &amp;&amp; MIX_ENV=dev iex -S mix phx.server

migrate m:
	MIX_ENV=dev mix ash.migrate

format f:
	mix format

test t:
	mix test

coverage cover co:
	mix test --cover

unit-tests ut:
	@echo &quot;Running unit tests...&quot;
	@find test/unit -name &quot;*.exs&quot; -exec elixir {} \;
	@echo &quot;All unit tests completed.&quot;

versions v:
	@echo &quot;Tool Versions&quot;
	@cat .tool-versions
	@cat Aptfile
	@echo</file><file path="mix.exs">defmodule WandererApp.MixProject do
  use Mix.Project

  @source_url &quot;https://github.com/wanderer-industries/wanderer&quot;

  @version &quot;1.65.8&quot;

  def project do
    [
      app: :wanderer_app,
      version: @version,
      elixir: &quot;~&gt; 1.16&quot;,
      elixirc_paths: elixirc_paths(Mix.env()),
      start_permanent: Mix.env() == :prod,
      aliases: aliases(),
      deps: deps(),
      source_url: @source_url,
      releases: [
        wanderer_app: [
          include_executables_for: [:unix],
          steps: [:assemble, :tar],
          applications: [
            wanderer_app: :permanent
          ],
          version: &quot;1.0.0&quot;
        ]
      ]
    ]
  end

  # Configuration for the OTP application.
  #
  # Type `mix help compile.app` for more information.
  def application do
    [
      mod: {WandererApp.Application, []},
      extra_applications: [:logger, :runtime_tools, :ex_rated]
    ]
  end

  # Specifies which paths to compile per environment.
  defp elixirc_paths(:test), do: [&quot;lib&quot;, &quot;test/support&quot;]
  defp elixirc_paths(_), do: [&quot;lib&quot;]

  # Specifies your project dependencies.
  #
  # Type `mix help deps` for examples and options.
  defp deps do
    [
      {:credo, &quot;~&gt; 1.7&quot;, only: [:dev, :test], runtime: false},
      {:dialyxir, &quot;&gt;= 0.0.0&quot;, only: [:dev], runtime: false},
      {:doctor, &quot;&gt;= 0.0.0&quot;, only: [:dev], runtime: false},
      {:ex_doc, &quot;~&gt; 0.37&quot;, runtime: false},
      {:sobelow, &quot;&gt;= 0.0.0&quot;, only: [:dev], runtime: false},
      {:mix_audit, &quot;&gt;= 0.0.0&quot;, only: [:dev], runtime: false},
      {:ex_check, &quot;~&gt; 0.14.0&quot;, only: [:dev], runtime: false},
      {:open_api_spex, github: &quot;mbuhot/open_api_spex&quot;, branch: &quot;master&quot;},
      {:ex_rated, &quot;~&gt; 2.0&quot;},
      {:retry, &quot;~&gt; 0.18.0&quot;},
      {:phoenix, &quot;~&gt; 1.7.14&quot;},
      {:phoenix_ecto, &quot;~&gt; 4.6&quot;},
      {:ecto_sql, &quot;~&gt; 3.10&quot;},
      {:postgrex, &quot;~&gt; 0.19.1&quot;},
      {:phoenix_html, &quot;~&gt; 4.0&quot;},
      {:phoenix_live_reload, &quot;~&gt; 1.5.3&quot;, only: :dev},
      {:phoenix_live_view, &quot;~&gt; 1.0.0-rc.7&quot;, override: true},
      {:phoenix_pubsub, &quot;~&gt; 2.1&quot;},
      {:floki, &quot;&gt;= 0.30.0&quot;, only: :test},
      {:phoenix_live_dashboard, &quot;~&gt; 0.8.3&quot;},
      {:phoenix_ddos, &quot;~&gt; 1.1&quot;},
      {:tailwind, &quot;~&gt; 0.2.2&quot;, runtime: Mix.env() == :dev},
      {:heroicons, &quot;~&gt; 0.5.5&quot;},
      {:swoosh, &quot;~&gt; 1.3&quot;},
      {:finch, &quot;~&gt; 0.13&quot;},
      {:telemetry_metrics, &quot;~&gt; 1.0&quot;, override: true},
      {:telemetry_poller, &quot;~&gt; 1.0&quot;},
      {:gettext, &quot;~&gt; 0.20&quot;},
      {:jason, &quot;~&gt; 1.4&quot;},
      {:dns_cluster, &quot;~&gt; 0.1.1&quot;},
      {:plug_cowboy, &quot;~&gt; 2.5&quot;},
      {:plug_dynamic, &quot;~&gt; 1.0&quot;},
      {:plug_content_security_policy, &quot;~&gt; 0.2.1&quot;},
      {:dart_sass, &quot;~&gt; 0.5.1&quot;, runtime: Mix.env() == :dev},
      {:oauth2, &quot;~&gt; 1.0 or ~&gt; 2.0&quot;},
      {:ueberauth, &quot;~&gt; 0.10.0&quot;},
      {:req, &quot;~&gt; 0.4.0&quot;},
      {:ash, &quot;~&gt; 3.4&quot;},
      {:ash_cloak, &quot;~&gt; 0.1.2&quot;},
      {:ash_phoenix, &quot;~&gt; 2.1&quot;},
      {:ash_postgres, &quot;~&gt; 2.4&quot;},
      {:exsync, &quot;~&gt; 0.4&quot;, only: :dev},
      {:nimble_csv, &quot;~&gt; 1.2.0&quot;},
      {:cachex, &quot;~&gt; 3.6&quot;},
      {:live_select, &quot;~&gt; 1.5&quot;},
      {:nebulex, &quot;~&gt; 2.6&quot;},
      {:decorator, &quot;~&gt; 1.4&quot;},
      {:slugify, &quot;~&gt; 1.3&quot;},
      {:debounce_and_throttle, &quot;~&gt; 0.9.0&quot;},
      {:ex2ms, &quot;~&gt; 1.0&quot;},
      {:merkle_map, &quot;~&gt; 0.2.1&quot;},
      {:prom_ex, &quot;~&gt; 1.9&quot;},
      {:fresh, &quot;~&gt; 0.4.4&quot;},
      {:nimble_publisher, &quot;~&gt; 1.0&quot;},
      {:makeup_elixir, &quot;&gt;= 0.0.0&quot;},
      {:makeup_erlang, &quot;&gt;= 0.0.0&quot;},
      {:better_number, &quot;~&gt; 1.0.0&quot;},
      {:delta_crdt, &quot;~&gt; 0.6.5&quot;, override: true},
      {:qex, &quot;~&gt; 0.5&quot;},
      {:site_encrypt, &quot;~&gt; 0.6.0&quot;},
      {:bandit, &quot;~&gt; 1.0&quot;},
      {:uuid, &quot;~&gt; 1.1&quot;},
      {:cloak, &quot;1.1.4&quot;},
      {:quantum, &quot;~&gt; 3.0&quot;},
      {:pathex, &quot;~&gt; 2.5&quot;},
      {:mox, &quot;~&gt; 1.1&quot;, only: [:test, :integration]},
      {:git_ops, &quot;~&gt; 2.6.1&quot;},
      {:version_tasks, &quot;~&gt; 0.12.0&quot;},
      {:error_tracker, &quot;~&gt; 0.2&quot;},
      {:ddrt, &quot;~&gt; 0.2.1&quot;},
      {:live_view_events, &quot;~&gt; 0.1.0&quot;},
      {:ash_pagify, &quot;~&gt; 1.4.1&quot;},
      {:timex, &quot;~&gt; 3.0&quot;}
    ]
  end

  defp aliases do
    [
      setup: [&quot;deps.get&quot;, &quot;ecto.setup&quot;, &quot;assets.setup&quot;, &quot;assets.build&quot;],
      &quot;ecto.setup&quot;: [&quot;ecto.create&quot;, &quot;ecto.migrate&quot;, &quot;run priv/repo/seeds.exs&quot;],
      &quot;ecto.reset&quot;: [&quot;ecto.drop&quot;, &quot;ecto.setup&quot;],
      test: [&quot;ecto.create --quiet&quot;, &quot;ecto.migrate --quiet&quot;, &quot;test&quot;],
      &quot;assets.setup&quot;: [
        &quot;cmd yarn install --cwd assets&quot;
      ],
      &quot;assets.build&quot;: [],
      &quot;assets.deploy&quot;: [
        &quot;assets.setup&quot;,
        &quot;cmd --cd assets yarn run build&quot;,
        &quot;phx.digest&quot;
      ]
    ]
  end
end</file><file path="phoenix_static_buildpack.config"># Clean out cache contents from previous deploys
clean_cache=false

# We can change the filename for the compile script with this option
compile=&quot;compile&quot;

# We can set the version of Node to use for the app here
node_version=16.13.2

# We can set the version of NPM to use for the app here
npm_version=8.1.2

# We can set the version of Yarn to use for the app here
yarn_version=1.22.10

# We can set the path to phoenix app. E.g. apps/phoenix_app when in umbrella.
phoenix_relative_path=.

# Remove node and node_modules directory to keep slug size down if it is not needed.
remove_node=false

# We can change path that npm dependencies are in relation to phoenix app. E.g. assets for phoenix 1.3 support.
assets_path=./assets

# We can change phoenix mix namespace tasks. E.g. `phoenix` for phoenix &lt; 1.3 support.
phoenix_ex=phx</file><file path="README.md"># Wanderer

[Wanderer](https://wanderer.ltd/) is an #1 EVE Online mapper tool, light and fast alternative to Pathfinder. You can self-host Wanderer Community Edition or have us manage Wanderer for you in the cloud. Made and hosted in the EU üá™üá∫

![Wanderer](https://wanderer.ltd/images/news/09-10-map-features-guide/cover.png)

## Why Wanderer?

Here&apos;s what makes Wanderer a great Pathfinder alternative:

- **Clutter Free**: Wanderer provides simple interface and it cuts through the noise. No training necessary.
- **Lightweight, fast and secure**: Wanderer is lightweight and fast. It uses a self-hosted database and a self-hosted server.
- **See all your characaters on a single page**: Wanderer provides a simple interface to see all your characters on a single page.
- **SPA support**: Wanderer is built with modern web frameworks in core.
- **Active development**: Wanderer is actively developed and improved with new features and updates every week based on user feedback.

Interested to learn more? [Check more on our website](https://wanderer.ltd/news).

### Can Wanderer be self-hosted?

Wanderer is open source project and we have a free as in beer and self-hosted solution called [Wanderer Community Edition (CE)](https://wanderer.ltd/news/community-edition). Here are the differences between Wanderer and Wanderer CE:

|                               | Wanderer Cloud                                                                                                                                                                                                                                                                                                                              | Wanderer Community Edition                                                                                                                                                                                                                           |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Infrastructure management** | Easy and convenient. It takes 2 minutes to register your character and create a map. We manage everything so you don‚Äôt have to worry about anything and can focus on gameplay.                                                                                                                                                              | You do it all yourself. You need to get a server and you need to manage your infrastructure. You are responsible for installation, maintenance, upgrades, server capacity, uptime, backup, security, stability, consistency, loading time and so on. |
| **Release schedule**          | Continuously developed and improved with new features and updates multiple times per week.                                                                                                                                                                                                                                                  | Latest features and improvements won&apos;t be immediately available.                                                                                                                                                                                     |
| **Server location**           | All visitor data is exclusively processed on EU-owned cloud infrastructure. We keep your site data on a secure, encrypted and green energy powered server in Germany. This ensures that your site data is protected by the strict European Union data privacy laws and ensures compliance with GDPR. Your website data never leaves the EU. | You have full control and can host your instance on any server in any country that you wish. Host it on a server in your basement or host it with any cloud provider wherever you want, even those that are not GDPR compliant.                      |

Interested in self-hosting Wanderer CE on your server? Take a look at our [Wanderer CE installation instructions](https://github.com/wanderer-industries/community-edition/).

Wanderer CE is a community supported project and there are no guarantees that you will get support from the creators of Wanderer to troubleshoot your self-hosting issues. There is a [community supported forum](https://github.com/orgs/wanderer-industries/discussions/4) where you can ask for help.

Our only source of funding is your donations.

## Technology

Wanderer is a standard Elixir/Phoenix application backed by a PostgreSQL database for general data. On the frontend we use [TailwindCSS](https://tailwindcss.com/) for styling and React to make the map interactive.

## Development

### Setup

- Copy `.env.example` to `.env` and fill in the values

- Run `mix setup` to install and setup dependencies
- (optional step) run `make yarn` to install client dependencies

### Run

- Start server with `make server` or `make s`

Now you can visit [`localhost:8000`](http://localhost:8000) from your browser.

#### Using .devcontainer

- Run devcontainer
- Install additional dependencies inside Dev container
- `root@0d0a785313b6:/app# apt update`
- `root@0d0a785313b6:/app# curl -sL https://deb.nodesource.com/setup_18.x  | bash -`
- `root@0d0a785313b6:/app# apt-get install nodejs inotify-tools -y`
- `root@0d0a785313b6:/app# npm install -g yarn`
- `root@0d0a785313b6:/app# mix setup`

- See how to run server in #Run section

#### Using nix flakes

- Run `nix develop`
- Run local postgres server: `pg-setup` &amp; `pg-start`
- See how to start server in #setup section

### Migrations

#### Reset database

`mix ecto.reset`

#### Run seed data

- `mix run priv/repo/seeds.exs`

#### Generate new migration

- `mix ash.codegen &lt;name_of_migration&gt;`
- `mix ash.migrate`

#### Generate cloak key

- `iex&gt; 32 |&gt; :crypto.strong_rand_bytes() |&gt; Base.encode64()`</file><file path="repomix.config.json">{
  &quot;output&quot;: {
    &quot;filePath&quot;: &quot;repomix-output.xml&quot;,
    &quot;style&quot;: &quot;xml&quot;,
    &quot;parsableStyle&quot;: true,
    &quot;compress&quot;: false,
    &quot;fileSummary&quot;: true,
    &quot;directoryStructure&quot;: true,
    &quot;removeComments&quot;: false,
    &quot;removeEmptyLines&quot;: false,
    &quot;showLineNumbers&quot;: false,
    &quot;copyToClipboard&quot;: true,
    &quot;topFilesLength&quot;: 5,
    &quot;includeEmptyDirectories&quot;: false
  },
  &quot;include&quot;: [
    &quot;**/*&quot;
  ],
  &quot;ignore&quot;: {
    &quot;useGitignore&quot;: true,
    &quot;useDefaultPatterns&quot;: true,
    &quot;customPatterns&quot;: [
      &quot;priv/**/*&quot;,
      &quot;**/*.svg&quot;,
      &quot;.notes/**/*&quot;,
      &quot;.cursor/**/*&quot;,
      &quot;_build/**/*&quot;,
      &quot;deps/**/*&quot;,
      &quot;assets/node_modules/**/*&quot;,
      &quot;CHANGELOG.md&quot;,
      &quot;CONTRIBUTING.md&quot;,
      &quot;CODE_OF_CONDUCT.md&quot;,
      &quot;LICENSE&quot;,
      &quot;SECURITY.md&quot;,
      &quot;UPGRADE.md&quot;
    ]
  },
  &quot;security&quot;: {
    &quot;enableSecurityCheck&quot;: true
  },
  &quot;tokenCount&quot;: {
    &quot;encoding&quot;: &quot;o200k_base&quot;
  }
}</file></files></repomix>